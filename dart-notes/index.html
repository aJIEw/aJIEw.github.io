<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="阅读 language-tour 时做的一些笔记。  Important concepts Dart 中一切皆对象，除了 null 之外，所有对象都继承自 Object Dart 是强类型语言，但是类型标注是可选的，因为 Dart 中存在类型推断的机制，使用 var 关键字后编译器可以推断出具体的类型 当开启了空安全（dart ≧ v2.12）之后，对于可为空的值必须明确指出（用 ?），可为空">
<meta property="og:type" content="article">
<meta property="og:title" content="Dart 学习笔记">
<meta property="og:url" content="https://ajiew.github.io/dart-notes/index.html">
<meta property="og:site_name" content="aJIEw">
<meta property="og:description" content="阅读 language-tour 时做的一些笔记。  Important concepts Dart 中一切皆对象，除了 null 之外，所有对象都继承自 Object Dart 是强类型语言，但是类型标注是可选的，因为 Dart 中存在类型推断的机制，使用 var 关键字后编译器可以推断出具体的类型 当开启了空安全（dart ≧ v2.12）之后，对于可为空的值必须明确指出（用 ?），可为空">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://dart.dev/assets/shared/dart-logo-for-shares.png">
<meta property="article:published_time" content="2021-04-03T12:30:00.000Z">
<meta property="article:modified_time" content="2023-08-30T08:30:49.050Z">
<meta property="article:author" content="aJIEw">
<meta property="article:tag" content="Notes">
<meta property="article:tag" content="Dart">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dart.dev/assets/shared/dart-logo-for-shares.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Dart 学习笔记</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="aJIEw" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/blog/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/effective-dart-notes/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2021-3/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ajiew.github.io/dart-notes/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ajiew.github.io/dart-notes/&text=Dart 学习笔记"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ajiew.github.io/dart-notes/&title=Dart 学习笔记"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ajiew.github.io/dart-notes/&is_video=false&description=Dart 学习笔记"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li> -->
  <li><a class="icon" href="mailto:?subject=Dart 学习笔记&body=Check out this article: https://ajiew.github.io/dart-notes/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ajiew.github.io/dart-notes/&title=Dart 学习笔记"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ajiew.github.io/dart-notes/&title=Dart 学习笔记"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ajiew.github.io/dart-notes/&title=Dart 学习笔记"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ajiew.github.io/dart-notes/&title=Dart 学习笔记"><i class="fab fa-digg " aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ajiew.github.io/dart-notes/&name=Dart 学习笔记&description=&lt;p&gt;&lt;img src=&#34;https://dart.dev/assets/shared/dart-logo-for-shares.png&#34; alt=&#34;dart-logo&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读 &lt;a href=&#34;https://dart.dev/guides/language/language-tour&#34;&gt;language-tour&lt;/a&gt; 时做的一些笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;Important-concepts&#34;&gt;&lt;a href=&#34;#Important-concepts&#34; class=&#34;headerlink&#34; title=&#34;Important concepts&#34;&gt;&lt;/a&gt;Important concepts&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Dart 中一切皆对象，除了 null 之外，所有对象都继承自 &lt;a href=&#34;https://api.dart.dev/stable/dart-core/Object-class.html&#34;&gt;Object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dart 是强类型语言，但是类型标注是可选的，因为 Dart 中存在类型推断的机制，使用 &lt;code&gt;var&lt;/code&gt; 关键字后编译器可以推断出具体的类型&lt;/li&gt;
&lt;li&gt;当开启了空安全（dart ≧ v2.12）之后，对于可为空的值必须明确指出（用 &lt;code&gt;?&lt;/code&gt;），可为空的值转换成不为空的值时使用 &lt;code&gt;!&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当需要接收任意对象时使用 &lt;code&gt;Object?&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Dart 支持泛型，比如 &lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Dart 支持顶层函数和局部函数，同样也支持顶层变量&lt;/li&gt;
&lt;li&gt;标识符可以以字母或者 &lt;code&gt;_&lt;/code&gt; 开头，Dart 中 &lt;code&gt;_&lt;/code&gt; 开头的方法表示私有方法&lt;/li&gt;
&lt;li&gt;Dart 中也分为表达式 &lt;em&gt;expressions&lt;/em&gt; 和声明 &lt;em&gt;statements&lt;/em&gt;，表达式有返回值而声明无返回值&lt;/li&gt;
&lt;li&gt;Dart 工具提供了两种类型的问题：警告和错误。警告表示代码可能无法正确执行，错误分为编译期错误和运行时错误，编译期错误会导致程序无法执行，而运行时错误是代码执行过程中抛出的异常。&lt;/li&gt;
&lt;/ul&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ajiew.github.io/dart-notes/&t=Dart 学习笔记"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li> -->
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Important-concepts"><span class="toc-number">1.</span> <span class="toc-text">Important concepts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Variables"><span class="toc-number">2.</span> <span class="toc-text">Variables</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">2.1.</span> <span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Late-%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">Late 变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final-%E5%92%8C-const"><span class="toc-number">2.3.</span> <span class="toc-text">final 和 const</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Build-in-types"><span class="toc-number">3.</span> <span class="toc-text">Build-in types</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Numbers"><span class="toc-number">3.1.</span> <span class="toc-text">Numbers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Strings"><span class="toc-number">3.2.</span> <span class="toc-text">Strings</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Booleans"><span class="toc-number">3.3.</span> <span class="toc-text">Booleans</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lists"><span class="toc-number">3.4.</span> <span class="toc-text">Lists</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sets"><span class="toc-number">3.5.</span> <span class="toc-text">Sets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Maps"><span class="toc-number">3.6.</span> <span class="toc-text">Maps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runes-and-grapheme-clusters"><span class="toc-number">3.7.</span> <span class="toc-text">Runes and grapheme clusters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbols"><span class="toc-number">3.8.</span> <span class="toc-text">Symbols</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Functions"><span class="toc-number">4.</span> <span class="toc-text">Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">具名参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.2.</span> <span class="toc-text">可选位置参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">main() 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lexical-scope"><span class="toc-number">4.4.</span> <span class="toc-text">Lexical scope</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lexical-closures"><span class="toc-number">4.5.</span> <span class="toc-text">Lexical closures</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Operators"><span class="toc-number">5.</span> <span class="toc-text">Operators</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cascade-notation"><span class="toc-number">5.1.</span> <span class="toc-text">Cascade notation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Control-flow-statements"><span class="toc-number">6.</span> <span class="toc-text">Control flow statements</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#switch-and-case"><span class="toc-number">6.1.</span> <span class="toc-text">switch and case</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exceptions"><span class="toc-number">7.</span> <span class="toc-text">Exceptions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Catch"><span class="toc-number">7.1.</span> <span class="toc-text">Catch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Classes"><span class="toc-number">8.</span> <span class="toc-text">Classes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-class-members"><span class="toc-number">8.1.</span> <span class="toc-text">Using class members</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-constructors"><span class="toc-number">8.2.</span> <span class="toc-text">Using constructors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Getting-an-object%E2%80%99s-type"><span class="toc-number">8.3.</span> <span class="toc-text">Getting an object’s type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instance-variables"><span class="toc-number">8.4.</span> <span class="toc-text">Instance variables</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Constructors"><span class="toc-number">8.5.</span> <span class="toc-text">Constructors</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.5.1.</span> <span class="toc-text">具名构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">8.5.2.</span> <span class="toc-text">构造器初始化列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">8.5.3.</span> <span class="toc-text">构造器初始化顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.5.4.</span> <span class="toc-text">重定向构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.5.5.</span> <span class="toc-text">常量构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.5.6.</span> <span class="toc-text">工厂构造器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Getters-and-setters"><span class="toc-number">8.6.</span> <span class="toc-text">Getters and setters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Abstract-classes"><span class="toc-number">8.7.</span> <span class="toc-text">Abstract classes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Implicit-interfaces"><span class="toc-number">8.8.</span> <span class="toc-text">Implicit interfaces</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Extending-a-class"><span class="toc-number">8.9.</span> <span class="toc-text">Extending a class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Extension-methods"><span class="toc-number">8.10.</span> <span class="toc-text">Extension methods</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Enumerated-types"><span class="toc-number">8.11.</span> <span class="toc-text">Enumerated types</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Adding-features-to-a-class-mixins"><span class="toc-number">8.12.</span> <span class="toc-text">Adding features to a class: mixins</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Class-variables-and-methods"><span class="toc-number">8.13.</span> <span class="toc-text">Class variables and methods</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generics"><span class="toc-number">9.</span> <span class="toc-text">Generics</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="toc-number">9.1.</span> <span class="toc-text">为什么使用泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-collection-literals"><span class="toc-number">9.2.</span> <span class="toc-text">Using collection literals</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%E5%8F%8A%E5%85%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.3.</span> <span class="toc-text">泛型集合及其类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">9.4.</span> <span class="toc-text">泛型参数类型的限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Libraries-and-visibility"><span class="toc-number">10.</span> <span class="toc-text">Libraries and visibility</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%BA%93%E7%9A%84%E5%89%8D%E7%BC%80"><span class="toc-number">10.1.</span> <span class="toc-text">指定库的前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E5%AF%BC%E5%85%A5"><span class="toc-number">10.2.</span> <span class="toc-text">部分导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-libraries"><span class="toc-number">10.3.</span> <span class="toc-text">实现 libraries</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Asynchrony-support"><span class="toc-number">11.</span> <span class="toc-text">Asynchrony support</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generators"><span class="toc-number">12.</span> <span class="toc-text">Generators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable-classes"><span class="toc-number">13.</span> <span class="toc-text">Callable classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Isolates"><span class="toc-number">14.</span> <span class="toc-text">Isolates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typedefs"><span class="toc-number">15.</span> <span class="toc-text">Typedefs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Metadata"><span class="toc-number">16.</span> <span class="toc-text">Metadata</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comments"><span class="toc-number">17.</span> <span class="toc-text">Comments</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Dart 学习笔记
    </h1>



    <div class="meta">
      <p/>
      <!-- <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">aJIEw</span>
      </span> -->
      
    <div class="postdate">
      
        <time datetime="2021-04-03T12:30:00.000Z" itemprop="datePublished">2021-04-03</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Dart/" rel="tag">Dart</a>, <a class="tag-link-link" href="/tags/Notes/" rel="tag">Notes</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p><img src="https://dart.dev/assets/shared/dart-logo-for-shares.png" alt="dart-logo"></p>
<blockquote>
<p>阅读 <a target="_blank" rel="noopener" href="https://dart.dev/guides/language/language-tour">language-tour</a> 时做的一些笔记。</p>
</blockquote>
<h3 id="Important-concepts"><a href="#Important-concepts" class="headerlink" title="Important concepts"></a>Important concepts</h3><ul>
<li>Dart 中一切皆对象，除了 null 之外，所有对象都继承自 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-core/Object-class.html">Object</a></li>
<li>Dart 是强类型语言，但是类型标注是可选的，因为 Dart 中存在类型推断的机制，使用 <code>var</code> 关键字后编译器可以推断出具体的类型</li>
<li>当开启了空安全（dart ≧ v2.12）之后，对于可为空的值必须明确指出（用 <code>?</code>），可为空的值转换成不为空的值时使用 <code>!</code></li>
<li>当需要接收任意对象时使用 <code>Object?</code></li>
<li>Dart 支持泛型，比如 <code>List&lt;int&gt;</code></li>
<li>Dart 支持顶层函数和局部函数，同样也支持顶层变量</li>
<li>标识符可以以字母或者 <code>_</code> 开头，Dart 中 <code>_</code> 开头的方法表示私有方法</li>
<li>Dart 中也分为表达式 <em>expressions</em> 和声明 <em>statements</em>，表达式有返回值而声明无返回值</li>
<li>Dart 工具提供了两种类型的问题：警告和错误。警告表示代码可能无法正确执行，错误分为编译期错误和运行时错误，编译期错误会导致程序无法执行，而运行时错误是代码执行过程中抛出的异常。</li>
</ul>
<span id="more"></span>

<h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Bob&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>变量保存了引用，上面的例子中，name 变量包含了一个引用，该引用指向了一个值为 Bob 的 String 对象。</p>
<p>当使用 <code>var</code> 关键字时，变量的类型可以自动被推断出来，当然你也可以显式指出对象的类型。除此之外，如果你不想限定变量的类型，则可以使用 <code>Obejct</code> 或者 <code>dynamic</code>。</p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>如果没有开启空安全 (dart ≧ v2.12)，则所有未被初始化的变量都会被初始化为 null，哪怕是数字型的变量，因为 Dart 中一切都是对象。但是，如果开启了空安全，则所有不可为空的变量会被要求先初始化才能使用。</p>
<h4 id="Late-变量"><a href="#Late-变量" class="headerlink" title="Late 变量"></a>Late 变量</h4><p>Dart 2.12 之后添加了 <code>late</code> 修饰符，主要有两种用途：</p>
<ul>
<li>声明不可为空的顶层变量或者成员变量而不直接初始化值</li>
<li>延迟初始化变量（使用到时才初始化）</li>
</ul>
<p>第一种情况很好理解，因为如果开启了空安全，则顶层变量和成员变量必须要在声明的同时进行初始化，否则编译期无法保证空安全，所以引进 <code>late</code> 之后表明我们不想立马初始化该变量，但是它会在稍后被初始化。</p>
<p>第二种情况则适用于，一个变量对于程序来说是非必须的，或者性能消耗比较大，则可以用 <code>late</code> 修饰，这样，只有在使用到该变量时程序才会初始化它。比如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 如果该变量未被使用，则 _readThermometer() 不会被调用</span><br><span class="hljs-keyword">late</span> <span class="hljs-built_in">String</span> temperature = _readThermometer(); <span class="hljs-comment">// 延迟初始化</span><br></code></pre></td></tr></table></figure>

<h4 id="final-和-const"><a href="#final-和-const" class="headerlink" title="final 和 const"></a>final 和 const</h4><p><code>final</code> 修饰的变量只能被赋值一次，并且 <code>final</code> 修饰的顶层变量会在第一次被使用时初始化。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> name = <span class="hljs-string">&#x27;Bob&#x27;</span>; <span class="hljs-comment">// final 修饰的变量可以没有类型标注</span><br><span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> nickname = <span class="hljs-string">&#x27;Bobby&#x27;</span>;<br><br>name = <span class="hljs-string">&#x27;Alice&#x27;</span>; <span class="hljs-comment">// Error: a final variable can only be set once.</span><br></code></pre></td></tr></table></figure>

<p><code>const</code> 变量是编译期常量（同时也是 final 的）。如果 <code>const</code> 修饰的是成员变量，则需要用 <code>static const</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> bar = <span class="hljs-number">1000000</span>; <span class="hljs-comment">// Unit of pressure (dynes/cm2)</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> atm = <span class="hljs-number">1.01325</span> * bar; <span class="hljs-comment">// Standard atmosphere</span><br></code></pre></td></tr></table></figure>

<p><code>final</code> 和 <code>const</code> 的不同之处在于，<code>final</code> 修饰的对象不能被修改，但是其属性可以被修改；而 <code>const</code> 修饰的对象和属性都不能被修改，它们是<em>不可变的</em>。</p>
<h3 id="Build-in-types"><a href="#Build-in-types" class="headerlink" title="Build-in types"></a>Build-in types</h3><h4 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h4><ul>
<li><a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-core/int-class.html">int</a>, 不大于 64 位</li>
<li><a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-core/double-class.html">double</a>, 64 位浮点数</li>
</ul>
<p>int 和 double 都是 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-core/num-class.html">num</a> 的子类，num 类型的数据包含了基本的操作符，比如加减乘以及 abs(), ceil(), floor(), 位运算等。</p>
<h4 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h4><ul>
<li>Dart 中使用 String 可以用单引号或者双引号。不过，在单引号中的 String 对象中需要对 <code>&#39;</code> 进行转义。</li>
<li>我们可以使用 <code>$&#123;expression&#125;</code> 在 String 中引用变量或者表达式。</li>
<li>我们可以用 <code>==</code> 比较两个 String 的值是否一致。</li>
<li>我们可以在 String 值之前加 <code>r</code> 来表示原始类型 (raw) 的 String，这样就不需要转义。</li>
<li>我们可以使用三个单引号或者双引号来创建多行 String，同样不需要在其中使用转义符。</li>
<li>我们可以使用字符相乘，但是字符必须在乘数系数的左边，如 <code>🔥 * 3</code>。</li>
<li>我们可以使用字符填充方法，比如 <code>paddingLeft</code> 和 <code>paddingRight</code>。</li>
</ul>
<h4 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h4><p>Dart 中使用 <code>bool</code> 表示布尔类型的值。</p>
<h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><p>Dart 中数组是用 <code>List</code> 表示的。可以用如下的方式创建数组：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> list = [<br>  <span class="hljs-string">&#x27;Car&#x27;</span>,<br>  <span class="hljs-string">&#x27;Boat&#x27;</span>,<br>  <span class="hljs-string">&#x27;Plane&#x27;</span>, <span class="hljs-comment">// Dart 中允许添加 trailing comma，这样可以防止复制粘贴出错</span><br>];<br></code></pre></td></tr></table></figure>

<p>Dart 2.3 之后添加了扩展运算符 (<code>...</code>) 和空值敏感的扩展运算符 (<code>...?</code>)：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> list2 = [<span class="hljs-number">0</span>, ...list];<br><span class="hljs-keyword">assert</span>(list2.length == <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>

<p>Dart 中还有提供了<em>集合 if</em> 和<em>集合 for</em> 的操作：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> nav = [<br>  <span class="hljs-string">&#x27;Home&#x27;</span>,<br>  <span class="hljs-string">&#x27;Mall&#x27;</span>,<br>  <span class="hljs-string">&#x27;Mine&#x27;</span>,<br>  <span class="hljs-keyword">if</span> (promoActive) <span class="hljs-string">&#x27;Outlet&#x27;</span><br>];<br><br><span class="hljs-keyword">var</span> listOfInts = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> listOfStrings = [<br>  <span class="hljs-string">&#x27;#0&#x27;</span>,<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> listOfInts) <span class="hljs-string">&#x27;#<span class="hljs-subst">$i</span>&#x27;</span><br>];<br></code></pre></td></tr></table></figure>

<p>关于其它常见的 API 见 <a target="_blank" rel="noopener" href="https://dart.dev/guides/libraries/library-tour#collections">collections</a>。</p>
<h4 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h4><p>Dart 中同样用 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-core/Set-class.html"><code>Set</code></a> 类型表示无序且唯一的集合。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> halogens = &#123;<span class="hljs-string">&#x27;fluorine&#x27;</span>, <span class="hljs-string">&#x27;chlorine&#x27;</span>, <span class="hljs-string">&#x27;bromine&#x27;</span>, <span class="hljs-string">&#x27;iodine&#x27;</span>, <span class="hljs-string">&#x27;astatine&#x27;</span>&#125;;<br></code></pre></td></tr></table></figure>

<p>Set 和 List 一样，支持扩展运算符、集合 if 和集合 for 的操作。</p>
<h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><p><a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-core/Map-class.html">Map</a> 是包含了 key 和 value 集合，其中 key 必须唯一。Dar 中的 Map 同样使用花括号 <code>&#123;&#125;</code> 表示，而且优先级比集合 Set 更高：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> gifts = &#123;<br>  <span class="hljs-comment">// Key:    Value</span><br>  <span class="hljs-string">&#x27;first&#x27;</span>: <span class="hljs-string">&#x27;partridge&#x27;</span>,<br>  <span class="hljs-string">&#x27;second&#x27;</span>: <span class="hljs-string">&#x27;turtledoves&#x27;</span>,<br>  <span class="hljs-string">&#x27;fifth&#x27;</span>: <span class="hljs-string">&#x27;golden rings&#x27;</span><br>&#125;; <span class="hljs-comment">// 自动推断出 map 的类型为 Map&lt;String, String&gt;</span><br><br><span class="hljs-comment">// 也可以通过这种方式创建</span><br><span class="hljs-keyword">var</span> gifts = <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt;();<br>gifts[<span class="hljs-string">&#x27;first&#x27;</span>] = <span class="hljs-string">&#x27;partridge&#x27;</span>;<br>gifts[<span class="hljs-string">&#x27;second&#x27;</span>] = <span class="hljs-string">&#x27;turtledoves&#x27;</span>;<br>gifts[<span class="hljs-string">&#x27;fifth&#x27;</span>] = <span class="hljs-string">&#x27;golden rings&#x27;</span>;<br><br><span class="hljs-keyword">var</span> names = &#123;&#125;; <span class="hljs-comment">// 这种方式创建的是 map 而不是 set</span><br><br><span class="hljs-comment">// 访问 map 的语法 []，其实类似调用方法，具体获取到的值是不确定的</span><br><span class="hljs-comment">// 报错：Const variables must be initialized with a constant value</span><br><span class="hljs-keyword">const</span> lightRed = Colors.red[<span class="hljs-number">200</span>];<br></code></pre></td></tr></table></figure>

<h4 id="Runes-and-grapheme-clusters"><a href="#Runes-and-grapheme-clusters" class="headerlink" title="Runes and grapheme clusters"></a>Runes and grapheme clusters</h4><p>Dart 中，使用 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-core/Runes-class.html">Runes</a> 表示字符串的 Unicode 字符集。我们可以使用 <a target="_blank" rel="noopener" href="https://pub.dev/packages/characters">characters</a> 包下的类来操作字符。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:characters/characters.dart&#x27;</span>;<br>...<br><span class="hljs-keyword">var</span> hi = <span class="hljs-string">&#x27;Hi ✡️&#x27;</span>;<br><span class="hljs-built_in">print</span>(hi);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The end of the string: <span class="hljs-subst">$&#123;hi.substring(hi.length - <span class="hljs-number">1</span>)&#125;</span>&#x27;</span>);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The last character: <span class="hljs-subst">$&#123;hi.characters.last&#125;</span>\n&#x27;</span>); <span class="hljs-comment">// 使用 characters 才能正常打印 emoji</span><br></code></pre></td></tr></table></figure>

<p>Dart 中的字符串使用 UTF-16 编码，如果要用字符串表示 Unicode 字符则需要使用 <code>\uXXXX</code> 的语法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\u&#123;1f606&#125;&#x27;</span>); <span class="hljs-comment">// 😆</span><br></code></pre></td></tr></table></figure>

<h4 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h4><p>Dart 中使用 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-core/Symbol-class.html">Symbol</a> 对象表示操作符或者标识符，用 <code>#</code> + 修饰符表示。</p>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Dart 中一切都是对象，函数的类型用 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-core/Function-class.html">Function</a> 表示，而且函数也可以作为变量或者作为方法的参数进行传递。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> say(<span class="hljs-built_in">String</span> content) &#123;<br>  <span class="hljs-built_in">print</span>(content);<br>&#125;<br><br><span class="hljs-comment">// Dart 中只有单个表达式的函数可以使用缩写，用 =&gt; 代替 &#123; &#125;</span><br><span class="hljs-built_in">bool</span> isEvenNumber(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>) =&gt; <span class="hljs-built_in">num</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">num</span> % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 这里的参数 body 表示一个返回类型为 Future&lt;T&gt; 的函数</span><br><span class="hljs-keyword">void</span> calculate&lt;T&gt;(Future&lt;T&gt; <span class="hljs-built_in">Function</span>() body) &#123;&#125;<br></code></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>Dart 中的函数除了可以有普通的参数，还可以是<em>具名参数</em>或者<em>可选位置参数</em>。如果使用了 Sound null safety (sdk ≧ 2.12)，且没有指明默认值，则这两种类型参数都必须是可为空的，即参数后跟 <code>?</code>。</p>
<h5 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h5><p>具名参数 (Named parameters) 是必须写出名字的参数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 函数中使用 &#123;&#125; 圈起来的参数即具名参数</span><br><span class="hljs-keyword">void</span> enableFlags(&#123;<span class="hljs-built_in">bool?</span> bold, <span class="hljs-built_in">int?</span> index&#125;) &#123;&#125;<br><br><span class="hljs-comment">// 可以给具名参数添加默认值</span><br><span class="hljs-keyword">void</span> enableFlags(&#123;<span class="hljs-built_in">bool?</span> bold = <span class="hljs-keyword">true</span>&#125;) &#123;&#125;<br><br><span class="hljs-comment">// 用 required 标记具名参数中必须有的参数</span><br><span class="hljs-keyword">void</span> enableFlags(&#123;<span class="hljs-keyword">required</span> <span class="hljs-built_in">bool?</span> bold&#125;) &#123;&#125;<br><br><span class="hljs-comment">// 调用函数，无参数</span><br>enableFlags()<br><br><span class="hljs-comment">// 调用时如果有参数名则必须写参数名称</span><br>enableFlags(<br>  bold: <span class="hljs-keyword">true</span>,<br>  hidden: <span class="hljs-keyword">false</span><br>);<br></code></pre></td></tr></table></figure>

<p>Dart 2.17 之后，可选具名参数的位置可以在普通参数之前：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// Dart 2.17 之前</span><br><span class="hljs-built_in">List</span>.generate(<span class="hljs-number">5</span>, (index) =&gt; index, growable: <span class="hljs-keyword">true</span>);<br><br><span class="hljs-comment">// Dart 2.17 之后</span><br><span class="hljs-built_in">List</span>.generate(<span class="hljs-number">5</span>, growable: <span class="hljs-keyword">true</span>, (index) =&gt; index);<br></code></pre></td></tr></table></figure>

<h5 id="可选位置参数"><a href="#可选位置参数" class="headerlink" title="可选位置参数"></a>可选位置参数</h5><p>可选位置参数 (Optional positional parameters) 和普通的参数唯一的不同之处是它是可选的😅。用 <code>[]</code> 圈起来的参数即可选位置参数。比如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// title 是必须的位置参数，而 subtitle 是可选的</span><br><span class="hljs-keyword">void</span> say(<span class="hljs-built_in">String</span> title, [<span class="hljs-built_in">String?</span> subtitle]) &#123;<br>  <span class="hljs-built_in">print</span>(title);<br>  <span class="hljs-keyword">if</span> (subtitle != <span class="hljs-keyword">null</span>) <span class="hljs-built_in">print</span>(subtitle);<br>&#125;<br><br><span class="hljs-comment">// 可选位置参数也可以有默认值</span><br><span class="hljs-keyword">void</span> sing(<span class="hljs-built_in">String</span> song, [<span class="hljs-built_in">String?</span> instrument = <span class="hljs-string">&#x27;Piano&#x27;</span>]) &#123; &#125;<br></code></pre></td></tr></table></figure>

<h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main() 函数"></a>main() 函数</h4><p>每个应用都有一个 main() 函数作为应用的入口。main() 函数通常返回空，并且可以有数组作为参数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; arguments) &#123;<br>  <span class="hljs-built_in">print</span>(arguments);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>Dart 中的匿名函数和其它语言中类似，可以有多个参数或者没有参数，后跟方法体，形式如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">([[<span class="hljs-built_in">Type</span>] param1[, …]]) &#123;<br>  codeBlock;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果只有单个的表达式或者只有返回值，可以使用箭头表达式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">([[<span class="hljs-built_in">Type</span>] param1[, …]]) =&gt; expression; <span class="hljs-comment">// 如果是赋值表达式，则该值就是返回值</span><br></code></pre></td></tr></table></figure>

<h4 id="Lexical-scope"><a href="#Lexical-scope" class="headerlink" title="Lexical scope"></a>Lexical scope</h4><p>Dart 同样是具有<strong>词法作用域</strong>或静态作用域的语言，即只要还在代码作用域内的值，都能访问到。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">bool</span> topLevel = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> insideMain = <span class="hljs-keyword">true</span>;<br><br>  <span class="hljs-keyword">void</span> myFunction() &#123;<br>    <span class="hljs-keyword">var</span> insideFunction = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">void</span> nestedFunction() &#123;<br>      <span class="hljs-keyword">var</span> insideNestedFunction = <span class="hljs-keyword">true</span>;<br><br>      <span class="hljs-keyword">assert</span>(topLevel);<br>      <span class="hljs-keyword">assert</span>(insideMain);<br>      <span class="hljs-keyword">assert</span>(insideFunction);<br>      <span class="hljs-keyword">assert</span>(insideNestedFunction);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Lexical-closures"><a href="#Lexical-closures" class="headerlink" title="Lexical closures"></a>Lexical closures</h4><p>词法闭包也叫<strong>函数闭包</strong>，和 JS 中的闭包概念类似，即定义在函数中的函数，同时使得该函数能够访问其它函数作用域中的变量。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Function</span> makeAdder(<span class="hljs-built_in">int</span> addBy) &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span> i) =&gt; addBy + i;<br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> add2 = makeAdder(<span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">print</span>(add2(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 这里 add2 访问了 makeAdder 中定义的值，也即把 2 保存了下来</span><br>  <span class="hljs-built_in">print</span>(makeAdder(<span class="hljs-number">10</span>)(<span class="hljs-number">3</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><p>Dart 中支持的操作符表，见 <a target="_blank" rel="noopener" href="https://dart.dev/guides/language/language-tour#operators">Operators</a>。</p>
<h4 id="Cascade-notation"><a href="#Cascade-notation" class="headerlink" title="Cascade notation"></a>Cascade notation</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// cascade notation，可以在赋值的基础上对属性和方法进行调用</span><br><span class="hljs-comment">// 使得创建对象和属性赋值变得更简单，省去创建临时对象的步骤</span><br><span class="hljs-keyword">var</span> paint = Paint()<br>  ..color = <span class="hljs-string">&#x27;Black&#x27;</span><br>  ..strokeCap = <span class="hljs-string">&#x27;Round&#x27;</span><br>  ..strokeWidth = <span class="hljs-number">5.0</span>;<br><span class="hljs-built_in">print</span>(paint);<br></code></pre></td></tr></table></figure>

<h3 id="Control-flow-statements"><a href="#Control-flow-statements" class="headerlink" title="Control flow statements"></a>Control flow statements</h3><h4 id="switch-and-case"><a href="#switch-and-case" class="headerlink" title="switch and case"></a>switch and case</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// Dart 中的 case 语法有 fall through 机制</span><br><span class="hljs-comment">// 但是如果定义了 case 内容而没有 break 则会报错</span><br><span class="hljs-keyword">var</span> command = <span class="hljs-string">&#x27;CLOSED&#x27;</span>;<br><span class="hljs-keyword">switch</span> (command) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EARLY_CLOSE&#x27;</span>: <span class="hljs-comment">// fall through to &#x27;CLOSED&#x27;</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;CLOSED&#x27;</span>:<br>    <span class="hljs-keyword">var</span> youCantAccess = <span class="hljs-number">1</span>; <span class="hljs-comment">// Dart 中的 case 自带作用域</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;bye bye&#x27;</span>);<br>    <span class="hljs-keyword">continue</span> afterClosed; <span class="hljs-comment">// 可以使用 label 绕过无 break 的限制</span><br><br>  afterClosed:<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;CLOSED_AFTER&#x27;</span>:<br>    <span class="hljs-comment">// print(youCantAccess); // undefined</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;see you tomorrow&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p>Dart 中所有异常都是 unchecked exceptions，意味着 Dart 不会强制你去捕捉异常。</p>
<h4 id="Catch"><a href="#Catch" class="headerlink" title="Catch"></a>Catch</h4><p>Dart 中的 try catch 语法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">try</span> &#123;<br>  breedMoreLlamas();<br>&#125; <span class="hljs-keyword">on</span> OutOfLlamasException &#123;<br>  <span class="hljs-comment">// 特定类型的异常</span><br>  buyMoreLlamas();<br>&#125; <span class="hljs-keyword">on</span> Exception <span class="hljs-keyword">catch</span> (error, stacktrace) &#123; <span class="hljs-comment">// 第二个参数为错误栈</span><br>  <span class="hljs-comment">// 其它类型的异常</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Unknown exception: <span class="hljs-subst">$error</span>&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-comment">// 所有其它未指定的错误</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Something really unknown: <span class="hljs-subst">$error</span>&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>Dart 中一切皆对象，除了 null 之外，所有对象都是某个类的实例。除了可以继承类之外，Dart 还提供了一种基于 mixin 的继承，也就是说可以通过 with 关键字继承某个没有构造器的类来扩展功能，还可以使用<a target="_blank" rel="noopener" href="https://dart.dev/guides/language/extension-methods">扩展函数</a>。</p>
<h4 id="Using-class-members"><a href="#Using-class-members" class="headerlink" title="Using class members"></a>Using class members</h4><p>所有对象都由成员变量和方法构成，使用 <code>.</code> 的语法访问对象的属性或者方法，使用 <code>?.</code> 访问可为空对象的属性和方法。</p>
<h4 id="Using-constructors"><a href="#Using-constructors" class="headerlink" title="Using constructors"></a>Using constructors</h4><p>Dart 中创建构造器除了可以使用类名，也可以使用 <code>类名.构造器名()</code> 的形式。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DummyClass</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">// 默认构造函数</span><br>  DummyClass(<span class="hljs-keyword">this</span>.i);<br>  <br>  <span class="hljs-comment">// 我们可以为构造函数定义名称，这种构造器被称为「具名构造器」</span><br>  DummyClass.create(<span class="hljs-built_in">int</span> i, <span class="hljs-built_in">String</span> message) &#123;<br>    <span class="hljs-built_in">print</span>(message);<br>    <span class="hljs-keyword">this</span>.i = i;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 在「具名构造器」后为成员变量赋值</span><br>  DummyClass.ten() : i = <span class="hljs-number">10</span> &#123; <span class="hljs-comment">// :后的部分称为 initializer list</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Ten <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.i&#125;</span>&#x27;</span>); <span class="hljs-comment">// print: Ten 10</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Getting-an-object’s-type"><a href="#Getting-an-object’s-type" class="headerlink" title="Getting an object’s type"></a>Getting an object’s type</h4><p>我们可以使用 <code>runtimeType</code> 获得对象的类型 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-core/Type-class.html">Type</a>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> dummy = DummyClass.create(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The type of a is <span class="hljs-subst">$&#123;dummy.runtimeType&#125;</span>&#x27;</span>);<br></code></pre></td></tr></table></figure>

<h4 id="Instance-variables"><a href="#Instance-variables" class="headerlink" title="Instance variables"></a>Instance variables</h4><ul>
<li>所有未初始化可为空的实例变量都会被初始化为 null。</li>
<li>所有实例变量都会默认自带 getter 函数，非 final 的实例变量和不带初始化器的 late final 实例变量会自动生成 setter 函数。</li>
<li>非延迟初始化的实例变量的值会在对象创建之后，构造器和初始化器列表执行之前，就被赋值。可为空的赋值为 null，不可为空的赋值为初始值。</li>
<li>实例变量可以是 final 的，但是必须在构造器或者初始化列表中进行赋值。</li>
</ul>
<h4 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h4><p>Dart 中类的构造器和其它语言类似：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-built_in">double</span> x = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">double</span> y = <span class="hljs-number">0</span>;<br><br>  Point(<span class="hljs-built_in">double</span> x, <span class="hljs-built_in">double</span> y) &#123;<br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不过，Dart 提供了一种语法糖的写法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-built_in">double</span> x = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">double</span> y = <span class="hljs-number">0</span>;<br><br>  Point(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="具名构造器"><a href="#具名构造器" class="headerlink" title="具名构造器"></a>具名构造器</h5><p>我们可以通过具名构造器 (Named constructors) 为一个类实现多个构造器。不过具名构造器不能被继承，如果想在子类中使用和父类相同的构造器，只能为子类单独实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weather</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> humidity = <span class="hljs-string">&#x27;&#x27;</span>;<br><br>  Weather.display(<span class="hljs-keyword">this</span>.humidity);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shower</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Weather</span></span>&#123;<br>  Shower.display(<span class="hljs-built_in">String</span> humidity) : <span class="hljs-keyword">super</span>.display(humidity);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="构造器初始化列表"><a href="#构造器初始化列表" class="headerlink" title="构造器初始化列表"></a>构造器初始化列表</h5><p>除了调用父类构造器之外，我们还可以在构造器方法体执行之前初始化成员变量，称为 <em>Initializer list</em>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">Point.fromJson(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">double</span>&gt; json)<br>    : x = json[<span class="hljs-string">&#x27;x&#x27;</span>]!,<br>      y = json[<span class="hljs-string">&#x27;y&#x27;</span>]!,<br>			<span class="hljs-keyword">super</span>(x) &#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;In Point.fromJson(): (<span class="hljs-subst">$x</span>, <span class="hljs-subst">$y</span>)&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>初始化起列表中，调用父类构造器必须放到最后。</p>
<h5 id="构造器初始化顺序"><a href="#构造器初始化顺序" class="headerlink" title="构造器初始化顺序"></a>构造器初始化顺序</h5><p>默认情况下，子类会先调用父类中的默认构造函数（未定义的话会生成一个无参构造器），如果存在构造器初始化列表 (Initializer list) 则会先调用它们。所以，当使用默认构造函数创建对象时，构造器的初始化顺序为：</p>
<ol>
<li>构造器初始化列表</li>
<li>父类无参构造器</li>
<li>子类无参构造器</li>
</ol>
<p>另外，如果父类未定义默认构造器，则子类实现构造器时必须先调用父类的某个具名构造器。</p>
<h5 id="重定向构造器"><a href="#重定向构造器" class="headerlink" title="重定向构造器"></a>重定向构造器</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-built_in">double</span> x, y;<br><br>  Point(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);<br><br>  <span class="hljs-comment">// 使用 this 关键字重定向到默认构造器</span><br>  Point.alongXAxis(<span class="hljs-built_in">double</span> x) : <span class="hljs-keyword">this</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="常量构造器"><a href="#常量构造器" class="headerlink" title="常量构造器"></a>常量构造器</h5><p>当你想要创建的对象是编译期常量时（比如用于创建注解），可以使用 <code>const</code> 修饰构造器：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImmutablePoint</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> ImmutablePoint origin = ImmutablePoint(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> x, y; <span class="hljs-comment">// 记得所有的变量都要是 final 的</span><br><br>  <span class="hljs-keyword">const</span> ImmutablePoint(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用常量构造器 (Constant Constructors) 初始化对象时，使用相同的值的对象只会在第一次创建时被初始化，也就是说<strong>相同值的对象只会初始化一次</strong>。</p>
<h5 id="工厂构造器"><a href="#工厂构造器" class="headerlink" title="工厂构造器"></a>工厂构造器</h5><p>使用 <code>factory</code> 关键字的构造器，适用于不需要每次创建新对象的情况，比如使用了缓存。另一个使用场景是通过 JSON 数据初始化对象。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> name;<br>  <span class="hljs-built_in">bool</span> mute = <span class="hljs-keyword">false</span>;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Logger&gt; _cache = &lt;<span class="hljs-built_in">String</span>, Logger&gt;&#123;&#125;;<br><br>  <span class="hljs-keyword">factory</span> Logger(<span class="hljs-built_in">String</span> name) &#123;<br>    <span class="hljs-keyword">return</span> _cache.putIfAbsent(name, () =&gt; Logger._internal(name));<br>  &#125;<br><br>  <span class="hljs-keyword">factory</span> Logger.fromJson(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; json) &#123;<br>    <span class="hljs-keyword">return</span> Logger(json[<span class="hljs-string">&#x27;name&#x27;</span>].toString());<br>  &#125;<br><br>  Logger._internal(<span class="hljs-keyword">this</span>.name);<br><br>  <span class="hljs-keyword">void</span> log(<span class="hljs-built_in">String</span> msg) &#123;<br>    <span class="hljs-keyword">if</span> (!mute) <span class="hljs-built_in">print</span>(msg);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Getters-and-setters"><a href="#Getters-and-setters" class="headerlink" title="Getters and setters"></a>Getters and setters</h4><p>使用 getters 和 setters 方法定义一些需要通过计算得到的值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>&#123;<br>  <span class="hljs-built_in">double</span> left, top, width, height;<br><br>  Rectangle(<span class="hljs-keyword">this</span>.left, <span class="hljs-keyword">this</span>.top, <span class="hljs-keyword">this</span>.width, <span class="hljs-keyword">this</span>.height);<br><br>  <span class="hljs-comment">// Define two calculated properties: right and bottom.</span><br>  <span class="hljs-built_in">double</span> <span class="hljs-keyword">get</span> right =&gt; left + width;<br>  <span class="hljs-keyword">set</span> right(<span class="hljs-built_in">double</span> value) =&gt; left = value - width;<br><br>  <span class="hljs-built_in">double</span> <span class="hljs-keyword">get</span> bottom =&gt; top + height;<br>  <span class="hljs-keyword">set</span> bottom(<span class="hljs-built_in">double</span> value) =&gt; top = value - height;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Abstract-classes"><a href="#Abstract-classes" class="headerlink" title="Abstract classes"></a>Abstract classes</h4><p>Dart 中的抽象类同样无法被直接实例化，如果需要实例化可以通过<a href="#%E5%B7%A5%E5%8E%82%E6%9E%84%E9%80%A0%E5%99%A8">工厂构造器</a>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractContainer</span> </span>&#123;<br>  <span class="hljs-comment">// Define constructors, fields, methods...</span><br><br>  <span class="hljs-keyword">void</span> updateChildren(); <span class="hljs-comment">// Abstract method.</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>另外，在一个非 abstract 类中，我们可以使用 <code>external</code> 关键字修饰一个需要由子类去实现的抽象方法，例如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> </span>&#123;<br>  <span class="hljs-keyword">external</span> <span class="hljs-keyword">void</span> doSomething();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Implicit-interfaces"><a href="#Implicit-interfaces" class="headerlink" title="Implicit interfaces"></a>Implicit interfaces</h4><p>Dart 中所有的类都可以作为接口被实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 使用 implement 关键字实现一个或多个接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>, <span class="hljs-title">Location</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以使用直接继承获得所有父类的实现，也可以使用 <code>implements</code> 将类作为接口实现，此时子类必须提供所有父类的属性和方法的实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">String</span> name;<br><br>  <span class="hljs-built_in">int</span> age;<br>  <br>  Animal(<span class="hljs-keyword">this</span>.age);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">String</span> name = <span class="hljs-string">&quot;Dog&quot;</span>;<br>  <br>  Dog() : <span class="hljs-keyword">super</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">// 如果使用 implements 则必须实现所有类属性</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animal</span> </span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">String</span> name = <span class="hljs-string">&quot;Cat&quot;</span>; <br>  <br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">int</span> age = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Extending-a-class"><a href="#Extending-a-class" class="headerlink" title="Extending a class"></a>Extending a class</h4><p>Dart 中所有类都可以被继承，使用 <code>extends</code> 关键字继承父类，使用 <code>super</code> 引用父类。</p>
<p>Dart 2.17 之后允许在构造器中使用 super 语法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OutlinedButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Button</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> OutlinedButton(&#123;<br>    <span class="hljs-keyword">super</span>.key,<br>    <span class="hljs-keyword">super</span>.onPress = () &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Pressed OutlinedButton&#x27;</span>);<br>    &#125;,<br>    <span class="hljs-keyword">super</span>.onLongPress,<br>    <span class="hljs-keyword">required</span> Widget <span class="hljs-keyword">super</span>.child<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样就不需要调用父类构造器，写出 super(…) 这样的模板代码了。</p>
<h4 id="Extension-methods"><a href="#Extension-methods" class="headerlink" title="Extension methods"></a>Extension methods</h4><p>和 Kotlin 类似，在 Dart 中我们同样可以通过<a target="_blank" rel="noopener" href="https://dart.dev/guides/language/extension-methods">扩展函数</a>扩充函数库。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">extension</span> NumberParsing <span class="hljs-keyword">on</span> <span class="hljs-built_in">String</span> &#123;<br>  <span class="hljs-built_in">int</span> parseInt() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>.parse(<span class="hljs-keyword">this</span>);<br>  &#125;<br>  <br>  <span class="hljs-built_in">double</span> parseDouble() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>.parse(<span class="hljs-keyword">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Enumerated-types"><a href="#Enumerated-types" class="headerlink" title="Enumerated types"></a>Enumerated types</h4><p>Dart 中的枚举类和 Java 中类似。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">enum</span> Color &#123; red, green, blue &#125;<br></code></pre></td></tr></table></figure>

<p>Dart 2.17 之后允许在 enum 类中使用成员变量：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">enum</span> Water &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> temperature;<br>  <span class="hljs-keyword">const</span> Water(<span class="hljs-keyword">this</span>.temperature);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>枚举类有以下限制：</p>
<ul>
<li>无法继承、实现或者混用 (mixin) 枚举类</li>
<li>无法直接实例化</li>
</ul>
<h4 id="Adding-features-to-a-class-mixins"><a href="#Adding-features-to-a-class-mixins" class="headerlink" title="Adding features to a class: mixins"></a>Adding features to a class: mixins</h4><p>Dart 中还提供了另外一种复用代码的方式 mixin，我们可以把可复用的代码放到 mixin 类中。子类使用 <code>with</code> 关键字进行关联。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">mixin</span> Musical &#123;<br>  <span class="hljs-built_in">bool</span> canPlayPiano = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-built_in">bool</span> canCompose = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-built_in">bool</span> canConduct = <span class="hljs-keyword">false</span>;<br><br>  <span class="hljs-keyword">void</span> entertainMe() &#123;<br>    <span class="hljs-keyword">if</span> (canPlayPiano) &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Playing piano&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (canConduct) &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Waving hands&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Humming to self&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Musician</span> <span class="hljs-title">with</span> <span class="hljs-title">Musical</span> </span>&#123;<br>  <span class="hljs-comment">// ···</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Maestro</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> <span class="hljs-title">with</span> <span class="hljs-title">Musical</span> </span>&#123;<br>  Maestro(<span class="hljs-built_in">String</span> maestroName) : <span class="hljs-keyword">super</span>(maestroName) &#123;<br>    canPlayPiano = <span class="hljs-keyword">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除此之外，我们还可以限制 mixin 的使用范围 (<code>on</code>)，以及像接口一样使用逗号 (<code>,</code>) 分割继承多个 mixin：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Musician</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">mixin</span> MusicalPerformer <span class="hljs-keyword">on</span> Musician &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingerDancer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Musician</span> <span class="hljs-title">with</span> <span class="hljs-title">MusicalPerformer</span>, <span class="hljs-title">DancerPerformer</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Class-variables-and-methods"><a href="#Class-variables-and-methods" class="headerlink" title="Class variables and methods"></a>Class variables and methods</h4><p>Dart 中的类同样可以使用静态变量和常量，以及静态方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DummyClass</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> f() &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><p>Dart 中的泛型（参数化类型）和 Java 以及 Kotlin 等语言非常相似，使用 <code>&lt;&gt;</code> 表示泛型。</p>
<h4 id="为什么使用泛型"><a href="#为什么使用泛型" class="headerlink" title="为什么使用泛型"></a>为什么使用泛型</h4><p>使用泛型一般有两个目的：</p>
<ul>
<li>指明泛型类型之后，减少代码出错。比如在集合中加入不该加入的值。</li>
<li>使用泛型减少复制粘贴的代码。比如持有某个对象的类，当需要改变持有的对象而其它部分不发生变化时，如果使用了泛型就不用重新复制一个新的类。</li>
</ul>
<h4 id="Using-collection-literals"><a href="#Using-collection-literals" class="headerlink" title="Using collection literals"></a>Using collection literals</h4><p>即在使用集合时定义集合类型，形式如 <code>&lt;type&gt;[]</code> or <code>&lt;type&gt;&#123;&#125;</code> or <code>&lt;keyType, valueType&gt;&#123;&#125;</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> names = &lt;<span class="hljs-built_in">String</span>&gt;[<span class="hljs-string">&#x27;Seth&#x27;</span>, <span class="hljs-string">&#x27;Kathy&#x27;</span>, <span class="hljs-string">&#x27;Lars&#x27;</span>];<br><span class="hljs-keyword">var</span> uniqueNames = &lt;<span class="hljs-built_in">String</span>&gt;&#123;<span class="hljs-string">&#x27;Seth&#x27;</span>, <span class="hljs-string">&#x27;Kathy&#x27;</span>, <span class="hljs-string">&#x27;Lars&#x27;</span>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="泛型集合及其类型"><a href="#泛型集合及其类型" class="headerlink" title="泛型集合及其类型"></a>泛型集合及其类型</h4><p>Java 中，由于泛型存在<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">类型擦除</a>，所以是无法确定集合的确切类型的。但是，Dart 中的泛型是 <em>reified</em> 的，也就是说在运行时也能得到集合的类型信息。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> names = &lt;<span class="hljs-built_in">String</span>&gt;[];<br>names.addAll([<span class="hljs-string">&#x27;Seth&#x27;</span>, <span class="hljs-string">&#x27;Kathy&#x27;</span>, <span class="hljs-string">&#x27;Lars&#x27;</span>]);<br><span class="hljs-built_in">print</span>(names <span class="hljs-keyword">is</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h4 id="泛型参数类型的限制"><a href="#泛型参数类型的限制" class="headerlink" title="泛型参数类型的限制"></a>泛型参数类型的限制</h4><p>Dart 中限制泛型参数边界同样使用 <code>extends</code> 关键字。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SomeBaseClass</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// Implementation goes here...</span><br>  <span class="hljs-built_in">String</span> toString() =&gt; <span class="hljs-string">&quot;Instance of &#x27;Foo&lt;<span class="hljs-subst">$T</span>&gt;&#x27;&quot;</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Extender</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SomeBaseClass</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Libraries-and-visibility"><a href="#Libraries-and-visibility" class="headerlink" title="Libraries and visibility"></a>Libraries and visibility</h3><p>Dart 中，我们可以通过 <code>import </code> 和 <code>library</code> 指示符创建模块化的、可共享的代码库。另外，即使不使用 <code>library</code> 指示符，每个 dart app 都是一个 library。</p>
<p>导入一个 library 的语法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:html&#x27;</span>; <span class="hljs-comment">// html 是 dart 内建的库，所以使用 dart 作为命名空间</span><br></code></pre></td></tr></table></figure>

<p>其它库可以使用文件路径或者 <code>package:</code> 命名空间：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:test/test.dart&#x27;</span>; <span class="hljs-comment">// 导入一些三方库，比如通过 pub 包管理工具发布的三方库</span><br></code></pre></td></tr></table></figure>

<h4 id="指定库的前缀"><a href="#指定库的前缀" class="headerlink" title="指定库的前缀"></a>指定库的前缀</h4><p>如果两个库有相同的名称，可以通过 <code>as</code> 指定前缀解决冲突。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:lib1/lib1.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="hljs-keyword">as</span> lib2;<br><br><span class="hljs-comment">// Uses Element from lib1.</span><br><span class="hljs-built_in">Element</span> element1 = <span class="hljs-built_in">Element</span>();<br><br><span class="hljs-comment">// Uses Element from lib2.</span><br>lib2.<span class="hljs-built_in">Element</span> element2 = lib2.<span class="hljs-built_in">Element</span>();<br></code></pre></td></tr></table></figure>

<h4 id="部分导入"><a href="#部分导入" class="headerlink" title="部分导入"></a>部分导入</h4><p>如果只使用到库的一部分，可以使用部分导入的语法，通过 <code>show</code> 和 <code>hide</code> 做到。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 只导入 foo</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:lib1/lib1.dart&#x27;</span> <span class="hljs-keyword">show</span> foo;<br><br><span class="hljs-comment">// 导入除了 foo 意外的部分</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="hljs-keyword">hide</span> foo;<br></code></pre></td></tr></table></figure>

<h4 id="实现-libraries"><a href="#实现-libraries" class="headerlink" title="实现 libraries"></a>实现 libraries</h4><p>见 <a target="_blank" rel="noopener" href="https://dart.dev/guides/libraries/create-library-packages">Create Library Packages</a></p>
<h3 id="Asynchrony-support"><a href="#Asynchrony-support" class="headerlink" title="Asynchrony support"></a>Asynchrony support</h3><p>Dart 中有很多返回 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-async/Future-class.html">Future</a> 和 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-async/Stream-class.html">Stream</a> 对象的函数，我们可以使用它们编写出异步的代码。除此之外，Dart 还提供了 <code>async</code> 和 <code>await</code> 关键字，让你可以像 JS 一样，更方便地写出一些更具易读性的异步代码。</p>
<p>常见的用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart">Future&lt;<span class="hljs-built_in">String</span>&gt; lookUpVersion() <span class="hljs-keyword">async</span> =&gt; <span class="hljs-string">&#x27;1.0.0&#x27;</span>;<br><br><span class="hljs-comment">// 在方法末尾添加 async 关键字，说明方法执行耗时操作，返回值通常是 Future</span><br><span class="hljs-comment">// 如果 async 方法无有意义的返回值，可以返回 Future&lt;void&gt;</span><br>Future&lt;<span class="hljs-built_in">String</span>&gt; checkVersion() <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">var</span> version = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    version = <span class="hljs-keyword">await</span> lookUpVersion();<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">// React to inability to look up the version</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> verion;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Stream 和 Future 的不同之处在于，它可以连续接收多个异步事件。我们可以通过 StreamBuilder 对持续发生变化的数据流进行监听，比如通过 WebSocket 获取数据：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart">StreamBuilder(<br>    stream: webSocketChannel.stream,<br>    builder: (context, snapshot) &#123;<br>      <span class="hljs-built_in">String</span> message = <span class="hljs-string">&#x27;&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (snapshot.connectionState != ConnectionState.active ||<br>          snapshot.hasError) &#123;<br>        message = <span class="hljs-string">&#x27;has error&#x27;</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (snapshot.hasData) &#123;<br>        message = snapshot.data.toString();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        message = <span class="hljs-string">&#x27;no data&#x27;</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> Container(<br>        padding: EdgeInsets.symmetric(vertical: <span class="hljs-number">10</span>),<br>        child: Text(<span class="hljs-string">&#x27;<span class="hljs-subst">$message</span>&#x27;</span>,<br>            style: Theme.of(context).textTheme.headline6),<br>      );<br>    &#125;,<br>  ),<br>)<br></code></pre></td></tr></table></figure>

<p>另外，我们还可以通过 Stream 实现事件总线的功能，比如 <a target="_blank" rel="noopener" href="https://github.com/marcojakob/dart-event-bus">event_bus</a> 就是基于 Stream 实现的。</p>
<h3 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h3><p>Dart 中的 Generator 函数和 ES6 中相似，如果你想要延迟生成一系列值，可以考虑使用生成器。Dart 中的 Generator 函数分为两种：</p>
<ul>
<li>同步生成器：返回 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-core/Iterable-class.html">Iterable</a> 对象</li>
<li>异步生成器：返回 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-async/Stream-class.html">Stream</a> 对象</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 同步生成器</span><br><span class="hljs-built_in">Iterable</span>&lt;<span class="hljs-built_in">int</span>&gt; naturalsTo(<span class="hljs-built_in">int</span> n) <span class="hljs-keyword">sync</span>* &#123;<br>  <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (k &lt; n) <span class="hljs-keyword">yield</span> k++;<br>&#125;<br><br><span class="hljs-comment">// 异步生成器</span><br>Stream&lt;<span class="hljs-built_in">int</span>&gt; asynchronousNaturalsTo(<span class="hljs-built_in">int</span> n) <span class="hljs-keyword">async</span>* &#123;<br>  <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (k &lt; n) <span class="hljs-keyword">yield</span> k++;<br>&#125;<br><br><span class="hljs-comment">// 递归的生成器，使用 yield* 提高性能</span><br><span class="hljs-built_in">Iterable</span>&lt;<span class="hljs-built_in">int</span>&gt; naturalsDownFrom(<span class="hljs-built_in">int</span> n) <span class="hljs-keyword">sync</span>* &#123;<br>  <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">yield</span> n;<br>    <span class="hljs-keyword">yield</span>* naturalsDownFrom(n - <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Callable-classes"><a href="#Callable-classes" class="headerlink" title="Callable classes"></a>Callable classes</h3><p>我们可以通过给某个类实现 <code>call()</code> 方法，使得该类可以像方法一样被调用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WannabeFunction</span> </span>&#123;<br>  <span class="hljs-built_in">String</span> call(<span class="hljs-built_in">String</span> a, <span class="hljs-built_in">String</span> b, <span class="hljs-built_in">String</span> c) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;WannabeFunction.call()&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;<span class="hljs-subst">$a</span> <span class="hljs-subst">$b</span> <span class="hljs-subst">$c</span>!&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> wf = WannabeFunction(); <span class="hljs-comment">// 初始化该类对象，然后可以像方法一样调用它们</span><br>wf(<span class="hljs-string">&#x27;Hi&#x27;</span>, <span class="hljs-string">&#x27;there,&#x27;</span>, <span class="hljs-string">&#x27;gang&#x27;</span>) <span class="hljs-comment">// 实际调用的是 call() 方法</span><br></code></pre></td></tr></table></figure>

<h3 id="Isolates"><a href="#Isolates" class="headerlink" title="Isolates"></a>Isolates</h3><p>与其它语言的并发机制不同，Dart 中并没有采用共享状态的并发机制 (shared-state concurrency)，而是使用了 <em>isolates</em>。所有的代码都运行在自己的 <code>isolate</code> 中，每个 <code>isolate</code> 都有自己的内存堆，保证了相互独立性。</p>
<p>更多资料见：<a target="_blank" rel="noopener" href="https://dart.dev/guides/language/language-tour#isolates">Isolates</a>。</p>
<h3 id="Typedefs"><a href="#Typedefs" class="headerlink" title="Typedefs"></a>Typedefs</h3><p>Dart 中，一切皆是对象，函数也是对象，但是函数对象的信息在运行时往往会被丢失，比如下面这个例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedCollection</span> </span>&#123;<br>  <span class="hljs-built_in">Function</span> compare;<br><br>  SortedCollection(<span class="hljs-built_in">int</span> f(<span class="hljs-built_in">Object</span> a, <span class="hljs-built_in">Object</span> b)) : compare = f;<br>&#125;<br><br><span class="hljs-built_in">int</span> sort(<span class="hljs-built_in">Object</span> a, <span class="hljs-built_in">Object</span> b) =&gt; <span class="hljs-number">0</span>;<br><br>SortedCollection sc = SortedCollection(sort);<br><br><span class="hljs-comment">// 只知道 compare 是 Function，但是其具体类型被丢失了</span><br><span class="hljs-keyword">assert</span>(sc.compare <span class="hljs-keyword">is</span> <span class="hljs-built_in">Function</span>);<br></code></pre></td></tr></table></figure>

<p><code>typedef</code> 就是为了解决上面这个问题而出现的，我们可以给方法类型一个别名，这样，当方法被赋值到一个变量上时就能保留其类型信息：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 函数的信息被保存在 Compare 中</span><br><span class="hljs-keyword">typedef</span> Compare = <span class="hljs-built_in">int</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">Object</span> a, <span class="hljs-built_in">Object</span> b);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedCollection</span> </span>&#123;<br>  Compare compare; <span class="hljs-comment">// 用于接收我们定义的函数</span><br><br>  SortedCollection(<span class="hljs-keyword">this</span>.compare);<br>&#125;<br><br><span class="hljs-built_in">int</span> sort(<span class="hljs-built_in">Object</span> a, <span class="hljs-built_in">Object</span> b) =&gt; <span class="hljs-number">0</span>;<br><br>SortedCollection sc = SortedCollection(sort);<br><span class="hljs-keyword">assert</span>(sc.compare <span class="hljs-keyword">is</span> Compare); <span class="hljs-comment">// 现在可以确定函数的具体类型了</span><br></code></pre></td></tr></table></figure>

<p><code>typedef</code> 也可以使用泛型：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">typedef</span> Compare&lt;T&gt; = <span class="hljs-built_in">int</span> <span class="hljs-built_in">Function</span>(T a, T b);<br><br><span class="hljs-built_in">int</span> sort(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) =&gt; a - b;<br><br><span class="hljs-keyword">assert</span>(sort <span class="hljs-keyword">is</span> Compare&lt;<span class="hljs-built_in">int</span>&gt;); <span class="hljs-comment">// True!</span><br></code></pre></td></tr></table></figure>

<h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>通过元信息注解，我们可以为类和方法提供额外的信息。Dart 中自带的注解有 <code>@deprecated</code> 和 <code>@override</code>，除此之外，你也可以自定义注解，只要在类的构造器上使用 <code>const</code> 关键字就可以了：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> who;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> what;<br><br>  <span class="hljs-keyword">const</span> Todo(<span class="hljs-keyword">this</span>.who, <span class="hljs-keyword">this</span>.what);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h3><p>Dart 支持三种类型的注释：单行注释、多行注释和文档注释。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="language-markdown">文档注释，使用 [] 给成员属性或者方法添加链接，比如查看 [main] 方法</span></span><br><span class="hljs-comment">/// <span class="language-markdown">虽然 Dart 中也能用 /** <span class="hljs-emphasis">*/ 作为文档注释，但是编辑器会提醒你用 /// 代替</span></span></span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">// 单行注释</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Howdy!&#x27;</span>);<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * 多行注释</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hola!&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/blog/">Writing</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Important-concepts"><span class="toc-number">1.</span> <span class="toc-text">Important concepts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Variables"><span class="toc-number">2.</span> <span class="toc-text">Variables</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">2.1.</span> <span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Late-%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">Late 变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final-%E5%92%8C-const"><span class="toc-number">2.3.</span> <span class="toc-text">final 和 const</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Build-in-types"><span class="toc-number">3.</span> <span class="toc-text">Build-in types</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Numbers"><span class="toc-number">3.1.</span> <span class="toc-text">Numbers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Strings"><span class="toc-number">3.2.</span> <span class="toc-text">Strings</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Booleans"><span class="toc-number">3.3.</span> <span class="toc-text">Booleans</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lists"><span class="toc-number">3.4.</span> <span class="toc-text">Lists</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sets"><span class="toc-number">3.5.</span> <span class="toc-text">Sets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Maps"><span class="toc-number">3.6.</span> <span class="toc-text">Maps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runes-and-grapheme-clusters"><span class="toc-number">3.7.</span> <span class="toc-text">Runes and grapheme clusters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbols"><span class="toc-number">3.8.</span> <span class="toc-text">Symbols</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Functions"><span class="toc-number">4.</span> <span class="toc-text">Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">具名参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.2.</span> <span class="toc-text">可选位置参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">main() 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lexical-scope"><span class="toc-number">4.4.</span> <span class="toc-text">Lexical scope</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lexical-closures"><span class="toc-number">4.5.</span> <span class="toc-text">Lexical closures</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Operators"><span class="toc-number">5.</span> <span class="toc-text">Operators</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cascade-notation"><span class="toc-number">5.1.</span> <span class="toc-text">Cascade notation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Control-flow-statements"><span class="toc-number">6.</span> <span class="toc-text">Control flow statements</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#switch-and-case"><span class="toc-number">6.1.</span> <span class="toc-text">switch and case</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exceptions"><span class="toc-number">7.</span> <span class="toc-text">Exceptions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Catch"><span class="toc-number">7.1.</span> <span class="toc-text">Catch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Classes"><span class="toc-number">8.</span> <span class="toc-text">Classes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-class-members"><span class="toc-number">8.1.</span> <span class="toc-text">Using class members</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-constructors"><span class="toc-number">8.2.</span> <span class="toc-text">Using constructors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Getting-an-object%E2%80%99s-type"><span class="toc-number">8.3.</span> <span class="toc-text">Getting an object’s type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instance-variables"><span class="toc-number">8.4.</span> <span class="toc-text">Instance variables</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Constructors"><span class="toc-number">8.5.</span> <span class="toc-text">Constructors</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.5.1.</span> <span class="toc-text">具名构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">8.5.2.</span> <span class="toc-text">构造器初始化列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">8.5.3.</span> <span class="toc-text">构造器初始化顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.5.4.</span> <span class="toc-text">重定向构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.5.5.</span> <span class="toc-text">常量构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.5.6.</span> <span class="toc-text">工厂构造器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Getters-and-setters"><span class="toc-number">8.6.</span> <span class="toc-text">Getters and setters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Abstract-classes"><span class="toc-number">8.7.</span> <span class="toc-text">Abstract classes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Implicit-interfaces"><span class="toc-number">8.8.</span> <span class="toc-text">Implicit interfaces</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Extending-a-class"><span class="toc-number">8.9.</span> <span class="toc-text">Extending a class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Extension-methods"><span class="toc-number">8.10.</span> <span class="toc-text">Extension methods</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Enumerated-types"><span class="toc-number">8.11.</span> <span class="toc-text">Enumerated types</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Adding-features-to-a-class-mixins"><span class="toc-number">8.12.</span> <span class="toc-text">Adding features to a class: mixins</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Class-variables-and-methods"><span class="toc-number">8.13.</span> <span class="toc-text">Class variables and methods</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generics"><span class="toc-number">9.</span> <span class="toc-text">Generics</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="toc-number">9.1.</span> <span class="toc-text">为什么使用泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-collection-literals"><span class="toc-number">9.2.</span> <span class="toc-text">Using collection literals</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%E5%8F%8A%E5%85%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.3.</span> <span class="toc-text">泛型集合及其类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">9.4.</span> <span class="toc-text">泛型参数类型的限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Libraries-and-visibility"><span class="toc-number">10.</span> <span class="toc-text">Libraries and visibility</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%BA%93%E7%9A%84%E5%89%8D%E7%BC%80"><span class="toc-number">10.1.</span> <span class="toc-text">指定库的前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E5%AF%BC%E5%85%A5"><span class="toc-number">10.2.</span> <span class="toc-text">部分导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-libraries"><span class="toc-number">10.3.</span> <span class="toc-text">实现 libraries</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Asynchrony-support"><span class="toc-number">11.</span> <span class="toc-text">Asynchrony support</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generators"><span class="toc-number">12.</span> <span class="toc-text">Generators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable-classes"><span class="toc-number">13.</span> <span class="toc-text">Callable classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Isolates"><span class="toc-number">14.</span> <span class="toc-text">Isolates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typedefs"><span class="toc-number">15.</span> <span class="toc-text">Typedefs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Metadata"><span class="toc-number">16.</span> <span class="toc-text">Metadata</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comments"><span class="toc-number">17.</span> <span class="toc-text">Comments</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ajiew.github.io/dart-notes/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ajiew.github.io/dart-notes/&text=Dart 学习笔记"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ajiew.github.io/dart-notes/&title=Dart 学习笔记"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ajiew.github.io/dart-notes/&is_video=false&description=Dart 学习笔记"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li> -->
  <li><a class="icon" href="mailto:?subject=Dart 学习笔记&body=Check out this article: https://ajiew.github.io/dart-notes/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ajiew.github.io/dart-notes/&title=Dart 学习笔记"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ajiew.github.io/dart-notes/&title=Dart 学习笔记"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ajiew.github.io/dart-notes/&title=Dart 学习笔记"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ajiew.github.io/dart-notes/&title=Dart 学习笔记"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ajiew.github.io/dart-notes/&name=Dart 学习笔记&description=&lt;p&gt;&lt;img src=&#34;https://dart.dev/assets/shared/dart-logo-for-shares.png&#34; alt=&#34;dart-logo&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读 &lt;a href=&#34;https://dart.dev/guides/language/language-tour&#34;&gt;language-tour&lt;/a&gt; 时做的一些笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;Important-concepts&#34;&gt;&lt;a href=&#34;#Important-concepts&#34; class=&#34;headerlink&#34; title=&#34;Important concepts&#34;&gt;&lt;/a&gt;Important concepts&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Dart 中一切皆对象，除了 null 之外，所有对象都继承自 &lt;a href=&#34;https://api.dart.dev/stable/dart-core/Object-class.html&#34;&gt;Object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dart 是强类型语言，但是类型标注是可选的，因为 Dart 中存在类型推断的机制，使用 &lt;code&gt;var&lt;/code&gt; 关键字后编译器可以推断出具体的类型&lt;/li&gt;
&lt;li&gt;当开启了空安全（dart ≧ v2.12）之后，对于可为空的值必须明确指出（用 &lt;code&gt;?&lt;/code&gt;），可为空的值转换成不为空的值时使用 &lt;code&gt;!&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当需要接收任意对象时使用 &lt;code&gt;Object?&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Dart 支持泛型，比如 &lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Dart 支持顶层函数和局部函数，同样也支持顶层变量&lt;/li&gt;
&lt;li&gt;标识符可以以字母或者 &lt;code&gt;_&lt;/code&gt; 开头，Dart 中 &lt;code&gt;_&lt;/code&gt; 开头的方法表示私有方法&lt;/li&gt;
&lt;li&gt;Dart 中也分为表达式 &lt;em&gt;expressions&lt;/em&gt; 和声明 &lt;em&gt;statements&lt;/em&gt;，表达式有返回值而声明无返回值&lt;/li&gt;
&lt;li&gt;Dart 工具提供了两种类型的问题：警告和错误。警告表示代码可能无法正确执行，错误分为编译期错误和运行时错误，编译期错误会导致程序无法执行，而运行时错误是代码执行过程中抛出的异常。&lt;/li&gt;
&lt;/ul&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ajiew.github.io/dart-notes/&t=Dart 学习笔记"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li> -->
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024
    aJIEw
  </div>
  <div class="footer-right">
    Find me on
    
    
    
      
        <a class="icon" target="_blank" rel="noopener" href="https://github.com/aJIEw" aria-label="github"><i class="fa-brands fa-github"></i></a>
      
      , 
      
    
      
        <a class="icon" target="_blank" rel="noopener" href="https://twitter.com/ajiew42" aria-label="twitter"><i class="fa-brands fa-twitter"></i></a>
      
       or 
      
    
      
        <a class="icon" target="_blank" rel="noopener" href="mailto:ajiew42@gmail.com" aria-label="mail"><i class="fas fa-envelope"></i></a>
      
      
      
    
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
