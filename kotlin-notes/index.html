<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="阅读文档和《Kotlin in Action》做的一些笔记。  代码规范源码组织目录结构在纯 Kotlin 的项目中，推荐的目录结构是省略根包名。如果包名是 com.example.kotlin，那么所有的代码都应该在这个根目录之下，比如 org.example.kotlin.network.socket 中的文件就应该放在 network&#x2F;socket 子目录下。 文件命名如果文件中只包含一">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin 学习笔记">
<meta property="og:url" content="https://ajiew.github.io/kotlin-notes/index.html">
<meta property="og:site_name" content="aJIEw">
<meta property="og:description" content="阅读文档和《Kotlin in Action》做的一些笔记。  代码规范源码组织目录结构在纯 Kotlin 的项目中，推荐的目录结构是省略根包名。如果包名是 com.example.kotlin，那么所有的代码都应该在这个根目录之下，比如 org.example.kotlin.network.socket 中的文件就应该放在 network&#x2F;socket 子目录下。 文件命名如果文件中只包含一">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Kotlin_logo_2021.svg/1280px-Kotlin_logo_2021.svg.png">
<meta property="article:published_time" content="2021-05-23T12:30:00.000Z">
<meta property="article:modified_time" content="2023-03-13T13:29:42.735Z">
<meta property="article:author" content="aJIEw">
<meta property="article:tag" content="Notes">
<meta property="article:tag" content="Kotlin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Kotlin_logo_2021.svg/1280px-Kotlin_logo_2021.svg.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Kotlin 学习笔记</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="aJIEw" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/blog/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2021-5/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2021-4/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ajiew.github.io/kotlin-notes/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ajiew.github.io/kotlin-notes/&text=Kotlin 学习笔记"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ajiew.github.io/kotlin-notes/&title=Kotlin 学习笔记"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ajiew.github.io/kotlin-notes/&is_video=false&description=Kotlin 学习笔记"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li> -->
  <li><a class="icon" href="mailto:?subject=Kotlin 学习笔记&body=Check out this article: https://ajiew.github.io/kotlin-notes/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ajiew.github.io/kotlin-notes/&title=Kotlin 学习笔记"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ajiew.github.io/kotlin-notes/&title=Kotlin 学习笔记"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ajiew.github.io/kotlin-notes/&title=Kotlin 学习笔记"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ajiew.github.io/kotlin-notes/&title=Kotlin 学习笔记"><i class="fab fa-digg " aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ajiew.github.io/kotlin-notes/&name=Kotlin 学习笔记&description=&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Kotlin_logo_2021.svg/1280px-Kotlin_logo_2021.svg.png&#34; alt=&#34;kotlin_logo&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读&lt;a href=&#34;https://kotlinlang.org/docs/home.html&#34;&gt;文档&lt;/a&gt;和《&lt;a href=&#34;https://book.douban.com/subject/27093660/&#34;&gt;Kotlin in Action&lt;/a&gt;》做的一些笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;代码规范&#34;&gt;&lt;a href=&#34;#代码规范&#34; class=&#34;headerlink&#34; title=&#34;代码规范&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://kotlinlang.org/docs/coding-conventions.html&#34;&gt;代码规范&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;源码组织&#34;&gt;&lt;a href=&#34;#源码组织&#34; class=&#34;headerlink&#34; title=&#34;源码组织&#34;&gt;&lt;/a&gt;源码组织&lt;/h3&gt;&lt;h4 id=&#34;目录结构&#34;&gt;&lt;a href=&#34;#目录结构&#34; class=&#34;headerlink&#34; title=&#34;目录结构&#34;&gt;&lt;/a&gt;目录结构&lt;/h4&gt;&lt;p&gt;在纯 Kotlin 的项目中，推荐的目录结构是省略根包名。如果包名是 &lt;code&gt;com.example.kotlin&lt;/code&gt;，那么所有的代码都应该在这个根目录之下，比如 &lt;code&gt;org.example.kotlin.network.socket&lt;/code&gt; 中的文件就应该放在 &lt;code&gt;network/socket&lt;/code&gt; 子目录下。&lt;/p&gt;
&lt;h4 id=&#34;文件命名&#34;&gt;&lt;a href=&#34;#文件命名&#34; class=&#34;headerlink&#34; title=&#34;文件命名&#34;&gt;&lt;/a&gt;文件命名&lt;/h4&gt;&lt;p&gt;如果文件中只包含一个类（包括顶层声明），则它的文件名应该和类名保持一致。如果文件包含多个类、顶层声明等，则应该选择最能描述这些类作用的命名，尽量选择清晰易懂的名称，如果做不到就应该使用多个文件分别保存。对于命名风格应该选择大驼峰命名法，并且应该避免使用一些无意义的后缀，比如 util 等。&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ajiew.github.io/kotlin-notes/&t=Kotlin 学习笔记"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li> -->
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-number">1.</span> <span class="toc-text">代码规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.</span> <span class="toc-text">源码组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D"><span class="toc-number">1.1.2.</span> <span class="toc-text">文件命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.3.</span> <span class="toc-text">文件组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%86%85%E5%AE%B9%E6%8E%92%E5%B8%83"><span class="toc-number">1.1.4.</span> <span class="toc-text">类的内容排布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%97%B6%E7%9A%84%E6%8E%92%E5%B8%83"><span class="toc-number">1.1.5.</span> <span class="toc-text">实现接口时的排布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95%E7%9A%84%E6%8E%92%E5%B8%83"><span class="toc-number">1.1.6.</span> <span class="toc-text">重载方法的排布</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">1.2.</span> <span class="toc-text">命名规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%90%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">方法名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E7%9A%84%E5%91%BD%E5%90%8D"><span class="toc-number">1.2.2.</span> <span class="toc-text">测试方法的命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%90%8D"><span class="toc-number">1.2.3.</span> <span class="toc-text">属性名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%95%E5%90%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E5%91%BD%E5%90%8D"><span class="toc-number">1.2.4.</span> <span class="toc-text">幕后属性的命名</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%95%E5%90%8E%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">幕后字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%95%E5%90%8E%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">幕后属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%8D%E7%A7%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">如何选择名称</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%A9%E8%BF%9B"><span class="toc-number">1.3.1.</span> <span class="toc-text">缩进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E4%BD%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">表达体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.5.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.6.</span> <span class="toc-text">控制流程语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.7.</span> <span class="toc-text">方法调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.8.</span> <span class="toc-text">链式调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambdas"><span class="toc-number">1.3.9.</span> <span class="toc-text">Lambdas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%96%E5%B0%BE%E9%80%97%E5%8F%B7"><span class="toc-number">1.3.10.</span> <span class="toc-text">拖尾逗号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">1.4.</span> <span class="toc-text">文档注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E6%83%AF%E7%94%A8%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">习惯用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">1.5.1.</span> <span class="toc-text">不可变性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">1.5.3.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda-%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.4.</span> <span class="toc-text">Lambda 参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.5.5.</span> <span class="toc-text">Lambda 返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.6.</span> <span class="toc-text">命名参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.5.7.</span> <span class="toc-text">条件表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Loops"><span class="toc-number">1.5.8.</span> <span class="toc-text">Loops</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Loops-on-range"><span class="toc-number">1.5.9.</span> <span class="toc-text">Loops on range</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">1.5.10.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Functions-vs-properties"><span class="toc-number">1.5.11.</span> <span class="toc-text">Functions vs properties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.12.</span> <span class="toc-text">扩展方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E6%96%B9%E6%B3%95-Infix-functions"><span class="toc-number">1.5.13.</span> <span class="toc-text">中缀方法 (Infix functions﻿)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.14.</span> <span class="toc-text">工厂方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">2.</span> <span class="toc-text">标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scope-functions"><span class="toc-number">2.1.</span> <span class="toc-text">Scope functions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Distinctions"><span class="toc-number">2.1.1.</span> <span class="toc-text">Distinctions</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Context-object-this-or-it"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">Context object: this or it</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Return-value"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">Return value</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#let"><span class="toc-number">2.1.2.</span> <span class="toc-text">let</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#with"><span class="toc-number">2.1.3.</span> <span class="toc-text">with</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#run"><span class="toc-number">2.1.4.</span> <span class="toc-text">run</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#apply"><span class="toc-number">2.1.5.</span> <span class="toc-text">apply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#also"><span class="toc-number">2.1.6.</span> <span class="toc-text">also</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#takeIf-and-takeUnless"><span class="toc-number">2.1.7.</span> <span class="toc-text">takeIf and takeUnless</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%8B%E5%8F%98"><span class="toc-number">3.1.1.</span> <span class="toc-text">型变</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%A4%84%E5%9E%8B%E5%8F%98"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">声明处型变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%84%E5%9E%8B%E5%8F%98"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">使用处型变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Star-projections"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">Star-projections</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">泛型函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">泛型约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">3.1.4.</span> <span class="toc-text">类型擦除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">函数与 Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">4.1.2.</span> <span class="toc-text">函数类型实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E8%B0%83%E7%94%A8"><span class="toc-number">4.1.3.</span> <span class="toc-text">函数类型实例调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E6%9C%AB%E5%B0%BE%E7%9A%84-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">传递末尾的 lambda 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#it%EF%BC%9A%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E9%9A%90%E5%BC%8F%E5%90%8D%E7%A7%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">it：单个参数的隐式名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.2.4.</span> <span class="toc-text">从 lambda 表达式中返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E5%88%92%E7%BA%BF%E7%94%A8%E4%BA%8E%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">4.2.5.</span> <span class="toc-text">下划线用于未使用的变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%A3%E6%9E%84%E5%A3%B0%E6%98%8E"><span class="toc-number">4.2.6.</span> <span class="toc-text">lambda 表达式中的解构声明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">匿名函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">4.3.1.</span> <span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">内联函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E5%86%85%E8%81%94"><span class="toc-number">4.4.1.</span> <span class="toc-text">禁用内联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%B1%80%E9%83%A8%E8%BF%94%E5%9B%9E"><span class="toc-number">4.4.2.</span> <span class="toc-text">非局部返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">4.4.3.</span> <span class="toc-text">具体化的类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%B1%9E%E6%80%A7"><span class="toc-number">4.4.4.</span> <span class="toc-text">内联属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF"><span class="toc-number">5.1.</span> <span class="toc-text">异步编程技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83"><span class="toc-number">5.1.2.</span> <span class="toc-text">回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Futures-Promises-%E5%8F%8A%E5%85%B6%E5%AE%83"><span class="toc-number">5.1.3.</span> <span class="toc-text">Futures &#x2F; Promises 及其它</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%8F%92%E4%BB%B6"><span class="toc-number">5.1.4.</span> <span class="toc-text">响应式插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B-1"><span class="toc-number">5.1.5.</span> <span class="toc-text">协程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">5.2.</span> <span class="toc-text">协程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91"><span class="toc-number">5.2.1.</span> <span class="toc-text">结构化并发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CoroutineScope-vs-CoroutineContext"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">CoroutineScope vs CoroutineContext</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.2.</span> <span class="toc-text">挂起函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9E%84%E5%BB%BA%E5%99%A8"><span class="toc-number">5.2.3.</span> <span class="toc-text">作用域构建器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8D%8F%E7%A8%8B%E5%83%8F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.2.4.</span> <span class="toc-text">全局协程像守护线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E4%B8%8E%E8%B6%85%E6%97%B6"><span class="toc-number">5.3.</span> <span class="toc-text">取消与超时</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%B6%88"><span class="toc-number">5.3.1.</span> <span class="toc-text">取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6"><span class="toc-number">5.3.2.</span> <span class="toc-text">超时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">组合挂起函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-async-%E5%B9%B6%E5%8F%91"><span class="toc-number">5.4.1.</span> <span class="toc-text">使用 async 并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%90%AF%E5%8A%A8%E7%9A%84-async"><span class="toc-number">5.4.2.</span> <span class="toc-text">惰性启动的 async</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async-%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.3.</span> <span class="toc-text">async 风格的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-async-%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91"><span class="toc-number">5.4.4.</span> <span class="toc-text">使用 async 的结构化并发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">5.5.</span> <span class="toc-text">协程上下文与调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.5.1.</span> <span class="toc-text">调度器与线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%B5%81"><span class="toc-number">5.6.</span> <span class="toc-text">异步流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E4%B8%8E%E6%B5%81"><span class="toc-number">5.6.1.</span> <span class="toc-text">序列与流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E5%8F%96%E6%B6%88"><span class="toc-number">5.6.2.</span> <span class="toc-text">流的取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%98%AF%E5%86%B7%E7%9A%84"><span class="toc-number">5.6.3.</span> <span class="toc-text">流是冷的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84"><span class="toc-number">5.6.4.</span> <span class="toc-text">流是连续的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">5.6.5.</span> <span class="toc-text">流上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#withContext-%E5%8F%91%E5%87%BA%E9%94%99%E8%AF%AF"><span class="toc-number">5.6.5.1.</span> <span class="toc-text">withContext 发出错误</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%9E%84%E5%BB%BA%E5%99%A8"><span class="toc-number">5.6.6.</span> <span class="toc-text">流构建器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.</span> <span class="toc-text">流操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1%E6%93%8D%E4%BD%9C%E7%AC%A6-map"><span class="toc-number">5.6.7.1.</span> <span class="toc-text">过渡操作符 map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6-transform"><span class="toc-number">5.6.7.2.</span> <span class="toc-text">转换操作符 transform</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%90%E9%95%BF%E6%93%8D%E4%BD%9C%E7%AC%A6-take"><span class="toc-number">5.6.7.3.</span> <span class="toc-text">限长操作符 take</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AB%E7%AB%AF%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.4.</span> <span class="toc-text">末端操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#flowOn-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.5.</span> <span class="toc-text">flowOn 操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.6.</span> <span class="toc-text">缓冲操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#conflate"><span class="toc-number">5.6.7.6.1.</span> <span class="toc-text">conflate</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#collectLatest"><span class="toc-number">5.6.7.6.2.</span> <span class="toc-text">collectLatest</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.7.</span> <span class="toc-text">合并操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Zip"><span class="toc-number">5.6.7.7.1.</span> <span class="toc-text">Zip</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#combine"><span class="toc-number">5.6.7.7.2.</span> <span class="toc-text">combine</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%95%E5%B9%B3%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.8.</span> <span class="toc-text">展平操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#flatMapConcat"><span class="toc-number">5.6.7.8.1.</span> <span class="toc-text">flatMapConcat</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#flatMapMerge"><span class="toc-number">5.6.7.8.2.</span> <span class="toc-text">flatMapMerge</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#flatMapLatest"><span class="toc-number">5.6.7.8.3.</span> <span class="toc-text">flatMapLatest</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.9.</span> <span class="toc-text">异常操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-try-catch-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">5.6.7.9.1.</span> <span class="toc-text">使用 try..catch 捕获异常</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#catch-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.9.2.</span> <span class="toc-text">catch 操作符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8D%95%E8%8E%B7-onEach"><span class="toc-number">5.6.7.9.3.</span> <span class="toc-text">声明式捕获 onEach</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.10.</span> <span class="toc-text">完成操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%BC%8F-finally-%E5%9D%97"><span class="toc-number">5.6.7.10.1.</span> <span class="toc-text">命令式 finally 块</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%A4%84%E7%90%86-onCompletion"><span class="toc-number">5.6.7.10.2.</span> <span class="toc-text">声明式处理 onCompletion</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.11.</span> <span class="toc-text">启动操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E5%8F%96%E6%B6%88%E7%9A%84%E6%B5%81"><span class="toc-number">5.6.7.11.1.</span> <span class="toc-text">可取消的流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flow-%E4%B8%8E-Rx"><span class="toc-number">5.6.8.</span> <span class="toc-text">Flow 与 Rx</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93"><span class="toc-number">5.7.</span> <span class="toc-text">通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E5%9F%BA%E7%A1%80"><span class="toc-number">5.7.1.</span> <span class="toc-text">通道基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E7%9A%84%E5%85%B3%E9%97%AD%E4%B8%8E%E8%BF%AD%E4%BB%A3"><span class="toc-number">5.7.1.1.</span> <span class="toc-text">通道的关闭与迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%80%9A%E9%81%93%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">5.7.1.2.</span> <span class="toc-text">构建通道生产者</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">5.7.2.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%87%E5%87%BA"><span class="toc-number">5.7.3.</span> <span class="toc-text">扇出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%87%E5%85%A5"><span class="toc-number">5.7.4.</span> <span class="toc-text">扇入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-number">5.7.5.</span> <span class="toc-text">带缓冲的通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%98%AF%E5%85%AC%E5%B9%B3%E7%9A%84"><span class="toc-number">5.7.6.</span> <span class="toc-text">通道是公平的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8%E9%80%9A%E9%81%93"><span class="toc-number">5.7.7.</span> <span class="toc-text">计时器通道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E7%9B%91%E7%9D%A3"><span class="toc-number">5.8.</span> <span class="toc-text">异常处理与监督</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BC%A0%E6%92%AD"><span class="toc-number">5.8.1.</span> <span class="toc-text">异常的传播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CoroutineExceptionHandler"><span class="toc-number">5.8.2.</span> <span class="toc-text">CoroutineExceptionHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-number">5.8.3.</span> <span class="toc-text">取消与异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%81%9A%E5%90%88"><span class="toc-number">5.8.4.</span> <span class="toc-text">异常聚合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E7%9D%A3"><span class="toc-number">5.8.5.</span> <span class="toc-text">监督</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%91%E7%9D%A3%E4%BD%9C%E4%B8%9A"><span class="toc-number">5.8.5.1.</span> <span class="toc-text">监督作业</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%91%E7%9D%A3%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.8.5.2.</span> <span class="toc-text">监督作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%91%E7%9D%A3%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">5.8.5.3.</span> <span class="toc-text">监督协程中的异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E7%9A%84%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">5.9.</span> <span class="toc-text">共享的可变状态与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.9.1.</span> <span class="toc-text">线程安全的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E7%BB%86%E7%B2%92%E5%BA%A6%E9%99%90%E5%88%B6%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.9.2.</span> <span class="toc-text">以细粒度限制线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E7%B2%97%E7%B2%92%E5%BA%A6%E9%99%90%E5%88%B6%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.9.3.</span> <span class="toc-text">以粗粒度限制线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-number">5.9.4.</span> <span class="toc-text">互斥</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Kotlin 学习笔记
    </h1>



    <div class="meta">
      <p/>
      <!-- <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">aJIEw</span>
      </span> -->
      
    <div class="postdate">
      
        <time datetime="2021-05-23T12:30:00.000Z" itemprop="datePublished">2021-05-23</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Kotlin/" rel="tag">Kotlin</a>, <a class="tag-link-link" href="/tags/Notes/" rel="tag">Notes</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Kotlin_logo_2021.svg/1280px-Kotlin_logo_2021.svg.png" alt="kotlin_logo"></p>
<blockquote>
<p>阅读<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/home.html">文档</a>和《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/27093660/">Kotlin in Action</a>》做的一些笔记。</p>
</blockquote>
<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/coding-conventions.html">代码规范</a></h2><h3 id="源码组织"><a href="#源码组织" class="headerlink" title="源码组织"></a>源码组织</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>在纯 Kotlin 的项目中，推荐的目录结构是省略根包名。如果包名是 <code>com.example.kotlin</code>，那么所有的代码都应该在这个根目录之下，比如 <code>org.example.kotlin.network.socket</code> 中的文件就应该放在 <code>network/socket</code> 子目录下。</p>
<h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><p>如果文件中只包含一个类（包括顶层声明），则它的文件名应该和类名保持一致。如果文件包含多个类、顶层声明等，则应该选择最能描述这些类作用的命名，尽量选择清晰易懂的名称，如果做不到就应该使用多个文件分别保存。对于命名风格应该选择大驼峰命名法，并且应该避免使用一些无意义的后缀，比如 util 等。</p>
<span id="more"></span>

<h4 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h4><p>如果多个类相互关系密切，并且描述的是同一个功能，那么推荐将它们放在同一个文件，只要最终的文件不是太长就可以。尤其是当我们需要为类定义一些扩展方法的时候，如果扩展方法只和当前类有关，那么就应该把这些扩展方法放到类一起，而不是单独创建一个文件用于保存扩展方法。</p>
<h4 id="类的内容排布"><a href="#类的内容排布" class="headerlink" title="类的内容排布"></a>类的内容排布</h4><p>类的各部分排列应该按照以下顺序：</p>
<ol>
<li>属性声明和初始化代码块</li>
<li>从构造器</li>
<li>方法声明</li>
<li>伴生对象</li>
</ol>
<p>初次之外，不要将方法根据首字母顺序排序，或者根据可见性排序，也不要将普通方法和扩展方法分开来，而是应该将相关的方法放在一起，根据功能依次排列，这样阅读你的代码的人才能方便地从上到下阅读你的代码，而不是频繁地来回跳转寻找相关代码。推荐将关键方法放到上面，然后是较基础和底层的方法。</p>
<p>对于嵌套类来说，推荐将它们放到使用到这些类的地方。如果嵌套类只是被外界使用，则可以将它们放到类的底部，位于伴生对象之后。</p>
<h4 id="实现接口时的排布"><a href="#实现接口时的排布" class="headerlink" title="实现接口时的排布"></a>实现接口时的排布</h4><p>保持类中实现的各个方法的顺序和接口中方法定义顺序一致，如果有私有方法的话，应该放在实现的方法附近。</p>
<h4 id="重载方法的排布"><a href="#重载方法的排布" class="headerlink" title="重载方法的排布"></a>重载方法的排布</h4><p>永远要把重载方法放在一起，方便阅读者看到一个方法全部的重载方法。</p>
<h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>包名和类名的命名规则：</p>
<ul>
<li>包名由小写单词和 <code>.</code> 构成，且不能使用下划线，多个单词推荐使用 <code>.</code> 分割或者直接拼接。</li>
<li>类名使用 UpperCamelCase，大驼峰命名。</li>
</ul>
<h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>方法名、属性名、局部变量都应该使用小写字母开头，并且使用驼峰命名法，且不能使用下划线。只有工厂方法才可以使用与类名相同的方法名。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span></span>: Foo &#123; <span class="hljs-keyword">return</span> FooImpl() &#125;<br></code></pre></td></tr></table></figure>

<h4 id="测试方法的命名"><a href="#测试方法的命名" class="headerlink" title="测试方法的命名"></a>测试方法的命名</h4><p>只有在测试方法中才可以使用反引号，但是注意安卓运行环境下并不支持这种方式，不过可以使用下划线。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span> &#123;<br>    <span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> `ensure everything works`<span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">/*...*/</span> &#125;<br><br>    <span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ensureEverythingWorks_onAndroid</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">/*...*/</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="属性名"><a href="#属性名" class="headerlink" title="属性名"></a>属性名</h4><p>常量，被标记为 <code>const val</code> 的属性，以及没有自定义 getter、数据不可变的 <code>val</code> 属性应该使用大写字符+下划线分割：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MAX_COUNT = <span class="hljs-number">8</span><br><span class="hljs-keyword">val</span> USER_NAME_FIELD = <span class="hljs-string">&quot;UserName&quot;</span><br></code></pre></td></tr></table></figure>

<p>顶层变量或者类的成员属性如果携带可变数据，则应该使用小驼峰命名法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> mutableCollection: MutableSet&lt;String&gt; = HashSet()<br></code></pre></td></tr></table></figure>

<p>如果表示单例对象，则命名应该和对象声明保持一致：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> PersonComparator: Comparator&lt;Person&gt; = <span class="hljs-comment">/*...*/</span><br></code></pre></td></tr></table></figure>

<p>枚举类的命名应该和 Java 中的命名保持一致：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> &#123; RED, GREEN, LIGHT_BLUE &#125;<br></code></pre></td></tr></table></figure>

<h4 id="幕后属性的命名"><a href="#幕后属性的命名" class="headerlink" title="幕后属性的命名"></a>幕后属性的命名</h4><h5 id="幕后字段"><a href="#幕后字段" class="headerlink" title="幕后字段"></a>幕后字段</h5><p>一个类中通常包含属性（Property）和字段（Field），外界不可直接访问字段，一般是通过属性提供对字段的访问，有时属性中还包括对字段的计算和转换，然后再返回。Kotlin 中的属性分为只读的（通过 <code>val</code> 声明）和可变的（通过 <code>var</code> 声明），除此之外，我们还可以为属性提供自定义的访问器（getters &amp; setters）。</p>
<p>Kotlin 中的字段无法显式被声明（我们只能创建属性），但是，当属性需要用到字段的时候，Kotlin 会默认它自动生成幕后字段（backing field），这个幕后字段可以在访问器通过 <code>field</code> 关键字进行调用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span> <span class="hljs-comment">// the initializer assigns the backing field directly</span><br>    <span class="hljs-keyword">set</span>(value) &#123;<br>        <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0</span>)<br>            field = value<br>            <span class="hljs-comment">// ERROR StackOverflow: Using actual name &#x27;counter&#x27; would make setter recursive</span><br>            <span class="hljs-comment">// counter = value</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>只有在使用了至少一个默认的访问器或者自定义访问器中引用了 <code>field</code> 才会生成幕后字段，下面这个例子中就没有幕后字段：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 没有初始化器而且自定义访问器中没有调用 field，此时就不会有幕后字段。</span><br><span class="hljs-keyword">val</span> isEmpty: <span class="hljs-built_in">Boolean</span> <span class="hljs-comment">// 只要有初始化器，则必定会生成幕后字段；没有幕后字段就不能被初始化。</span><br>    <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span>.size == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h5 id="幕后属性"><a href="#幕后属性" class="headerlink" title="幕后属性"></a>幕后属性</h5><p>如果你不喜欢这种隐式的幕后字段，则可以使用幕后属性，也就是通过在类的内部维护一个可读可写的属性，然后对外界提供一个只读的属性：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment"><span class="language-markdown">/**</span></span><br><span class="language-markdown"><span class="hljs-comment"><span class="hljs-bullet"> *</span> 外部只能通过 table 来访问，但实际上访问的是 <span class="hljs-emphasis">_table</span></span></span><br><span class="hljs-emphasis"><span class="language-markdown"><span class="hljs-comment"> * 类似于 Java 中通过设置 Getter 和 Setter 来控制对属性的访问</span></span></span><br><span class="hljs-emphasis"><span class="language-markdown"><span class="hljs-comment"> * */</span></span></span><br>private <span class="hljs-keyword">var</span> _table: <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Int&gt;? = <span class="hljs-keyword">null</span><br>val table: <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Int&gt;<br>    <span class="hljs-keyword">get</span>() &#123;<br>        <span class="hljs-keyword">if</span> (_table == <span class="hljs-keyword">null</span>) &#123;<br>            _table = HashMap()<br>        &#125;<br>        <span class="hljs-keyword">return</span> _table ?: <span class="hljs-keyword">throw</span> AssertionError(<span class="hljs-string">&quot;Set to null by another thread&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>在命名幕后字段时，私有属性应该使用下划线作为开头。</p>
<h4 id="如何选择名称"><a href="#如何选择名称" class="headerlink" title="如何选择名称"></a>如何选择名称</h4><p>类名应该以名词为结尾，描述该类的作用或功能。类名应该避免使用一些无意义的单词，比如前面提到过的 Util，还有 Manager/Wrapper 等等。</p>
<p>方法名应该是动词或者动词短语，描述方法的功能或执行哪些操作，并且应该表明是否会修改对象或者返回一个新的对象，比如 sort 和 sorted。</p>
<p>对于缩写词，应该尽量少用，除非是特别常见的，比如 <code>IO</code>/<code>TV</code> 等等，或者是在当前项目的文档中注明过的常见缩写。如果是两个字母以上的缩写，应该当做普通的单词使用，比如 <code>HttpConnection</code>/<code>XmlParser</code> 等等。</p>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>打开 IDE (IDEA/Android Studio) 的 <strong>Preferences &gt; Editor &gt; Code Style &gt; Kotlin</strong>，使用默认设置，全部看一遍就够了。</p>
<h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>使用四个空格作为缩进，不要使用 Tab。</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>如果类的签名很长，主构造函数中的参数很多，实现的接口很多时，都应该使用换行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<br>    id: <span class="hljs-built_in">Int</span>,<br>    name: String,<br>    surname: String<br>) : Human(id, name),<br>    KotlinMaker,<br>    SomeOtherInterface,<br>    AndAnotherOne &#123;<br>    <br>    <span class="hljs-comment">// 这种情况下类的第一行应该使用空白行增加可读性</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>同理，如果方法签名很长，应该使用换行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">longMethodName</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    argument: <span class="hljs-type">ArgumentType</span> = defaultValue,</span></span><br><span class="hljs-params"><span class="hljs-function">    argument2: <span class="hljs-type">AnotherArgumentType</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: ReturnType &#123;<br><br>    <span class="hljs-comment">// body</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="表达体"><a href="#表达体" class="headerlink" title="表达体"></a>表达体</h4><p>如果方法体只有一行代码，或者只有返回值，则应该使用表达体：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// = 后面就是表达体(expression bodies)</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> = value.size()<br><br><span class="hljs-comment">// 当表达体很长时，使用换行并添加 4 个空格</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f</span><span class="hljs-params">(x: <span class="hljs-type">String</span>, y: <span class="hljs-type">String</span>, z: <span class="hljs-type">String</span>)</span></span> =<br>    veryLongFunctionCallWithManyWords(andLongParametersToo(), x, y, z)<br></code></pre></td></tr></table></figure>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>如果是比较简单的属性，应该放在同一行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> isEmpty: <span class="hljs-built_in">Boolean</span> <span class="hljs-keyword">get</span>() = size == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>如果 getters/setters 比较复杂，则应该换行并使用缩进：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> foo: String<br>    <span class="hljs-keyword">get</span>() &#123;<br>        <span class="hljs-comment">// body</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>如果初始化器比较长，同样应该换行并使用缩进：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> defaultCharset: Charset? =<br>    EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)<br></code></pre></td></tr></table></figure>

<h4 id="控制流程语句"><a href="#控制流程语句" class="headerlink" title="控制流程语句"></a>控制流程语句</h4><p>如果 if 或 when 中包含多个语句，必须使用花括号，并且每个条件或者语句都要使用缩进，与第一个语句条件对齐：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (!component.isSyncing &amp;&amp;<br>    !hasAnyKotlinRuntimeInScope(module) ||<br>    (someOtherCondition &amp;&amp; andSomeMore)<br>) &#123;<br>    <span class="hljs-keyword">return</span> createKotlinNotConfiguredPanel(module)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>when 语句中，只有在分支包含多个表达式时才使用花括号：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parsePropertyValue</span><span class="hljs-params">(propName: <span class="hljs-type">String</span>, token: <span class="hljs-type">Token</span>)</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (token) &#123;<br>        condition1 -&gt; shortCondition()<br>        <span class="hljs-keyword">is</span> Token.ValueToken -&gt;<br>            callback.visitValue(propName, token.value)<br>      <br>        Token.LBRACE -&gt; &#123;<br>          <span class="hljs-comment">// long body</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>如果方法的参数较多，使用换行，并将多个相近的参数放在同一行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">drawSquare(<br>    x = <span class="hljs-number">10</span>, y = <span class="hljs-number">10</span>,<br>    width = <span class="hljs-number">100</span>, height = <span class="hljs-number">100</span>,<br>    fill = <span class="hljs-literal">true</span><br>)<br></code></pre></td></tr></table></figure>

<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> anchor = owner<br>    ?.firstChild!!<br>    .siblings(forward = <span class="hljs-literal">true</span>)<br>    .dropWhile &#123; it <span class="hljs-keyword">is</span> PsiComment || it <span class="hljs-keyword">is</span> PsiWhiteSpace &#125;<br></code></pre></td></tr></table></figure>

<h4 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h4><p>如果方法只接收一个 lambda 表达式，方法体应该放在括号外面并省略括号：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">list.filter &#123; it &gt; <span class="hljs-number">10</span> &#125;<br></code></pre></td></tr></table></figure>

<p>如果给 lambda 指定了标签，标签和花括号之间不能有空格：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    ints.forEach <span class="hljs-symbol">lit@</span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果 lambda 中指定了参数名，则应该使用换行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">appendCommaSeparated(properties) &#123; prop -&gt;<br>    <span class="hljs-keyword">val</span> propertyValue = prop.<span class="hljs-keyword">get</span>(obj)<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果 lambda 中的参数列表很长，则应该使用换行并将 <code>-&gt;</code> 单独放在一行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">foo &#123;<br>   context: Context,<br>   environment: Env<br>   -&gt;<br>   context.configureEnv(environment)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="拖尾逗号"><a href="#拖尾逗号" class="headerlink" title="拖尾逗号"></a>拖尾逗号</h4><p>当参数或者值的列表很长时，应该使用拖尾逗号 (<em>Trailing commas</em>)：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@ApplicableFor([</span><br><span class="hljs-meta">    <span class="hljs-string">&quot;serializer&quot;</span>,</span><br><span class="hljs-meta">    <span class="hljs-string">&quot;balancer&quot;</span>,</span><br><span class="hljs-meta">    <span class="hljs-string">&quot;database&quot;</span>,</span><br><span class="hljs-meta">    <span class="hljs-string">&quot;inMemoryCache&quot;</span>, // trailing comma</span><br><span class="hljs-meta">])</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<br>    <span class="hljs-keyword">val</span> firstName: String,<br>    <span class="hljs-keyword">val</span> lastName: String,<br>    <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>, <span class="hljs-comment">// trailing comma</span><br>) &#123;<br><br>    <span class="hljs-keyword">val</span> colors = listOf(<br>        <span class="hljs-string">&quot;red&quot;</span>,<br>        <span class="hljs-string">&quot;green&quot;</span>,<br>        <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-comment">// trailing comma</span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>当文档注释较长时，应该使用换行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This is a summary, what this class does, blablabla...</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * More detailed description, explain how this works,</span><br><span class="hljs-comment"> * how to use it, and maybe add some sample codes.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AwesomeClass</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure>

<p>文档注释中，尽量不要使用 @param 或者 @return，而是尽可能地使用叙述性的文字，这样可以增加可读性。只有在参数特别多、解释性文字特别长时，才使用它们。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the absolute value of the given [number].</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">abs</span><span class="hljs-params">(number: <span class="hljs-type">Int</span>)</span></span> &#123; <span class="hljs-comment">/*...*/</span> &#125;<br></code></pre></td></tr></table></figure>

<h3 id="习惯用法"><a href="#习惯用法" class="headerlink" title="习惯用法"></a>习惯用法</h3><h4 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h4><p>倾向于使用不可变的数据。对于局部变量而言，如果初始化之后不会再进行修改的话，尽量使用 <code>val</code> 声明而不是 <code>var</code>。尽量创建不可变的集合以及使用不可变的集合作为参数，以避免在使用过程中集合被意外改变后产生的各种错误。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Bad: use of mutable collection type for value which will not be mutated</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">validateValue</span><span class="hljs-params">(actualValue: <span class="hljs-type">String</span>, allowedValues: <span class="hljs-type">HashSet</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123; ... &#125;<br><br><span class="hljs-comment">// Good: immutable collection type used instead</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">validateValue</span><span class="hljs-params">(actualValue: <span class="hljs-type">String</span>, allowedValues: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123; ... &#125;<br><br><span class="hljs-comment">// Bad: arrayListOf() returns ArrayList&lt;T&gt;, which is a mutable collection type</span><br><span class="hljs-keyword">val</span> allowedValues = arrayListOf(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>)<br><br><span class="hljs-comment">// Good: listOf() returns List&lt;T&gt;</span><br><span class="hljs-keyword">val</span> allowedValues = listOf(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>)<br></code></pre></td></tr></table></figure>

<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>尽量为方法创建默认参数。</p>
<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>如果某个方法签名或者类型参数在你的代码库中被多次使用，那就应该为它创建类型别名：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">typealias</span> MouseClickHandler = (Any, MouseEvent) -&gt; <span class="hljs-built_in">Unit</span><br><span class="hljs-keyword">typealias</span> PersonIndex = Map&lt;String, Person&gt;<br></code></pre></td></tr></table></figure>

<p>尽量使用 <code>import xxx as xxx</code> 避免命名冲突。</p>
<h4 id="Lambda-参数"><a href="#Lambda-参数" class="headerlink" title="Lambda 参数"></a>Lambda 参数</h4><p>Lambda 中尽量使用 <code>it</code> 而不是显式指定参数名称，但是如果是在嵌套的 lambda 中，则应该为每个 lambda 表达式指定参数。</p>
<h4 id="Lambda-返回值"><a href="#Lambda-返回值" class="headerlink" title="Lambda 返回值"></a>Lambda 返回值</h4><p>尽量使得 lambda 表达式的返回值只有一个出口，而不是在多处使用 return，如果无法做到则应该使用匿名方法代替 lambda 表达式。</p>
<h4 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h4><p>如果调用的方法参数很多且有多个相同类型的参数，或者包含多个布尔值，则应该使用命名参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">drawSquare(x = <span class="hljs-number">10</span>, y = <span class="hljs-number">10</span>, width = <span class="hljs-number">100</span>, height = <span class="hljs-number">100</span>, fill = <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure>

<h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><p>尽量使用条件表达式的返回值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// if </span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (x) foo() <span class="hljs-keyword">else</span> bar()<br><br><span class="hljs-comment">// when</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span>(x) &#123;<br>    <span class="hljs-number">0</span> -&gt; <span class="hljs-string">&quot;zero&quot;</span><br>    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">&quot;nonzero&quot;</span><br>&#125;<br><br><span class="hljs-comment">// try..catch</span><br><span class="hljs-keyword">val</span> readFromInput: <span class="hljs-built_in">Int</span>? = <span class="hljs-keyword">try</span> &#123;<br>    parseInt(input)<br>&#125; <span class="hljs-keyword">catch</span> (e: NumberFormatException) &#123;<br>    <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h4><p>尽量使用高阶函数 (<code>filter</code>, <code>map</code> 等) 而不是循环，除了 <code>forEach</code>。</p>
<p>在决定使用高阶函数还是循环时，需要考虑使用场景和操作的性能消耗。</p>
<h4 id="Loops-on-range"><a href="#Loops-on-range" class="headerlink" title="Loops on range"></a>Loops on range</h4><p>需要关闭区间时使用 <code>until</code> 而不是 <code>x..n-1</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// bad:</span><br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.n - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/*...*/</span> &#125;<br><span class="hljs-comment">// good:</span><br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until n) &#123; <span class="hljs-comment">/*...*/</span> &#125;<br></code></pre></td></tr></table></figure>

<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>尽量使用字符串模板而不是字符串拼接。当需要换行时，优先使用多行字符串而不是 <code>\n</code>。</p>
<h4 id="Functions-vs-properties"><a href="#Functions-vs-properties" class="headerlink" title="Functions vs properties"></a>Functions vs properties</h4><p>对于没有参数的方法而言，其作用和自定义 getter 的属性是类似的。如果满足下列条件，则应该使用属性：</p>
<ul>
<li>不会抛出异常；</li>
<li>结果的计算是比较轻量级的操作；</li>
<li>只要对象的状态没有发生变化，调用的结果就不会发生变化；</li>
</ul>
<h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4><p>请自由使用扩展方法，如果一个方法在某个对象上被多次调用，那就应该把它设为扩展方法。为了减少 API 污染，应该注意扩展方法的可见性。</p>
<h4 id="中缀方法-Infix-functions"><a href="#中缀方法-Infix-functions" class="headerlink" title="中缀方法 (Infix functions﻿)"></a>中缀方法 (Infix functions﻿)</h4><p>只有在两个对象角色（功能）类似时才使用中缀方法，正确示例：<code>and</code>, <code>to</code>, <code>zip</code>，错误示例：<code>add</code>。</p>
<p>不要将一个会改变接收对象的方法定义为中缀方法。</p>
<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>工厂方法名尽量不要定义成和类名一样，尽量使用能体现其作用的命名，比如 <code>fromXxx</code> 等等。</p>
<h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="Scope-functions"><a href="#Scope-functions" class="headerlink" title="Scope functions"></a>Scope functions</h3><p>Kotlin 标准库中包含了一些在对象的上下文中执行代码块的方法，比如 <code>let</code>, <code>run</code>, <code>with</code>, <code>apply</code>, <code>also</code> 等，在调用这些方法时，会在 lambda 表达式中形成一个临时的 scope，在这个 scope 中，你可以直接访问对象的属性和方法。</p>
<p>举个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 传统方式调用，需要创建一个变量，然后通过变量来调用其方法</span><br><span class="hljs-keyword">val</span> alice = Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Amsterdam&quot;</span>)<br>println(alice)<br>alice.moveTo(<span class="hljs-string">&quot;London&quot;</span>)<br>alice.incrementAge()<br>println(alice)<br><br><span class="hljs-comment">// 使用 let</span><br>Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Amsterdam&quot;</span>).let &#123;<br>    println(it)<br>    it.moveTo(<span class="hljs-string">&quot;London&quot;</span>)<br>    it.incrementAge()<br>    println(it)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到使用 scope function 可以使我们的代码更简短以及具有可读性。</p>
<p>本质上来看，所有这些方法的执行效果都是相同的，唯一不同的是对象被调用的方式以及返回的结果不同。所以，我们了解并区分它们的区别，并在合适的场景下调用它们。</p>
<p>最简单的使用原则可以参考以下几点：</p>
<ul>
<li><p>执行一段 lambda 表达式：<code>let</code></p>
</li>
<li><p>在当前上下文中，创建一个表达式并使用其结果作为变量：<code>let</code></p>
</li>
<li><p>对象构建，比如使用 Builder 模式：<code>apply</code></p>
</li>
<li><p>配置对象属性并计算结果：<code>run</code></p>
</li>
<li><p>执行需要含有表达式的语句：<code>run</code></p>
</li>
<li><p>添加更多效果：<code>also</code></p>
</li>
<li><p>将多个方法调用合并到一起：<code>with</code></p>
</li>
</ul>
<p>可以看到，有些功能并不是只有一种方法才能实现，以上只是推荐的做法。另外，虽然使用 scope functions 可以使你的代码更灵活，但是如果过度使用比如使用嵌套等也会降低你的代码的可读性。另外，也要注意链式调用时 context 的变化，比如对象的参数由 <code>it</code> 变成了 <code>this</code> 或者由 <code>this</code> 变成了 <code>it</code>。</p>
<h4 id="Distinctions"><a href="#Distinctions" class="headerlink" title="Distinctions"></a>Distinctions</h4><p>Scope functions 之间最明显的区别主要有两个：如何引用 context 对象以及返回值。</p>
<h5 id="Context-object-this-or-it"><a href="#Context-object-this-or-it" class="headerlink" title="Context object: this or it"></a>Context object: this or it</h5><p><code>run</code>, <code>with</code>, <code>apply</code> 都通过 <code>this</code> 引用当前的 context 对象，因此，我们可以像在对象中一样访问它的属性和方法。当然，我们也可以省略 <code>this</code> 关键字，但是，这样做有时候会造成与外部其它代码造成名字冲突，所以，推荐的做法是加上 <code>this.</code> 来访问对象的属性和方法。</p>
<p>而 <code>let</code> 和 <code>also</code> 则通过 <code>it</code> 引用当前的 context 对象，而且我们需要手动调用 <code>it</code> 来访问对象上的属性和方法，不过这样可以使我们的代码显得更清晰。</p>
<h5 id="Return-value"><a href="#Return-value" class="headerlink" title="Return value"></a>Return value</h5><p><code>apply</code>, <code>also</code> 返回的是当前的 context 对象本身。因此，它们可以使用链式调用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> numberList = mutableListOf&lt;<span class="hljs-built_in">Double</span>&gt;()<br>numberList.also &#123; println(<span class="hljs-string">&quot;Populating the list&quot;</span>) &#125;<br>    .apply &#123;<br>        add(<span class="hljs-number">2.71</span>)<br>        add(<span class="hljs-number">3.14</span>)<br>        add(<span class="hljs-number">1.0</span>)<br>    &#125;<br>    .also &#123; println(<span class="hljs-string">&quot;Sorting the list&quot;</span>) &#125;<br>    .sort()<br></code></pre></td></tr></table></figure>

<p>也可以被用在 return 语句中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getRandomInt</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> Random.nextInt(<span class="hljs-number">100</span>).also &#123;<br>        writeToLog(<span class="hljs-string">&quot;getRandomInt() generated value <span class="hljs-variable">$it</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>let</code>, <code>run</code>, <code>with</code> 返回的 lambda 表达式的结果。所以，你可以用它们给变量赋值，也可以使用链式调用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> numbers = mutableListOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)<br><span class="hljs-keyword">val</span> countEndsWithE = numbers.run &#123; <br>    add(<span class="hljs-string">&quot;four&quot;</span>)<br>    add(<span class="hljs-string">&quot;five&quot;</span>)<br>    count &#123; it.endsWith(<span class="hljs-string">&quot;e&quot;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>在 let 方法中，context 对象以参数 <code>it</code> 的形式存在，返回值是 lambda 表达式的结果。</p>
<p>使用 let 方法可以帮我们减少创建一些临时变量，尤其是不打破链式调用的结构：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> numbers = mutableListOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>)<br>numbers.map &#123; it.length &#125;.filter &#123; it &gt; <span class="hljs-number">3</span> &#125;.let &#123; <br>    println(it)<br>    <span class="hljs-comment">// and more function calls if needed</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>另外，如果 let 中只包含一个方法调用，可以使用方法引用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">numbers.map &#123; it.length &#125;.filter &#123; it &gt; <span class="hljs-number">3</span> &#125;.let(::println)<br></code></pre></td></tr></table></figure>

<p>第三种用法是为变量创建一个局部 scope 提升代码的可读性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 需要在第一个数字上做一些操作</span><br><span class="hljs-keyword">val</span> modifiedFirstItem = numbers.first().let &#123; firstItem -&gt;<br>    println(<span class="hljs-string">&quot;The first item of the list is &#x27;<span class="hljs-variable">$firstItem</span>&#x27;&quot;</span>)<br>    <span class="hljs-keyword">if</span> (firstItem.length &gt;= <span class="hljs-number">5</span>) firstItem <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;!&quot;</span> + firstItem + <span class="hljs-string">&quot;!&quot;</span><br>&#125;.uppercase()<br></code></pre></td></tr></table></figure>

<h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>with 方法是一个非扩展函数，context 对象通过 <code>this</code> 访问，返回值是 lambda 表达式的结果。但是不推荐在 with 方法中返回结果，最好只做一些操作，表示 “<em>with this object, do the following.</em>“</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> numbers = mutableListOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)<br>with(numbers) &#123;<br>    println(<span class="hljs-string">&quot;&#x27;with&#x27; is called with argument <span class="hljs-variable">$this</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;It contains <span class="hljs-variable">$size</span> elements&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另一种使用场景是使用对象的属性和方法计算值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> numbers = mutableListOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)<br><span class="hljs-keyword">val</span> firstAndLast = with(numbers) &#123;<br>    <span class="hljs-string">&quot;The first element is <span class="hljs-subst">$&#123;first()&#125;</span>,&quot;</span> +<br>    <span class="hljs-string">&quot; the last element is <span class="hljs-subst">$&#123;last()&#125;</span>&quot;</span><br>&#125;<br>println(firstAndLast)<br></code></pre></td></tr></table></figure>

<h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>context 对象通过 <code>this</code> 访问，返回值是 lambda 表达式的结果。</p>
<p>run 方法的效果和 with 的效果一致，但是调用方式和 let 一样，作为扩展方法。run 适合在既需要对对象进行初始化配置，也需要对结果进行计算的情况：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> service = MultiportService(<span class="hljs-string">&quot;https://example.kotlinlang.org&quot;</span>, <span class="hljs-number">80</span>)<br><br><span class="hljs-keyword">val</span> result = service.run &#123;<br>    port = <span class="hljs-number">8080</span><br>    query(prepareRequest() + <span class="hljs-string">&quot; to port <span class="hljs-variable">$port</span>&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 使用 let</span><br><span class="hljs-keyword">val</span> letResult = service.let &#123;<br>    it.port = <span class="hljs-number">8080</span><br>    it.query(it.prepareRequest() + <span class="hljs-string">&quot; to port <span class="hljs-subst">$&#123;it.port&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除此之外，run 方法还有一个非扩展方法，我们可以用它执行一些需要执行表达式的语句，比如变量声明时：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> hexNumberRegex = run &#123;<br>    <span class="hljs-keyword">val</span> digits = <span class="hljs-string">&quot;0-9&quot;</span><br>    <span class="hljs-keyword">val</span> hexDigits = <span class="hljs-string">&quot;A-Fa-f&quot;</span><br>    <span class="hljs-keyword">val</span> sign = <span class="hljs-string">&quot;+-&quot;</span><br><br>    Regex(<span class="hljs-string">&quot;[<span class="hljs-variable">$sign</span>]?[<span class="hljs-variable">$digits</span><span class="hljs-variable">$hexDigits</span>]+&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>context 对象通过 <code>this</code> 访问，返回值是对象本身。</p>
<p>当不需要返回值，且主要对对象的成员和方法进行操作的时候可以使用 apply，最常见的是对象初始化配置：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> adam = Person(<span class="hljs-string">&quot;Adam&quot;</span>).apply &#123;<br>    age = <span class="hljs-number">32</span><br>    city = <span class="hljs-string">&quot;London&quot;</span>        <br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于返回的是对象本身，所以我们可以很方便地进行链式调用。</p>
<h4 id="also"><a href="#also" class="headerlink" title="also"></a>also</h4><p>context 对象通过 <code>it</code> 访问，返回值是对象本身。</p>
<p>also 适用于需要对象的引用而不是其属性和方法的场景下，以及你不想污染 <code>this</code> 关键字的时候，可以将其理解为 “<em>and also do the following with the object.</em>“</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> numbers = mutableListOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)<br>numbers<br>    .also &#123; println(<span class="hljs-string">&quot;The list elements before adding new one: <span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>    .add(<span class="hljs-string">&quot;four&quot;</span>)<br></code></pre></td></tr></table></figure>

<h4 id="takeIf-and-takeUnless"><a href="#takeIf-and-takeUnless" class="headerlink" title="takeIf and takeUnless"></a>takeIf and takeUnless</h4><p>除了 scope functions 之外，标准库中还提供了 <code>takeIf</code> 和 <code>takeUnless</code> 方法，可以让我们在使用对象之前对其状态进行检查。</p>
<p><code>takeIf</code> 只有在对象满足断言时才返回对象，否则返回 null，<code>takeUnless</code> 则恰恰相反，只有在对象不满足断言时才返回对象，否则返回 null，所以 <code>takeIf</code> 和 <code>takeUnless</code> 是对单个对象的筛选方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> number = Random.nextInt(<span class="hljs-number">100</span>)<br><br><span class="hljs-keyword">val</span> evenOrNull = number.takeIf &#123; it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#125;<br><span class="hljs-keyword">val</span> oddOrNull = number.takeUnless &#123; it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#125;<br><br>evenOrNull?.let &#123;<br>    println(<span class="hljs-string">&quot;even: <span class="hljs-variable">$evenOrNull</span>&quot;</span>)<br>&#125;<br>oddOrNull?.let &#123;<br>    println(<span class="hljs-string">&quot;odd: <span class="hljs-variable">$oddOrNull</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于返回值可能为空，所以必须使用 <code>?.</code>。而且可以看到 <code>takeIf</code> 和 <code>takeUnless</code> 非常适合配合 scope functions 使用。</p>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>和 Java 中一样，Kotlin 中也有类型参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-type">T</span>&gt;(t: T) &#123;<br>    <span class="hljs-keyword">var</span> value = t<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果通过构造器创建对象，类型参数也可以被推断出来，所以可以省略：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> box = Box(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<h4 id="型变"><a href="#型变" class="headerlink" title="型变"></a>型变</h4><p>Java 中的泛型不是型变的，因此会带来很多问题，所以我们一般需要使用通配符来为泛型确定上下边界。Kotlin 中没有通配符类型，而是引入了声明处型变（declaration-site variance）和类型投影（type projections）。</p>
<h5 id="声明处型变"><a href="#声明处型变" class="headerlink" title="声明处型变"></a>声明处型变</h5><p>先看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br>List&lt;Number&gt; numberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(); <span class="hljs-comment">// Incompatible types</span><br></code></pre></td></tr></table></figure>

<p>类似 <code>List</code> 这样的声明在 Java 中是不被允许的，因为 Java 中泛型不支持<em>协变</em>（Covariant，即 <code>A</code> 是 <code>B</code> 的父类，同时 <code>List&lt;A&gt;</code> 也是 <code>List&lt;B&gt;</code> 的父类，则称 List 类是协变的），我们需要使用通配符来告诉编译器这种声明是安全的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure>

<p>而在 Kotlin 中，我们通过 <code>out</code> 标注类型参数来支持协变，并且确保它只是被返回（生产）从不被消费：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-type">out T</span>&gt; : <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>)</span></span>: T <span class="hljs-comment">// 返回类型叫 out 位置，生产类型为 T 的元素</span><br>  <br>    <span class="hljs-comment">// 参数类型叫 in 位置，它消费类型为 T 的值。使用 @UnsafeVariance 是为了避免编译器报错</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(element: @<span class="hljs-type">UnsafeVariance</span> <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">copyList</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> source: List&lt;Number&gt; = list <span class="hljs-comment">// 现在可以被允许了</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里有一个原则，如果一个类 C 的类型参数 <code>T</code> 被声明为 <code>out</code> 时，它就只能出现在 C 的成员的输出位置（返回类型），回报是 <code>C&lt;Base&gt;</code> 可以安全地作为 <code>C&lt;Derived&gt;</code> 的父类。这样，我们就可以称类型参数 <code>T</code> 在 C 上是协变的。你可以认为 C 是 <code>T</code> 的生产者，而不是 <code>T</code> 的消费者。</p>
<p><code>out</code> 修饰符称为<em>型变注解</em>，并且由于它在类型参数声明处提供，所以我们称之为<strong>声明处型变</strong>。Java 中是在使用处通过通配符使得类型型变，Kotlin 与之正好相反。</p>
<p>另外，与之相对的，Kotlin 中还提供了另一个型变注释 <code>in</code>，它的作用是使得类型参数<em>逆变</em>（Contravariant，如果 <code>A</code> 是 <code>B</code> 的父类，那么 <code>List&lt;A&gt;</code> 就是 <code>List&lt;B&gt;</code> 的子类型），只可以被消费而不能被生产。逆变类型的一个很好的例子是 <code>Comparable</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;<span class="hljs-type">in T</span>&gt; &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(other: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showContravariant</span><span class="hljs-params">(x: <span class="hljs-type">Comparable</span>&lt;<span class="hljs-type">Number</span>&gt;)</span></span> &#123;<br>    x.compareTo(<span class="hljs-number">1.0</span>) <span class="hljs-comment">// 参数 1.0 的类型 Double，它是 Number 的子类型</span><br>    <span class="hljs-comment">// 因此，我们可以将 x 赋给类型为 Comparable&lt;Double&gt; 的变量</span><br>    <span class="hljs-keyword">val</span> y: Comparable&lt;<span class="hljs-built_in">Double</span>&gt; = x <span class="hljs-comment">// OK！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>总结一下，我们使用 <code>out</code> 关键字把类声明成是<em>协变</em> 的，并且要求 T 只能在 out 位置（被生产），只有这样才能确保子类型才是安全的：<code>List&lt;Int&gt;</code> 是 <code>List&lt;Number&gt;</code> 的子类型。使用 <code>in</code> 关键字使得类是逆变的，并且要求 T 只能在 in 位置（被消费）。</p>
<h5 id="使用处型变"><a href="#使用处型变" class="headerlink" title="使用处型变"></a>使用处型变</h5><p>同样先看个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">copy</span><span class="hljs-params">(from: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Number</span>&gt;, to: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Number</span>&gt;)</span></span> &#123;<br>    assert(from.size == to.size)<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> from.indices)<br>        to[i] = from[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> ints: Array&lt;<span class="hljs-built_in">Int</span>&gt; = arrayOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">val</span> nums = Array&lt;Number&gt;(<span class="hljs-number">3</span>) &#123; <span class="hljs-number">3.3</span> &#125;<br>    <span class="hljs-comment">// 无法调用 copy 方法，因为 Array&lt;Int&gt; 不是 Array&lt;Number&gt;！</span><br>    <span class="hljs-comment">// copy(ints, nums) // Type mismatch</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Array</code> 类需要能被读和写，因此既不能是协变的也不能是逆变的，这就带来了一个问题，<code>Array&lt;Number&gt;</code> 不能被转换为 <code>Array&lt;Int&gt;</code>，因此，我们需要在<em><strong>使用处</strong></em> 也就是 from 的类型参数前添加 <code>out</code> 关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">copy</span><span class="hljs-params">(from: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Number</span>&gt;, to: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Number</span>&gt;)</span></span> &#123; …… &#125;<br></code></pre></td></tr></table></figure>

<p>我们把 from 称为一个受限制 (<em>projected</em>) 的数组，只可以调用返回类型为 <code>T</code> 的方法，这被叫做 <em>type projection</em>（不知道怎么翻译，Kotlin 中文网翻译为<em>类型投影</em> ）。</p>
<p>这其实就是 Kotlin 中的<strong>使用处型变</strong>，对应与 Java 中的 <code>Array&lt;? extends Number&gt;</code>，限制泛型类型的上边界。当然，我们也可以使用 <code>in</code> 关键字，它对应于 Java 中的 <code>Array&lt;? super Number&gt;</code>，限制泛型类型的下边界。不过，和 Java 中不同，我们可以在这样的限制了下边界的数组中，添加任何父类及子类元素：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> arr: Array&lt;<span class="hljs-keyword">in</span> String&gt; = arrayOf(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">123</span>, Origin(), <span class="hljs-literal">null</span>) <span class="hljs-comment">// 连 null 也可以添加</span><br></code></pre></td></tr></table></figure>

<h5 id="Star-projections"><a href="#Star-projections" class="headerlink" title="Star-projections"></a>Star-projections</h5><p>如果你对泛型参数的类型一无所知，但是依旧想要使用它，则可以使用 star-projections，用 <code>*</code> 表示。我觉得有点类似于 Java 中的捕获转换，使用无界通配符 <code>&lt;?&gt;</code> 去捕捉类型。</p>
<ul>
<li>如果用 <code>House&lt;*&gt;</code> 去捕获签名为 <code>House&lt;out T : Human&gt;</code> 的类，则捕获到的具体类型为 <code>House&lt;out Human&gt;</code>，这样你就可以安全地调用 <code>House</code> 中的成员方法和属性了。</li>
<li>如果用 <code>House&lt;*&gt;</code> 去捕获签名为 <code>House&lt;in T&gt;</code> 的类，由于类型参数 T 是逆变的，而且没有任何有关 T 的类型，所以捕获到的类型为 <code>House&lt;in Nothing&gt;</code>，此时往 <code>House</code> 添加任何对象都是不安全的。</li>
<li>如果用 <code>House&lt;*&gt;</code> 去捕获签名为 <code>House&lt;T : Human&gt;</code> 的类，则对于读取而言捕获到的是 <code>House&lt;out Human&gt;</code>，对于写入而言捕获到的是 <code>House&lt;in Nothing&gt;</code>。</li>
</ul>
<p>如果类的类型参数有多个，则每个类型参数都可以被单独 <em>projected</em>。比如类型声明为 <code>interface Function&lt;in T, out U&gt;</code>，则它的 proection 可以分为以下几种情况：</p>
<ul>
<li><code>Function&lt;*, String&gt;</code> 表示 <code>Function&lt;in Nothing, String&gt;</code>；</li>
<li><code>Function&lt;String, *&gt;</code> 表示 <code>Function&lt;String, out Any?&gt;</code>；</li>
<li><code>Function&lt;*, *&gt;</code> 表示 <code>Function&lt;in Nothing, out Any?&gt;</code>。</li>
</ul>
<h4 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h4><p>Kotlin 中的泛型函数和 Java 中的泛型方法类似，类型参数要放在方法名之前：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 声明泛型方法</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">singletonList</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>: List&lt;T&gt; &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br><span class="hljs-comment">// 调用方法</span><br><span class="hljs-keyword">val</span> list = singletonList&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>我们可以给泛型参数限定其可能的类型。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 使用 : 限定其上界，如果没有指定，默认的上界是 Any?</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="hljs-title">sort</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br><span class="hljs-comment">// 如果同一个类型参数需要使用多个上界，则应该使用 where-clause</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">copyWhenGreater</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;, threshold: <span class="hljs-type">T</span>)</span></span>: List&lt;String&gt;<br>    <span class="hljs-keyword">where</span> T : CharSequence,<br>          T : Comparable&lt;T&gt; &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>与 Java 中类似，泛型的类型安全检测仅在编译期有效，运行时泛型类的实例不保留其类型实参的任何信息，其类型信息被擦除了，比如 <code>Foo&lt;Bar&gt;</code> 和 <code>Foo&lt;Baz&gt;</code> 都会被擦除为 <code>Foo&lt;*&gt;</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> foo: Box&lt;String&gt; = Box(<span class="hljs-string">&quot;foo&quot;</span>)<br><span class="hljs-keyword">val</span> bar: Box&lt;Number&gt; = Box(<span class="hljs-number">1</span>)<br><br>println(foo <span class="hljs-keyword">is</span> Box&lt;*&gt;) <span class="hljs-comment">// true</span><br>println(bar <span class="hljs-keyword">is</span> Box&lt;*&gt;) <span class="hljs-comment">// true</span><br>println(foo.javaClass.toGenericString()) <span class="hljs-comment">// Box&lt;T&gt;</span><br>println(bar.javaClass.toGenericString()) <span class="hljs-comment">// Box&lt;T&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="函数与-Lambda-表达式"><a href="#函数与-Lambda-表达式" class="headerlink" title="函数与 Lambda 表达式"></a>函数与 Lambda 表达式</h2><p>Kotlin 中函数是头等的，这意味着函数可以存储在变量、参数、数据结构中，或者从其它高等函数中被返回。可以简单理解为，函数也可以被当做变量使用。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是指接收函数作为参数或者返回一个函数的函数。最具代表性的是 <code>fold</code> 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> Collection<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">fold</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    initial: <span class="hljs-type">R</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    combine: (<span class="hljs-type">acc</span>: <span class="hljs-type">R</span>, <span class="hljs-type">nextElement</span>: <span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: R &#123;<br>    <span class="hljs-keyword">var</span> accumulator: R = initial<br>    <span class="hljs-keyword">for</span> (element: T <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) &#123;<br>        accumulator = combine(accumulator, element)<br>    &#125;<br>    <span class="hljs-keyword">return</span> accumulator<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它接收一个初始值和一个计算函数。计算函数中包含一个累积值和 next 元素值，在方法体中将集合遍历，将遍历到的元素通过计算函数计算，得到新的累积值，并替换原有的累积值，最终返回结果。</p>
<p>我们可以通过以下方式调用该方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">items.fold(<span class="hljs-number">0</span>, &#123; acc: <span class="hljs-built_in">Int</span>, i: <span class="hljs-built_in">Int</span> -&gt; <span class="hljs-comment">// 参数后用 -&gt; 分割</span><br>    <span class="hljs-comment">// 方法主体</span><br>    print(<span class="hljs-string">&quot;acc = <span class="hljs-variable">$acc</span>, i = <span class="hljs-variable">$i</span>, &quot;</span>)<br>    <span class="hljs-keyword">val</span> result = acc + i<br>    println(<span class="hljs-string">&quot;result = <span class="hljs-variable">$result</span>&quot;</span>)<br>    <span class="hljs-comment">// 最后一个表达式作为返回值     </span><br>    result<br>&#125;)<br><br><span class="hljs-comment">// 参数类型如果可以被推断出来则可以省略</span><br>items.fold(<span class="hljs-string">&quot;Elements:&quot;</span>) &#123; acc, i -&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$acc</span> <span class="hljs-variable">$i</span>&quot;</span> &#125;<br><br><span class="hljs-comment">// 也可以使用方法引用</span><br>items.fold(<span class="hljs-number">1</span>, <span class="hljs-built_in">Int</span>::times)<br></code></pre></td></tr></table></figure>

<h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>Kotlin 中用 <code>(Int) -&gt; String</code> 这样的形式声明一个函数类型的变量，比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> onClick: () -&gt; <span class="hljs-built_in">Unit</span> = <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<p>函数类型主要形式如下：</p>
<ul>
<li>所有函数类型都有一个圆括号括起来的参数类型列表以及一个返回类型：<code>(A, B) -&gt; C</code>，表示它接受类型分别为 <code>A</code> 与 <code>B</code> 的两个参数，并返回一个 <code>C</code> 类型的值。参数类型列表可以为空，比如 <code>() -&gt; A</code>；如果没有返回值则必须注明，比如 <code>(A, B) -&gt; Unit</code>。</li>
<li>函数类型可以有一个额外的<em>接收者</em> 类型，通过 <code>A.</code> 这样的形式表示。当调用函数时，第一个参数是该接收者，然后才是函数参数。另外，函数中可以通过 <code>this</code> 关键字引用该对象。带与不带接收者的函数类型可以互换。</li>
<li><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/coroutines-basics.html#extract-function-refactoring">挂起函数</a>是一种特殊的函数类型，表示法中包含一个 <code>suspend</code> 修饰符，如 <code>suspend () -&gt; Unit</code>。</li>
</ul>
<p>声明函数类型时，函数的参数名是可选的。下面看几个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 可为空的函数类型</span><br><span class="hljs-keyword">val</span> nullableFun : ((<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span>)? = <span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// 函数的返回值也为函数类型，使用 () 括起来就可以了</span><br><span class="hljs-keyword">val</span> returnFun : (<span class="hljs-built_in">Int</span>) -&gt; ((<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Unit</span>) = <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<p>我们还可以通过<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/type-aliases.html">类型别名</a>给函数起一个别名：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">typealias</span> ClickHandler = (View) -&gt; <span class="hljs-built_in">Unit</span><br></code></pre></td></tr></table></figure>

<h4 id="函数类型实例化"><a href="#函数类型实例化" class="headerlink" title="函数类型实例化"></a>函数类型实例化</h4><p>我们主要可以通过以下几种方法获得函数类型的实例：</p>
<ul>
<li><p>使用函数字面值的代码块</p>
<ul>
<li>lambda 表达式：<code>&#123; a, b -&gt; a + b &#125;</code></li>
<li>匿名函数：<code>fun(s: String): Int &#123; return s.toIntOrNull() ?: 0 &#125;</code></li>
</ul>
</li>
<li><p>使用已声明的可调用引用：</p>
<ul>
<li>顶层、局部、成员、扩展函数：<code>::isOdd</code>、 <code>String::toInt</code></li>
<li>顶层、成员、扩展属性：<code>List&lt;Int&gt;::size</code></li>
<li>构造函数：<code>::Regex</code></li>
</ul>
</li>
<li><p>使用实现函数类型接口的自定义类的实例:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntTransformer</span>: <span class="hljs-type"></span>(<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = TODO()<br>&#125;<br><br><span class="hljs-keyword">val</span> intFunction: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = IntTransformer() <span class="hljs-comment">// 实例化</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>如果有足够信息，编译器可以推断出具体的函数类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = &#123; i: <span class="hljs-built_in">Int</span> -&gt; i + <span class="hljs-number">1</span> &#125; <span class="hljs-comment">// 推断出的类型是 (Int) -&gt; Int</span><br></code></pre></td></tr></table></figure>

<p>不过，函数类型推断默认推断出的是<em>没有接收者</em>的函数类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = &#123; i: <span class="hljs-built_in">Int</span>, s: String -&gt; s + i &#125;<br></code></pre></td></tr></table></figure>

<p>上面的例子中，默认推断出的是 <code>(String, Int) -&gt; String</code> 而不是 <code>String.(Int) -&gt; String</code>。如果这不符合你的需要，请显式指定函数类型。</p>
<h4 id="函数类型实例调用"><a href="#函数类型实例调用" class="headerlink" title="函数类型实例调用"></a>函数类型实例调用</h4><p>除了直接调用之外，我们还可以使用 <code>invoke()</code> 对函数进行调用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> stringPlus: (String, String) -&gt; String = String::plus<br><br>println(stringPlus(<span class="hljs-string">&quot;Hello, &quot;</span>, <span class="hljs-string">&quot;world!&quot;</span>)) <br>println(stringPlus.invoke(<span class="hljs-string">&quot;&lt;-&quot;</span>, <span class="hljs-string">&quot;-&gt;&quot;</span>))<br></code></pre></td></tr></table></figure>

<h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>完整语法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 声明一个名称为 sum 的函数类型，并使用 lambda 表达式初始化</span><br><span class="hljs-keyword">val</span> sum: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123; x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x + y &#125;<br></code></pre></td></tr></table></figure>

<p>Lambda 表达式总是括在花括号中，完整语法形式的参数声明放在花括号内，并有可选的类型标注，函数体跟在一个 <code>-&gt;</code> 符号之后。如果推断出的该 lambda 的返回类型不是 <code>Unit</code>，那么该 lambda 主体中的最后一个表达式会被视为返回值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> result = &#123;<br>    <span class="hljs-keyword">val</span> s = <span class="hljs-string">&quot;hi&quot;</span><br>    s.length<br>&#125;<br>println(result <span class="hljs-keyword">is</span> Function&lt;<span class="hljs-built_in">Int</span>&gt;) <span class="hljs-comment">// 返回值是 Int</span><br></code></pre></td></tr></table></figure>

<h4 id="传递末尾的-lambda-表达式"><a href="#传递末尾的-lambda-表达式" class="headerlink" title="传递末尾的 lambda 表达式"></a>传递末尾的 lambda 表达式</h4><p>如果函数的最后一个参数是函数类型，那么作为参数传入的 lambda 表达式可以放在圆括号之外：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> product = items.fold(<span class="hljs-number">1</span>) &#123; acc, e -&gt; acc * e &#125;<br></code></pre></td></tr></table></figure>

<p>这种语法叫做拖尾 lambda (<em>trailing lambdas</em>﻿)，如果该 lambda 表达式是调用时唯一的参数，那么圆括号可以省略：<code>run &#123; println(&quot;...&quot;) &#125;</code>。</p>
<h4 id="it：单个参数的隐式名称"><a href="#it：单个参数的隐式名称" class="headerlink" title="it：单个参数的隐式名称"></a><code>it</code>：单个参数的隐式名称</h4><p>如果 lambda 表达式中只有一个参数，那么我们可以省略它以及 <code>-&gt;</code>，该参数会被隐式声明为 <code>it</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ints.filter &#123; it &gt; <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure>

<h4 id="从-lambda-表达式中返回值"><a href="#从-lambda-表达式中返回值" class="headerlink" title="从 lambda 表达式中返回值"></a>从 lambda 表达式中返回值</h4><p>我们可以使用<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/returns.html#return-at-labels">标签返回</a>的语法从 lambda 显式返回一个值。 否则，将隐式返回最后一个表达式的值。</p>
<h4 id="下划线用于未使用的变量"><a href="#下划线用于未使用的变量" class="headerlink" title="下划线用于未使用的变量"></a>下划线用于未使用的变量</h4><p>如果 lambda 表达式的参数未使用，那么可以用下划线取代其名称：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">map.forEach &#123; _, value -&gt; println(<span class="hljs-string">&quot;<span class="hljs-variable">$value</span>!&quot;</span>) &#125;<br></code></pre></td></tr></table></figure>

<h4 id="lambda-表达式中的解构声明"><a href="#lambda-表达式中的解构声明" class="headerlink" title="lambda 表达式中的解构声明"></a>lambda 表达式中的解构声明</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">map.mapValues &#123; (key, value) -&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$value</span>!&quot;</span> &#125;<br></code></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>Lambda 表达式缺少指定函数的返回类型的能力。在大多数情况下，这是不必要的，因为返回值类型可以被推断出来，但是如果你需要显式指定返回值类型，就可以使用匿名函数代替 lambda 表达式。</p>
<p>匿名函数与普通函数的唯一区别是匿名函数省略了函数名称。其使用方式和 lambda 表达式基本一致：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> add = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = x + y<br></code></pre></td></tr></table></figure>

<p>不过，不同的是，匿名函数的参数必须在括号内才能传递。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ints.filter(<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(item)</span></span> = item &gt; <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p>除此之外，还有<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/inline-functions.html#non-local-returns">非局部返回</a>的不同。非 lambda 表达式中，不带标签的 return 总是在函数中直接返回，而 lambda 表达式是从包含它的函数返回，所以在 lambda 表达式中如果要正确地 return 需要使用标签：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ints.filter &#123;<br>    <span class="hljs-keyword">val</span> mold = it % <span class="hljs-number">2</span><br>    println(mold)<br>    <span class="hljs-keyword">return</span><span class="hljs-symbol">@filter</span> mold == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>Lambda 表达式或者匿名函数（以及<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/functions.html#local-functions">局部函数</a>和<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/object-declarations.html#object-declarations">对象表达式</a>） 可以访问其<em>闭包</em> ，即在外部作用域中声明的变量。与 Java 不同，Kotlin 中不但允许访问闭包中的非 final 变量，还允许直接修改它们：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>ints.filter &#123; it &gt; <span class="hljs-number">0</span> &#125;.forEach &#123;<br>    <span class="hljs-comment">// 修改闭包中的变量</span><br>    sum += it<br>&#125;<br>print(sum)<br></code></pre></td></tr></table></figure>

<p>其实现原理是，Kotlin 为我们捕捉并保存了可变变量的引用，然后在我们修改其值的时候改变引用。所以，如果变量被 lambda 表达式捕捉，其声明周期会和 lambda 的表达式的生命周期一致。</p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包，即在那些函数体内会访问到的变量，对于函数对象和类的内存分配和虚拟调用会引入运行时开销。举个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">lock(l) &#123; foo() &#125;<br></code></pre></td></tr></table></figure>

<p>在这个方法中，<code>foo()</code> 方法其实只有在被调用到时才起作用，其他时候只是作为参数传递，所以我们期望的行为是希望编译器可以帮我们生成这样一个方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">lock.lock()<br><span class="hljs-keyword">try</span> &#123;<br>    body() <span class="hljs-comment">// 对目标方法进行调用</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为了让编译器这么做，我们需要使用 <code>inline</code> 关键字。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">lock</span><span class="hljs-params">(lock: <span class="hljs-type">Lock</span>, body: () -&gt; <span class="hljs-type">T</span>)</span></span>: T &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure>

<p><code>inline</code> 修饰符影响函数和传给它的 lambda 表达式：所有这些都被内联到调用的地方。也就是 lambda 表达式成为函数调用者定义的一部分，而不是保存在匿名类中。</p>
<p>内联虽然有可能会导致生成的方法数增加，但是只要内联的方法体不是太大就可以节省性能开销。</p>
<h4 id="禁用内联"><a href="#禁用内联" class="headerlink" title="禁用内联"></a>禁用内联</h4><p>如果希望只内联一部分函数，我们可以在内联函数上使用 <code>noinline</code> 关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(inlined: () -&gt; <span class="hljs-type">Unit</span>, <span class="hljs-keyword">noinline</span> notInlined: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure>

<h4 id="非局部返回"><a href="#非局部返回" class="headerlink" title="非局部返回"></a>非局部返回</h4><p>在 Kotlin 中，我们只能对具名或匿名函数使用正常的、非限定的 return 来退出。 但是，如果一个 lambda 表达式是内联的，那么就可以使用<em>非局部返回</em>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(s: <span class="hljs-type">String</span>)</span></span> &#123;<br>    s.let &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-comment">// OK：该 lambda 表达式是内联的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不仅仅是 let，所有的 scope functions 都是内联的。</p>
<p>一些内联函数可能调用传给它们的不是直接来自函数体、而是来自另一个执行上下文的 lambda 表达式参数，例如来自局部对象或嵌套函数。在这种情况下，该 lambda 表达式中也不允许非局部控制流。为了标识这种情况，该 lambda 表达式参数需要用 <code>crossinline</code> 修饰符标记：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 使用 crossinline 修饰，不允许局部返回</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> body: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> f = <span class="hljs-keyword">object</span>: Runnable &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> = body() <span class="hljs-comment">// 比如这段代码执行的 context 和当前 context 不同</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="具体化的类型参数"><a href="#具体化的类型参数" class="headerlink" title="具体化的类型参数"></a>具体化的类型参数</h4><p>有时候，我们需要得到类型参数的具体信息，这个时候可以在内联函数中使用 <code>reified</code> 关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Number&gt;</span> TreeNode.<span class="hljs-title">findParentOfType</span><span class="hljs-params">()</span></span>: T? &#123;<br>    <span class="hljs-keyword">var</span> p = parent<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; p !<span class="hljs-keyword">is</span> T) &#123;<br>        p = p.parent<br>    &#125;<br>    <span class="hljs-keyword">return</span> p <span class="hljs-keyword">as</span> T?<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例子中，由于函数是内联的，不需要反射，所以 <code>!is</code> 和 <code>as</code> 都可以使用了。</p>
<h4 id="内联属性"><a href="#内联属性" class="headerlink" title="内联属性"></a>内联属性</h4><p><code>inline</code> 修饰符可用于没有幕后字段的属性的访问器。既可以单独标注某个属性访问器，也可以标注整个属性使得两个访问器都是内联的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> foo: Foo<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">get</span>() = Foo()<br><br><span class="hljs-keyword">var</span> bar: Bar<br>    <span class="hljs-keyword">get</span>() = <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">set</span>(v) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">var</span> bar: Bar<br>    <span class="hljs-keyword">get</span>() = <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">set</span>(v) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure>



<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="异步编程技术"><a href="#异步编程技术" class="headerlink" title="异步编程技术"></a>异步编程技术</h3><p>在学习协程之前，让我们先回顾一下已有的异步编程方案。</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程可能是目前为止最著名的防止程序造成阻塞的方案。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postItem</span><span class="hljs-params">(item: <span class="hljs-type">Item</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> token = preparePost()<br>    <span class="hljs-keyword">val</span> post = submitPost(token, item)<br>    processPost(post)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">preparePost</span><span class="hljs-params">()</span></span>: Token &#123;<br>    <span class="hljs-comment">// makes a request and consequently blocks the main thread</span><br>    <span class="hljs-keyword">return</span> token<br>&#125;<br></code></pre></td></tr></table></figure>

<p>比如上面这段代码中，我们需要在 <code>preparePost()</code> 方法中做网络请求获取数据，我们可以把它放在子线程中来防止 UI 被阻塞，但是这样做有一些缺陷：</p>
<ul>
<li>创建线程所需的性能开销并不低。线程造成的上下文切换非常昂贵。</li>
<li>线程不是无限制的。可创建的线程数量受限于当前操作系统，如果是服务端的应用程序，这会造成主要的瓶颈。</li>
<li>线程不一定总是可用。在一些平台，比如在 JavaScript 中就不支持线程。</li>
<li>线程的使用并不简单。在多线程编程中，多线程应用的调试和避免出现竞争状况是常见的问题。</li>
</ul>
<h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>另一种思路是使用回调，也就是将目标方法作为参数传递到另一个函数中，在任务结束时再对目标函数进行调用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postItem</span><span class="hljs-params">(item: <span class="hljs-type">Item</span>)</span></span> &#123;<br>    preparePostAsync &#123; token -&gt;<br>        submitPostAsync(token, item) &#123; post -&gt;<br>            processPost(post)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">preparePostAsync</span><span class="hljs-params">(callback: (<span class="hljs-type">Token</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-comment">// make request and return immediately</span><br>    <span class="hljs-comment">// arrange callback to be invoked later</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用回调看起来优雅了许多，但是依旧存在一些问题：</p>
<ul>
<li>多层嵌套导致代码变复杂。</li>
<li>错误处理变得异常困难。</li>
</ul>
<h4 id="Futures-Promises-及其它"><a href="#Futures-Promises-及其它" class="headerlink" title="Futures / Promises 及其它"></a>Futures / Promises 及其它</h4><p>Future / Promises 背后的思想是当我们调用了异步请求之后，我们会得到一个 Promise 对象，其中包含了异步请求成功或失败的结果，然后我们可以对它进行处理：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postItem</span><span class="hljs-params">(item: <span class="hljs-type">Item</span>)</span></span> &#123;<br>    preparePostAsync()<br>        .thenCompose &#123; token -&gt;<br>            submitPostAsync(token, item)<br>        &#125;<br>        .thenAccept &#123; post -&gt;<br>            processPost(post)<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">preparePostAsync</span><span class="hljs-params">()</span></span>: Promise&lt;Token&gt; &#123;<br>    <span class="hljs-comment">// makes request and returns a promise that is completed later</span><br>    <span class="hljs-keyword">return</span> promise<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种解决方式需要我们改变编程方式，具体而言：</p>
<ul>
<li>不同的编程模型。从自上而下的命令式编程到通过链式调用的组合式编程。</li>
<li>需要学习如何使用一套全新的 API。</li>
<li>指定返回值类型。返回值从原始的真实数据到 Promise 对象。</li>
<li>错误处理变得异常复杂。</li>
</ul>
<h4 id="响应式插件"><a href="#响应式插件" class="headerlink" title="响应式插件"></a>响应式插件</h4><p>响应式插件 (<em>Reactive Extensions</em>, <em>Rx</em>) 最初是在 C# 中被 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)">Erik Meijer</a> 提出的，后来 Netflix 将它移植到了 Java 中创造了 RxJava，于是慢慢受到了越来越多人的青睐。其背后的思想是 <code>observable streams</code>，数据以可被观察的流的形式存在。与 Future 返回具体的对象不同，Rx 返回的是数据流，并且使用观察者模式。</p>
<p>如果你接受并理解了 Rx 的核心理念，那么这种编程习惯的确可以很快被应用到其它平台上，而且其错误处理也比前面提到的几种更好一些。</p>
<h4 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h4><p>Kotlin 处理异步代码的方式是通过协程，其思想核心是<em>可挂起的运算</em>：函数可以将它的执行挂起，并在稍后继续执行。协程最大的优势是开发者可以像写阻塞式代码一样写非阻塞式代码（写出的异步代码和顺序执行的代码一样）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postItem</span><span class="hljs-params">(item: <span class="hljs-type">Item</span>)</span></span> &#123;<br>    launch &#123;<br>        <span class="hljs-keyword">val</span> token = preparePost()<br>        <span class="hljs-keyword">val</span> post = submitPost(token, item)<br>        processPost(post)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">preparePost</span><span class="hljs-params">()</span></span>: Token &#123;<br>    <span class="hljs-comment">// makes a request and suspends the coroutine</span><br>    <span class="hljs-keyword">return</span> suspendCoroutine &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面这个例子中，<code>postItem</code> 中会执行一些耗时操作，但是它不会阻塞主线程，<code>preparePost)()</code> 就是一个可挂起的函数，它会在执行并返回结果之后，再继续往下执行其它代码。</p>
<p>相比前面的一些方案，协程具有以下优势：</p>
<ul>
<li>方法签名不需要改变；</li>
<li>代码结构也不需要改变，我们可以像写同步代码一样编写异步代码；</li>
<li>编程模型和 API 保持可用，比如使用循环、异常处理等保持一致；</li>
<li>平台独立性，无论是针对 JVM、JavaScript 或者其它平台，代码始终保持一致，编译器会为我们适配到各自的平台。</li>
</ul>
<p>Kotlin 并不是唯一采用这种异步编程思想的语言，比如 C# Go 等语言很早就开始使用了。比较特殊的是，除了 <code>suspend</code> 关键字之外，Kotlin 中协程功能全都是以库的形式提供的，我们需要导入 <code>kotlinx.coroutines</code> 包才能使用协程。</p>
<h3 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h3><p>一个协程是一个可终止运算的实例。从概念上看，它与线程相似，因为它需要运行一块与其余代码块同时工作的代码块。但是，协程不绑定到任何特定线程，它可以在一个线程中暂停执行，然后在另一个线程中恢复执行。因此，协程可以被看作是轻量级的线程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123; <span class="hljs-comment">// runBlocking 用于连接阻塞式代码和协程代码</span><br>    <span class="hljs-keyword">val</span> job = GlobalScope.launch &#123; <span class="hljs-comment">// 启动一个新协程并保持对这个 job 的引用</span><br>        delay(<span class="hljs-number">1000L</span>)<br>        println(<span class="hljs-string">&quot;World!&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Hello,&quot;</span>)<br>    job.join() <span class="hljs-comment">// 等待直到子协程执行结束</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h4><p>以上示例中，我们创建了一个顶层协程，保持对其的引用并将协程挂起直至 job 执行结束。这存在一些问题，比如创建顶层协程需要消耗更多的资源，手动保持对协程的引用容易出错等等。</p>
<p>更好的做法是使用<strong>结构化并发</strong>。我们可以在 runBlocking 所在的 CoroutineScope 中直接启动一个新协程，这样就毋需显式 join 它了。正因为在同一个作用域中，所以会等待所有启动的协程都执行完毕后才会退出：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123; <span class="hljs-comment">// this: CoroutineScope</span><br>    launch &#123; <span class="hljs-comment">// 在 runBlocking 作用域中启动一个新协程</span><br>        delay(<span class="hljs-number">1000L</span>)<br>        println(<span class="hljs-string">&quot;World!&quot;</span>)<br>    &#125;<br>    print(<span class="hljs-string">&quot;Hello &quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>依次介绍下这里涉及到的几个协程函数：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch </a>是一个协程构造器，它会相对其余代码并发地启动一个新的协程，并且与它们保持相互独立。这也是为什么 “Hello “ 会被先打印出来。</li>
<li><a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a> 是一个特殊的挂起函数，它会将当前协程挂起指定的一段时间。挂起一个协程不会阻塞当前所在的线程，但是会允许其它协程运行并且使用当前线程运行它们的代码。</li>
<li><a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a> 也是一个协程构造器，它桥接起了外部非协程代码和方法体中的协程代码。</li>
</ul>
<p>所谓的<strong>结构化并发</strong>指的是新的协程只能在 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> 中才能启动，这样就限定了该协程的生命周期。在真实的使用场景中，我们通常会启动非常多的协程，结构化并发保证了这些协程不会被丢失或者泄露。外部的协程只有等待内部的子协程全都执行完毕才会退出。另外，结构化并发也保证了当代码出错的时候，错误能够被正确地抛出而且不会被丢失。</p>
<h5 id="CoroutineScope-vs-CoroutineContext"><a href="#CoroutineScope-vs-CoroutineContext" class="headerlink" title="CoroutineScope vs CoroutineContext"></a>CoroutineScope vs CoroutineContext</h5><p>CoroutineScope 除了提供一个 CoroutineContext，还负责保存并发结构以及多个协程间的父子关系，我们只能在 CoroutineScope 中启动一个新协程。CoroutineContext 则保存了协程相关的信息。</p>
<h4 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h4><p>我们可以将上面打印 “World!” 的部分代码提取到一个 <code>printWorld()</code> 方法中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 挂起函数</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doWorld</span><span class="hljs-params">()</span></span> &#123;<br>    delay(<span class="hljs-number">1000L</span>)<br>    println(<span class="hljs-string">&quot;World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到提取该方法时，IDE 为我们自动添加了 <code>suspend</code> 修饰符，这样的函数被称为挂起函数 (<em>suspending function</em>)。挂起函数的作用是可以让我们在协程中调用其它挂起函数，并且暂停执行。</p>
<h4 id="作用域构建器"><a href="#作用域构建器" class="headerlink" title="作用域构建器"></a>作用域构建器</h4><p>我们还可以使用 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a> 创建自己的协程作用域，它和 runBlocking 一样会等待代码主体和子协程执行完毕，唯一的不同之处是 runBlocking 会阻塞当前线程，但 coroutineScope 只是<em>挂起</em>，它会释放占有的当前线程下的资源。正因如此，coroutineScope 是一个挂起函数，而 runBlocking 只是普通的函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    doWorld()<br>    println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doWorld</span><span class="hljs-params">()</span></span> = coroutineScope &#123;<br>    launch &#123;<br>        delay(<span class="hljs-number">2000L</span>)<br>        println(<span class="hljs-string">&quot;World 2&quot;</span>)<br>    &#125;<br>    launch &#123;<br>        delay(<span class="hljs-number">1000L</span>)<br>        println(<span class="hljs-string">&quot;World 1&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Hello&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 输出：</span><br>Hello<br>World <span class="hljs-number">1</span><br>World <span class="hljs-number">2</span><br>Done<br></code></pre></td></tr></table></figure>

<p>在上面这个例子中，由于 coroutineScope 不会阻塞当前线程，所以当它在内部启动两个协程之后，这些代码会被同步执行。而 runBlocking 是阻塞式运行的，所以它会等待 <code>doWorld()</code> 执行完毕。所以，最先被打印的是 “Hello”，然后是 delay 了 1 秒的 “World 1”，再然后是 delay 了 2 秒的 “World 2”，最后才是 “Done”。</p>
<h4 id="全局协程像守护线程"><a href="#全局协程像守护线程" class="headerlink" title="全局协程像守护线程"></a>全局协程像守护线程</h4><p>看个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">GlobalScope.launch &#123;<br>    repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;<br>        println(<span class="hljs-string">&quot;I&#x27;m sleeping <span class="hljs-variable">$i</span> ...&quot;</span>)<br>        delay(<span class="hljs-number">500L</span>)<br>    &#125;<br>&#125;<br>delay(<span class="hljs-number">1300L</span>)<br></code></pre></td></tr></table></figure>

<p>这里打印的结果是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">I&#x27;m sleeping 0 ...<br>I&#x27;m sleeping 1 ...<br>I&#x27;m sleeping 2 ...<br></code></pre></td></tr></table></figure>

<p>原因是在 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html">GlobalScope</a> 中启动的活动协程并不会使进程保活，它们就像守护线程。</p>
<h3 id="取消与超时"><a href="#取消与超时" class="headerlink" title="取消与超时"></a>取消与超时</h3><h4 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">job.cancel()<br><span class="hljs-comment">// or</span><br>job.cancelAndJoin()<br></code></pre></td></tr></table></figure>

<p>如果协程没有检查取消状态，那么仅仅调用 <code>cancel()</code> 是无法被取消的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancelIsCooperative</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> startTime = System.currentTimeMillis()<br>    <span class="hljs-keyword">val</span> job = launch(Dispatchers.Default) &#123;<br>        <span class="hljs-keyword">var</span> nextPrintTime = startTime<br>        <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>            <span class="hljs-keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;<br>                println(<span class="hljs-string">&quot;job: I&#x27;m sleeping <span class="hljs-subst">$&#123;i++&#125;</span> ...&quot;</span>)<br>                nextPrintTime += <span class="hljs-number">500L</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    delay(<span class="hljs-number">1300L</span>)<br>    println(<span class="hljs-string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)<br>    job.cancelAndJoin() <span class="hljs-comment">// 取消 job 并且等待它结束</span><br>    println(<span class="hljs-string">&quot;main: Now I can quit.&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br>job: I<span class="hljs-string">&#x27;m sleeping 0 ...</span><br><span class="hljs-string">job: I&#x27;</span>m sleeping <span class="hljs-number">1</span> ...<br>job: I<span class="hljs-string">&#x27;m sleeping 2 ...</span><br><span class="hljs-string">main: I&#x27;</span>m tired of waiting!<br>job: I<span class="hljs-string">&#x27;m sleeping 3 ...</span><br><span class="hljs-string">job: I&#x27;</span>m sleeping <span class="hljs-number">4</span> ...<br>main: Now I can quit.<br></code></pre></td></tr></table></figure>

<p>为了使取消起作用，我们需要对子协程做以下修改：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// isActive 是 CoroutineScope 的扩展属性</span><br><span class="hljs-keyword">while</span> (isActive) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们还可以在 <code>finally</code> 代码块中释放资源：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">try</span> &#123;<br>    repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;<br>        println(<span class="hljs-string">&quot;job: I&#x27;m sleeping <span class="hljs-variable">$i</span> ...&quot;</span>)<br>        delay(<span class="hljs-number">500L</span>)<br>    &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    println(<span class="hljs-string">&quot;job: I&#x27;m running finally&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于不可取消的协程还可以在 <code>finally</code> 中判断：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">try</span> &#123;<br>    repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;<br>        println(<span class="hljs-string">&quot;job: I&#x27;m sleeping <span class="hljs-variable">$i</span> ...&quot;</span>)<br>        delay(<span class="hljs-number">500L</span>)<br>    &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// NonCancellable 是一个对象，且需要结合 withContext 方法使用</span><br>    withContext(NonCancellable) &#123;<br>        println(<span class="hljs-string">&quot;job: I&#x27;m running finally&quot;</span>)<br>        delay(<span class="hljs-number">1000L</span>)<br>        println(<span class="hljs-string">&quot;job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p>由于协程很有可能会超时，所以协程库为我们提供了 <code>withTimeout()</code> 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runWithTimeout</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    withTimeout(<span class="hljs-number">1300L</span>) &#123;<br>        repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;<br>            println(<span class="hljs-string">&quot;I&#x27;m sleeping <span class="hljs-variable">$i</span> ...&quot;</span>)<br>            delay(<span class="hljs-number">500L</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果会抛出 <code>TimeoutCancellationException</code> 异常，它是 <code>CancellationException</code> 的子类，我们之前没有看到这个异常是因为被取消的协程中，即使抛出 <code>CancellationExcetption</code> 也被认为是正确退出的。</p>
<p>如果不想看到异常，我们可以使用 <code>withTimeoutOrNull()</code> 方法，该方法中对 <code>TimeoutCancellationException</code> 进行了捕捉：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">withTimeoutOrNull</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>, block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">T</span>)</span></span>: T? &#123;<br>    <span class="hljs-keyword">if</span> (timeMillis &lt;= <span class="hljs-number">0L</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">var</span> coroutine: TimeoutCoroutine&lt;T?, T?&gt;? = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;<br>            <span class="hljs-keyword">val</span> timeoutCoroutine = TimeoutCoroutine(timeMillis, uCont)<br>            coroutine = timeoutCoroutine<br>            setupTimeout&lt;T?, T?&gt;(timeoutCoroutine, block)<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e: TimeoutCancellationException) &#123;<br>        <span class="hljs-keyword">if</span> (e.coroutine === coroutine) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>        &#125;<br>        <span class="hljs-keyword">throw</span> e<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>withTimeout</code> 中的 timeout 事件是异步的，并且有可能在任何时间点发生，甚至在内部代码块返回值被返回之前。来看个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> acquired = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> released = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> &#123;<br>    <span class="hljs-keyword">init</span> &#123;<br>        acquired++<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span> &#123;<br>        released++<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 由于 timeout 事件是异步的，所以最终，acquired 事件触发的此时有可能多于 released 事件</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runTimeoutWithCloseResource</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        repeat(<span class="hljs-number">100_000</span>) &#123;<br>            launch &#123;<br>                <span class="hljs-keyword">val</span> resource = withTimeout(<span class="hljs-number">60</span>) &#123;<br>                    delay(<span class="hljs-number">50</span>)<br>                    Resource() <span class="hljs-comment">// 由于 timeout 事件随时都有可能被触发，所以这里有可能会被调用多次</span><br>                &#125;<br>                resource.close()<br>            &#125;<br>        &#125;<br>    &#125;<br>    println(acquired)<br>    println(released)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为了解决这个问题，我们可以使用 try..finally 语句：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 try..finally 保证 Resource 的 acquire 和 release 都是成对的</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runTimeoutWithCloseResourceSafely</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        repeat(<span class="hljs-number">100_000</span>) &#123;<br>            launch &#123;<br>                <span class="hljs-comment">// 不依赖 withTimeout 的返回值</span><br>                <span class="hljs-keyword">var</span> resource: Resource? = <span class="hljs-literal">null</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    withTimeout(<span class="hljs-number">60</span>) &#123;<br>                        delay(<span class="hljs-number">50</span>)<br>                        resource = Resource()<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    resource?.close()<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    println(acquired)<br>    println(released)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="组合挂起函数"><a href="#组合挂起函数" class="headerlink" title="组合挂起函数"></a>组合挂起函数</h3><p>首先看个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    sequentialInvocation()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sequentialInvocation</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        <span class="hljs-keyword">val</span> one = doSomethingUsefulOne()<br>        <span class="hljs-keyword">val</span> two = doSomethingUsefulTwo()<br>        println(<span class="hljs-string">&quot;The answer is <span class="hljs-subst">$&#123;one + two&#125;</span>&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Completed in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomethingUsefulOne</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    println(<span class="hljs-string">&quot;Calculating one...&quot;</span>)<br>    delay(<span class="hljs-number">1000L</span>) <span class="hljs-comment">// 假设我们在这里做了一些有用的事</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">13</span><br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomethingUsefulTwo</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    println(<span class="hljs-string">&quot;Calculating two...&quot;</span>)<br>    delay(<span class="hljs-number">1000L</span>) <span class="hljs-comment">// 假设我们在这里也做了一些有用的事</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">29</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于它们都是运行在协程中的，所以如果按顺序调用，则它们也会像常规方法一样，按顺序被执行。</p>
<h4 id="使用-async-并发"><a href="#使用-async-并发" class="headerlink" title="使用 async 并发"></a>使用 async 并发</h4><p>上面的例子中，<code>doSomethingUsefulOne</code> 和 <code>doSomethingUsefulTwo</code> 之间并没有依赖，为了更快地得到结果，我们可以对它们使用并发，这需要用到 <code>async</code> 关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">concurrentAsync</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        <span class="hljs-keyword">val</span> one = async &#123; doSomethingUsefulOne() &#125;<br>        <span class="hljs-keyword">val</span> two = async &#123; doSomethingUsefulTwo() &#125;<br>        println(<span class="hljs-string">&quot;The answer is <span class="hljs-subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Completed in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>async</code> 是 <code>CoroutineScope</code> 的扩展方法，默认会在调用后立即执行，并且返回一个 <code>Deferred</code> 作为结果，我们可以在 <code>Deferred</code> 上调用 <code>await()</code> 获取结果值。</p>
<h4 id="惰性启动的-async"><a href="#惰性启动的-async" class="headerlink" title="惰性启动的 async"></a>惰性启动的 async</h4><p><a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> 可以通过将 <code>start</code> 参数设置为 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html">CoroutineStart.LAZY</a> 而变为惰性的。在这个模式下，只有结果通过 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html">await</a> 获取的时候协程才会启动，或者在 <code>Job</code> 的 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html">start</a> 函数调用的时候。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">concurrentAsyncLazy</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        <span class="hljs-keyword">val</span> one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125;<br>        <span class="hljs-keyword">val</span> two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125;<br>        one.start()<br>        two.start()<br>        println(<span class="hljs-string">&quot;The answer is <span class="hljs-subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Completed in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="async-风格的函数"><a href="#async-风格的函数" class="headerlink" title="async 风格的函数"></a>async 风格的函数</h4><p>我们可以定义异步风格的函数来<em>异步</em> 地调用 <code>doSomethingUsefulOne</code> 和 <code>doSomethingUsefulTwo</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        <span class="hljs-comment">// 我们可以在协程外面启动异步执行</span><br>        <span class="hljs-keyword">val</span> one = somethingUsefulOneAsync()<br>        <span class="hljs-keyword">val</span> two = somethingUsefulTwoAsync()<br>        <span class="hljs-comment">// 但是等待结果必须调用其它的挂起或者阻塞</span><br>        <span class="hljs-comment">// 当我们等待结果的时候，这里我们使用 `runBlocking &#123; …… &#125;` 来阻塞主线程</span><br>        runBlocking &#123;<br>            println(<span class="hljs-string">&quot;The answer is <span class="hljs-subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>    println(<span class="hljs-string">&quot;Completed in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">somethingUsefulOneAsync</span><span class="hljs-params">()</span></span> = GlobalScope.async &#123;<br>    doSomethingUsefulOne()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">somethingUsefulTwoAsync</span><span class="hljs-params">()</span></span> = GlobalScope.async &#123;<br>    doSomethingUsefulTwo()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里我们通过 <code>GlobalScope</code> 对象创建出来的 <code>CoroutineScope</code> 创建出一个 async 协程，并在其中调用我们的挂起函数。这样，我们就可以在协程外调用该方法了，因为该方法不依赖外界是否是 <code>CoroutineScope</code>。而且这些方法总是异步且并发被执行的（在顶层协程中）。不过，在获取运行结果 (<code>Deferred.await()</code>) 的时候，我们需要等待挂起函数执行的结果，这里的例子里我们使用了 <code>runBlocking</code> 阻塞主线程并创建了一个 <code>CoroutineScope</code> 来等待执行结束。</p>
<h4 id="使用-async-的结构化并发"><a href="#使用-async-的结构化并发" class="headerlink" title="使用 async 的结构化并发"></a>使用 async 的结构化并发</h4><p>上面的例子中，虽然我们可以这么做，但是 Kotlin 中并不推荐这种异步编程的风格。考虑一下，如果程序在 <code>somethingUsefulOneAsync</code> 或者在 <code>one.await()</code> 中发生错误抛出了异常，那么，<code>somethingUsefulTwoAsync</code> 依旧会被执行，这明显破坏了结构化并发的原则。所以我们可以对代码做以下修改：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">concurrentSum</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = coroutineScope &#123;<br>    <span class="hljs-keyword">val</span> one = async &#123; doSomethingUsefulOne() &#125;<br>    <span class="hljs-keyword">val</span> two = async &#123; doSomethingUsefulTwo() &#125;<br>    one.await() + two.await()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们把 <code>doSomethingUsefulOne</code> 和 <code>doSomethingUsefulTwo</code> 放到了同一个 CoroutineScope 中，这样，当程序抛出异常的时候，所有在当前作用域内启动的协程都会被取消：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFailedConcurrentSum</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        failedConcurrentSum()<br>    &#125; <span class="hljs-keyword">catch</span> (e: ArithmeticException) &#123;<br>        println(<span class="hljs-string">&quot;Computation failed with ArithmeticException&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">failedConcurrentSum</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = coroutineScope &#123;<br>    <span class="hljs-keyword">val</span> one = async &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            delay(<span class="hljs-built_in">Long</span>.MAX_VALUE) <span class="hljs-comment">// 模拟一个长时间的运算</span><br>            <span class="hljs-number">42</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 结束或者取消时会被打印</span><br>            println(<span class="hljs-string">&quot;First child was cancelled&quot;</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">val</span> two = async&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>        println(<span class="hljs-string">&quot;Second child throws an exception&quot;</span>)<br>        <span class="hljs-keyword">throw</span> ArithmeticException()<br>    &#125;<br>    one.await() + two.await()<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="协程上下文与调度器"><a href="#协程上下文与调度器" class="headerlink" title="协程上下文与调度器"></a>协程上下文与调度器</h3><p>协程总是运行在一些以 <a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a> 类型为代表的上下文中。协程上下文是各种不同元素的集合，其中主元素是协程中的 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>。</p>
<h4 id="调度器与线程"><a href="#调度器与线程" class="headerlink" title="调度器与线程"></a>调度器与线程</h4><p>协程上下文包含一个<em>协程调度器</em> <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher，</a>它确定了相关的协程在哪个线程或哪些线程上执行。协程调度器可以将协程限制在一个特定的线程执行，或将它分派到一个线程池，亦或是让它不受限地运行。</p>
<p>所有的协程构建器诸如 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a> 和 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> 接收一个可选的 <a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a> 参数，它可以被用来显式的为一个新协程或其它上下文元素指定一个调度器。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    launch &#123; <span class="hljs-comment">// 运行在父协程的上下文中，即 runBlocking 主协程</span><br>        println(<span class="hljs-string">&quot;main runBlocking      : I&#x27;m working in thread <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>    &#125;<br>    launch(Dispatchers.Unconfined) &#123; <span class="hljs-comment">// 不受限的——将工作在主线程中</span><br>        println(<span class="hljs-string">&quot;Unconfined            : I&#x27;m working in thread <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>    &#125;<br>    launch(Dispatchers.Default) &#123; <span class="hljs-comment">// 将会获取默认调度器</span><br>        println(<span class="hljs-string">&quot;Default               : I&#x27;m working in thread <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>    &#125;<br>    launch(newSingleThreadContext(<span class="hljs-string">&quot;MyOwnThread&quot;</span>)) &#123; <span class="hljs-comment">// 将使它获得一个新的线程</span><br>        println(<span class="hljs-string">&quot;newSingleThreadContext: I&#x27;m working in thread <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h3><p>挂起函数可以异步的返回单个值，但是该如何异步返回多个计算好的值呢？这正是 Kotlin 流（Flow）的用武之地。</p>
<h4 id="序列与流"><a href="#序列与流" class="headerlink" title="序列与流"></a>序列与流</h4><p>如果使用一些消耗 CPU 资源的阻塞代码计算数字（每次计算需要 100 毫秒）那么我们可以使用 <a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/index.html">Sequence</a> 来表示数字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printSequenceList</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> sequence: Sequence&lt;<span class="hljs-built_in">Int</span>&gt; = sequence &#123; <span class="hljs-comment">// 序列构建器</span><br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>            Thread.sleep(<span class="hljs-number">300</span>) <span class="hljs-comment">// 假装我们正在计算</span><br>            yield(i) <span class="hljs-comment">// 产生下一个值</span><br>        &#125;<br>    &#125;<br><br>    sequence.forEach &#123; println(it) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以使用挂起函数，在不阻塞的情况下执行其工作并将结果作为列表返回：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printDelayedList</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    launch &#123;<br>        <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>            println(<span class="hljs-string">&quot;I&#x27;m not blocked <span class="hljs-variable">$k</span>&quot;</span>)<br>            delay(<span class="hljs-number">300</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> list = mutableListOf&lt;<span class="hljs-built_in">Int</span>&gt;()<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>        delay(<span class="hljs-number">300</span>) <span class="hljs-comment">// delay 函数不是阻塞式的</span><br>        list.add(i)<br>    &#125;<br><br>    list.forEach &#123; println(it) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用 List 结果类型，意味着我们只能一次返回所有值。 为了表示异步计算的值流（stream），我们可以使用 <code>Flow</code> 类型（正如同步计算值会使用 <code>Sequence</code> 类型）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">flowList</span><span class="hljs-params">()</span></span> = flow &#123; <span class="hljs-comment">// 流构建器</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>        delay(<span class="hljs-number">100</span>) <span class="hljs-comment">// 假装我们在这里做了一些有用的事情</span><br>        println(<span class="hljs-string">&quot;Emitting <span class="hljs-variable">$i</span>&quot;</span>)<br>        emit(i) <span class="hljs-comment">// 发送下一个值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printFlowList</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    launch &#123;<br>        <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>            println(<span class="hljs-string">&quot;I&#x27;m not blocked <span class="hljs-variable">$k</span>&quot;</span>)<br>            delay(<span class="hljs-number">300</span>)<br>        &#125;<br>    &#125;<br>    flowList().collect &#123; println(it) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用 <code>flow</code> 具有以下特点：</p>
<ul>
<li>名为 <code>flow</code> 的构建器函数</li>
<li><code>flow &#123; ... &#125;</code> 构建块中的代码可以挂起</li>
<li><code>flow</code> 不是 suspend 函数</li>
<li><code>flow</code> 使用 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">emit</a> 函数<em>发射</em> 值</li>
<li><code>flow</code> 使用 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> 函数<em>收集</em> 值</li>
</ul>
<h4 id="流的取消"><a href="#流的取消" class="headerlink" title="流的取消"></a>流的取消</h4><p>流采用与协程同样的协作取消。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithTimeOut</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    withTimeoutOrNull(<span class="hljs-number">800</span>) &#123; <span class="hljs-comment">// 超时后 flow 不再继续执行</span><br>        flowList().collect &#123; value -&gt; println(value) &#125;<br>    &#125;<br>    println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="流是冷的"><a href="#流是冷的" class="headerlink" title="流是冷的"></a>流是冷的</h4><p>Flow 是一种类似于序列的冷流——只有在被 <code>collect</code> 的时候才会运行。</p>
<h4 id="流是连续的"><a href="#流是连续的" class="headerlink" title="流是连续的"></a>流是连续的</h4><ul>
<li>流的每次单独收集都是按顺序执行的，除非进行特殊操作的操作符使用多个流。</li>
<li>收集过程直接在当前协程中运行，默认情况下不启动新协程。</li>
<li>从上游到下游每个过渡操作符都会处理每个发射出的值然后再交给末端操作符。</li>
</ul>
<h4 id="流上下文"><a href="#流上下文" class="headerlink" title="流上下文"></a>流上下文</h4><p>流的收集总是在调用协程的上下文中发生，流的该属性称为<em>上下文保存</em> 。默认情况下，<code>flow &#123; ... &#125;</code> 构建器中的代码总是运行在相应流的收集器提供的上下文中。</p>
<h5 id="withContext-发出错误"><a href="#withContext-发出错误" class="headerlink" title="withContext 发出错误"></a>withContext 发出错误</h5><p>然而，长时间运行的消耗 CPU 的代码也许需要在 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Dispatchers.Default</a> 上下文中执行，并且更新 UI 的代码也许需要在 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html">Dispatchers.Main</a> 中执行。通常，<a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html">withContext</a> 用于在 Kotlin 协程中改变代码的上下文，但是 <code>flow &#123;...&#125;</code> 构建器中的代码必须遵循上下文一致原则，并且不允许从其他上下文中发射（<a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">emit</a>）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithContextDispatchers</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    flow &#123;<br>        <span class="hljs-comment">// 在流构建器中更改上下文，会抛出异常：</span><br>        <span class="hljs-comment">// java.lang.IllegalStateException: Flow invariant is violated</span><br>        withContext(Dispatchers.Default) &#123;<br>            <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>                delay(<span class="hljs-number">300</span>)<br>                emit(i)<br>            &#125;<br>        &#125;<br>    &#125;.collect &#123; println(it) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="流构建器"><a href="#流构建器" class="headerlink" title="流构建器"></a>流构建器</h4><p>除了使用 <code>flow &#123; ... &#125;</code> 构建 <code>Flow</code> 之外，我们还可以使用：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-of.html">flowOf</a>：定义了一个发射固定值集的流</li>
<li><code>.asFlow()</code>：扩展函数，可以将各种集合与序列转换为流</li>
</ul>
<p>比如可以将一个整数区间转换为流：<code>(1..3).asFlow().collect &#123; value -&gt; println(value) &#125;</code></p>
<h4 id="流操作符"><a href="#流操作符" class="headerlink" title="流操作符"></a>流操作符</h4><h5 id="过渡操作符-map"><a href="#过渡操作符-map" class="headerlink" title="过渡操作符 map"></a>过渡操作符 <code>map</code></h5><p>我们可以像使用集合与序列一样，使用操作符对流进行转换，比如 <code>filter</code> 和 <code>map</code>。过渡操作符应用于上游流，并返回下游流，而且像流一样也是冷操作符。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">performRequest</span><span class="hljs-params">(request: <span class="hljs-type">Int</span>)</span></span>: String &#123;<br>    delay(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 模仿长时间运行的异步工作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;response <span class="hljs-variable">$request</span>&quot;</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithFilterAndMap</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow() <span class="hljs-comment">// 一个请求流</span><br>        .filter &#123; request -&gt; request &gt; <span class="hljs-number">1</span> &#125;<br>        .map &#123; request -&gt; performRequest(request) &#125;<br>        .collect &#123; response -&gt; println(response) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="转换操作符-transform"><a href="#转换操作符-transform" class="headerlink" title="转换操作符 transform"></a>转换操作符 <code>transform</code></h5><p>我们还可以使用 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform.html">转换操作符</a> 实现更为复杂的转换，使用形式 <code>transformXxx</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithTransform</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow() <span class="hljs-comment">// 一个请求流</span><br>        .transform &#123; request -&gt;<br>            emit(<span class="hljs-string">&quot;Making request <span class="hljs-variable">$request</span>&quot;</span>)<br>            emit(performRequest(request))<br>        &#125;<br>        .collect &#123; response -&gt; println(response) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="限长操作符-take"><a href="#限长操作符-take" class="headerlink" title="限长操作符 take"></a>限长操作符 <code>take</code></h5><p>我们可以使用限长操作符在流触及相应限制的时候，将它的执行取消。形式如 <code>takeXxx</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithTake</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow()<br>        .take(<span class="hljs-number">2</span>)<br>        .collect &#123; response -&gt; println(response) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="末端操作符"><a href="#末端操作符" class="headerlink" title="末端操作符"></a>末端操作符</h5><p>末端操作符是在流上用于启动流收集的<em>挂起函数</em>。 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> 是最基础的末端操作符，但是还有另外一些更方便使用的末端操作符：</p>
<ul>
<li>转化为各种集合，例如 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html"><code>toList</code></a> 与 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-set.html"><code>toSet</code></a></li>
<li>获取第一个 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/first.html"><code>first</code></a> 值与确保流发射单个 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/single.html"><code>single</code></a> 值的操作符</li>
<li>使用 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/reduce.html"><code>reduce</code></a> 与 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/fold.html"><code>fold</code></a> 将流规约到单个值</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithTerminalOperators</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.5</span>).asFlow()<br>        .map &#123; it * it &#125; <span class="hljs-comment">// 数字 1 至 5 的平方</span><br>        <span class="hljs-comment">// .toList()</span><br>        .reduce &#123; a, b -&gt; a + b &#125; <span class="hljs-comment">// 求和</span><br>        .let &#123; println(it) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="flowOn-操作符"><a href="#flowOn-操作符" class="headerlink" title="flowOn 操作符"></a><code>flowOn</code> 操作符</h5><p>前面说过不允许直接使用 <code>withContext</code> 修改上下文，所以正确更改流发射的上下文需要通过 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html"><code>flowOn</code></a> 操作符：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithFlowOn</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    flowList()<br>        .flowOn(Dispatchers.Default)<br>        .collect &#123; println(it) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="缓冲操作符"><a href="#缓冲操作符" class="headerlink" title="缓冲操作符"></a>缓冲操作符</h5><p>我们可以使用 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html">buffer</a> 操作符来并发运行上流中发射元素的代码以及 collect 中的代码，而不是顺序运行它们：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithBuffer</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        flowList()<br>            .buffer() <span class="hljs-comment">// 缓冲发射项，无需等待</span><br>            .collect &#123; value -&gt;<br>                delay(<span class="hljs-number">300</span>)<br>                println(value)<br>            &#125;<br>    &#125;<br>    println(<span class="hljs-string">&quot;Collected in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="conflate"><a href="#conflate" class="headerlink" title="conflate"></a><code>conflate</code></h6><p>当流只代表部分操作结果或操作状态更新时，可能没有必要处理每个值，而是只处理最新的值。当收集器处理它们太慢的时候，我们可以使用 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html">conflate</a> 操作符，用于跳过中间值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithConflate</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        flowList()<br>            .conflate() <span class="hljs-comment">// 合并发射项，不对每个值进行处理</span><br>            .collect &#123; value -&gt;<br>                delay(<span class="hljs-number">300</span>)<br>                println(value)<br>            &#125;<br>    &#125;<br>    println(<span class="hljs-string">&quot;Collected in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Emitting</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">Emitting</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">Emitting</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">3</span><br><span class="hljs-attribute">Collected</span> in <span class="hljs-number">797</span> ms<br></code></pre></td></tr></table></figure>

<p>可以看到，虽然第一个数字仍在处理中，但第二个和第三个数字已经产生，因此第二个被 <em>conflated</em>，只有最新的（第三个）被交付给收集器。</p>
<h6 id="collectLatest"><a href="#collectLatest" class="headerlink" title="collectLatest"></a><code>collectLatest</code></h6><p>当发射器和收集器都很慢的时候，合并是加快处理速度的一种方式，它通过删除发射值来实现。另一种方式是取消缓慢的收集器，并在每次发射新值的时候再收集：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithCollectLatest</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        flowList()<br>            .collectLatest &#123; value -&gt; <span class="hljs-comment">// 只收集最新的值</span><br>                println(<span class="hljs-string">&quot;Collecting <span class="hljs-variable">$value</span>&quot;</span>)<br>                delay(<span class="hljs-number">300</span>)<br>                println(<span class="hljs-string">&quot;Done with <span class="hljs-variable">$value</span>&quot;</span>)<br>            &#125;<br>    &#125;<br>    println(<span class="hljs-string">&quot;Collected in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，由于 <code>flowList</code> 每个 100ms 发射一个新值，但是收集的时候会被 <code>delay</code> 300ms，所以只有最后一个值才会被收集。</p>
<h5 id="合并操作符"><a href="#合并操作符" class="headerlink" title="合并操作符"></a>合并操作符</h5><h6 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a><code>Zip</code></h6><p>与标准库中的 <a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/zip.html">Sequence.zip</a> 扩展函数一样，流拥有一个 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html">zip</a> 操作符用于组合两个流：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithZip</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> nums = (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow()<br>    <span class="hljs-keyword">val</span> strs = flowOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)<br>    nums.zip(strs) &#123; a, b -&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -&gt; <span class="hljs-variable">$b</span>&quot;</span> &#125; <span class="hljs-comment">// 组合成新的字符串</span><br>        .collect &#123; println(it) &#125; <span class="hljs-comment">// 收集并打印</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="combine"><a href="#combine" class="headerlink" title="combine"></a><code>combine</code></h6><p>当流表示一个变量或操作的最新值时，可能需要执行计算，我们可以使用 combine 来对上游流进行重新计算：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 各个时间节点下产生的单个和合并后的事件</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *    Time       : 300   400     600     800     900     1200</span><br><span class="hljs-comment"> * Single Event  :  1    one      2      two      3      three</span><br><span class="hljs-comment"> * Combined Event:     1-&gt;one  2-&gt;one  2-&gt;two  3-&gt;two  3-&gt;three</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithCombine</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> nums = (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow().onEach &#123; delay(<span class="hljs-number">300</span>) &#125; <span class="hljs-comment">// 发射数字 1..3，间隔 300 毫秒</span><br>    <span class="hljs-keyword">val</span> strs = flowOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>).onEach &#123; delay(<span class="hljs-number">400</span>) &#125; <span class="hljs-comment">// 每 400 毫秒发射一次字符串</span><br>    <span class="hljs-keyword">val</span> startTime = System.currentTimeMillis() <span class="hljs-comment">// 记录开始的时间</span><br>    nums.combine(strs) &#123; a, b -&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>-&gt;<span class="hljs-variable">$b</span>&quot;</span> &#125; <span class="hljs-comment">// 使用“zip”组合单个字符串</span><br>        .collect &#123; value -&gt; <span class="hljs-comment">// 收集并打印</span><br>            println(<span class="hljs-string">&quot;<span class="hljs-variable">$value</span> at <span class="hljs-subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="展平操作符"><a href="#展平操作符" class="headerlink" title="展平操作符"></a>展平操作符</h5><p>流表示异步接收的值的序列，所以很容易遇到这样的情况：每个值都会触发对另一个值序列的请求。所有当我们对流进行操作的时候会出现包含流的流，这个时候我们就需要对流进行展平 (<em>flatten</em>) 然后再进行其它操作。</p>
<h6 id="flatMapConcat"><a href="#flatMapConcat" class="headerlink" title="flatMapConcat"></a><code>flatMapConcat</code></h6><p>展平连接主要由 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html">flatMapConcat</a> 与 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-concat.html">flattenConcat</a> 操作符实现。</p>
<h6 id="flatMapMerge"><a href="#flatMapMerge" class="headerlink" title="flatMapMerge"></a><code>flatMapMerge</code></h6><p>另一种展平模式是并发收集所有传入的流，并将它们的值合并到一个单独的流，以便尽快的发射值。 它由 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-merge.html">flatMapMerge</a> 与 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-merge.html">flattenMerge</a> 操作符实现。他们都接收可选的用于限制并发收集的流的个数的 <code>concurrency</code> 参数（默认情况下，它等于 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-d-e-f-a-u-l-t_-c-o-n-c-u-r-r-e-n-c-y.html">DEFAULT_CONCURRENCY</a>）。</p>
<h6 id="flatMapLatest"><a href="#flatMapLatest" class="headerlink" title="flatMapLatest"></a><code>flatMapLatest</code></h6><p>与 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html">collectLatest</a> 操作符类似，在发出新流后立即取消先前流的收集，这由 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html">flatMapLatest</a> 操作符来实现。</p>
<h5 id="异常操作符"><a href="#异常操作符" class="headerlink" title="异常操作符"></a>异常操作符</h5><p>当运算符中的发射器或代码抛出异常时，我们可以使用异常操作符对异常进行处理。</p>
<h6 id="使用-try-catch-捕获异常"><a href="#使用-try-catch-捕获异常" class="headerlink" title="使用 try..catch 捕获异常"></a>使用 try..catch 捕获异常</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithTryCatch</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        flowList().collect &#123; value -&gt;<br>            println(value)<br>            check(value &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-string">&quot;Collected <span class="hljs-variable">$value</span>&quot;</span> &#125; <span class="hljs-comment">// 值 &gt; 1 的时候抛出一个 IllegalStateException</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;<br>        println(<span class="hljs-string">&quot;Caught <span class="hljs-variable">$e</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是，上面这个例子中实际上捕获了任何在发射器或者过渡操作符、末端操作符中抛出的异常。</p>
<h6 id="catch-操作符"><a href="#catch-操作符" class="headerlink" title="catch 操作符"></a><code>catch</code> 操作符</h6><p>发射器可以使用 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch</a> 操作符来保留此异常的透明性并允许封装它的异常处理。<code>catch</code> 操作符的代码块可以分析异常并根据捕获到的异常以不同的方式对其做出反应，它的特点是：</p>
<ul>
<li>可以使用 <code>throw</code> 重新抛出异常</li>
<li>可以使用 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">emit</a> 将异常转换为值发射出去</li>
<li>可以将异常忽略，或用日志打印，或使用一些其他代码处理它</li>
<li>仅捕获上游异常</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">catchFlowException</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        flowListWithException()<br>            .<span class="hljs-keyword">catch</span> &#123; e -&gt; emit(<span class="hljs-string">&quot;Caught <span class="hljs-variable">$e</span>&quot;</span>) &#125; <span class="hljs-comment">// 发射一个异常</span><br>            .collect &#123; value -&gt;<br>                check(value.length &lt; <span class="hljs-number">20</span>) &#123; <span class="hljs-string">&quot;Collected <span class="hljs-variable">$value</span>&quot;</span> &#125; <span class="hljs-comment">// 仅捕获上游异常</span><br>                println(<span class="hljs-string">&quot;Collect <span class="hljs-variable">$value</span>&quot;</span>)<br>            &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>        <span class="hljs-comment">// 捕获下游的异常</span><br>        println(<span class="hljs-string">&quot;Collect Exception: <span class="hljs-variable">$e</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="声明式捕获-onEach"><a href="#声明式捕获-onEach" class="headerlink" title="声明式捕获 onEach"></a>声明式捕获 <code>onEach</code></h6><p>我们可以将 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch</a> 操作符的声明性与处理所有异常的期望相结合，将 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> 操作符的代码块移动到 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html">onEach</a> 中，并将其放到 <code>catch</code> 操作符之前。收集该流必须由调用无参的 <code>collect()</code> 来触发：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">catchFlowExceptionOnEach</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    flowListWithException()<br>        .onEach &#123;<br>            check(it.length &gt; <span class="hljs-number">10</span>) &#123; <span class="hljs-string">&quot;Collected <span class="hljs-variable">$it</span>&quot;</span> &#125;<br>            println(it)<br>        &#125;<br>        .<span class="hljs-keyword">catch</span> &#123; println(<span class="hljs-string">&quot;Caught <span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>        .collect()<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="完成操作符"><a href="#完成操作符" class="headerlink" title="完成操作符"></a>完成操作符</h5><p>当流收集完成时（普通情况或异常情况），它可能需要执行一个动作。我们可以使用命令式或声明式在流完成时做一些操作。</p>
<h6 id="命令式-finally-块"><a href="#命令式-finally-块" class="headerlink" title="命令式 finally 块"></a>命令式 finally 块</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">flowWithFinally</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        flowList().collect &#123; println(<span class="hljs-string">&quot;Collected <span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        println(<span class="hljs-string">&quot;Done&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="声明式处理-onCompletion"><a href="#声明式处理-onCompletion" class="headerlink" title="声明式处理 onCompletion"></a>声明式处理 <code>onCompletion</code></h6><p>我们可以使用 <code>onCompletion</code> 操作符在流完成收集时进行调用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">flowOnCompletion</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    flowList()<br>        .onCompletion &#123; println(<span class="hljs-string">&quot;Done&quot;</span>) &#125;<br>        .collect &#123; println(<span class="hljs-string">&quot;Collected <span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的输出和使用 <code>finally</code> 代码块的输出一致，除此之外，如果流完成时抛出了异常我们还可以通过 <code>onCompletion</code> 中的可空参数进行捕捉：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">flowOnCompletionWithUpStreamException</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    flowListWithException()<br>        .onCompletion &#123; cause -&gt; cause?.let &#123; println(<span class="hljs-string">&quot;Flow completed but has exceptions: <span class="hljs-variable">$it</span>&quot;</span>) &#125; &#125;<br>        .<span class="hljs-keyword">catch</span> &#123; println(<span class="hljs-string">&quot;Exception: <span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>        .collect &#123; println(<span class="hljs-string">&quot;Collected <span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不过，<code>onCompletion</code> 不会对异常进行处理，而是交由后面的 <code>catch</code> 操作符进行处理。并且与 <code>catch</code> 操作符不同，收集时抛出的异常在 <code>onCompletion</code> 也会感知到：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">flowOnCompletionWithDownStreamException</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    flowList()<br>        <span class="hljs-comment">// onCompletion 能观察到所有的异常，包括下游收集时抛出的异常</span><br>        .onCompletion &#123; cause -&gt; cause?.let &#123; println(<span class="hljs-string">&quot;Flow completed but has exceptions: <span class="hljs-variable">$it</span>&quot;</span>) &#125; &#125;<br>        .<span class="hljs-keyword">catch</span> &#123; println(<span class="hljs-string">&quot;Exception: <span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>        .collect &#123;<br>            check(it &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-string">&quot;Illegal value: <span class="hljs-variable">$it</span>&quot;</span> &#125;<br>            println(<span class="hljs-string">&quot;Collected <span class="hljs-variable">$it</span>&quot;</span>)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>选择命令式或者声明式对异常和流完成进行处理，取决于我们的需求和喜好，两种方式都是有效的。</p>
<h5 id="启动操作符"><a href="#启动操作符" class="headerlink" title="启动操作符"></a>启动操作符</h5><p>我们可以使用 <code>launchIn</code> 替换 <code>collect</code>，在单独的协程中启动流的收集。我们需要通过指定参数 <code>CoroutineScope</code> 用以确定哪一个协程来启动流的收集。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">flowWithLaunchIn</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    flowList()<br>        .onEach &#123; event -&gt; println(<span class="hljs-string">&quot;Event: <span class="hljs-variable">$event</span>&quot;</span>) &#125;<br>        .launchIn(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// &lt;--- 在单独的协程中执行流</span><br>    println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在实际的应用中，作用域来自于一个寿命有限的实体。在该实体的寿命终止后，相应的作用域就会被取消，即取消相应流的收集。这种成对的 <code>onEach &#123; ... &#125;.launchIn(scope)</code> 工作方式就像 <code>addEventListener</code> 一样。而且，这不需要相应的 <code>removeEventListener</code> 函数， 因为取消与结构化并发可以达成这个目的。</p>
<p>另外，<a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/launch-in.html">launchIn</a> 也会返回一个 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>，可以在不取消整个作用域的情况下仅<a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/cancel.html">取消</a>相应的流收集或对其进行 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html">join</a>。</p>
<h6 id="可取消的流"><a href="#可取消的流" class="headerlink" title="可取消的流"></a>可取消的流</h6><p>使用 <code>flow &#123; ... &#125;</code> 创建的流会对每个发射值执行附加的 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/ensure-active.html">ensureActive</a> 检测以进行取消，但是大多数其它流（比如 <code>asFlow()</code>）都不会自行执行取消检测，不过我们可以在 <code>onEach</code> 中对添加 <code>currentCoroutineContext().ensureActive()</code> 或者使用 <code>cancellable</code> 操作符：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeFlowCancellable</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.5</span>).asFlow().cancellable().collect &#123; value -&gt;<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-number">3</span>) cancel()<br>        println(value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Flow-与-Rx"><a href="#Flow-与-Rx" class="headerlink" title="Flow 与 Rx"></a>Flow 与 Rx</h4><p>熟悉 RxJava 的人会觉得 Flow 非常相似，这是因为 Flow 的设计灵感正是来源于响应式流及其各种实现。虽然略有不同，但从概念上讲，Flow <em>依然是</em> 响应式流。</p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>通道提供了一种在流中传输值的方法。</p>
<h4 id="通道基础"><a href="#通道基础" class="headerlink" title="通道基础"></a>通道基础</h4><p>一个 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html">Channel</a> 是一个和 <code>BlockingQueue</code> 非常相似的概念。其中一个不同是它代替了阻塞的 <code>put</code> 操作并提供了挂起的 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/send.html">send</a>，还替代了阻塞的 <code>take</code> 操作并提供了挂起的 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html">receive</a>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">headFirstChannel</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;() <span class="hljs-comment">// 实现了 SendChannel 和 ReceiveChannel</span><br>    launch &#123;<br>        <span class="hljs-comment">// 这里可能是消耗大量 CPU 运算的异步逻辑，我们将仅仅做 5 次整数的平方并发送</span><br>        <span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span>) channel.send(x * x)<br>    &#125;<br>    <span class="hljs-comment">// 这里我们打印了 5 次被接收的整数：</span><br>    repeat(<span class="hljs-number">5</span>) &#123; println(channel.receive()) &#125;<br>    println(<span class="hljs-string">&quot;Done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="通道的关闭与迭代"><a href="#通道的关闭与迭代" class="headerlink" title="通道的关闭与迭代"></a>通道的关闭与迭代</h5><p>和队列不同，一个通道可以通过被关闭来表明没有更多的元素将会进入通道。在接收者中可以使用 <code>for</code> 循环来从通道中接收元素：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">closeAndIterateChannel</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;()<br>    launch &#123;<br>        <span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span>) channel.send(x * x)<br>        channel.close()<br>    &#125;<br>    <span class="hljs-keyword">for</span> (c <span class="hljs-keyword">in</span> channel) println(c)<br>    println(<span class="hljs-string">&quot;Done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="构建通道生产者"><a href="#构建通道生产者" class="headerlink" title="构建通道生产者"></a>构建通道生产者</h5><p>使用生产者-消费者模式对通道进行创建和使用，需要注意这些接口是实验性的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produceAndConsumeChannel</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    produce &#123;<br>        <span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span>) send(x * x)<br>    &#125;.consumeEach &#123; println(it) &#125;<br>    println(<span class="hljs-string">&quot;Done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道是指在一个协程中创建拥有无穷多个值的流。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">infiniteNumberPipeline</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> numbers = produce &#123;<br>        <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) send(x++)<br>    &#125;<br>    <span class="hljs-keyword">val</span> squares = produce &#123;<br>        <span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> numbers) send(x * x)<br>    &#125;<br>    repeat(<span class="hljs-number">10</span>) &#123;<br>        print(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;squares.receive()&#125;</span>, &quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Done!&quot;</span>)<br><br>    <span class="hljs-comment">// 获取 coroutineContext 取消所有后续的 job</span><br>    coroutineContext.cancelChildren()<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="扇出"><a href="#扇出" class="headerlink" title="扇出"></a>扇出</h4><p>多个协程也许会接收相同的管道，它们之间可以进行分布式的工作。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">panOut</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> producer = infiniteDelayedNumbers(<span class="hljs-number">1</span>)<br>    repeat(<span class="hljs-number">5</span>) &#123; launchProcessors(it, producer) &#125;<br>    delay(<span class="hljs-number">950</span>) <span class="hljs-comment">// 等待一会儿</span><br>    producer.cancel() <span class="hljs-comment">// 取消 channel</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="扇入"><a href="#扇入" class="headerlink" title="扇入"></a>扇入</h4><p>多个协程可以发送到同一个通道。 比如说，让我们创建一个字符串的通道，并且在这个通道中以指定的延迟反复发送一个字符串：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">panIn</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> channel = Channel&lt;String&gt;()<br>    launch &#123; sendString(channel, <span class="hljs-string">&quot;Foo&quot;</span>, <span class="hljs-number">200</span>) &#125;<br>    launch &#123; sendString(channel, <span class="hljs-string">&quot;Bar&quot;</span>, <span class="hljs-number">500</span>) &#125;<br>    repeat(<span class="hljs-number">6</span>) &#123; println(channel.receive()) &#125;<br>    coroutineContext.cancelChildren()<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="带缓冲的通道"><a href="#带缓冲的通道" class="headerlink" title="带缓冲的通道"></a>带缓冲的通道</h4><p>到目前为止展示的通道都是没有缓冲区的。无缓冲的通道在发送者和接收者相遇时才传输元素，也叫<em>对接</em>。如果发送先被调用，则它将被挂起直到接收被调用；如果接收先被调用，则它将被挂起直到发送被调用。</p>
<p><code>Channel</code> 构造器与 <code>produce</code> 建造器通过一个可选的参数 <code>capacity</code> 来指定<em>缓冲区的大小</em>。缓冲允许发送者在被挂起前发送多个元素， 就像 <code>BlockingQueue</code> 有指定的容量一样，当缓冲区被占满的时候将会引起阻塞。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bufferedChannels</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">val</span> sender = launch &#123;<br>        repeat(<span class="hljs-number">10</span>) &#123;<br>            println(<span class="hljs-string">&quot;Sending <span class="hljs-variable">$it</span>&quot;</span>)<br>            channel.send(it)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 不对其进行接收，只是等待</span><br>    delay(<span class="hljs-number">1000</span>)<br>    sender.cancel()<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="通道是公平的"><a href="#通道是公平的" class="headerlink" title="通道是公平的"></a>通道是公平的</h4><p>发送和接收操作是<em>公平的</em> 并且尊重调用它们的多个协程。它们遵守先进先出原则，可以看到第一个协程调用 <code>receive</code> 并得到了元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">channelIsSequential</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ball</span>(<span class="hljs-keyword">var</span> hits: <span class="hljs-built_in">Int</span>)<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">player</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, table: <span class="hljs-type">Channel</span>&lt;<span class="hljs-type">Ball</span>&gt;)</span></span> &#123;<br>        <span class="hljs-keyword">for</span> (ball <span class="hljs-keyword">in</span> table) &#123; <span class="hljs-comment">// 在循环中接收球</span><br>            ball.hits++<br>            println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> <span class="hljs-variable">$ball</span>&quot;</span>)<br>            delay(<span class="hljs-number">300</span>) <span class="hljs-comment">// 等待一段时间</span><br>            table.send(ball) <span class="hljs-comment">// 将球发送回去</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> table = Channel&lt;Ball&gt;()<br>    <span class="hljs-comment">// 先启动的协程先接收到事件</span><br>    launch &#123; player(<span class="hljs-string">&quot;ping&quot;</span>, table) &#125;<br>    launch &#123; player(<span class="hljs-string">&quot;pong&quot;</span>, table) &#125;<br>    table.send(Ball(<span class="hljs-number">0</span>))<br>    delay(<span class="hljs-number">2000</span>)<br>    coroutineContext.cancelChildren()<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="计时器通道"><a href="#计时器通道" class="headerlink" title="计时器通道"></a>计时器通道</h4><p>计时器通道是一种特别的会合通道 (<code>ReceiveChannel</code>)，每次经过特定的延迟都会从该通道进行消费并产生 <code>Unit</code>。虽然它看起来似乎没用，它被用来构建分段来创建复杂的基于时间的 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html">produce</a> 管道和进行窗口化操作以及其它时间相关的处理。可以在 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html">select</a> 中使用计时器通道来进行“打勾”操作。</p>
<p>使用工厂方法 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html">ticker</a> 来创建这些通道，使用 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html">ReceiveChannel.cancel</a> 方法关闭通道。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tickerChannel</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> tickerChannel = ticker(delayMillis = <span class="hljs-number">1000</span>, initialDelayMillis = <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">var</span> nextElement = withTimeoutOrNull(<span class="hljs-number">1</span>) &#123; tickerChannel.receive() &#125;<br>    println(<span class="hljs-string">&quot;Initial element is available immediately: <span class="hljs-variable">$nextElement</span>&quot;</span>)<br><br>    nextElement = withTimeoutOrNull(<span class="hljs-number">500</span>) &#123; tickerChannel.receive() &#125;<br>    println(<span class="hljs-string">&quot;Next element is not available in 500ms: <span class="hljs-variable">$nextElement</span>&quot;</span>)<br><br>    nextElement = withTimeoutOrNull(<span class="hljs-number">600</span>) &#123; tickerChannel.receive() &#125;<br>    println(<span class="hljs-string">&quot;Next element is available in 1100ms: <span class="hljs-variable">$nextElement</span>&quot;</span>)<br><br>    println(<span class="hljs-string">&quot;Consumer pauses for 1500ms&quot;</span>)<br>    delay(<span class="hljs-number">1500</span>)<br><br>    nextElement = withTimeoutOrNull(<span class="hljs-number">1</span>) &#123; tickerChannel.receive() &#125;<br>    println(<span class="hljs-string">&quot;Next element is available after delay: <span class="hljs-variable">$nextElement</span>&quot;</span>)<br><br>    nextElement = withTimeoutOrNull(<span class="hljs-number">600</span>) &#123; tickerChannel.receive() &#125;<br>    println(<span class="hljs-string">&quot;Next element is available sooner because of the previous delay: <span class="hljs-variable">$nextElement</span>&quot;</span>)<br><br>    tickerChannel.cancel()<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="异常处理与监督"><a href="#异常处理与监督" class="headerlink" title="异常处理与监督"></a>异常处理与监督</h3><p>我们已经知道被取消的协程会在挂起点抛出 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a> 并且它会被协程的机制所忽略。在这里我们会看看在取消过程中抛出异常或同一个协程的多个子协程抛出异常时会发生什么。</p>
<h4 id="异常的传播"><a href="#异常的传播" class="headerlink" title="异常的传播"></a>异常的传播</h4><p>协程构建器有两种形式：自动传播异常（<a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a> 与 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html">actor</a>）或向用户暴露异常（<a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> 与 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html">produce</a>）。当这些构建器用于创建一个<em>根</em> 协程时，即该协程不是另一个协程的<em>子</em> 协程，前者这类构建器将异常视为<strong>未捕获</strong>异常，类似 Java 的 <code>Thread.uncaughtExceptionHandler</code>，而后者则依赖用户来最终消费异常，例如通过 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html">await</a> 或 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html">receive</a>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">exceptionPropagation</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> job = GlobalScope.launch &#123; <span class="hljs-comment">// launch 自动传播异常</span><br>        println(<span class="hljs-string">&quot;Throwing exception from launch&quot;</span>)<br>        <span class="hljs-keyword">throw</span> IndexOutOfBoundsException()<br>    &#125;<br>    job.join()<br>    println(<span class="hljs-string">&quot;Joined failed job&quot;</span>)<br>    <span class="hljs-keyword">val</span> deferred = GlobalScope.async &#123; <span class="hljs-comment">// async 用户调用处消费异常</span><br>        println(<span class="hljs-string">&quot;Throwing exception from async&quot;</span>)<br>        <span class="hljs-keyword">throw</span> ArithmeticException() <span class="hljs-comment">// 没有打印任何东西，依赖用户去调用等待</span><br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        deferred.await()<br>        println(<span class="hljs-string">&quot;Unreached&quot;</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (e: ArithmeticException) &#123;<br>        println(<span class="hljs-string">&quot;Caught ArithmeticException&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="CoroutineExceptionHandler"><a href="#CoroutineExceptionHandler" class="headerlink" title="CoroutineExceptionHandler"></a>CoroutineExceptionHandler</h4><p>将<strong>未捕获</strong>异常打印到控制台的默认行为是可自定义的。<em>根</em> 协程中的 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html">CoroutineExceptionHandler</a> 上下文元素可以被用于这个根协程通用的 <code>catch</code> 块，及其所有可能自定义了异常处理的子协程。 </p>
<p>它类似于 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><code>Thread.uncaughtExceptionHandler</code></a> 。你无法从 <code>CoroutineExceptionHandler</code> 的异常中恢复。当调用处理者的时候，协程已经完成并带有相应的异常。通常，该处理者用于记录异常，显示某种错误消息，终止和（或）重新启动应用程序。</p>
<h4 id="取消与异常"><a href="#取消与异常" class="headerlink" title="取消与异常"></a>取消与异常</h4><p>取消与异常紧密相关。协程内部使用 <code>CancellationException</code> 来进行取消，这个异常会被所有的处理者忽略，所以那些可以被 <code>catch</code> 代码块捕获的异常仅仅应该被用来作为额外调试信息的资源。当一个协程使用 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/cancel.html">Job.cancel</a> 取消的时候，它会被终止，但是它不会取消它的父协程。</p>
<h4 id="异常聚合"><a href="#异常聚合" class="headerlink" title="异常聚合"></a>异常聚合</h4><p>当协程的多个子协程因异常而失败时，一般规则是“取第一个异常”，因此将处理第一个异常。在第一个异常之后发生的所有其他异常都作为被抑制的异常绑定至第一个异常。</p>
<h4 id="监督"><a href="#监督" class="headerlink" title="监督"></a>监督</h4><p>取消是在协程的整个层次结构中传播的双向关系。让我们看一下需要单向取消的情况。</p>
<p>此类需求的一个良好示例是在其作用域内定义作业的 UI 组件。如果任何一个 UI 的子作业执行失败了，它并不总是有必要取消（有效地杀死）整个 UI 组件， 但是如果 UI 组件被销毁了（并且它的作业也被取消了），由于它的结果不再被需要了，它有必要使所有的子作业执行失败。</p>
<p>另一个例子是服务进程孵化了一些子作业并且需要<em>监督</em> 它们的执行，追踪它们的故障并在这些子作业执行失败的时候重启。</p>
<h5 id="监督作业"><a href="#监督作业" class="headerlink" title="监督作业"></a>监督作业</h5><p><a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-supervisor-job.html">SupervisorJob</a> 可以用于这些目的。它类似于常规的 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job.html">Job</a>，唯一的不同是：<code>SupervisorJob</code> 的取消只会向下传播：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">supervisorJobExample</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> supervisor = SupervisorJob()<br>    with(CoroutineScope(coroutineContext + supervisor)) &#123;<br>        <span class="hljs-comment">// 启动第一个子作业——这个示例将会忽略它的异常（不要在实践中这么做！）</span><br>        <span class="hljs-keyword">val</span> firstChild = launch(CoroutineExceptionHandler &#123; _, _ -&gt;  &#125;) &#123;<br>            println(<span class="hljs-string">&quot;The first child is failing&quot;</span>)<br>            <span class="hljs-keyword">throw</span> AssertionError(<span class="hljs-string">&quot;The first child is cancelled&quot;</span>)<br>        &#125;<br>        <span class="hljs-comment">// 启动第二个子作业</span><br>        <span class="hljs-keyword">val</span> secondChild = launch &#123;<br>            firstChild.join()<br>            <span class="hljs-comment">// 取消了第一个子作业且没有传播给第二个子作业</span><br>            println(<span class="hljs-string">&quot;The first child is cancelled: <span class="hljs-subst">$&#123;firstChild.isCancelled&#125;</span>, but the second one is still active&quot;</span>)<br>            <span class="hljs-keyword">try</span> &#123;<br>                delay(<span class="hljs-built_in">Long</span>.MAX_VALUE)<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 但是取消了监督的传播</span><br>                println(<span class="hljs-string">&quot;The second child is cancelled because the supervisor was cancelled&quot;</span>)<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 等待直到第一个子作业失败且执行完成</span><br>        firstChild.join()<br>        println(<span class="hljs-string">&quot;Cancelling the supervisor&quot;</span>)<br>        supervisor.cancel()<br>        secondChild.join()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="监督作用域"><a href="#监督作用域" class="headerlink" title="监督作用域"></a>监督作用域</h5><p>对于<em>作用域</em> 的并发，可以用 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html">supervisorScope</a> 来替代 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a> 来实现相同的目的。它只会单向的传播并且当作业自身执行失败的时候将所有子作业全部取消。作业自身也会在所有的子作业执行结束前等待，就像 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a> 所做的那样。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">supervisorScopeExample</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        supervisorScope &#123;<br>            <span class="hljs-keyword">val</span> child = launch &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    println(<span class="hljs-string">&quot;The child is sleeping&quot;</span>)<br>                    delay(<span class="hljs-built_in">Long</span>.MAX_VALUE)<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    println(<span class="hljs-string">&quot;The child is cancelled&quot;</span>)<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 使用 yield 来给我们的子作业一个机会来执行打印</span><br>            yield()<br>            println(<span class="hljs-string">&quot;Throwing an exception from the scope&quot;</span>)<br>            <span class="hljs-keyword">throw</span> AssertionError()<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e: AssertionError) &#123;<br>        println(<span class="hljs-string">&quot;Caught an assertion error&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="监督协程中的异常"><a href="#监督协程中的异常" class="headerlink" title="监督协程中的异常"></a>监督协程中的异常</h5><p>常规的作业和监督作业之间的另一个重要区别是异常处理。监督协程中的每一个子作业应该通过异常处理机制处理自身的异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">coroutineExceptionHandler</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> handler = CoroutineExceptionHandler &#123; _, exception -&gt;<br>        println(<span class="hljs-string">&quot;CoroutineExceptionHandler got <span class="hljs-variable">$exception</span>&quot;</span>)<br>    &#125;<br>    supervisorScope &#123;<br>        <span class="hljs-keyword">val</span> child = launch(handler) &#123;<br>            println(<span class="hljs-string">&quot;The child throws an exception&quot;</span>)<br>            <span class="hljs-keyword">throw</span> AssertionError()<br>        &#125;<br>        println(<span class="hljs-string">&quot;The scope is completing&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;The scope is completed&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="共享的可变状态与并发"><a href="#共享的可变状态与并发" class="headerlink" title="共享的可变状态与并发"></a>共享的可变状态与并发</h3><p>协程可被多线程调度器并发地执行，这会造成常见的并发问题。主要的问题是同步访问<strong>共享的可变状态</strong>。</p>
<h4 id="线程安全的数据结构"><a href="#线程安全的数据结构" class="headerlink" title="线程安全的数据结构"></a>线程安全的数据结构</h4><p>一种对线程、协程都有效的常规解决方法，就是使用线程安全（也称为同步的、 可线性化、原子）的数据结构，它为需要在共享状态上执行的相应操作提供所有必需的同步处理。比如使用 <code>AtomicInteger</code> 类代替 Int 类。</p>
<h4 id="以细粒度限制线程"><a href="#以细粒度限制线程" class="headerlink" title="以细粒度限制线程"></a>以细粒度限制线程</h4><p><em>限制线程</em> 是解决共享可变状态问题的一种方案：对特定共享状态的所有访问权都限制在单个线程中。它通常应用于 UI 程序中：所有 UI 状态都局限于单个事件分发线程或应用主线程中。这在协程中很容易实现，通过使用一个单线程上下文。</p>
<h4 id="以粗粒度限制线程"><a href="#以粗粒度限制线程" class="headerlink" title="以粗粒度限制线程"></a>以粗粒度限制线程</h4><p>在实践中，线程限制是在大段代码中执行的，比如在单线程上下文中运行每个协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">massiveRunExecutorCoarseGrained</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    withContext(coroutineContext) &#123;<br>        massiveRun &#123;<br>            counter++<br>        &#125;<br>    &#125;<br>    println(<span class="hljs-string">&quot;Counter = <span class="hljs-variable">$counter</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>另外我们还可以使用互斥解决方案：使用永远不会同时执行的<em>关键代码块</em> 来保护共享状态的所有修改。</p>
<p>在阻塞的世界中，你通常会为此目的使用 <code>synchronized</code> 或者 <code>ReentrantLock</code>。 在协程中的替代品叫做 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html">Mutex</a>，它具有 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html">lock</a> 和 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html">unlock</a> 方法，可以隔离关键的部分。关键的区别在于 <code>Mutex.lock()</code> 是一个挂起函数，它不会阻塞线程。</p>
<p>还有 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html">withLock</a> 扩展函数，可以方便的替代常用的 <code>mutex.lock(); try &#123; …… &#125; finally &#123; mutex.unlock() &#125;</code> 模式。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/blog/">Writing</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-number">1.</span> <span class="toc-text">代码规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.</span> <span class="toc-text">源码组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D"><span class="toc-number">1.1.2.</span> <span class="toc-text">文件命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.3.</span> <span class="toc-text">文件组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%86%85%E5%AE%B9%E6%8E%92%E5%B8%83"><span class="toc-number">1.1.4.</span> <span class="toc-text">类的内容排布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%97%B6%E7%9A%84%E6%8E%92%E5%B8%83"><span class="toc-number">1.1.5.</span> <span class="toc-text">实现接口时的排布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95%E7%9A%84%E6%8E%92%E5%B8%83"><span class="toc-number">1.1.6.</span> <span class="toc-text">重载方法的排布</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">1.2.</span> <span class="toc-text">命名规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%90%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">方法名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E7%9A%84%E5%91%BD%E5%90%8D"><span class="toc-number">1.2.2.</span> <span class="toc-text">测试方法的命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%90%8D"><span class="toc-number">1.2.3.</span> <span class="toc-text">属性名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%95%E5%90%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E5%91%BD%E5%90%8D"><span class="toc-number">1.2.4.</span> <span class="toc-text">幕后属性的命名</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%95%E5%90%8E%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">幕后字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%95%E5%90%8E%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">幕后属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%8D%E7%A7%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">如何选择名称</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%A9%E8%BF%9B"><span class="toc-number">1.3.1.</span> <span class="toc-text">缩进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E4%BD%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">表达体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.5.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.6.</span> <span class="toc-text">控制流程语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.7.</span> <span class="toc-text">方法调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.8.</span> <span class="toc-text">链式调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambdas"><span class="toc-number">1.3.9.</span> <span class="toc-text">Lambdas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%96%E5%B0%BE%E9%80%97%E5%8F%B7"><span class="toc-number">1.3.10.</span> <span class="toc-text">拖尾逗号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">1.4.</span> <span class="toc-text">文档注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E6%83%AF%E7%94%A8%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">习惯用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">1.5.1.</span> <span class="toc-text">不可变性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">1.5.3.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda-%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.4.</span> <span class="toc-text">Lambda 参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.5.5.</span> <span class="toc-text">Lambda 返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.6.</span> <span class="toc-text">命名参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.5.7.</span> <span class="toc-text">条件表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Loops"><span class="toc-number">1.5.8.</span> <span class="toc-text">Loops</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Loops-on-range"><span class="toc-number">1.5.9.</span> <span class="toc-text">Loops on range</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">1.5.10.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Functions-vs-properties"><span class="toc-number">1.5.11.</span> <span class="toc-text">Functions vs properties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.12.</span> <span class="toc-text">扩展方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E6%96%B9%E6%B3%95-Infix-functions"><span class="toc-number">1.5.13.</span> <span class="toc-text">中缀方法 (Infix functions﻿)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.14.</span> <span class="toc-text">工厂方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">2.</span> <span class="toc-text">标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scope-functions"><span class="toc-number">2.1.</span> <span class="toc-text">Scope functions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Distinctions"><span class="toc-number">2.1.1.</span> <span class="toc-text">Distinctions</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Context-object-this-or-it"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">Context object: this or it</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Return-value"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">Return value</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#let"><span class="toc-number">2.1.2.</span> <span class="toc-text">let</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#with"><span class="toc-number">2.1.3.</span> <span class="toc-text">with</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#run"><span class="toc-number">2.1.4.</span> <span class="toc-text">run</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#apply"><span class="toc-number">2.1.5.</span> <span class="toc-text">apply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#also"><span class="toc-number">2.1.6.</span> <span class="toc-text">also</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#takeIf-and-takeUnless"><span class="toc-number">2.1.7.</span> <span class="toc-text">takeIf and takeUnless</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%8B%E5%8F%98"><span class="toc-number">3.1.1.</span> <span class="toc-text">型变</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%A4%84%E5%9E%8B%E5%8F%98"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">声明处型变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%84%E5%9E%8B%E5%8F%98"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">使用处型变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Star-projections"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">Star-projections</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">泛型函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">泛型约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">3.1.4.</span> <span class="toc-text">类型擦除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">函数与 Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">4.1.2.</span> <span class="toc-text">函数类型实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E8%B0%83%E7%94%A8"><span class="toc-number">4.1.3.</span> <span class="toc-text">函数类型实例调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E6%9C%AB%E5%B0%BE%E7%9A%84-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">传递末尾的 lambda 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#it%EF%BC%9A%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E9%9A%90%E5%BC%8F%E5%90%8D%E7%A7%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">it：单个参数的隐式名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.2.4.</span> <span class="toc-text">从 lambda 表达式中返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E5%88%92%E7%BA%BF%E7%94%A8%E4%BA%8E%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">4.2.5.</span> <span class="toc-text">下划线用于未使用的变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%A3%E6%9E%84%E5%A3%B0%E6%98%8E"><span class="toc-number">4.2.6.</span> <span class="toc-text">lambda 表达式中的解构声明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">匿名函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">4.3.1.</span> <span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">内联函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E5%86%85%E8%81%94"><span class="toc-number">4.4.1.</span> <span class="toc-text">禁用内联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%B1%80%E9%83%A8%E8%BF%94%E5%9B%9E"><span class="toc-number">4.4.2.</span> <span class="toc-text">非局部返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">4.4.3.</span> <span class="toc-text">具体化的类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%B1%9E%E6%80%A7"><span class="toc-number">4.4.4.</span> <span class="toc-text">内联属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF"><span class="toc-number">5.1.</span> <span class="toc-text">异步编程技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83"><span class="toc-number">5.1.2.</span> <span class="toc-text">回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Futures-Promises-%E5%8F%8A%E5%85%B6%E5%AE%83"><span class="toc-number">5.1.3.</span> <span class="toc-text">Futures &#x2F; Promises 及其它</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%8F%92%E4%BB%B6"><span class="toc-number">5.1.4.</span> <span class="toc-text">响应式插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B-1"><span class="toc-number">5.1.5.</span> <span class="toc-text">协程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">5.2.</span> <span class="toc-text">协程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91"><span class="toc-number">5.2.1.</span> <span class="toc-text">结构化并发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CoroutineScope-vs-CoroutineContext"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">CoroutineScope vs CoroutineContext</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.2.</span> <span class="toc-text">挂起函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9E%84%E5%BB%BA%E5%99%A8"><span class="toc-number">5.2.3.</span> <span class="toc-text">作用域构建器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8D%8F%E7%A8%8B%E5%83%8F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.2.4.</span> <span class="toc-text">全局协程像守护线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E4%B8%8E%E8%B6%85%E6%97%B6"><span class="toc-number">5.3.</span> <span class="toc-text">取消与超时</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%B6%88"><span class="toc-number">5.3.1.</span> <span class="toc-text">取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6"><span class="toc-number">5.3.2.</span> <span class="toc-text">超时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">组合挂起函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-async-%E5%B9%B6%E5%8F%91"><span class="toc-number">5.4.1.</span> <span class="toc-text">使用 async 并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%90%AF%E5%8A%A8%E7%9A%84-async"><span class="toc-number">5.4.2.</span> <span class="toc-text">惰性启动的 async</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async-%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.3.</span> <span class="toc-text">async 风格的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-async-%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91"><span class="toc-number">5.4.4.</span> <span class="toc-text">使用 async 的结构化并发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">5.5.</span> <span class="toc-text">协程上下文与调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.5.1.</span> <span class="toc-text">调度器与线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%B5%81"><span class="toc-number">5.6.</span> <span class="toc-text">异步流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E4%B8%8E%E6%B5%81"><span class="toc-number">5.6.1.</span> <span class="toc-text">序列与流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E5%8F%96%E6%B6%88"><span class="toc-number">5.6.2.</span> <span class="toc-text">流的取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%98%AF%E5%86%B7%E7%9A%84"><span class="toc-number">5.6.3.</span> <span class="toc-text">流是冷的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84"><span class="toc-number">5.6.4.</span> <span class="toc-text">流是连续的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">5.6.5.</span> <span class="toc-text">流上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#withContext-%E5%8F%91%E5%87%BA%E9%94%99%E8%AF%AF"><span class="toc-number">5.6.5.1.</span> <span class="toc-text">withContext 发出错误</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%9E%84%E5%BB%BA%E5%99%A8"><span class="toc-number">5.6.6.</span> <span class="toc-text">流构建器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.</span> <span class="toc-text">流操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1%E6%93%8D%E4%BD%9C%E7%AC%A6-map"><span class="toc-number">5.6.7.1.</span> <span class="toc-text">过渡操作符 map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6-transform"><span class="toc-number">5.6.7.2.</span> <span class="toc-text">转换操作符 transform</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%90%E9%95%BF%E6%93%8D%E4%BD%9C%E7%AC%A6-take"><span class="toc-number">5.6.7.3.</span> <span class="toc-text">限长操作符 take</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AB%E7%AB%AF%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.4.</span> <span class="toc-text">末端操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#flowOn-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.5.</span> <span class="toc-text">flowOn 操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.6.</span> <span class="toc-text">缓冲操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#conflate"><span class="toc-number">5.6.7.6.1.</span> <span class="toc-text">conflate</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#collectLatest"><span class="toc-number">5.6.7.6.2.</span> <span class="toc-text">collectLatest</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.7.</span> <span class="toc-text">合并操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Zip"><span class="toc-number">5.6.7.7.1.</span> <span class="toc-text">Zip</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#combine"><span class="toc-number">5.6.7.7.2.</span> <span class="toc-text">combine</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%95%E5%B9%B3%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.8.</span> <span class="toc-text">展平操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#flatMapConcat"><span class="toc-number">5.6.7.8.1.</span> <span class="toc-text">flatMapConcat</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#flatMapMerge"><span class="toc-number">5.6.7.8.2.</span> <span class="toc-text">flatMapMerge</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#flatMapLatest"><span class="toc-number">5.6.7.8.3.</span> <span class="toc-text">flatMapLatest</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.9.</span> <span class="toc-text">异常操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-try-catch-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">5.6.7.9.1.</span> <span class="toc-text">使用 try..catch 捕获异常</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#catch-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.9.2.</span> <span class="toc-text">catch 操作符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8D%95%E8%8E%B7-onEach"><span class="toc-number">5.6.7.9.3.</span> <span class="toc-text">声明式捕获 onEach</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.10.</span> <span class="toc-text">完成操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%BC%8F-finally-%E5%9D%97"><span class="toc-number">5.6.7.10.1.</span> <span class="toc-text">命令式 finally 块</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%A4%84%E7%90%86-onCompletion"><span class="toc-number">5.6.7.10.2.</span> <span class="toc-text">声明式处理 onCompletion</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.7.11.</span> <span class="toc-text">启动操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E5%8F%96%E6%B6%88%E7%9A%84%E6%B5%81"><span class="toc-number">5.6.7.11.1.</span> <span class="toc-text">可取消的流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flow-%E4%B8%8E-Rx"><span class="toc-number">5.6.8.</span> <span class="toc-text">Flow 与 Rx</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93"><span class="toc-number">5.7.</span> <span class="toc-text">通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E5%9F%BA%E7%A1%80"><span class="toc-number">5.7.1.</span> <span class="toc-text">通道基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E7%9A%84%E5%85%B3%E9%97%AD%E4%B8%8E%E8%BF%AD%E4%BB%A3"><span class="toc-number">5.7.1.1.</span> <span class="toc-text">通道的关闭与迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%80%9A%E9%81%93%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">5.7.1.2.</span> <span class="toc-text">构建通道生产者</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">5.7.2.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%87%E5%87%BA"><span class="toc-number">5.7.3.</span> <span class="toc-text">扇出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%87%E5%85%A5"><span class="toc-number">5.7.4.</span> <span class="toc-text">扇入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-number">5.7.5.</span> <span class="toc-text">带缓冲的通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%98%AF%E5%85%AC%E5%B9%B3%E7%9A%84"><span class="toc-number">5.7.6.</span> <span class="toc-text">通道是公平的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8%E9%80%9A%E9%81%93"><span class="toc-number">5.7.7.</span> <span class="toc-text">计时器通道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E7%9B%91%E7%9D%A3"><span class="toc-number">5.8.</span> <span class="toc-text">异常处理与监督</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BC%A0%E6%92%AD"><span class="toc-number">5.8.1.</span> <span class="toc-text">异常的传播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CoroutineExceptionHandler"><span class="toc-number">5.8.2.</span> <span class="toc-text">CoroutineExceptionHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-number">5.8.3.</span> <span class="toc-text">取消与异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%81%9A%E5%90%88"><span class="toc-number">5.8.4.</span> <span class="toc-text">异常聚合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E7%9D%A3"><span class="toc-number">5.8.5.</span> <span class="toc-text">监督</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%91%E7%9D%A3%E4%BD%9C%E4%B8%9A"><span class="toc-number">5.8.5.1.</span> <span class="toc-text">监督作业</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%91%E7%9D%A3%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.8.5.2.</span> <span class="toc-text">监督作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%91%E7%9D%A3%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">5.8.5.3.</span> <span class="toc-text">监督协程中的异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E7%9A%84%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">5.9.</span> <span class="toc-text">共享的可变状态与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.9.1.</span> <span class="toc-text">线程安全的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E7%BB%86%E7%B2%92%E5%BA%A6%E9%99%90%E5%88%B6%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.9.2.</span> <span class="toc-text">以细粒度限制线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E7%B2%97%E7%B2%92%E5%BA%A6%E9%99%90%E5%88%B6%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.9.3.</span> <span class="toc-text">以粗粒度限制线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-number">5.9.4.</span> <span class="toc-text">互斥</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ajiew.github.io/kotlin-notes/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ajiew.github.io/kotlin-notes/&text=Kotlin 学习笔记"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ajiew.github.io/kotlin-notes/&title=Kotlin 学习笔记"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ajiew.github.io/kotlin-notes/&is_video=false&description=Kotlin 学习笔记"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li> -->
  <li><a class="icon" href="mailto:?subject=Kotlin 学习笔记&body=Check out this article: https://ajiew.github.io/kotlin-notes/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ajiew.github.io/kotlin-notes/&title=Kotlin 学习笔记"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ajiew.github.io/kotlin-notes/&title=Kotlin 学习笔记"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ajiew.github.io/kotlin-notes/&title=Kotlin 学习笔记"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ajiew.github.io/kotlin-notes/&title=Kotlin 学习笔记"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ajiew.github.io/kotlin-notes/&name=Kotlin 学习笔记&description=&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Kotlin_logo_2021.svg/1280px-Kotlin_logo_2021.svg.png&#34; alt=&#34;kotlin_logo&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读&lt;a href=&#34;https://kotlinlang.org/docs/home.html&#34;&gt;文档&lt;/a&gt;和《&lt;a href=&#34;https://book.douban.com/subject/27093660/&#34;&gt;Kotlin in Action&lt;/a&gt;》做的一些笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;代码规范&#34;&gt;&lt;a href=&#34;#代码规范&#34; class=&#34;headerlink&#34; title=&#34;代码规范&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://kotlinlang.org/docs/coding-conventions.html&#34;&gt;代码规范&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;源码组织&#34;&gt;&lt;a href=&#34;#源码组织&#34; class=&#34;headerlink&#34; title=&#34;源码组织&#34;&gt;&lt;/a&gt;源码组织&lt;/h3&gt;&lt;h4 id=&#34;目录结构&#34;&gt;&lt;a href=&#34;#目录结构&#34; class=&#34;headerlink&#34; title=&#34;目录结构&#34;&gt;&lt;/a&gt;目录结构&lt;/h4&gt;&lt;p&gt;在纯 Kotlin 的项目中，推荐的目录结构是省略根包名。如果包名是 &lt;code&gt;com.example.kotlin&lt;/code&gt;，那么所有的代码都应该在这个根目录之下，比如 &lt;code&gt;org.example.kotlin.network.socket&lt;/code&gt; 中的文件就应该放在 &lt;code&gt;network/socket&lt;/code&gt; 子目录下。&lt;/p&gt;
&lt;h4 id=&#34;文件命名&#34;&gt;&lt;a href=&#34;#文件命名&#34; class=&#34;headerlink&#34; title=&#34;文件命名&#34;&gt;&lt;/a&gt;文件命名&lt;/h4&gt;&lt;p&gt;如果文件中只包含一个类（包括顶层声明），则它的文件名应该和类名保持一致。如果文件包含多个类、顶层声明等，则应该选择最能描述这些类作用的命名，尽量选择清晰易懂的名称，如果做不到就应该使用多个文件分别保存。对于命名风格应该选择大驼峰命名法，并且应该避免使用一些无意义的后缀，比如 util 等。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li> -->
<!--   <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ajiew.github.io/kotlin-notes/&t=Kotlin 学习笔记"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li> -->
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2025
    aJIEw
  </div>
  <div class="footer-right">
    Find me on
    
    
    
      
        <a class="icon" target="_blank" rel="noopener" href="https://github.com/aJIEw" aria-label="github"><i class="fa-brands fa-github"></i></a>
      
      , 
      
    
      
        <a class="icon" target="_blank" rel="noopener" href="https://twitter.com/ajiew42" aria-label="twitter"><i class="fa-brands fa-twitter"></i></a>
      
       or 
      
    
      
        <a class="icon" target="_blank" rel="noopener" href="mailto:ajiew42@gmail.com" aria-label="mail"><i class="fas fa-envelope"></i></a>
      
      
      
    
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
