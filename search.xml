<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>接受不完美</title>
      <link href="/2023-3/"/>
      <url>/2023-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这个月是我在最近一年中发生变化最大的一个月（主要是心理上的），这点最主要的原因当然是外部环境的刺激，引发了我对自我的反思以及产生了一些行动。不过，很难说最终的结果完全是由自己当下的行为带来的，也许有自己过去的积累，也许有一些运气的成分，还有缘分和天意。但无论如何，我接受这样的安排。因为无论是好是坏，它们都是我生命的一部分，某种程度上也变成了我身体的一部分。我接受它们，就像我接受自己并不完美这个事实一样。</p></blockquote><span id="more"></span><h4 id="3-月-1-日-我们都是奇迹"><a href="#3-月-1-日-我们都是奇迹" class="headerlink" title="3 月 1 日 - 我们都是奇迹"></a>3 月 1 日 - 我们都是奇迹</h4><p>想到一百亿亿亿年宇宙热寂之后，所有的星系甚至黑洞都将瓦解消失掉，不禁让人感叹：人类的存在的确毫无意义。但是，转念又想到此刻的自己能够坐在舒适的房间里，想象着这个遥远到无法想象的未来，那时候寒冷而又毫无生机的宇宙，又不禁心生敬畏。的确，我们只是这个世界的过客，但毫无疑问的是，我们是这个宇宙中能够诞生的最神奇的产物之一。</p><h4 id="3-月-2-日-远程工作-Offer"><a href="#3-月-2-日-远程工作-Offer" class="headerlink" title="3 月 2 日 - 远程工作 Offer"></a>3 月 2 日 - 远程工作 Offer</h4><p>昨晚熬夜准备今天早上的远程面试，从自我介绍到技术面试、行为面试问题，还有需要问面试官的问题等等，睡前还紧张到失眠，结果早上面试之后发现，大多数问题都没有被问到，反而是我一直在问面试官问题，而且他好像也没有什么需要我回答的问题。我猜想他可能是在看过我的 github 项目之后，心里已经认可我的技术水平了，只是不知道我人到底怎么样，所以需要和我沟通一些团队以及开发流程相关的问题。下午正常回公司上班，快下班的时候如愿收到了 offer 邮件，晚上怀着激动的心情写完回复，又用 ChatGPT 帮忙润色了一把，才哆哆嗦嗦把接受 offer 的邮件发了出去。</p><p>对于一个从来没有做过远程工作的人来说，此刻的心情真的是又激动又忐忑。不知道未来会怎么样，但是我想既然都已经来到了这一步，保持谦虚是应该的，但妄自菲薄也没必要。我觉得我还是需要慢慢积累起自信心吧，我其实没有自己想得那么好，也没有那么差。但说起来，一个人想要做到公正、客观地评价自己，真的是非常难的一件事。我也在慢慢努力变得更好，无论发生什么事，相信只要自己尽力而为，结果都一定不会太差。</p><h4 id="3-月-3-日-每次换工作都是在重建新生活"><a href="#3-月-3-日-每次换工作都是在重建新生活" class="headerlink" title="3 月 3 日 - 每次换工作都是在重建新生活"></a>3 月 3 日 - 每次换工作都是在重建新生活</h4><p>最近这两天心境波动挺大的，周三下午面试完的时候心情明显是沮丧的，但晚上还是强行给自己打了鸡血准备第二天的面试，结果第二天却出人意料地顺利，我都感到有种不太真实的感觉。本来对远程工作就挺艳羡的，没想到这次居然这么轻松就实现了。有可能是自己积攒的人品爆发了吧。今天早上仍然像昨天一样很早就醒来了，但不是因为焦虑，而是感到放松和喜悦。古人说福祸相依可能就是这个道理吧，原本以为今年工作很难找，没想到我并没有花费太多时间和精力去准备就得到了一个相对还不错的结果。不过，开心只是一时的，接下来还是要好好思考怎么做好自己该做的部分。首要的是准备入职材料，然后购置设备，再就是学习使用新的协同工具等，还要学习如何成为一个合格的远程开发者。进入新团队后，还得学习新的工作流程，包括 git 工作流，任务分配，项目细节等等。需要学习的东西还很多，但是万事开头难，等度过了这个初期阶段，熟悉了之后，可能就会慢慢找到新的工作和生活节奏了吧。</p><p>越来越发现，其实每一次换工作都是一次重建新生活的机会，抛弃自己过去熟悉、习以为常的东西，去接触新的人、事、物。奇怪的是，有的人总是能利用这样的机会发现自己的弱点，然后慢慢自我改善，而有的人却一再忽视它们，然后不停地犯下类似的错误，长久之后这两种人的差距就会变得越来越大。我希望自己是前一种人，但事实是，我也的确会犯后一种人的错误。我的缺陷很明显，那就是缺乏与人沟通的技巧。过去我会用我不喜欢与人交流作为借口，但是此刻的我才意识到，其实没有不爱与人交流的人，我们不愿意交流是因为我们内心非常抵触交流。我们害怕被拒绝、被嘲笑、被伤害，但唯独不愿意面对真实的自己。他人的想法并不重要，重要的是我们有没有活成自己想要的样子，有没有说自己想说的话，有没有倾听自己内心的声音，有没有表达自己真实的感受。还有就是，我们都是平等的人，不要看低他人，也不要看低自己。要相信每个人都在尽力而为，我们需要的是理解、鼓励和帮助彼此，而不是制造对立。有时候哪怕是你的「敌人」，仔细想想，其实他们的存在也是在帮你变得更好，因为你意识到了自己不必成为像他们一样的人。真正厉害的人，是那种「哪怕是他的竞争对手，都从心里敬重他」的人。那才是真正的高山仰止。</p><h4 id="3-月-4-日-离职之际的心态变化"><a href="#3-月-4-日-离职之际的心态变化" class="headerlink" title="3 月 4 日 - 离职之际的心态变化"></a>3 月 4 日 - 离职之际的心态变化</h4><p>意识到自己即将离职之后，我的心理状态发生了很大的变化。首先对周围人事物的态度都不一样了，哪怕是自己不喜欢的一些东西，看起来好像也没那么讨厌了。尤其是对待同事的态度，感觉他们都变可爱了。还有就是对手上的项目更加珍惜了，想要多完善一点，一方面是想要让接手项目的人尽量无痛地上手，因为每当自己查看屎山代码的时候，内心都会感到厌恶，我不想让别人体会相同的感觉，尤其是出自我手上的项目。另外一方面，其实也有点舍不得，毕竟这也算是自己的作品，我去年一年绝大部分的时间基本上都花在这个项目上了。除此之外，闲下来的时候，常常还会回忆起自己过去在工作中的言行，想到那些在微信群里和客户沟通解决问题的时刻，想到自己和同事的相处，想到老板和自己的谈话。再然后就是还会有点焦虑，担心自己无法胜任新的工作，无法满足他人的期待。有可能是我把自己想得太好了吧，尝试着降低一点期待可能会好一些。承认自己成长得比较慢，承认自己会犯错。同时，也要看到那些自己做得好的地方，强化自己身上的优点，而不是放大身上的缺陷。承认不足才有可能改进，但贬低自我并没有任何助益。人的一生可能就是不断认清自己的过程，我擅长什么，如何放大自己的优势，如何改进自己的缺点让它们不至于影响整体，这是我们一辈子的最大也是最重要的修炼。</p><h4 id="3-月-5-日-做好当下能做的部分"><a href="#3-月-5-日-做好当下能做的部分" class="headerlink" title="3 月 5 日 - 做好当下能做的部分"></a>3 月 5 日 - 做好当下能做的部分</h4><p>晚上把房间收拾了一下，因为以后这个小小的房间就不仅是我吃饭、睡觉的地方了，还是我工作的地方。目光掠过房间里的一件件物品，突然意识到，我一个人生活的话，其实并不需要多么大的房子：一张床，一个卫生间，两张桌子，一个衣柜和书架，再有就是一些杂物箱子之类的。这些东西根本占用不了多少空间。脑海中一瞬间闪过了不该买房的念头，而后又意识到，和租房子相比，住在自己的房子里会更让人感到心安吧，这是在租的房子里无论如何装饰也获得不了的感觉。还有就是，房贷的压力无形中会让人变得更加务实，也更容易存下钱。</p><p>不过，也很难说哪个就更好，因为我们有时候也会因为房贷压力而放弃了一些东西，比如导致自己错过一些机会，去体验另一种人生的可能性，等等。不过，我的观念是，事情一旦发生且无法被改变，那么就不该再去判断好坏，按照现有的路径一直走下去就好了。就像我最近的状态，之前对远程工作完全没有任何概念，突然面临到这样一个机会，心里也还是会犹豫。但是，我知道既然已经做出了决定，那么就只能让自己去慢慢适应。结果是未来的我需要担心的，我只要把眼前能做的部分做好，就行了。</p><h4 id="3-月-6-日-非理性的自我"><a href="#3-月-6-日-非理性的自我" class="headerlink" title="3 月 6 日 - 非理性的自我"></a>3 月 6 日 - 非理性的自我</h4><p>离职前夕观察到自己心态上的第二个变化是，我的内心出现了两个自我，一个自我想在同事面前装出一副可怜、无辜的样子，另一个自我则暗地里觉得未来一定要更加努力，展示出自己离开这家公司后生活过得更好的一面，让裁掉我的人后悔。这两个自我其实背后都来自于想要报复的心理。前一个自我想要通过博取同事的同情来让公司领导难堪，后一个自我则是更直接地想要告诉老板：你裁掉我是你的损失。我觉得这两种心态都是我对被裁这件事做出的应激反应，证明了人厌恶损失以及害怕承认被抛弃的心理。事实上，被裁员对我并没有造成多大的损失，我还因此找到了一直向往的工作，然而我还是出现了这样的心理，这足以说明人的情绪是非理性的。</p><p>坐下来思考之后发现，其实生活中还有很多这样的例子。有时候明明承认自己错了就能挽回很多不必要的损失，但我们还是会忽视错误，坚持自己是正确的，最后反而失去更多。有时候是为了面子，有时候则是纯粹的非理性。所以，古人才会说：三思而后行。当然，对于我这样喜欢拖延和容易想太多的人来说，直接去做可能更好一些。虽然有时候也会为了面子逞强，但是真正需要我表现出勇气的时刻，我却往往容易退缩。意识到这一点也算是改变的开始吧，今后要多多注意，哪些时候只是情绪在起作用，而又有哪些时候是我该放弃大脑中的恐惧想象，直接去行动。</p><h4 id="3-月-7-日-拾米的最后一天"><a href="#3-月-7-日-拾米的最后一天" class="headerlink" title="3 月 7 日 - 拾米的最后一天"></a>3 月 7 日 - 拾米的最后一天</h4><p>今天是我在拾米的最后一天。晚上最后一个离开公司，拍了一张工位的照片留作纪念。回想过去的这两年，在感叹时间真的过得好快的同时，也意识到，自己虽然过着按部就班的生活，但其实也从这段经历中得到了很多。比如，尝试了新技术，通过外包项目体验了大公司的工作环境和氛围，接触了各种各样不同生活状态的人，也对自己未来的生活有了更多的思考。我从来都不算是一个聪明的人，对生活也没有什么特别的规划。一路走来，在人生有限的几个关键的路口，都是靠直觉做出的选择。能拥有这样的结果，我已经非常满意了，我其实已经算是非常幸运的人了。所以呢，我一直在碎碎念中强调，要对自己的一切感到知足和感恩。我有好的家人，也接受了还不错的教育。虽然也许当初更加努力一些，结果会更好，但是我对当下的一切也没什么好抱怨的。未来会怎样我不知道，但是，我知道我会一边珍惜当下的一切，一边继续往前走。但行好事，莫问前程。</p><h4 id="3-月-8-日-活着就是和世界创造连结"><a href="#3-月-8-日-活着就是和世界创造连结" class="headerlink" title="3 月 8 日 - 活着就是和世界创造连结"></a>3 月 8 日 - 活着就是和世界创造连结</h4><p>今天准备回家，下午收拾完东西后，开始在房间里等顺风车司机来，外放着好久没听的歌单，躺在椅子里陷入了沉思。想到接下来的工作，想到我将继续过着更加”清净”的生活，虽然很好，但是总感觉少了点什么。我对亲密关系还是向往的吧，有天下午我还专门花时间写了一则相亲贴，写了对另一半的期望，还有关于我自己。人说到底还是无法脱离和其他人的关系的。尽管我现在的生活已经简单到极致，但终究还是会和同事接触，和父母家人接触，即使是这么简单的人际关系，我也还是会有人际关系上的烦恼。所以，没有人真的可以过上一种与世隔绝的生活。</p><p>但说到底，我们活着，不就是一直在处理自己和这个世界的关系吗？和他人的关系乃至和亲密伴侣的关系，只是其中至关重要的一部分而已。我们从一出生开始，就是在和这个世界建立关系，先是和父母，然后是家人，老师，同学，朋友，领导，同事，爱人，子女，等等。除了人和人的关系，还有我们和物的关系，比如我们一开始通过玩具认识世界，而后又通过书本、电视等，我们逐渐建立了所有物和金钱的观念，然后又通过课堂和接触自然认识到更大的世界。我们无时无刻不处在人和世界的关系之中，并且不断地和这个世界建立更加深入的联系。假如一个人认为自己和这个世界没有任何联系，那么他就不会选择继续存在于这个世界。</p><p>人生最本质的问题在于：我们是如何看待这个世界和自己的关系的。这也是绝大部分哲学都在讨论的问题之一。从这个角度来看，其实每个人都有自己的哲学，因为你只要还活着，那你就有自己看待这个世界的方式，因此你也就有你自己的生存哲学。“我和这个世界的关系是什么”，这个问题决定了你是如何看待自己和他人的关系的，而亲密关系也包含在其中。我的观点是，活着有两个目的，一个是为了更多地体验人生，其次是创造价值。</p><h4 id="3-月-9-日-寻常景色也能让人放松"><a href="#3-月-9-日-寻常景色也能让人放松" class="headerlink" title="3 月 9 日 - 寻常景色也能让人放松"></a>3 月 9 日 - 寻常景色也能让人放松</h4><p>下午去江边玩轮滑，走了一条平时比较少走的路，一直到路的尽头，轮滑很难再往前走了才停下来。边上有一个差不多三米宽的石板桥洞，下面有一点点水流，从桥洞底下延伸出来，流过河堤，汇入江水中。黑黑的桥洞里还有一只蝙蝠在飞舞，仔细看了下，好像是在捕食桥洞里成群的飞虫，对它来说，这应该是它的夜宵吧。在江边吹了一会儿风，开始往回走。周四下午的江边没什么人，偶尔碰到一两个路人，看到我在玩轮滑，都会不自觉地盯着我看好一会儿，看得我多少有点不自在，但内心却有点暗喜的感觉。很难描述这种感觉，我觉得我选择玩这种比较小众的运动，除了真的能从中得到很多快乐以及为了锻炼身体之外，多少也是因为能通过它获得一种被他人关注的感觉吧，毕竟谁都会有一点虚荣心。每次回家玩轮滑，都能发现家乡景色中过去不曾关注到的一面。同样是江滨，桥东那边明显要更幽静。在一个有树荫的地方坐下来休息，望着江面和江对岸的居民楼，远处的群山和毫无遮挡的天空，心里觉得放松极了。好久没有过这种感觉了，也许是因为心中没有任何烦恼，也没有什么需要担心的事吧。有时候，人真的特别需要这种没有压力的状态，让心灵放松，让大脑彻底放空。做一个自由自在的人，活得更真实，才听得到内心的声音。</p><h4 id="3-月-10-日-重新变得好奇"><a href="#3-月-10-日-重新变得好奇" class="headerlink" title="3 月 10 日 - 重新变得好奇"></a>3 月 10 日 - 重新变得好奇</h4><p>我们为什么会记住某段经历呢，通常都是因为它是超出我们日常生活之外的、不太平常的经历。经常可以观察到，某些小孩子总是能一整天都充满活力，他们每次来到一个新地方，或者拿到一个没接触过的东西，总是能像发现新大陆一样，去观察、探索、发现，从不同角度和新场景或者事物发生互动。反观成年人，新鲜和好奇已经是非常稀缺的东西，而且我们的文化还会抑制成年人的好奇心，即使内心感到惊讶，我们还是会习惯性地克制自己，装出一副见怪不怪的样子，从而显得自己见多识广。这是成年人逐渐失去好奇心、逐渐变得无趣的最主要原因，而要让自己打破这种习惯其实也很简单，那就是向小孩子学习，多观察那些平凡事物中的细节，放下自己的身段，学会多问为什么，承认自己的无知。其实只要你愿意去观察，这个世界真的特别丰富多彩。我们生活的时代恰恰是个物质丰裕的年代，而且也给予了我们特别多的自由去探索和发现。只要我们愿意跳脱出世俗的价值观和规则，去追随更多元的生活，我们其实有很大的选择权去让自己的生活变得更有意思，更充分地去满足自己的好奇心。</p><h4 id="3-月-13-日-远程工作的第一天"><a href="#3-月-13-日-远程工作的第一天" class="headerlink" title="3 月 13 日 - 远程工作的第一天"></a>3 月 13 日 - 远程工作的第一天</h4><p>今天是我开始远程工作后的第一天。早上基本在看各种文档，下午才开始看项目，发现老外的项目真的太规范了，文档全，代码规范也不错，还有各种流程文档也一应俱全，相比较起来的话我过去做过的项目简直都不能看。当然，看到这样的项目心里其实也有点发怵，因为我知道以后不能再像过去一个人做开发的时候一样，随心所欲地使用各种骚操作写代码了，同样也得遵循这套规范，而且估计还要花不少的时间去维护文档。怎么说呢，有利有弊吧。好处是无论是谁接手项目都能比较轻松地上手，坏处是需要花时间学习这套规范。从软件开发的角度来说，无疑是利大于弊的，因为这套规范可以应用到方方面面。养成习惯之后，这对我以后的开发工作也会有很大帮助，毕竟软件开发是一项非常依赖与他人合作的事情，尤其是在现在的开源大潮之下。</p><p>除此之外，我也意识到，其实远程工作是个非常依靠个人自驱力的。假如一个人比较擅长管理时间和精力，远程工作可以解放他的生产力。在完成工作上的任务之后，我们可以将剩下的时间用于学习和自我提升，还帮我们省下了通勤的时间，而且也不用再忍受办公室嘈杂的环境和糟糕的空气质量了，简直一举多得。不过，关键还是要看自己能否养成比较好的工作习惯了。我对自己最大的担心是，太容易分心，虽然在家工作不用再担心会受到周围同事的影响，但是有时候一个人还是会陷入各种细节和琐事之中，导致工作效率降低。假如能够克服这个问题，我想这份工作未来可能会让我收获很多很多。</p><h4 id="3-月-14-日-人生是不断成长和寻找答案的过程"><a href="#3-月-14-日-人生是不断成长和寻找答案的过程" class="headerlink" title="3 月 14 日 - 人生是不断成长和寻找答案的过程"></a>3 月 14 日 - 人生是不断成长和寻找答案的过程</h4><p>我们人类真的是特别健忘的物种，明明才提醒自己要如何如何，但是转过头在实际行动中却又使用了另一套做法，无论是在工作中还是生活上，都是如此。我想，可能正是因为这样，我们才需要不停地自省吧。要经常提醒自己，多关注自己所拥有的一切，而不是拿自己的生活与他人对比。多关注那些积极向上的消息，而不是负面的。多感恩，而不是抱怨。幸福的生活要靠自己去争取，而不是坐着空想，抱怨自己的出身、缺乏贵人的赏识或者运气不佳，并没有什么卵用。大多数时候，愤世嫉俗并不会让你显得与众不同，只会更加令人讨厌。多帮助他人，多展现善意，哪怕是微不足道的事情。要选择站在正义的一面，敢于在关键时刻站出来发声，维护自己和他人的利益。拒绝做老好人，要明辨是非，立场坚定，决不让坏人占便宜。即使是吃了亏，犯了错，也要学会纠正自己。争取少犯相同的错误。另外，也要学会放松，对自己不要太过严苛，允许自己为人，允许自己犯错。学会放手，学会享受生活。不要怕陷入生活的低谷，要相信一切都会过去的。我们都是第一次来到这个世界上，这是一个美妙神奇而又无比复杂的世界，不要想着能在某一瞬间搞懂一切。人生很长，我们都有足够的时间去找到自己关于生命、关于爱、关于意义的答案。即使很难，即使会不停地感受到痛苦和无聊，然而这就是我们存在意义中的一部分。耐心一点，继续成长下去吧。</p><h4 id="3-月-15-日-回避型依恋人格"><a href="#3-月-15-日-回避型依恋人格" class="headerlink" title="3 月 15 日 - 回避型依恋人格"></a>3 月 15 日 - 回避型依恋人格</h4><p>看了一篇关于<a href="https://zhuanlan.zhihu.com/p/264425224">回避型依恋人格</a>的文章，挺受启发的，刚好这两天也在思考我是不是应该花那么多时间独处，要不要更加积极地参与社交的问题。我其实非常反感仅仅依靠几篇文章或者网上的某些测试就断定出一个人性格的做法，我觉得我们每个人都是非常复杂的个体，每个人的性格都有其独特之处，即使可以通过一些手段总结出一些共性，但是无论如何还是很难简单用几个分类描述出一个人的性格。不过，我觉得从大体上判断出一个人的个性倾向还是可以做到的，比如内向还是外向，依恋类型等等。我觉得自己是属于内向性格、回避型依恋类型的人，这点稍微观察下自己的言行以及思维方式就能看得出来。关键的问题在于，我是否觉得自己需要改变？我过去其实一直处于不断摇摆中的状态。有段时间觉得自己这样不好，应该改变自己，只有让自己的性格变得更加宜人才能拥有幸福。之后有段时间又觉得，何必呢？我们每个人的生命都只有短短三万多天，为了别人而改变只会增加自己的痛苦，而且结果也不一定会减轻人生中可能出现的各种痛苦，那还不如选择做真实的自己，反正同样都是痛苦，至少还能让自己活得更加自在一些。现在的我又有了新的想法，我觉得人终归还是要回归现实的。我其实并不太想做一个与众不同的人，融入世俗生活才更符合我的价值观。既然如此，那我就必须学会放弃一些东西，比如不要过于理想主义，比如改变自己的性格，适应当今社会的游戏规则，利用好自己的才能，为他人创造价值，等等。人生说到底是一个选择的过程，但无论是什么样的选择，只要你能承受相应的后果，并且也发自内心觉得这样的结果是自己想要的，那么你就能够获得内心的平静。</p><h4 id="3-月-16-日-完美人生的定义"><a href="#3-月-16-日-完美人生的定义" class="headerlink" title="3 月 16 日 - 完美人生的定义"></a>3 月 16 日 - 完美人生的定义</h4><p>昨晚睡前写下一段话：我对完美人生的定义是：充足睡眠，健康饮食，适量运动，冥想，阅读，建立和谐的人际关系（亲情、友情、爱情），勤奋工作，承担责任，照顾好自己和家人。进阶版本：承担更大的社会责任，创造更多的社会财富，改善他人的生活，提升人类的认知边界。</p><p>要是在十年前，我绝对想不到未来我对完美人生的定义居然是这样的，看起来如此平淡无奇。人可能的确会随着年龄的增长而变得更加成熟吧。现在的我知道，绝大多数人都是普通人，能完成这些看似普通的目标其实都已经非常不容易了。真正有能力改造社会、创造出巨大价值、发明新工具或者商业模式的人，都是千万里挑一的人物。所以，符合逻辑的做法是，从小处着手，先尝试改善自己和家人的生活，然后才是身边的其他人。承认自己是普通人，就要把自己分内的事情做好，那也无非就是上面那些事情。当然，我们也需要保持好奇，去探索这个世界，不过要先看看自己是否尽到了应尽的责任。我觉得人生最理想的情况是，我们做的是自己最擅长的事，而这事恰好也能为他人创造价值，无论这价值是有形的还是无形的。</p><h4 id="3-月-17-日-心中有爱，和这个世界的联系就不会断"><a href="#3-月-17-日-心中有爱，和这个世界的联系就不会断" class="headerlink" title="3 月 17 日 - 心中有爱，和这个世界的联系就不会断"></a>3 月 17 日 - 心中有爱，和这个世界的联系就不会断</h4><p>前段时间看到一个视频，讲的是一个女生在养父母都去世之后才发现自己并不是他们亲生的，所以打算通过网络寻亲。当时看了之后真的很震撼，很难想象那种感觉，一个人失去了和这个世界最重要的联系，没有了最亲的家人，而自己也才刚独立。每到节日的时候别人都去和家人相聚了，自己却只能一个人面对无处可去的境地，即使有朋友陪伴，但朋友总会有不在身边的时候。我虽然曾经也反问过自己，假如失去了所有的家人和朋友，我要如何找到继续在这个世界生存下去的目标和动力？此刻虽然还是无法给出任何有意义的答案，但还是隐隐觉得，人总归是会向前看的。哪怕是一个人，只要还活着，就能继续和这个世界创造出更多的连结。我们会认识新朋友，甚至还有可能组建自己的家庭。即使没有血缘关系作为依托，但是这个世界并不缺少原本是陌生人，但是通过一段时间的相处之后，感情胜过父子、母女和兄弟手足的关系，这也是为什么我们会喜欢倾听那些来自他人的、描述爱情和友情的故事。我觉得我们的人生就像是一本时刻不停笔的书，只要时间还在流逝，我们就在上面写下一点什么，哪怕是不与其他人相处的时候——一个人内心的情感也能勾画出一个丰富多彩的世界。更何况，没有人能真正独立于这个世界，我们终究还是会和自己所处的环境发生互动，会认识一些人，会发生一些事。哪怕这种关系非常浅，总归还是会造成一点点波澜，然后这波澜会一圈圈向外传递，最终影响到越来越多的人。最重要的是心中要有爱，因为只有爱，才能对这个世界造成持久而又深刻的影响。我希望自己能够成为这样的人。</p><h4 id="3-月-18-日-我们是否会被人工智能取代"><a href="#3-月-18-日-我们是否会被人工智能取代" class="headerlink" title="3 月 18 日 - 我们是否会被人工智能取代"></a>3 月 18 日 - 我们是否会被人工智能取代</h4><p>一直以来我都不喜欢在碎碎念聊时事热点，除非和自己有关或者特别让我有感触。通常情况下，我更喜欢记录自己身上或者发生在我身边的事，因为我觉得大多数热点其实都和我日常的生活没什么关系。未来的我再回过头来看那些过去发生的热点，其实根本没什么意义，反而是那些发生在我生活中的小事更能对我有启发。不过，对于最近一个大热点 GPT 以及延伸出来的 AGI 话题，还是想稍微聊一下自己的想法。</p><p>对于这种新技术的出现，人群中永远分为两派人，一部分人非常兴奋，觉得能用这种新技术开发出许多新产品，必须得赶上这趟红利；另一派人则特别悲观，十分焦虑，觉得这种技术会让许多人失业，甚至包括发明这种新技术的工种——程序员。我觉得自己属于中间派，既觉得这种技术可以提升我们的工作效率，同时也觉得我们自身也要有自我更新的意识。首先，未来一定会出现许多这种基于语义识别的应用，比如图像生成应用等。也有可能会让现有的工具变得更加智能，比如更好用的搜索引擎，更智能的语音助理等等。其次，很多特定领域的非创造性的工作的确有可能会被这种人工智能替代。这种现象现在其实已经发生了，比如购物网站的人工客服，只不过未来这些产品会变得更智能，更像是真的人类在为你服务。</p><p>最和我相关的部分是，程序员是否会被人工智能替代？我觉得现阶段最有可能发生的是，程序员会变得习惯使用人工智能工具辅助写代码，而不是像过去一样主要依赖于搜索引擎。初级开发者可能的确会变得更容易被替代，因为这类简单重复的工作可以直接交给工具去完成，而中高级开发人员只需要关注核心的业务逻辑、架构设计以及关键技术的攻关。假如有一天人工智能不但能够理解人类提出的问题，甚至能总结出核心的需求，并且能够考虑到现有资源的限制，考虑到实现的细节，考虑到代码的可维护性和可扩展性，并且能够自己优化代码，那么，这种时候的确就不需要我们人类程序员了。不过，当我们能够拥有这种程度的人工智能，大多数行业应该都可以实现自动化了，那时候我们人类最重要的工作可能就只是寻找活着的意义了。不过，我还是期待能够尽早实现这种工具，因为这意味着我们可以走入下一个发展阶段了。</p><h4 id="3-月-19-日-个人感受、直觉和反直觉"><a href="#3-月-19-日-个人感受、直觉和反直觉" class="headerlink" title="3 月 19 日 - 个人感受、直觉和反直觉"></a>3 月 19 日 - 个人感受、直觉和反直觉</h4><p>前两天看完了美剧最后生还者第一季，今天刷到一个视频才发现，原来剧集中扮演 Joel 的男主角 Pedro Pascal 在现实中其实并没有子女。我也突然意识到自己的愚蠢，他是一个演员，在剧中的表演和现实生活本来就没有任何联系，我不能因为他在剧中给人一种深爱自己女儿的印象就确信他在现实中也一定是一位慈爱的父亲。我欣赏他在剧中的表演，他让我体会到父爱的伟大，这就够了，至于他生活中是个什么样的人，根本就不重要。</p><p>通过这件小事可以看出，人的情感是多么地非理性。我们很多时候只是通过个人感受就以为自己了解了一个人，但实际上并没有任何事实依据。不过，我们能够生存下来，很大程度上的确是依靠个人感受的。我们喜欢用直觉这个词，直觉有时候也可以理解为一个人当下的感受。假如我们在某种场景下感到不舒服，直觉告诉我们应该马上离开，否则可能会有不好的事情发生，而之后发生的事情也的确验证了我们的直觉。事实上，这种「直觉」是我们通过千百万年的进化之后才获得的，也有人把它叫做潜意识，潜意识总是先于意识觉察到周围环境里的危险信号，然后提醒我们要小心。又比如我们有时候能立马分辨出一个人是否在撒谎，因为这些看似隐秘的信号对于我们的祖先来说至关重要，假如我们不擅长识别它们，很可能就无法存活下来。但坏消息是，现代社会中很多事情都是反直觉的，我们不能完全跟随直觉的做法，而是要绕过它，比如刚刚提到的演员的表演，其实现实中也有很多这样的「演员」，我们有时候甚至都意识不到他们是在进行一种表演。再比如，信任他人的能力，我们会习惯性掩盖自己的信息，害怕暴露出自己的弱点。然而在现代社会中，假如一个人不能习惯一定程度的自我揭露，我们会发现自己很难与他人建立起任何有意义的关系。</p><h4 id="3-月-20-日-任何工作都能获得成就感"><a href="#3-月-20-日-任何工作都能获得成就感" class="headerlink" title="3 月 20 日 - 任何工作都能获得成就感"></a>3 月 20 日 - 任何工作都能获得成就感</h4><p>一个人无论从事什么样的工作，都一定能从中得到成就感，关键在于改变看问题的角度。哪怕是非常枯燥无聊的工作，比如流水线上的重复性工作，假如你能改变自己看待它的方式，你就能从中发现新的意义。实际上大多数人也正是这么做的，不然的话人类社会早就崩溃了。驱动人类社会进步的无非是那些最基本的欲望，食欲、色欲、权力欲、财富欲，大部分人工作的一大目的就是为了满足这些基础欲望，然后才是去追求一些更高尚的目标，比如帮助他人和自我实现的愿望。我有时候在想，其实在工作中获得成就感非常容易，只要用更高一层的方式去看待自己的工作就行了。比如，假设我是一名流水线上的操作员，我可以采用这份工作「毫无意义但是为了生存我不得不做」的态度，也可以采用这份工作可以「让我生存下来的同时帮助家人攒下看病钱」或者「为喜欢的女生买下她早就想买的某样东西」或者「用于提升自己的学历」的态度。我们也可以从个人发展的角度，观察自己能从某份工作学到哪些东西，比如增加了体力、手脚变得更加灵活（假如是体力劳动的话），或者是提高了阅读速度、提升了归纳总结的能力（假如你的工作需要阅读特别多的材料），又或者变得更加细心（假如你从事的是财务或者程序员之类的工作）。所以，其实每种工作都能让我们从中收获一点东西的，只要我们愿意改变看问题的角度。无论什么工作，只要我们愿意认真学习和反思，一段时间之后一定都能发现自己的进步。</p><p>我说的这些虽然听上去有种纸上谈兵的感觉，毕竟我并没有太多社会经历，但是我觉得，一个人越是处于糟糕的环境，就越是应该学会用这种方式看待问题。尽早让自己接受现实，然后想办法改善它。哪怕你所做的一切并没有给你的现实生活带来任何改变，至少能让你觉得自己不是在做无用功，并且是有意义的。人生嘛，对于绝大多数人来说，本来就是小范围的改善，一点一滴的积累，到最后才可能稍微有一点有意义的结果。</p><h4 id="3-月-21-日-Imposter-Syndrome"><a href="#3-月-21-日-Imposter-Syndrome" class="headerlink" title="3 月 21 日 - Imposter Syndrome"></a>3 月 21 日 - Imposter Syndrome</h4><p>如何处理冒名顶替综合症 (Imposter Syndrome)？并不是说自己有多厉害，而是因为我有时候的确会因为心态不佳而影响工作，体现在心烦意乱、无法进入正常的工作状态。上周刚入职的时候就是一个例子，心里老是觉得自己不行，做不了这份工作，迟早会露馅。不过好在是在家办公，焦虑到受不了的时候就会去卫生间里对着镜子发泄。等到过去了一周之后，适应了新的工作节奏，这种觉得自己不行、做不好这份工作、一定会被人发现其实自己是个垃圾的想法才慢慢淡去。虽然知道这种心理的出现主要和人的性格有关，但是还是想要改变它。我觉得最好的解决办法就是少想多做。行动起来之后，那些负面想法就会慢慢消失。随着你做得越来越好，这种觉得自己只是在伪装的想法就会慢慢被抛弃掉。另外一个比较好的安慰自己的做法是，采用「既来之，则安之」的心态。既然你已经处于当下的环境了，暂时也没有立马改变它的可能，那么不如就让自己尝试一下，把它当成是一种体验。哪怕最终自己真的无法胜任这个工作或者项目，至少你可以攒到一些经验。还有就是不要怕丢脸，更不要怕失败，因为失败也是一种经验。哪怕是纯粹的失败，至少也能让你的心力变强，变得更耐操。</p><h4 id="3-月-22-日-假如人类大规模失业了"><a href="#3-月-22-日-假如人类大规模失业了" class="headerlink" title="3 月 22 日 - 假如人类大规模失业了"></a>3 月 22 日 - 假如人类大规模失业了</h4><p>看书的时候想到一个问题，假如未来人工智能和机器人真的让大部分人都失业了，我们无法做自己喜欢的工作但是也不至于饿死（假设还有社会福利兜底），那么，我们要用这多出来的时间干什么呢？在做自己喜欢而且回报也非常丰厚的工作，以及失业领救济金、过着得过且过的生活之间，我可能会毫不犹豫地选择前者。但我也知道很多人不会这么想。那么，社会上必然就会多出很多有大把时间但是没什么钱的人，他们会把时间主要花在各种娱乐活动上。其实现在很多人已经在过这样的生活了，游戏、视频、直播、论坛、社交网络等等，一个人完全可以把自己的全部时间都花在这些东西上，连我自己也常常会陷入这样的状态。当然，我并不是说这些东西不好，这些其实都是拓宽我们认知、获取新知识和新体验的方式，但如果我们把全部的时间都花在这些上面，其实就不太利于自己的发展了。我觉得我们作为人类的一员，还是要承担起自己的责任的。首先是照顾好自己的身体健康，然后是关心身边其他人的发展，只有这样，科技才能持续地进步下去。阅读非常重要，社交也非常重要，它们能帮助我们思考以及保持情绪和心理的健康。控制自己的意识，持续不断地学习，保持独立思考，养成有规律地放松和锻炼身体的习惯，做到这些才能让我们持续不断地做出对他人有意义的贡献。</p><h4 id="3-月-23-日-一个人的信念"><a href="#3-月-23-日-一个人的信念" class="headerlink" title="3 月 23 日 - 一个人的信念"></a>3 月 23 日 - 一个人的信念</h4><p>有时候在想，我这样的人在人群中应该算是个少数派吧？好像成为少数派这件事对我来说挺重要的，但我也说不出为什么。有可能是为了获得优越感吧，以少数、小众来体现出自己与众不同的品味、显得特殊和高贵等。但是，我有时候真心希望自己不是少数派，我也渴望能找到同类，找到能够真正彼此理解、交流内心深处想法的人。然而现实是，我只能通过网络和书本才能找到同类。可能这就是成为少数派的代价吧。不过，这也和我自己的性格有关系，我不喜欢表达，也不喜欢和人争论。即使听到不同的想法，我也不会想要去说服对方。我觉得像这样活在自己的世界就很好，至少能保持内心的平衡。即便如此，有时候我内心也会出现动摇。因为无论一个人如何离群索居，终归还是会和外界接触，然后就会产生改造他所接触的那部分人和事的想法。其实也正常，我们自己以及我们所做出的一切行为和决定，都是我们个人信念的体现。我们具有什么样的价值观，决定了我们从事什么样的工作以及如何工作，我们在工作中接触到的人和事则决定了我们的眼界和观念，而这些反过来又会强化我们的价值观。所以，强者会变得越来越强，而弱者往往会变得越来越弱。改变的起点也就是改变的终点，归根结底全都在于一个人具有什么样的信念。</p><h4 id="3-月-24-日-积极的影响力"><a href="#3-月-24-日-积极的影响力" class="headerlink" title="3 月 24 日 - 积极的影响力"></a>3 月 24 日 - 积极的影响力</h4><p>晚上看了两个视频，一个是 Bernie Sanders 在 Oxford 回答学生问题，他谈到了美国政治的现状，直白地指出了顶层政治精英阶层对财富和权力的贪婪；谈到了技术应该具有普惠性，而不是被少部分人控制并为他们获利；谈到了当今世界迫切需要解决的全球性问题比如气候变化等。在结束之前，他回应在场的学生说：你们这一代年轻人，是与众不同的一代人，天生更平等和包容，比如在种族、性别、性取向方面，另外得益于现代科技，看问题的视角更广泛也更国际化，他相信这代年轻人一定能共同携手解决好他刚刚和大家谈论到的那些问题。另一个视频是准备参选下一届总统选举并且主张两岸和平统一的已经 84 岁高龄的台湾前监察院长王建煊的采访，里面谈到了他对台湾未来的担心，并且说明了自己为什么在这样的年龄还要来参选总统。虽然这两个视频没有太多关联，但是我却被这两位八十多岁的老人感动到了，然后有了一种顿悟的感觉。前段时间一直在碎碎念里写关于寻找生命意义相关的话题，我觉得现在看看他们其实就明白了生命的意义。古人说修身齐家治国平天下，其实总结得非常到位了。一个人自己活得好了，只是最基本的成就，当你能够做到影响其他人、甚至改善他人生活的时候，你的能量才能被完全释放出来。这点无论是哪个国家或者哪个行业，也无论年龄和性别，都能找得到例子。我们始终要记住自己是人类社会中的一员，我们有责任照顾好自己。而且能力越强的人，就越是要肩负起责任，去为他人的生活谋福利。即使是普通人，也应该具有这样的心态。首先，照顾好自己和家人的生活，然后是关爱身边的陌生人，乃至全人类的幸福。无论何时都应该记住，尽量保证自己散发出的都是积极的影响力，鼓励合作，传播爱与善意，因为这些最终也会让我们自己受益。</p><h4 id="3-月-25-日-致良知"><a href="#3-月-25-日-致良知" class="headerlink" title="3 月 25 日 - 致良知"></a>3 月 25 日 - 致良知</h4><p>昨天说到要关爱他人，传播爱与善意，正面影响身边的陌生人。这其实是一个非常高的标准，我自己常常都做不到这些，主要是因为我性格比较内向，不喜欢和陌生人相处，大多数时候更愿意一个人待着。但是，我依旧持有这种观念，因为我知道虽然每个人的情况都不同，但是我们都有能力发挥自己的影响力，造福其他人。对大多数人来说，实现这种目标的手段就是努力工作。你的工作就是在创造价值，无论最终产品是什么，你都能在其中发挥影响力，哪怕你的工作离最终产品有非常长的传递链条也一样。这样看来，把我们的工作做好，发挥出自己的特长，就是在为其他人谋福利了。以这种方式思考，哪怕是看起来「低端」、没有技术含量的工作，也会变得有意义起来。我们不再只是为了个人获益、为了生存去工作，也是在帮助、造福他人。当然，哪怕仅仅是为了对得起自己通过工作获得的酬劳，我们也应该努力工作，否则我们的产品就得不到客户的青睐，我们的雇主也会对我们产生不满。</p><p>刚好今早也看到连岳的<a href="https://mp.weixin.qq.com/s/RcFukYXvHGTKPa0kOm-rwQ">一篇文章</a>，提到王阳明的<strong>致良知</strong>，才意识到，原来我们的文化中早就被注入了这种思想。这样看来，其实我们从小所接受的教育还是有意义的。哪怕此刻我对王阳明心学并不了解，即使过去学过，大多数东西也都忘记了，但是并不妨碍我此刻马上就能理解它。我觉得人类能够生存发展到现在，最主要依赖的是知识的积累，我们不断研习前人的知识，包括思想和技术，并且在原有的基础上淘汰掉不符合时代潮流的部分，不断发展创新，从而获得新技术和新思想，最终只有那些好的思想和技术才能够流传下来。我们要做的就是继续传承和发展前人的智慧，这点无论什么样的人都能做到。虽然一个人的力量有限，但是总归还是能在自己所属的那一亩三分地里做出一点什么东西来。也许我们所做的东西未来会被淘汰、被舍弃掉，但至少在某一时间段内，对一小部分人，产生了一定的积极影响力。</p><h4 id="3-月-26-日-学会感恩"><a href="#3-月-26-日-学会感恩" class="headerlink" title="3 月 26 日 - 学会感恩"></a>3 月 26 日 - 学会感恩</h4><p>早上睡到中午才起床，起来后第一件事是做一组腹肌撕裂者，然后是洗漱、下楼取外卖，一边吃着自己喜欢吃的食物一边看圆桌派。看着落地窗边的阳光从右边逐渐移到左边，心里觉得特别舒服。真心觉得自己是个特别幸运的人，也有可能是我是个特别容易知足的人吧。我觉得像我这个年纪，还能熬夜玩游戏、看电影，还能睡到中午起床内心也不觉得愧疚，除了身上没有太多责任之外，最关键的是，我知道我可以掌控自己的人生，我清楚自己的价值观。我知道为了得到一样东西就得失去另外一些东西，我知道选择的后果，也知道不选择的后果，大多数时候我也都准备好了承受任何结果。可能这就是年龄带给我们的智慧吧。当然，我知道自己说这样的话可能还太早了，毕竟才三十岁不到，很多事情我都还没有经历过，比如真正的爱与被爱，比如和异性的亲密接触，比如和一个人彻夜交谈到天亮。我有时候也在想，可能也正是因为我的年轻、缺乏经历才让我显得有点理想主义吧。也许真实的情况是，大多数人都找不到那样理想的关系。我们自己都很难理解自己，又怎么能要求另一个人能完全懂得自己？我们自己有时候都做不到对自己有耐心，倾听自己内心的声音，又怎么能要求另一个人能耐心倾听并做出恰当的回应？所以，还是不要过分要求太多了吧。过好当下的每一天，感恩自己所拥有的一切，珍惜身边的每一段缘分，这样就很好了。</p><h4 id="3-月-27-日-悲观的乐观主义者"><a href="#3-月-27-日-悲观的乐观主义者" class="headerlink" title="3 月 27 日 - 悲观的乐观主义者"></a>3 月 27 日 - 悲观的乐观主义者</h4><p>越来越觉得自卑与自负其实是相连的，最近常常在自己身上观察到这点，有时候会没来由地感到自卑，倒不是自己敏感，而是真心觉得自己挺可笑的。身高焦虑、容貌焦虑也常常困扰我。以前总觉得，别人怎么想是别人的事，并不会真正影响到自己。但是随着越来越多时间的独处，反而更加容易感到自卑。这大概说明其实我还是想要得到他人的接纳和喜欢的吧，只不过内心总是觉得自己不够好，所以老是去关注自己身上的那些缺点。这个世界上本来就没有完美的人，看到那些已经非常优秀的人的真诚聊天，才发现原来他们也会感到焦虑，有时候甚至比普通人还要焦虑。我想这也是为什么他们能够做到如此出众的原因之一吧。但是，我想我们都得学会和这些负面情绪相处，学会控制好它们，至少不能让他们影响自己的生活。我有段时间觉得自己有非常严重的心理问题，反复在考虑要不要去看心理医生，但是后来自己通过阅读、运动、新爱好疏解开了。虽然并不是非常严重的问题，但是此刻回想起来，还是觉得自己挺厉害的。有时候想想，既然我可以只靠自己一个人解决那些看起来很难、让人很痛苦的问题，未来即使再遇到相似的问题，又有什么好怕的呢。麻烦再多、再难，只要我不放弃，总归会有熬过去的那一天，只要熬过去了，就是新生。有人说这个世界上活得最快乐的是那种悲观的乐观主义者，因为他们总是倾向于先看到事物中不好的一面，但同时内心又坚定地相信一定能找到解决办法，或者通过个人的努力和积极创造，让它变得更好。我有时候觉得自己可能也属于是这样的人，这应该是我目前最大的幸运。</p><h4 id="3-月-28-日-人际交往能力"><a href="#3-月-28-日-人际交往能力" class="headerlink" title="3 月 28 日 - 人际交往能力"></a>3 月 28 日 - 人际交往能力</h4><p>现在大多数男女结婚的原因是什么？理想情况下当然是因为彼此相爱，想要和对方共度一生，然而现实往往却是：年龄到了，需要通过婚姻安定下来；找不到比对方更好的人了；获取财富和社会地位；想要小孩。我想也正是因为这样，大多数人都选择不婚，有的人甚至选择单身不恋爱。假如一开始就带着目的去交友，你的行为难免会失真，对方也一定会察觉到，有时候连你自己也会感到不自在。所以这也给了我一个启发，那就是不要目的性太强。大多数时候，先把彼此当作地位平等的朋友慢慢相处，互相熟悉起来之后，才容易发展成为长期的朋友。一直以来，我都觉得自己的人际交往能力非常差，所以很多时候更喜欢独处，慢慢也就养成了什么事都靠自己的习惯。这个习惯虽然提高了我的解决问题的能力、独处的能力，但是却让我陷入更加孤立的环境，这也是我最近特别想要改变的地方。工作、交友和爱是人生的三大课题，谁也逃不掉，意识到了自己的弱点就要想办法去解决它。除此之外，个人的成长也特别重要。无论你拥有多么棒的人际关系，终究还是得回到个人，还是要和自己相处。那么，提升自己的智慧和能力就特别重要。首先要学会和自己相处，一个人要能活得舒服自在。其次是要想清楚自己想要什么，把目标和行动结合起来，你就能拥有一个快乐、充实的人生。</p><h4 id="3-月-29-日-人类一直在进步"><a href="#3-月-29-日-人类一直在进步" class="headerlink" title="3 月 29 日 - 人类一直在进步"></a>3 月 29 日 - 人类一直在进步</h4><p>虽然一个人大多数的烦恼都来自人际关系，但是我也发现，只要能学会感恩，学会看到人性中积极的一面，我们的生活态度就会变得乐观许多。比如，昨晚在看一本 18 世纪的小说的时候，我突然意识到，我们此刻生活中很多被视为理所当然的东西，比如更加平等的人权以及生活的便利性，在当时是完全不可想象的。我们大多数人都可以拥有许许多多的物品，远多于历史上任何时期的普通人所能拥有的；战争、暴力犯罪对大多数人来说都很遥远；我们可以快速且低成本地移动到另一个地点；我们可以使用手机和远方的人面对面交谈；我们可以随时随地阅读书籍。当你注意到这些差别的时候，你很难不感到感恩，你会意识到其实人类一直都在进步，只不过我们过去一直都在关注错误的东西。尽管现代社会还是有很多问题，普通人能够改变的东西也非常有限，我们影响不了贫富差距的拉大，也阻止不了领袖发动战争，但是在我们能控制的范围内，我们可以努力尝试让自己的生活变得更好，比如去关注那些能够提升生活幸福度、让自己的生活态度变得更加积极的事物。生活在现代，我们最关键的任务是找到自己的人生目标。我非常尊敬那些拥有远大理想的人，他们积极从事公益，尝试用自己的财富和知识去改善和自己素不相识的陌生人的生活，他们劝说人们重视气候变化，他们身体力行地去尝试改变看似不可改变的东西。假如你想清楚了自己的人生使命，并且也决定投入自己的全部精力，那么，只要去做就行了。最终你会得到你对生命意义的理解。</p><h4 id="3-月-30-日-乐观需要知识"><a href="#3-月-30-日-乐观需要知识" class="headerlink" title="3 月 30 日 - 乐观需要知识"></a>3 月 30 日 - 乐观需要知识</h4><p>这两天中午和晚上都会忍不住在 YouTube 上点开一些非常 Clickbait 的新闻看，而且看得越多首页推荐类似的内容也越多。我甚至一度开始担心台海战争真的会爆发，甚至在想「为了阻止战争爆发，有什么是我能做的」这种问题。后来看了一个分析战争爆发后可能出现的结果的视频才意识到，发生战争的可能性太低了，根本就没必要担心。而且即使真的发生了，后果根本就不是此刻的我们所能预见到的。到时候无论出现什么样的结果都是有可能的，普通人只能自求多福。既然如此，还不如把时间和精力花在真正重要的地方，比如提高自己的技能水平。大多数人的工作效率其实都可以大幅提高很多，只要我们有能力控制自己的注意力。而控制自己注意力的关键在于不去思考那些自己影响圈之外的事情，只专注于当下。但是，这反过来又要求我们有足够的智慧，能够分辨出自己的能力边界，以及不去杞人忧天。越来越觉得，乐观的态度不仅仅是后天习得的，也需要在拥有了一定的知识后才能获得。</p><h4 id="3-月-31-日-理想的工作状态：热爱以及快乐"><a href="#3-月-31-日-理想的工作状态：热爱以及快乐" class="headerlink" title="3 月 31 日 - 理想的工作状态：热爱以及快乐"></a>3 月 31 日 - 理想的工作状态：热爱以及快乐</h4><p>晚上看了鲁豫跟拍李诞工作、生活的<a href="https://www.youtube.com/watch?v=Gq1wqNHyoxY">采访</a>，心里不由得升起了羡慕，不仅仅是对被采访者的羡慕，还有采访者。因为我觉得他们都是热爱自己工作的人，而对这样的人来说，工作是生活的一部分，同时也是非常快乐的事情。我希望自己有一天也能拥有这样的工作和生活状态。一边看的时候一边在想，我的工作为什么不能像他们一样？我虽然也能全情投入自己的工作，但是很少会出现那种发自内心想要把它做得更好，并且完成之后能够获得特别强烈的成就感的情况。我觉得可能是因为我还不够热爱吧。另外就是还不够好，毕竟人家已经做到行业顶尖了。要知道，现在最厉害的那批程序员，要么创造了世界顶级科技企业，要么在制订行业标准，要么在做基础架构方面的工作，我和他们相差了不知道多少个数量级。所以有时候也挺矛盾的，大多数人都只是普通人而已，做不到像那些耀眼的大人物一样优秀，那么我们努力的意义是什么呢？想来想去，可能就是让自己感到心安吧。知道有那么多比自己厉害多得多得多的人，而且还比自己聪明、勤奋、谦虚，如果连他们都还在努力进步，那我又有什么放弃自己的理由呢？而且过去也无数次说过，和别人比根本就没有用，人只能和自己比，只要我比过去的自己好了一点点，那就足够了。我们追求进步是为了成为一个更好的人，是为了满足自己的好奇心，去拥有选择权，去创造价值，去帮助其他人，而不是为了获得优越感或者满足虚荣心。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>意义与意识</title>
      <link href="/2023-2/"/>
      <url>/2023-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这个月是我到目前为止中断碎碎念写作次数最多、时间最长的一个月，一方面是因为假期后遗症，还有就是工作上的变动。非常可惜，没能把自己当时的心境记录下来，本来这是一个非常好的观察自己内心感受的机会。但我觉得以后一定还会有这样的机会，希望自己到时候能足够有勇气把它们全都记录下来。</p></blockquote><span id="more"></span><h4 id="2-月-15-日-最近发生的大事"><a href="#2-月-15-日-最近发生的大事" class="headerlink" title="2 月 15 日 - 最近发生的大事"></a>2 月 15 日 - 最近发生的大事</h4><p>半个多月没写碎碎念了，一开始是因为还没从假期结束的那种懒散状态恢复过来，后来逐渐变得越来越缺乏表达欲，直到养成习惯之后，彻底放飞自我了。这短短半个多月里也发生了一些事，有些是开心的，比如老姐生产，我有了一个亲外甥，还有难得的一大家族来杭州聚餐出游；也有一些是让我没想到的，比如我被裁员了。其实事后想想觉得也挺合理的，毕竟我作为公司的一份子，没有参与太多能够创造营收的项目，也没有主动做出什么突出的贡献，老板自然会想到要减少开支，尤其是在这种市场环境比较严峻的时刻。话虽这么说，但内心多少还是有点失落。同时也有点兴奋，因为要重新开始找工作了，这意味着一个体验新环境的机会。虽然当前市场环境并不好，但奇怪的是，我也不算太担心，可能是因为自己还有点存款吧，而且正好也可以趁这段时间思考下自己的未来以及探索新的工作方式。人都是在危机中成长的，也希望自己能够从这次小小的危机中得到警醒：不要故步自封，不要安于现状，永远要不停地寻找进步的空间。</p><h4 id="2-月-16-日-我眼中的价值"><a href="#2-月-16-日-我眼中的价值" class="headerlink" title="2 月 16 日 - 我眼中的价值"></a>2 月 16 日 - 我眼中的价值</h4><p>最近在思考人生价值的问题，可能是因为这两天逛论坛的时候看到很多负面的评论吧。我们活着的意义是什么呢？学习、工作、生活，赚钱养家，赡养老人，抚养子女，和朋友相处，与爱人一起度过漫长的人生，去见世界，去长见识，去阅读，去获得新的体验和经历。这些也许是答案的一部分，但是很难让人相信这就是全部。因为人总是会想要更多，觉得自己的人生应该过得更有意义。但事实是，这就是大多数人的一生。也许和那些历史上伟大的人物相比，我们所做的一切并不算什么，不够精彩，也不值得被后人称颂。然而，这就是现实。其实，哪怕是大人物，在他们的一生当中，一定也有许多孤独、沮丧、无助的时刻。比如，霍金一定比普通人更能理解宇宙的广阔和人类的渺小。所以，还是需要先定义什么是价值。假如你觉得刚刚列出的那些东西当中就蕴含着人生的真谛，那么，你只需要去做它们就好了，而且你会过得充实且幸福。但是，如果你觉得人生不仅如此，那么也没关系，我们所处的这个时代是个物质充裕的年代，你不需要花太多时间就能养活自己，然后再用剩余的时间去尽情地探索你理想中的价值和人生的终极意义就可以了，前提是你能够忽略周围环境中的噪音。对我来说，我并不认为我的人生一定要拥有什么才算是有意义的。我觉得生命本身就是奇迹，能够在母亲的子宫中成为受精卵并发育成胚胎并出生就是一种幸运。我出现在这个世界上的几率原本约等于零，但我还是出现了，因此，我要好好珍惜这种缘分，既然来到了这个世界，就要利用好这个机会，尽可能多地去体验，去做自己没做过的事，去学习，去让自己的生活变得更加充实，让自己的生命对自己和他人都更有意义。死亡是人生的终点，既然如此，在这趟人生旅程当中，只要不是违反法律和伦理道德的事，你犯下的任何错误都是可以接受的，也都是我们人生经历的一部分。其次，我并不觉得人的一生有什么东西是必须拥有的，财富、婚姻、爱情、友情都可能会有失去的一天，哪怕是我们最亲爱的家人也终有一天会离我们而去。既然如此，有必要执着于眼下的那一点点得失吗？过好自己的生活，感受自己的感受，尽可能地帮助、抚慰身边的人，尽可能多地体验、欣赏这个世界的美好。</p><h4 id="2-月-17-日-择业的优先级"><a href="#2-月-17-日-择业的优先级" class="headerlink" title="2 月 17 日 - 择业的优先级"></a>2 月 17 日 - 择业的优先级</h4><p>最近在找工作，那就聊聊择业的话题吧。我自己毕业后参加工作到现在也快 6 年了，按理说对职场应该也有一定的认识了，但要让我谈自己的职业规划的话，我还是没法十分清晰地描述出来。过去一直抱着走一步看一步的心态，觉得自己还年轻，有得是时间去探索，而且也还需要积累经验。但是，转眼间就到了需要认真面对如何选择职业道路的这个问题了，现实就是这么残酷。假如你一开始选择的时候没有考虑太多未来，那么当未来来临的时候，你需要面对的问题会更多。所以，当需要面对挑战的时候，最佳选项永远是直面它而不是拖延和逃避。说回我自己，其实到了这个年纪，有了一点工作经验，也见识过不同公司是如何运转的，此刻我看重的东西和刚毕业那会儿完全不同。以前总是习惯性把薪资待遇放在第一位，现在觉得，工作环境和工作内容才更重要。工作环境包括公司的同事、领导是否合得来，我能否做真实的自己而不是小心翼翼地隐藏起自己的真实想法；其次才是软硬件条件。工作内容必须是让我感到有意义的，并且能让我获得成长，哪怕我不喜欢也没关系，能让我觉得我的努力能帮助到他人，自己也有所收获，就行了。还有就像辉哥给出的建议，选择一个好的团队非常重要，其次是要着眼长期。我能不能在这家公司工作 10 年以上？假如可以，十年后我能获得哪些成长？我能保证自己还有竞争力吗？如果到时候不得不换工作的话，我能利用我的技能和人脉获得什么样的机会？假如不行，5 年呢？3 年呢？我目前能够接受的最低限度是 3 年，假如一家公司让我觉得我连 3 年都不能为它服务的话，那么还是放弃它去选择别的机会吧，除非真的没得选。</p><h4 id="2-月-26-日-人生意义和选择权"><a href="#2-月-26-日-人生意义和选择权" class="headerlink" title="2 月 26 日 - 人生意义和选择权"></a>2 月 26 日 - 人生意义和选择权</h4><p>又连续一个多礼拜中断了碎碎念写作，人真的是被习惯支配的动物。其实也不是不想写，只是觉得没有写的必要。今天能够打开软件敲一点字，是因为觉得心里积蓄了太多情绪。人生有意义吗？要说有也就有，要说没有也就没有。大多数人都只是想要活得更好一点，他们努力工作的目的是为了家人、尽到自己的责任，要么就是追求快乐和幸福，而这是一条永无止境的道路。不同的人对它们的定义也不同，可以是世俗意义上的成功，可以是和自己爱的人在一起生活，也可以是做自己喜欢做的事，实现自己的人生价值，等等。我觉得就像我之前在碎碎念中说的，人只要出生了，就是一种幸运。所以，要利用好这个机会，做点什么。最好的离开这个世界的方式是寿终正寝，在睡梦中没有痛苦地死去。除此之外，到了高龄的时候，最大的愿望是不要有太多的遗憾，比如觉得自己人生被浪费掉了。但是，我觉得到了那个年纪，可能也不会这么想了，能够平安、健康地活到老并且没有病痛安详地离开就是一种巨大的奢望了。不过，痛苦也不是什么不好的东西，因为只有智慧生命才能体验和表达痛苦，花草虫鱼也是生命，但是相比人类，它们对于自己命运能够掌控的部分却非常有限。人类的痛苦只有人类才能理解，我们甚至都不一定找得到能够理解彼此的同类。就像此刻的我。大多数时候只是一个人而已，工作之余，能有一点时间看点自己喜欢的视频，读几页书，听几首歌，去江边玩轮滑，感受风吹在脸颊上的感觉，还能开怀大笑，能享受一个人的状态，对我来说，这就是最好的生活。我爱我现在的生活，我也非常珍惜这样的生活，我不希望改变它。但是，我也知道哪怕只是想要维持这样的生活也不是件容易的事，所以一边还在不断提醒自己要更加努力一点，因为只有这样，才能让自己始终拥有选择权。</p><h4 id="2-月-27-日-活得更有意识"><a href="#2-月-27-日-活得更有意识" class="headerlink" title="2 月 27 日 - 活得更有意识"></a>2 月 27 日 - 活得更有意识</h4><p>有时候总是容易被身边的小东西感动，洗澡的时候看到瓷砖上的花纹，想到几万年前人类刚刚学会制作陶器的时候，画这么一点东西可能得花上几天的时间，然后联想到自己此刻的生活，假如他们有机会穿越到现在，我们日常生活中的一切对他们来说差不多都是神迹。说到底，一个人想要变得快乐其实非常容易，学会知足就可以了。但知足两个字谈何容易，我们总是不停地拿自己的生活和他人的生活比较。过去，人的活动范围有限，顶多也就和自己身边的人比，互联网时代来临之后，比较范围扩大到全世界，我们甚至可以看到地球上最富有的一批人的生活。所以，我们对自己的生活越来越不满意，越来越觉得自己要拥有更多才能过得快乐。拥有财富和被关注的确是一件让人快乐的事，这是人的天性，但是，我觉得每个人都有必要问问自己，为了得到它们，我付出了什么？值得吗？我相信，一个人只要开始认真思考并尝试回答这样的问题，我们就会活得更加有意识，而不仅仅是为了遵循社会风俗或者某种 rat racing 而活着。即使我们的生活没有发生改变，我们的心态也会逐渐发生变化。</p><h4 id="2-月-28-日-人生是一连串随机事件"><a href="#2-月-28-日-人生是一连串随机事件" class="headerlink" title="2 月 28 日 - 人生是一连串随机事件"></a>2 月 28 日 - 人生是一连串随机事件</h4><p>最近好像写了不少意义相关的话题，有可能是生活+工作上的变动吧，一下子让我有点无所适从。当然，这对我来说是一个挑战，也是一个机会，可以用来审视自己过去这段时间都干了什么，以及未来应该朝什么方向前进。一直以来，我好像都是随波逐流的状态，我也不知道自己怎么就走到了现在这个地步。其中当然有我自己的选择，但是我觉得大多数时候都是刚好碰到一个机会，或者没有更好的选择了，所以就凑合这样吧。这次找工作也是，我其实并没有特别认真在找，但是却都有看上去还不错的新机会出现在我面前，我也不知道自己能不能把握住它们，我也不知道该如何选择。也许随波逐流也挺好的吧，让潜意识来替自己做决定，这也是听从自己内心的一种方式吧。也许有更好的方式吧，但是想到人生本就是一连串随机事件的组合，就觉得，其实都不重要，健康、快乐地活着比什么都强。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新年快乐，兔年大吉</title>
      <link href="/2023-1/"/>
      <url>/2023-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>隔了一段时间之后再来看这个月写下的碎碎念，意识到文字真的可以抚慰人心，尤其是阅读自己在不同时期写下的文字。照片也许可以记录下一个人的外貌变化，但是只有通过文字记录才能真实还原一个人当时的心理状态。</p></blockquote><span id="more"></span><h4 id="1-月-1-日-带着明亮的希望前行"><a href="#1-月-1-日-带着明亮的希望前行" class="headerlink" title="1 月 1 日 - 带着明亮的希望前行"></a>1 月 1 日 - 带着明亮的希望前行</h4><p>2023 年第一篇碎碎念。最近这几天过得非常难受，除了身体上的不舒服之外，我觉得自己的精神也受到了点影响，一部分原因当然是因为长时间待在房间里，缺乏与其他人的交流。我越来越觉得，人的身、心、灵是一体的，一个强大的灵魂必须得有强大的躯体才能支撑得住。而此刻的我，身体正在遭受前所未有的打击。不过，我还是相信自己能挺过这一关的。在连续几天不出门的日子里，常常望着楼下的大树发呆，想象自己的肺就像挂在枝头上的树叶，随时都要被大风刮走，所以连咳嗽的时候也要小心再小心。真心希望自己能尽快度过这个阶段，回到那个可以尽情享受运动和食物带给我的快乐的状态。哪怕是最简单的深呼吸，在此刻的我看来也是一种宝贵的自由。所以，健康真的是我们最值得珍惜的东西，可惜人只有在失去它之后才会意识到这一点。</p><p>无论如何，2022 年都已经成为了过去，虽然我不喜欢这个结尾，但是人最重要的是经历，我相信，无论这一年里发生了什么，我们都已经挺过来了，而且，不出意外的话，还会带着这份经历给我们带来的改变，继续生活下去。借用社交平台上看到的一句话，祝愿我们：新的一年，带着明亮的希望前行。</p><h4 id="1-月-2-日-还是要做点什么"><a href="#1-月-2-日-还是要做点什么" class="headerlink" title="1 月 2 日 - 还是要做点什么"></a>1 月 2 日 - 还是要做点什么</h4><p>今天早上醒来，感觉好了很多，不过又好像是自己的心理作用。今天的计划是整理过去一个月的碎碎念，然后开始写年终总结。本来应该在过去的这一周多的时间里完成的，但是我都不知道自己是怎么度过最近这段时间的，每天起来之后，不知道怎么的就天黑了。明明什么都没干，但是内心却觉得这一天过得好慢。不过，好在今天已经恢复不少了，过去几天也许可以用生病作借口，但是现在的确要振作起来了。我有时候在想，是不是我内心也在期望过这样的生活，没有计划，没有目标，什么都不做，什么都不管，只是 let it rot？可能也有一部分这样的自我存在吧。其实说白了，就是想要偷懒嘛。过去我也有过相似的经历，比如疫情刚开始那会儿宅在家中的那段时间。但是长期来看，这样的状态也挺痛苦的，因为知道自己并没有产出任何有价值的东西，只是在混日子。人总是需要有一点意义感的，哪怕只是在做一些简单重复的劳动。当我们能从自己所做的事中找到价值时，便能感到心安和满足。</p><h4 id="1-月-3-日-艺术离不开生活"><a href="#1-月-3-日-艺术离不开生活" class="headerlink" title="1 月 3 日 - 艺术离不开生活"></a>1 月 3 日 - 艺术离不开生活</h4><p>今天终于去上班了，不过还是有点不知所措的感觉。早上跑了下项目，看了下 flutter 相关的东西，又认真对比了几个状态管理库，以及 flutter 实战第二版上的一些基础组件，下午开始整理项目文档，不过整理到一半又开始去看 GetX 相关的东西了，有点不知道自己该干什么。一整天最大的收获可能是下班后看的一个圆桌派的<a href="https://www.youtube.com/watch?v=opEmu3vJQi0">视频</a>，来的嘉宾是人艺的两位老演员，听他们聊话剧艺术中的「意」和术，真的很有意思。我觉得真正的艺术家都应该是这样的，不会看上去高不可攀，而且能用普通人都能听懂的话来表达自己对艺术的理解。表演只是舞台上的一部分，但是表演背后的东西，比如表演者是如何理解自己的表演的，才是真正重要的东西。假如一个演员不懂生活、对人生没有反思，那他又怎么能看懂剧本背后创作者想要表达的东西呢？好的艺术都是能让观众去思考的，或者至少是能够让观众获得一点启发的，而不仅仅是作为一种娱乐手段。虽然我们日常生活中消费的很多东西都只是娱乐，但是人还是得留出一点时间来欣赏一些更严肃的作品的，无论是通过阅读，还是通过观看演出，哪怕是看圆桌派这样的节目，我觉得也是一种提高自己审美和修养的手段。</p><h4 id="1-月-4-日-感受的良质"><a href="#1-月-4-日-感受的良质" class="headerlink" title="1 月 4 日 - 感受的良质"></a>1 月 4 日 - 感受的良质</h4><p>晚上在听李志的歌，突然有了一个顿悟，我觉得<strong>良质</strong>可以被定义为：能让人发自内心觉得「真牛」的东西。过去我常常把良质看作是一种实体，但是假如用上面这种定义，良质其实可以来自于他人的感受。比如我听了一首歌，这首歌让我内心涌过了千万种情绪，喜悦和感动交织在一起，并且勾起了我的回忆和种种想象，让我感到自己的生命和宇宙万物紧密相连在一起，那么，此时，这首歌在我眼里就是有良质的。更妙的地方在于，任何一个人都能给他人带去这种感受，比如当修剪草坪的工人把草坪修剪地非常整齐漂亮，当一个厨师用有限的食材烹饪出色香味俱全的菜肴，当程序员写出运行效率高、简洁优雅又容易理解的代码，当我们的工作成果在他人的心中产生了美、舒服甚至是一种尊敬的感受时，良质就产生了。希望未来我也能多多产出良质，而不仅仅是消费它们。</p><h4 id="1-月-5-日-宇宙与生命"><a href="#1-月-5-日-宇宙与生命" class="headerlink" title="1 月 5 日 - 宇宙与生命"></a>1 月 5 日 - 宇宙与生命</h4><p>每当情绪低落的时候我就提醒自己抬头望望天空，看看亿万年前的星光，想想地球花了多少时间才有幸进化出像人类这样的高智慧生命，我还有什么理由为自己的那一点破事而烦恼呢？距离人类最近的一颗恒星都超过了 4 光年，在上世纪七十年代的时候，人类发射了一颗卫星旅行者一号，它到现在才飞出了 1 光日多一点。照这种进度，它至少还需要 3 万多年才能飞出太阳系。即使人类发明了比旅行者一号快一万倍的飞行器，也就是达到光速的一半（这已经比科幻电影还要科幻了），我们前往最近的存在宜居行星的恒星系也要 1 万多年。飞出银河系需要 10 多万年，飞到目前可观测宇宙的边缘要上千亿年。宇宙对人类来说就是无边无际的，就算以人类最疯狂的想象力，也很难感受到哪怕这种巨大尺度的分毫。这一切都在提醒我们，要珍惜自己活着的机会，能在这个广阔的空间中存在，能有幸诞生在这个星球上，就已经是极低的概率了，想想那些无数没能诞生的生命，我们还有什么可抱怨的呢？</p><h4 id="1-月-6-日-珍惜身边的缘分"><a href="#1-月-6-日-珍惜身边的缘分" class="headerlink" title="1 月 6 日 - 珍惜身边的缘分"></a>1 月 6 日 - 珍惜身边的缘分</h4><p>最近经常会怀疑自己当初做的决定是否正确，现在的生活是我想要的吗？假如我当初没有做出那样的决定，我过的生活会是什么样子的？只是，现在再去假设或者后悔，已经没有任何意义了。无论如何，我只能接受当初的决定所带来的后果，即使这结果不是我想要的。也许我可以从中得到一些教训。说到底，我最大的问题是太自负，总是自以为自己比别人强，看不上周围的人，但其实我自己身上的毛病也一大堆。所以，大概也只能接受这样的结果了吧，事实上是我配不上他们。很可惜，要到几年之后，我才明白这个道理。假如当初的自己不是这么想的，也许就不会像现在这样一直孤家寡人了吧，这一切都是我自找的。</p><p>当然，现在能想明白这些也不算太晚。至少从现在开始，我还可以慢慢改变自己。不要那么自以为是，不要那么孤傲，多听听他人的意见，多向值得信任的人吐露自己的真实想法。还有，一定要真诚。过去，我总是喜欢藏着掖着，就连我自己也讨厌和这样的人打交道，所以，为什么还要表现成这个样子呢？以前大家常说「最终，我们都会变成自己讨厌的样子」，那时候我还不相信，现在只能苦笑尴尬了。人就是这样一点点成长的吧。我有时候也在想，是不是那时候我运气比较好，才能一切都顺顺利利，而我自己却不自知，所以才有点飘了，以至于后来所发生的事情，其实是我把他人推开了。一个人种下什么样的因，最终便得到什么样的果。希望从现在开始，自己能好好珍惜身边的缘分。</p><h4 id="1-月-7-日-不太执着的人"><a href="#1-月-7-日-不太执着的人" class="headerlink" title="1 月 7 日 - 不太执着的人"></a>1 月 7 日 - 不太执着的人</h4><p>这两天想明白一件事，那就是，我其实是个特别幸运的人。因为我真的是个特别随遇而安的人，我对大多数事情都不会特别执着，对钱不执着，对享受不执着，对社交不执着，对爱情也不执着。反正就是，眼前有什么就接受什么，一个人也能玩得很开心。这样的人对外界的需求不多，所以自然而然也容易变成做什么事都回到一个人的状态。虽然有时候也会觉得自己是不是不太正常，但是转念想想，这可能也是一种优势吧。再说，我真不觉得自己这样的生活有什么不好的。为什么一定要按照别人的标准去活呢？我觉得我一个人也能享受一个人的幸福，那又有什么问题呢？没有认真谈过恋爱，也没有什么知心的朋友，但是我接受这样的自己、这样的生活，我也能过得很开心。这可能也是一种天赋吧。不过，我还是觉得人是要多进行一些社交的。我也不会特别逃避社交，只是不想去刻意社交。假如身边没有什么聊得来的人，那就一个人吧，也没什么问题。毕竟现在资讯这么发达，我可以和网友交流，可以看书，可以看视频，虽然大多数时候都是单向的交流，比不上面对面的交流，但是至少是一种补充吧，我也接受这样的结果。关键是要让自己的生活变得更加充实起来，获得快乐的途径有很多种，但唯独不是坐着不行动。</p><h4 id="1-月-8-日-拖延与专注"><a href="#1-月-8-日-拖延与专注" class="headerlink" title="1 月 8 日 - 拖延与专注"></a>1 月 8 日 - 拖延与专注</h4><p>我觉得我这个人有点矛盾的地方在于，我有时候会突然不知道该怎么安排自己的时间，明明有很多事情想去做，但是等到终于有时间了却又提不起兴趣去做了。比如这个周末，原本想去自修室自习，查好位置后却又不想去了。可能还是自己一个人的时候想法太多太乱了吧。而且明明待在家里更舒服，晒晒太阳，看看视频，做点无关紧要的事，一个下午不知怎么就过去了。然而事后会觉得，虽然这个周末的时间被浪费掉了，但是还有下个周末呀，然后就一直这样拖着了。我觉得我毕业之后一直没有谈恋爱也是这个原因，太会拖延了。而且老是一个人玩，时间久了就会觉得这样也挺好，有想做的事一个人直接就能去做，也不用麻烦别人。虽然有时候会有想要倾诉的欲望，但是养成了写日记的习惯之后，这种欲望也降低了很多。我觉得与其期待别人有足够的耐心听我扯东扯西，还不如在一个安全的角落里把自己的想法全都写下来，实在不行还可以找个没人认识自己的网站上发出去，听听网友们的想法和意见。还有就是，我觉得我天生就是个适合倾听的人，我喜欢听别人说，包括阅读、看视频也是，我特别愿意倾听他人的看法，只要是我觉得有趣的话题，不管对方是什么人，我都愿意一直听下去。这也是为什么我那么容易分心的原因吧。每次看到一个自己感兴趣的东西，我就会忍不住去搜一搜，了解下相关的知识，即使看了之后没过多久就忘了，但下次遇到相同的情况，我依旧会乐此不疲。这也是为什么我看上去知道得很多，但其实对大多数事物的认知只是停留在肤浅的表层而已，包括对工作、对技术也是一样，我对很多技术感兴趣，但是往往这种兴趣只是停留在表面，一旦深入研究下去，我很容易就会感到无聊，然后分心去做别的事。</p><h4 id="1-月-9-日-孤单与孤独"><a href="#1-月-9-日-孤单与孤独" class="headerlink" title="1 月 9 日 - 孤单与孤独"></a>1 月 9 日 - 孤单与孤独</h4><p>孤独是一件很高级的情感，普通人大多数时候只是感到孤单而已。一个人上下班，一个人吃饭，一个人玩轮滑，一个人追剧，一个人睡觉和醒来，这样的生活看上去是挺孤单的，但很多时候，我根本意识不到孤单，只不过极偶尔地在某几个瞬间心里会想「要是身边有个能聊聊这件事的人就好了」。大多数时候，我不会觉得这种孤单有什么问题，感到孤独的情况更是极其罕见。我觉得从本质上看，每个人都是孤独的，我们来到这个世界本就是偶然，是件极低概率的事，再加上我们出生的家庭、一生中遇见的人，都是随机事件，但正是这一个个偶然和随机造就了此刻的我们。我们的思维方式，我们如何看待自己和这个世界，如何与周围的人相处等等，都受到了不可预测的基因和无数的随机事件的影响。而孤独，只是我们自己的一种感受而已。</p><h4 id="1-月-10-日-先长本事再助人"><a href="#1-月-10-日-先长本事再助人" class="headerlink" title="1 月 10 日 - 先长本事再助人"></a>1 月 10 日 - 先长本事再助人</h4><p>晚上洗澡的时候，想到过去这几年里接受的一个很重要的价值观是：要尽可能地为他人谋福利，为他人带去快乐和幸福。但是，我最近也才意识到，其实一个人<strong>年轻的时候更重要的事情是长本事</strong>，因为只有等你的能力提高了，你才能创造出更多的价值，然后才有能力去做出更好的选择，将资源更有效率地分配到那些真正需要的人身上。当然，为他人的福祉而努力的价值观本身是非常正确的，只不过我们每个人的时间和精力都是有限的，年轻的时候能够培养起为他人服务的观念就足够了，等到我们有了更大的影响力时再去做这些事会更有效率。尤其是当我们连自己的生活也过得不算太好的时候，那就更应该先努力把自己的生活过好，然后再去考虑其它。首要目标是，不要让自己成为他人的累赘，自己先成长，然后才是去尽可能多地帮助其他人。</p><h4 id="1-月-11-日-相亲节目的启发"><a href="#1-月-11-日-相亲节目的启发" class="headerlink" title="1 月 11 日 - 相亲节目的启发"></a>1 月 11 日 - 相亲节目的启发</h4><p>最近看了一个陌生人相亲的节目，参与相亲的人事先都完全不了解来见自己的人是什么样的，就像是开盲盒，我觉得更像是两个陌生人的相处。我一口气看了好多集，还是挺受启发的。第一个感触是要学会打开自己，因为既然来参加这个活动了，那么就说明自己还是想要找到另一半的，假如我们不愿意揭露自己，那么自然就谈不上相互了解了。其次，我们的社会真的发展得太快了，很多价值观都已经被大众熟悉且接受了，所以任何人都不用担心因为自己的价值观比较小众就找不到适合自己的人了，其实只要你生活在一个大城市，无论多小众，都有可能找到不少和自己价值观相似的人。还有就是，社会阶层真的会限制一个人的选择。过去的我虽然也是这么想的，但更多的还是从双方的家庭出发的，但是看了这个节目之后才意识到，假如两个人所处的阶层相差太多，真的很难走到一起。比如某一集中，我一开始以为男女生差距不小，因为一个是北京土著一个来自较为偏远的城市，但是，当我看到男生邀请女生去参加一场舞会时，我才意识到，其实这两个人来自相同的阶层。因为只有这样，他们才有可能有这么多共同话题以及相似的价值观。一个人的社交圈，生活习惯，对待工作的态度，很大程度上都取决于他所在的社会阶层。对于一个来自农村，没有受过高等教育，也没有什么技能的人来说，他在一个舞会上的表现，和一个同样未参加过舞会但是成长于城市中产家庭的人，一定是完全不同的。</p><p>我也在反思我自己，我此刻的生活中谈不上什么社交也没有什么朋友，除了个人的原因之外，多大程度上是由于我所在的阶层呢？我小时候就不喜欢跟着大人们去和亲戚朋友社交，也没有习惯和陌生人打交道，所以成年之后在这样的场合之下总是感到格格不入，于是进一步想要逃避这些场合。当然，这样的结果绝大部分是我自己的原因，我个人的性格以及缺乏锻炼和提高自己社交能力的意识和勇气，但是，假如在我的成长过程中，家中长辈们有人发现并帮助我改善了这个问题，现在的我可能至少会掌握一些技巧而不至于只是想要逃避了吧？虽然现在改善也还来得及，但是总归显得有些吃力。类似这样的由于阶层不同造成的差异还有很多，总得来说，生长在城市家庭，哪怕是比较中下层的家庭，也比出生在农村的条件更好一点，至少对于我们那个年代出生的人来说是这样。至于那些城市中产，尤其是大城市的中产家庭，他们的孩子和农村家庭孩子之间的差距只会越来越大。所以，任何一个城市中产家庭和农村家庭的结合，都得三思再三思，即使两个人的观念差不多，他们未来在一起生活所要面对的挑战和来自亲人的种种矛盾，也将是巨大的。除非一个人的能力特别强大，强大到能够弥补这条来自阶级的鸿沟。</p><h4 id="1-月-12-日-为自己的人生负责"><a href="#1-月-12-日-为自己的人生负责" class="headerlink" title="1 月 12 日 - 为自己的人生负责"></a>1 月 12 日 - 为自己的人生负责</h4><p>我发现想要做到全然自我接纳真的很难，每当看到比自己更优秀的人就会不由得心生羡慕，然后还是会拿自己和他人作比较，虽然我内心一直在催眠自己：要知足，要和过去的自己比，而不是去和别人比。这也是为什么我还得继续修炼吧，在工作中练习，在生活中练习。接纳那些偶然还是会出现的无意义感，接纳那些不想做但又不得不做的事，接纳自己的笨拙，接纳自己身上所有的其它缺点，接纳他人有可能不喜欢自己的这个事实。除了接纳之外，另一个非常重要的事情是，意识到自己是自己人生的主人。外界如何评论自己，无论是好是坏，都不重要，唯一的评判标准来自于我们的内心。<strong>我们要为自己的人生负责</strong>，无论你出生在什么样的家庭，个人条件如何，际遇如何，最终都必须要意识到这一点。只有我才能决定如何度过自己的人生，只有我才能知道什么是适合自己的。我此刻的个人感受是真实的，我的价值观也是从我过去的生活经历中缓慢形成的，因此，我必须要为这一切负责。我有我的信念，即使它未来有可能发生改变，此刻的我依然会全力向它进发。我的身体、我的精神、我的一切的一切，都是我存在的证明，我必须毫不犹豫地保护好它们。不但如此，我还要让它们不断进化，不断地从一个层次上升到更高的层次，只有这样才能证明自己没有白活。</p><h4 id="1-月-13-日-爱生命，爱自己"><a href="#1-月-13-日-爱生命，爱自己" class="headerlink" title="1 月 13 日 - 爱生命，爱自己"></a>1 月 13 日 - 爱生命，爱自己</h4><p>翻了翻最近这两天的碎碎念，感觉有点太正能量了，我觉得这也正常，因为越是状态不佳的时候，越是需要鼓励自己。我没有其他可以诉说的人，所以只能在碎碎念中一遍遍重复自己重复了很多遍的话，只有这样，才能让自己熬过那些迷茫、焦虑、失去斗志、充满挫败感的时刻。今天工作之余，又看了很多文章，有关于职场的，关于自我提升的，关于爱的，关于睡眠的，还有关于宇宙和地球。我觉得我常常觉得累的其中一个可能原因是，大脑每天接收了太多信息，多到来不及消化和吸收。每一篇文章看完之后我都会心生赞同，但是又不知道如何表达内心的感受，有时候我会把想法转换成文字记录下来，有的时候我发现根本没法用语言表达。所以，人的大脑真的是一架太过复杂的机器，没法像计算机一样接收信息之后就能输出一段结果。我现在才发现诗歌的魅力，它们不但能抒发人的感情，还可以将那种模棱两可的东西隐藏在文字后面，而且每个读者都可以根据自己的经历，发挥自己的想象力去解读它们。人说到底还是要活得更加实际一些，遥远的太空也许非常让人向往，但是只有脚下的土地才有让人获得心安的力量，丰富多彩的生命只有在地球这架宇宙飞船上才能繁衍生息。爱生命，更要爱自己。</p><h4 id="1-月-14-日-迷茫"><a href="#1-月-14-日-迷茫" class="headerlink" title="1 月 14 日 - 迷茫"></a>1 月 14 日 - 迷茫</h4><p>现在到周末都有种不知所措的感觉，有很多事情可以做，但什么都不想做，好像每年到年底的时候都是这样的状态。睡前躺在床上总是会胡思乱想，关于自己想要的生活，关于什么才是自己热爱的事，还有亲密关系等等一大堆乱七八糟的东西，好像很难马上把这些事情全都理清楚，越是想要让自己快点入睡往往越是容易失眠。我知道自己是个幸运的人，我也对我已经拥有的东西非常知足，我相信平静的生活也需要付出努力才能得到。但是，人总是很难感到满足，有了 X 之后就还会想要 Y，这是人的天性。最大的问题在于，我觉得我还没找到自己生活的支点，我还没有找到那种让自己上瘾和沉迷的东西，我对大多数事物的兴趣都只是短暂的。我有点理想主义，但是还没有疯狂到认为自己能够改变世界。我想要创造出更大的价值，想要让别人记住自己，但是又觉得自己的性格不适合抛头露面，也许默默无闻地做着自己喜欢又能享受其中的事情就很好了，这样，人生很快也就过去了。不知道，没有答案。</p><h4 id="1-月-15-日-人生是梦幻泡影吗"><a href="#1-月-15-日-人生是梦幻泡影吗" class="headerlink" title="1 月 15 日 - 人生是梦幻泡影吗"></a>1 月 15 日 - 人生是梦幻泡影吗</h4><p>今天网上冲浪刷到一句<em>人生是梦幻泡影</em>，我心里先是觉得认同，但又觉得似乎哪里不对劲。我虽然也是一个很丧的人，但还是觉得人生是有意义的，存在是有意义的，生命也是有意义的，相对于那些从来没有机会出现的人或者出现在一个不那么好的时空的人来说，更是如此。尽管我知道无论如何我都只能是一个普通人，我无法改变世界，也做不出什么对人类有用的贡献，哪怕是照顾好自己和家人，都需要我付出十分的努力了。但我还是相信，活着是一件美好的事。我喜欢山川湖海，喜欢云雨雪月，也喜欢活在天地间一切或高或低、或美或丑、或巨大或细微的生命。我更喜欢人类的想象力和不可思议的创造力，有人制造出复杂的机器，也有人发明各种千奇百怪的游戏，有人创作诗歌，也有人写词谱曲，有人考古探索过去，也有人预言和想象未来。活在这个时代是一种幸运，因为这是人类死亡率最低、最和平、也最富足的时期，只要我们能够做到不去和他人比较，是否活得幸福就是我们自己的选择。</p><h4 id="1-月-16-日-职业动机和人生目标相结合"><a href="#1-月-16-日-职业动机和人生目标相结合" class="headerlink" title="1 月 16 日 - 职业动机和人生目标相结合"></a>1 月 16 日 - 职业动机和人生目标相结合</h4><p>我的职业动机是什么？会问出这个问题，是因为我发现从毕业到现在，我一直在小公司之间来回跳转，从来没有感受过大公司的职级晋升带来的压力。除此之外，我也没有认真想过应该如何规划自己的职业路径。过去觉得要努力提高自己的技术跳槽到大公司才行，工作超过五年之后才意识到，虽然没能进入大公司，但是即使如愿，我要面对的问题并不会减少，除非我找到自己真正想要什么。一切问题的根本在于找到人生的 grand goal，一旦能够做到这一点，我们生活中面对的所有问题都不再是问题，没有什么是真正解决不了的问题。哪怕是突然间的身体残疾，只要还能呼吸，那也只是阻碍你实现目标的约束因素，而不是对你整个人生的否定，或者让你从此一蹶不振。假如我们找到了自己的人生目标，同时又与自己的职业动机结合在一起，那么，我们的人生就会获得由内而外的改变，我们不再是只为自己而活，而是为了更大的目标活着，并且会觉得活得更有意义。</p><h4 id="1-月-17-日-学会从他人的视角看世界"><a href="#1-月-17-日-学会从他人的视角看世界" class="headerlink" title="1 月 17 日 - 学会从他人的视角看世界"></a>1 月 17 日 - 学会从他人的视角看世界</h4><p>在网上如何才能显得不那么说教？有时候总觉得抱着一种分享的态度就没事了吧，但是逛论坛的时候，总会看到一些人，似乎特别容易被冒犯到，又或者是特别喜欢对号入座，总是容易被击中某些点，然后理性讨论就变成了针锋相对的吵架了。我有时候也会反思自己，我有没有这样的表现，虽然生活中很少会表现出这样的一面，但是在他人注意不到的地方，内心活动中有时候也还是会有一些这样的迹象。除了克制自己之外，还需要降低自己的姿态，记住对方是和你平等的。还有就是不要预设立场，不要把自己代入到某个角色之中去，始终保持独立思考是特别难的一件事。每个人都有改变自己的能力，也有改变此时此刻叙事的能力。我觉得这点我们需要从演员身上学习，一个好的演员总是可以让自己变成任何形状，当需要的时候，他可以成为那个人，像那个人一样去行动，甚至使用那个人的思维方式。假如我们允许自己变成另外一个人，那么，我们就有机会去像他一样去思考，以及感受对方的价值观。即使我们不赞同对方，至少可以得到一种新的看待世界的方式。</p><h4 id="1-月-18-日-打坐的生活方式"><a href="#1-月-18-日-打坐的生活方式" class="headerlink" title="1 月 18 日 - 打坐的生活方式"></a>1 月 18 日 - 打坐的生活方式</h4><p>看了和菜头的<a href="https://mp.weixin.qq.com/s/IN5lC6xo5oxUKhalTe8Bsw">一篇文章</a>，正好自己最近也在思考这方面的问题，其实这一年我都在实践「打坐」的生活方式，我发现自己已经习惯了一个人的生活。除此之外，我也发现自己对待工作的态度也发生了一些转变。虽然我还是经常在碎碎念中说要寻找热爱，要拥有一个 bigger than yourself 的目标，但是，我同时也认为，假如你此刻的工作并不能让你有这样的感觉的话，那你就应该在完成自己的工作之后，利用空余时间去多多探索。也就是说，工作其实不应该是你的主要目标，而是为了让你可以在下班之后有自己的时间去寻找和探索。不过，说来惭愧的是，2022 年我做的唯一一件算得上是在探索的事情就是玩轮滑。其它时候，大部分时间都被我挥霍掉了，有时候是纯粹的浪费时间，有时候是陷入了过去残留下来的一些不良习惯。不过，好在我还在继续成长，我也知道未来的我还会继续犯错，只是希望自己不再犯相同的错误。无论是生活方式还是人际关系方面，目前看来我都不太满意。所以，新的一年里，改变自己仍是我的人生主题。</p><h4 id="1-月-19-日-珍惜家人"><a href="#1-月-19-日-珍惜家人" class="headerlink" title="1 月 19 日 - 珍惜家人"></a>1 月 19 日 - 珍惜家人</h4><p>今天和姐姐、姐夫、妹妹踏上了回家之路，回家过年的路上是种什么样的心情呢？应该是开心、喜悦的吧，但是我除了对回家之后能过上一种不太节制、放松玩乐的生活之外，内心似乎也没有其他特别的感觉了，而且这种可以「什么都不干的快乐」在前段时间感染新冠居家隔离两周之后，似乎也不那么吸引我了。不过见到家人们还是很开心的，和家人们一起包米粿，看着一张张熟悉的脸彼此聊天说笑，就觉得，只有家的温暖和亲情才能真正让人放松下来做自己。我真的很感恩自己拥有的这一切，我知道能够拥有这样的家庭就已经比很多人幸福了。我爱我的家人，我知道他们也爱我。虽然有时候还是会怀疑生命的意义，但是每每想到家人，我就觉得自己的生命是有意义的，他们给予了我很多的爱，而且我们也需要彼此。所以，我们应该好好珍惜自己的生命，这是每个人仅此一次的机会。</p><h4 id="1-月-20-日-我们家的过年"><a href="#1-月-20-日-我们家的过年" class="headerlink" title="1 月 20 日 - 我们家的过年"></a>1 月 20 日 - 我们家的过年</h4><p>今天是在家第一天，早上照例睡到很晚才起床，老姐给煮了饺子，想想也是挺不好意思的，姐姐都快生了还要让她给我做早饭。下午家里大扫除，我在边上负责帮忙搬搬东西、拖拖地。说实话家里还是挺乱的，不过平时家中卫生基本都是老妈搞，而老妈上班没有周末所以也不太有时间清理，所以大扫除一下还是有必要的，不过，这也是我们家每年过年的必备项目之一。每年过年最忙的应该是老妈，从大年二十几就开始准备，要做豆腐、包粽子、准备年货，还有两个保留节目是包米粿和做猪杂汤，每次做这两样吃食的时候，都是我们大家族聚会的时候，阿姨、舅舅一家都会过来帮忙，然后一起吃米粿、喝猪杂汤。等到大年二十九，该准备的都准备得差不多了，所以就搞一下大扫除，然后就是把一些需要提前准备的食材准备好。到大年三十这一天，老妈从早上就开始准备年夜饭，一直忙到下午两、三点，一桌丰盛的年夜饭才算完成了。等我们祭祖回来放完鞭炮之后，一家人开始吃年夜饭，几乎年年如此。最近两年唯一的不同在于，姐姐结婚了，而我还没有结婚，所以我成了他们的催婚对象。尽管如此，我还是觉得自己挺幸福的，能拥有这样的家人是我最大的幸运。我也不再奢望更多了，我唯一的希望是他们能健健康康，生活过得开心愉快就好了。虽然我知道他们也希望我能遇到一个合适的人，组建自己的家庭，但是我知道人生总是不可能总是顺顺利利、十全十美的，有的时候学会珍惜自己已经拥有的东西同样重要。</p><h4 id="1-月-21-日-除夕"><a href="#1-月-21-日-除夕" class="headerlink" title="1 月 21 日 - 除夕"></a>1 月 21 日 - 除夕</h4><p>今天除夕，这是第一次姐姐姐夫都在家的年夜饭，因为老姐怀孕快要生了，所以不能和姐夫回温州，不知道以后还有没有这样全家人一起吃年夜饭的机会。不过，越长大越觉得，其实年夜饭和普通日子的晚餐也没啥大的区别，无非就是菜多一点，吃的时间早一点，然后可能还会喝点酒。除此之外，内心没有了那种翘首以盼的期待感了。但是，最重要是能够和家人相聚在一起，毕竟一年就只有这一段时间，大家都没什么特别的事，只是为了相聚在一起。我觉得我是个不擅长表达自己的人，这一点可能也是随了家庭氛围的影响，我爸妈都是不喜欢也不会说漂亮话的人，但日常对我和姐姐的关心都体现在实际生活的方方面面。我觉得这样也很好。虽然有时候也会觉得自己是不是太不会来事了，假如自己可以变得更外向一些，在各种场合下都能说出一些得体的漂亮话该多好，这样别人开心自己也有可能得到更多的关注。但我天生就害怕受到关注，在人多的场合就容易感到紧张不自在，本能地会想要逃避，这也是为什么我不擅长经营任何「关系」的主要原因之一。新的一年，对自己最大的希望是能够更加自在地生活吧，无论是从表面上看还是在内心里，我都希望自己能活得更加自得，无论是不是一个人。</p><h4 id="1-月-22-日-持续力以及找到方向"><a href="#1-月-22-日-持续力以及找到方向" class="headerlink" title="1 月 22 日 - 持续力以及找到方向"></a>1 月 22 日 - 持续力以及找到方向</h4><p>大年初一，第一次睡到下午才起床，窗外天空阴沉沉的，远处不时飘来一阵阵烟花响声。昨晚凌晨 2 点多才睡下，早上很早又被爆竹声吵醒，所以即使睡到下午也还是感觉没睡醒。这个假期应该怎么度过呢？带了一本书回来，但是不太想看。有几部想看的剧，不过看了开头几集就兴趣寥寥了。有想买的游戏，但是想到还有好多没玩通关的游戏又觉得还是算了吧。漫无目的地逛论坛、逛社交网站，发现自己对大多数东西的兴趣都减弱了。一个人的确需要有更远大的目标才能觉得人生有意义吧。假设一个人不太缺钱，又有足够多的娱乐方式，欲望也不多，那么，即使他曾经有过梦想，也会在这种环境下变得越来越容易对现状感到满足，失去了追求实现梦想的动力。常听人说持续不断地行动是一个人最强大的武器，但是有多少人能够坚持下来呢？我们要么是太早放弃，要么就是在不停地更换目标。假如能够始终如一地坚持下来，多数人都会对自己所能取得的成就感到惊讶。我希望成为这样的人，一个持久的人。即使我的目标不算远大，也总好过没有方向。我相信自己能够持续努力下去，但眼下我最需要的是，找到一个合适的方向。</p><h4 id="1-月-23-日-三体和智慧生命"><a href="#1-月-23-日-三体和智慧生命" class="headerlink" title="1 月 23 日 - 三体和智慧生命"></a>1 月 23 日 - 三体和智慧生命</h4><p>看了几集高晓松解说的三体，我对开脑洞部分其实并没有太多的感觉，因为大多数三体中首创的概念都已经成为了我们生活中的一部分。唯一有点疑问的地方在于，人类这个物种真的那么不堪吗？回望人类的文明史，无论是亚洲还是欧洲又或者美洲，战争都在其中占了非常大的一部分，难道我们天生就像那些狩猎动物一样嗜血吗？我觉得最主要的原因是人类不断增长的欲望吧。大刘是个非常悲观的人，而我是个非常乐观的人。我对人性还是有信心的，我觉得只要拥有足够的知识和理性，我们可以和任何人合作，并且能够发展出更加繁荣和富足的文明，而不是为了眼前的资源斗得你死我活。宇宙对于人类来说是无限大的，资源也是无限多的，我们只是缺乏知识去开发和更好地利用它们。另外，当我们意识到现代生活应该更有目的性，我们有必要控制自己的欲望时，我们的生命就可以超越简单的生存了。这就涉及到第二个容易产生争议的话题了，那就是：人类的生命是否比其它物种的生命更宝贵？</p><p>虽然生命无价，但是我觉得人类的生命相比其它动植物，还是略高一筹的。因为人有理性，能思考，哪怕是最濒危的物种，其价值也是因为与人类的联系才获得的，是人类赋予了该物种超越其他物种的意义。比如，假设人类不是位于食物链顶端，而是有一种比智人更加智能的物种生活在地球上，那么人类就不可能存在，在几十万年前就被他们消灭了，就像尼安德特人一样。即使有一部分人类幸存下来，也只是会被他们当做比较聪明的猴子对待，用作奴隶或者圈养起来作为一种观赏物种。这样看来，人类的存在也是符合自然选择论的，我们为什么不愿意承认这一点呢？我们为什么要保护一种物种而放弃另外一种物种呢？为什么某种哺乳动物的灭绝比某种水草的灭绝更能引起人类的同情呢？假设复杂的生命才值得同情，那么把人类捧为万物之灵有什么不对呢？要不要为了保护几公顷濒危动物栖息地而让一个村庄里的所有村民搬家呢？凭什么要让穷人为富人们的环保主义买单呢？让穷人吃饱饭重要还是保护环境更重要？假设人类灭绝是对自然界的其他物种最有益的，我们人类要不要集体自杀？既然答案是否定的，那么我们就应该坚定地站在人类以及保护人类的幸福和理性这一边。</p><p>至于外星文明，我觉得只有当我们的科技水平接近时，才有可能发生交流。假设他们的科技碾压我们，那他们一开始就不会理睬我们，就像我们不会和蜗牛解释万有引力，或者特意跑到另一座城市只是为了踩死一只蚂蚁。宇宙如此广阔，而智慧生命却又如此罕见，即使两种文明水平差距非常大，对更发达的文明来说，至少也是一次观测的机会。即使因为技术爆炸的缘故，对方的科技有可能在短时间内远远超过我们，那么既然我们能观测到他们，他们也一定会在某个阶段观测到我们，因此，做朋友还是做敌人是我们自己的选择。所以，两种文明的接触一定是发生在彼此科技水平接近的基础之上的，而且已经成为了星际文明，也就是能够探索其他星系。基于此，既然对方能够发展出星际旅行的科技，那么，他们一定也能理解交换和合作的价值。而由于双方都是星际文明，在无法彻底毁灭另一方的情况下，直接掠夺显然是成本更高的做法，双方一定会选择试探性接触，然后尝试彼此合作、互通有无、交换科技成果等。除此之外，当一个文明成长为星际文明的时候，文明的内核也一定发生了变化，并且有可能发展出更高级的道德水准，不再会为了扩张而去掠夺资源，因为资源是无限的，在科技足够发达的情况下，也许连暗物质都可以作为能量源。到那时，我们不再依赖行星和恒星，文明的存在只是为了探索宇宙，探索不同的星系，探索生命存在的形式，发现更多的未知。其实人类此刻正准备跨入这个阶段了，只不过我们还需要先解决能源、生态环境危机、贫富差距等问题，而这还是要依赖科技的发展和进步。</p><h4 id="1-月-24-日-和父母相处"><a href="#1-月-24-日-和父母相处" class="headerlink" title="1 月 24 日 - 和父母相处"></a>1 月 24 日 - 和父母相处</h4><p>在家和父母沟通难免会有矛盾，不过好在我已经接纳了这样的状态，我知道年轻一代和父母相处总归会有矛盾，毕竟我们差了一辈。我的处理方式也非常简单，尽量避免有分歧的话题就好了。因为我知道我无法改变他们，他们也一定改变不了我，既然如此，那么就让我们在彼此都能接受的范围内沟通交流就好了，毕竟日常在一起生活的是他们两个人，我只是偶尔回来小住一段时间，即使有分歧也不会影响到我们各自的生活。除此之外，我觉得和爸妈相处最让人不太舒服的地方在于，他们总是喜欢用居高临下方式来沟通。在他们面前，我似乎永远都只能扮演一个照顾不好自己的小孩子的角色。尽管我们都知道事实不是这样，但他们还是忍不住想要劝导我。而每当我抗拒、不服从的时候，他们又会表现出无奈的样子。我不知道这样的相处模式是不是会一直持续下去，但是我觉得相比过去，他们已经改变了很多。其实不只是他们，我也在改变。随着年龄的增长，我们都会逐渐获得一些新的认知，从而改变自己与其他人的相处方式。希望我们都能活得更随性自在吧。</p><h4 id="1-月-25-日-任何游戏都能让人沉迷"><a href="#1-月-25-日-任何游戏都能让人沉迷" class="headerlink" title="1 月 25 日 - 任何游戏都能让人沉迷"></a>1 月 25 日 - 任何游戏都能让人沉迷</h4><p>我们为什么会沉迷某件事？通常是因为我们能够从中得到在其他地方得不到的东西，比如他人的崇拜、虚荣心、特殊感、自重感、优越感，有时候甚至仅仅是陪伴和被需要的感觉。因此，许多游戏的设计目的都是为了满足人的一部分的欲望，从而让人越来越喜欢玩，并且在其中得到远远大于现实生活中所能得到的快感。当我们在进行游戏时，通常会感觉不到时间的流逝，这是因为我们完全将注意力放在了游戏中，任何有吸引力且能快速得到反馈的事物，只要设计合理都能让一个人持续投入时间，比如回合制通关的游戏，而大多数电子游戏都包含某种类型的回合制元素在内。因此，任何一个电子游戏都足以让我们感到沉迷。说这些是想提醒自己，利用游戏对人的吸引力原则为自己设定目标，从而让自己能像玩游戏一样投入。只有<strong>玩对游戏</strong>，才能产出更加有利于自己和他人的价值。</p><h4 id="1-月-26-日-家人的「直白」和反躬自省"><a href="#1-月-26-日-家人的「直白」和反躬自省" class="headerlink" title="1 月 26 日 - 家人的「直白」和反躬自省"></a>1 月 26 日 - 家人的「直白」和反躬自省</h4><p>这几天在家和家人相处，再加上去舅舅阿姨家拜年，再一次体会到了「家」的含义。我平常自己一个人生活，和周围同事也不太来往，所以习惯了和他人保持距离的相处方式，但是家人亲戚们就非常不同，他们说话都太直白了，尤其是在酒后。而且非常明显的一点是，他们非常看重经济利益的划分。其实有些陈年旧事在我们面前都说了很多遍了，但是每年过年还是会拿出来再说一遍。这点其实我也不太在意，毕竟这才是真实的生活，我只是目前还没有体会过而已。今年第一次听到的让我心头一震的话是关于外公的，聚餐结束后听到舅舅劝说外公别再去种菜了，年纪大了再干这种体力活伤身体，而且如果他能多活几年，多拿几个月退休金不是蛮好。说真的，第一次听到这话我还是挺震惊的，没想到人老了连做点想做的事也不能完全由自己来决定了。我听了有点伤感，但仔细想想舅舅的话，其实也是有道理的，毕竟他也是在担心外公的身体会吃不消，虽然从情感上来说，这话让人听了有点伤心，像是更看重老人的退休金。其实这样的「小事」还有很多，比如我在过去的碎碎念中提到过的重男轻女的话题，还有拿亲属的子女和自己家的孩子比较，而且还是当着两个孩子的面。幸好我们都已经长大成人，有自己的分辨能力，要不然真不知道会对一个人的心理产生多大的影响，至少感到不舒服是肯定的。不过，谁能说他们就是错的呢？他们内心肯定是爱自己的家人的，尤其是为了自己的孩子。会说出这些让人不愉快的话，我觉得一部分原因是他们所受的教育和我们不同，以及周围的环境。我们不能太苛责他们。而且，谁能保证自己到了他们那个年龄，是不是也会说出、做出一些让晚辈感到尴尬、不舒服的事呢？毕竟我们的年龄差了一代，很多事情还没有亲身经历过，每个人在人生的不同阶段所关注的东西本来就会发生变化。我们能做的，也许只有多多反躬自省了吧。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原创性无法被替代</title>
      <link href="/2022-12/"/>
      <url>/2022-12/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/rEXUxVzJhuM" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>这个月对我来说还是比较特殊的，生活方面，第一次感染新冠，第一次居家隔离那么长时间，第一次有那么多的时间用于阅读，因此，对科技和生命有了更多的新想法，这点从碎碎念的内容中也可以看得出来。除此之外，诸如 ChapGPT 这样的新技术让我感受到，未来一定会有许多值得期待的新产品出现，未来的工作也会更多地要求一个人具备原创性，这是技术永远无法取代人的地方。但是，我们要如何提升自己的原创性呢？除了大量输入信息和刻意练习之外，很多时候需要的只是专注和耐心，等待大脑的神经链路在偶然间被打通，“天才想法”突然出现的那一刻。</p></blockquote><span id="more"></span><h4 id="12-月-1-日-寻找热爱的必要性"><a href="#12-月-1-日-寻找热爱的必要性" class="headerlink" title="12 月 1 日 - 寻找热爱的必要性"></a>12 月 1 日 - 寻找热爱的必要性</h4><p>除了缺乏目标之外，另一个困扰很多人的问题是：我们找不到自己的独特之处。在学校里，每个人都被要求学习成绩好、处理好人际关系、为集体争光，特立独行的人从来都不受欢迎；在职场里，每个人都是一个可以随时被替换的螺丝钉，我们的工作看似重要，有时候还要加班完成别人交给自己的紧急任务，但假如从明天起我们离开了自己的工作岗位，公司依旧会照常运行下去，因为没有一个人是不可替代的。所以，当从网上看到统计临终遗言给他人的建议中，出现频率最高的是「不要把工作看得太重要、多花时间陪伴家人和朋友」的时候，也能理解了。到头来，大多数人还是要从家庭和亲友那里得到最多的个人价值感。无论如何，我们的家人才是最需要我们的，对他们来说我们是不可替代的，而工作很难让我们有这样的感受，哪怕你的工作能力很强、成就很高也一样。既然如此，那这个问题还需要解决吗？我觉得还是需要的，而且这是大部分人一生都要不停问自己的问题，也就是找到自己的所爱之事。我们可能做着自己不怎么喜欢的工作，然后还会在内心催眠自己：这份工作收入不错，能让我维持一个还算体面的生活，我应该喜欢这份工作。我们很可能还挺擅长这份工作，觉得自己能够不费太多力气就能把这件事做得比其他人更好，所以自己应该继续把它做得更好。我觉得自己当下就处于这样的状态，但是内心知道其实我并不足够热爱它。假如用「没有报酬我也要继续做这件事」为标准，那么我显然不符合。那么，要如何才能寻找到热爱呢？</p><h4 id="12-月-2-日-相信热爱会到来"><a href="#12-月-2-日-相信热爱会到来" class="headerlink" title="12 月 2 日 - 相信热爱会到来"></a>12 月 2 日 - 相信热爱会到来</h4><p>继续昨天的话题，其实寻找热爱和做好当下的事并不冲突，就像保罗·格雷厄姆在他的<a href="http://www.paulgraham.com/love.html">那篇文章</a>中说的，从小就知道自己以后该做什么的人很少很少，绝大部分人都得不停地寻找，可能要到三、四十岁之后才能有足够的自由去做自己热爱的工作。我们当下要做的是，始终坚信那一天会到来。即使眼下做的事不是自己最喜欢的，它也一定会在某种程度上帮助自己到达彼岸。说回我的工作，的确，我擅长它也能把它做好，除此之外，非常幸运的一点是，这份工作所需要的技能可以非常容易地迁移到其它行业，因此，我基本不用担心找不到工作。有了这样的优势，我其实可以心态轻松地去尝试其它行业，接触任何自己感兴趣的领域，当然，前提是我有足够的空余时间。过去，我其实一直都有这样的时间和机会，但是基本都被我挥霍和浪费掉了。不过，抱怨没用，当下的我虽然不像过去那样有大把的空余时间，但至少从现在开始还是来得及的。其实任何时候都来得及，只要一个人愿意改变。首先要问自己的问题是，我最核心的价值观有哪些？我擅长什么？未来哪些行业能创造出最大的价值？找到了这些问题的答案，再找到一个能够把它们结合在一起的领域，这就是值得尝试的工作了。</p><h4 id="12-月-3-日-疫情对我的影响"><a href="#12-月-3-日-疫情对我的影响" class="headerlink" title="12 月 3 日 - 疫情对我的影响"></a>12 月 3 日 - 疫情对我的影响</h4><p>最近看到消息说有可能要放松疫情管控了，心里一开始有点激动，但是后来却觉得，其实即使放开了对我的生活也不会产生多大的影响，我已经非常习惯了现在的生活节奏。尽管此刻的我变得更加独立，与外界联系更少了，但是，我却觉得这样也挺好，获得平静也是我当下生活中的目标之一。疫情刚开始那会经常会想，等到疫情结束之后我要去旅游，而且要自己选择目的地、规划行程，然后背上背包就走。但是，经过了这两年的疫情后，我发现自己已经没有那么强烈的旅行愿望了。当我站在窗边望着窗外的一切甚至一度觉得有些茫然，我其实已经没什么好抱怨的了。总有人比你过得更加辛苦，我已经算是非常幸运的了，我很感激自己能够拥有现在的一切。不过，我心里也没有什么愧疚，虽然我在这段时期里，很多次地感到迷茫、颓丧、懊恼，把精力用于内耗，浪费了很多时间，但是，我觉得这是每个人都需要面对的挑战。每个人的一生中至少都会遇到一两次这样的特殊事件，由此才能成长。毫无疑问，在我未来的生命中还会出现比这更加严峻的挑战，但是经过这一次，我对自己开始有更多的信心了。我相信自己的韧性，相信自己能够抵抗任何形式的压力和孤独。我对人类的痛苦有了更深一层的了解，我知道我们本质上都是一样的。当你坚信自己是不能被打倒的时候，这时候你才开始变得不可战胜。</p><h4 id="12-月-4-日-牙科医生与杠杆"><a href="#12-月-4-日-牙科医生与杠杆" class="headerlink" title="12 月 4 日 - 牙科医生与杠杆"></a>12 月 4 日 - 牙科医生与杠杆</h4><p>今天去复查牙齿，先是预约后等了一个多小时，然后又花了差不多 2 个半小时才把整套流程全搞定。因为戴完了最后一副牙套，所以要先把牙齿上的附件磨掉，然后再去补上牙两边拐角处的楔状缺损，然后是口腔拍照、做保持器的牙模。虽然之前也复查了很多次，可是还是不习惯被人用各种各样的工具在自己嘴里捅来捅去。忽然意识到，看牙之所以贵，可能也是因为他们使用的工具多吧。牙医光是要学会使用这些工具可能就得花上挺长的一段时间了，再加上各种牙齿疾病相关的知识，怪不得一个普通的牙医也要学习那么久才能正式上岗。还有就是人工成本，光是给我做检查和拍照等，一共就得了 4 个牙医和助理，我这情况还算比较简单的，遇上复杂的病人可能还需要与有经验的牙医讨论，而且还需要和患者沟通。所以，别看他们人多，有时候可能真的忙不过来。我也大概能理解为什么每次明明预约了时间，过来后还是要排队等待至少半个小时，当牙医真的很忙。</p><p>我觉得相比牙医，当软件工程师性价比还是很高的，成为一名普通的开发工程师所需要花费的时间和努力，和牙医比起来肯定要少，但是收入并不见得比牙医低很多。而且软件工程师可选的路比牙医宽太多了，上限也更高。好的软件工程师可以选择加入创业公司，并且有可能因此实现财务自由，但是好的牙医顶多也就开个自己的私人诊所，也还是得出卖自己的时间获取收入，顶多客单价高一些，但是并不能像软件工程师那样运用杠杆的力量。当然，这也是因为行业性质的缘故，一份软件复制成一万份的成本几乎为零。就像 Naval 说的，能和<a href="https://www.navalmanack.com/almanack-of-naval-ravikant/find-a-position-of-leverage">代码杠杆</a>相匹配的低成本、准入门槛也很低的媒介，应该只有音乐、书籍、影视作品、播客这些了。所以，至少在目前看来，从事这些行业的人还是挺有优势的。</p><h4 id="12-月-5-日-好奇心与责任心"><a href="#12-月-5-日-好奇心与责任心" class="headerlink" title="12 月 5 日 - 好奇心与责任心"></a>12 月 5 日 - 好奇心与责任心</h4><p>我是个有好奇心的人吗？应该算是吧。但是，我有利用好这份好奇心吗？我用它解决了哪些问题？还是仅仅作为满足自己个人欲望的工具？有时候觉得自己就像是河上的一根圆木，只是在随波逐流而已，看似转过了很多的弯，既见过风浪，也能随着平静流淌的河水缓慢前进，但是，这始终无法改变我并没有主动选择前进方向的事实。一个人安静下来的时候，翻看时间日志也会感到茫然，虽然我每天都详细记录下了自己的时间分配，但是，我只是在记录而已，我对未来并没有太多的规划，就像 Phoebe 说的，别说 plan 了，我连个「pla」都没有。可能是自己最近工作太闲了吧，看了太多 Paul Graham, David Perell 等人的文章，还有听了一些播客，有了一种「我的能力没有得到很好的利用」的错觉。事实上，我就是一普通人，不出意外的话，能安稳度过这一生就已经是天大的福分了。所以，还是不要想太多，努力把每天都过得充实有意义就不错了。每天都有进步、反思自己、独立思考，照顾好自己和家人，做一个负责的人，以乐观积极的态度对待身边的每一个人，先做到这些再说吧。</p><h4 id="12-月-6-日-互联网与未来科技"><a href="#12-月-6-日-互联网与未来科技" class="headerlink" title="12 月 6 日 - 互联网与未来科技"></a>12 月 6 日 - 互联网与未来科技</h4><p>最近进入了一个空档期，工作上基本没有什么任务分配给我，只是在完善 app 内部的一些小细节。白天整理书签的时候，看了很多过去收藏的文章，有一些再看一遍还是挺有启发的，比如 <a href="https://zenhabits.net/retrain/">Leo Babauta</a>、<a href="https://stevepavlina.com/blog/2006/12/triage/">Steve Pavlina</a> 的文章。晚上洗澡的时候想到，成为一个职业编辑似乎也挺不错的，因为我还算比较喜欢文字，对一些新想法非常感兴趣，而且做编辑的话，也是一个传播好观念的机会，似乎挺有意义的。这可能也说明了我现在的工作并不能完全满足自己的好奇心吧。我还是喜欢一些能够激活自己的大脑，能够让自己兴奋起来的工作。想到人工智能、XR、区块链技术的未来，太空资源开发和太空物流，热核聚变技术，衰老控制和寿命延长技术等等就不得不让人畅想未来，哪怕这样的未来离我们还很遥远，但是总有一天会到来，就像互联网突然出现在我们生活中一样。互联网最大的功能是使得信息传播的成本大大降低，使得地球上的所有人都可以通过网络连接在一起。但是，我不喜欢现在互联网上的内容，因为大多数都是垃圾，<strong>并不能增进我们对彼此的了解，也不能让我们变得更聪明，只是增加了偏见以及浪费我们的时间</strong>。假如每个人都能利用好互联网，用它创造出一些有用的东西，传播智慧，这样的互联网才是更有意义的。</p><h4 id="12-月-7-日-对职业前景的担忧"><a href="#12-月-7-日-对职业前景的担忧" class="headerlink" title="12 月 7 日 - 对职业前景的担忧"></a>12 月 7 日 - 对职业前景的担忧</h4><p>此刻我内心最大的顾虑是什么？找不到自己热爱且可以从事一生的事业。目前看起来，编程依然是最优解，因为我已经积累了足够的经验。虽然实际编程的功底可能并不怎么样，但是至少知道该如何完成一个项目，也能解决一些实际的问题。另外，这也是一条值得探索的道路，有很多新方向可供选择。然而虽然已经入行 5 年多，但我自认为还是一个新手，无论是知识的广度和深度，都比不上很多科班出身参加工作两三年的人。这可能和我一开始选择的方向有关系吧，入了安卓的坑，这一方向虽然看似简单，但是知识繁杂，我也乱七八糟地学了一大堆不太相关的技术，然后逐渐发展到现在在做的 flutter 开发。目前来看，普通应用的功能都实现过了，但是还没有接触过大型项目，所以也不知道自己的实际开发能力到底处于什么样的水平，不过我自认为还是处于初级阶段。接下来要往哪个方向发展呢？继续做 flutter 看似是比较直接的选择，但是我有点怀疑这条路可能会让我的技术栈越走越偏。因为移动端说到底路还是挺窄的，相比后端和前端开发，工作机会要少很多。假如未来出现新的移动端平台，那么我现在所掌握的这些技术很有可能就全都用不上了。我知道这样的未来离我们还有一段距离，但是很难不让人担心。有时候也会觉得是自己太菜了才会有这样的担心，因为编程的基础都是相通的，等你彻底掌握了一种技术之后，迁移到其它平台其实是非常快的。所以，还是多一点耐心吧，把基础掌握好，然后只管钻研自己感兴趣的技术就可以了，要相信船到桥头自然直。</p><h4 id="12-月-8-日-从了解世界到感叹生命的伟大"><a href="#12-月-8-日-从了解世界到感叹生命的伟大" class="headerlink" title="12 月 8 日 - 从了解世界到感叹生命的伟大"></a>12 月 8 日 - 从了解世界到感叹生命的伟大</h4><p>我们活着的目的是什么？更多地了解这个世界应该是其中之一吧。读历史是为了了解过去，观察过去的人的生活和思维方式，从中得到经验教训。有时候我们还会放飞想象，试图描绘出未来的人们的生活，他们会遇到哪些挑战，然后又是如何解决它们的。我觉得作为人类的一员，最精彩的部分就在于我们不但能思考，并且还学会了使用科学的方式来研究万事万物。经过几千年的发展，我们的科学已经发展到不但能够了解我们自身的起源，而且还能够去尝试寻找宇宙的起点和终点。我们建造起高耸入云的建筑，制造出能够像太阳表面一样释放出巨大能量的化学反应，发射火箭到太阳系中的其它星球上，破解了基因物质的基本组成结构，也发明了能将任何一个人连接到地球上任何一个地方的互联网，人类的未来从来没有像现在这样充满光明过，甚至有人预言我们能够在这个世纪结束前攻克衰老和死亡。我们越来越多地扮演起过去人们创造出的一个「主宰万物、无所不能」的角色。但是，也有不少人开始对未来忧心忡忡，担心我们发明的新技术会失控，或者我们会因为过度消耗地球资源而走向毁灭。不过，我个人对未来还是保持着乐观态度的，我同意此刻的我们正站在一个技术奇点附近，但我相信它会把我们带向更加美好的未来。即使我们这一代人还看不到这样的未来，但是光是能够意识到这样的未来就在我们眼前，也不禁让我感叹人类智慧的神奇以及生命的伟大。</p><h4 id="12-月-9-日-人的瑕疵以及不断修炼"><a href="#12-月-9-日-人的瑕疵以及不断修炼" class="headerlink" title="12 月 9 日 - 人的瑕疵以及不断修炼"></a>12 月 9 日 - 人的瑕疵以及不断修炼</h4><p>时间和注意力才是一个人最稀缺的资源。可是，我有利用好它们吗？大部分人都很难毫不犹豫地说出肯定的回答，我想这也是为什么大部分人都只能是普通人，因为我们做不到全权控制自己的注意力，总是容易被琐事打扰而分心，总是败给懒惰和拖延，总是经不住诱惑去追逐一时的快感。除此之外，我们身上还有许多人类这个物种固有的「瑕疵」，比如贪婪、傲慢、易怒、嫉妒、好色、虚荣、过度关注自我等等，这些缺点哪怕是圣人都很难完全克服，更别说我们这种凡夫俗子了。所以，只能日常多多提醒自己，时刻注意观察脑海中的想法，克制自己的行为，不断地修炼，也许才能获得一点点进步。</p><h4 id="12-月-10-日-人的一生是个大包裹"><a href="#12-月-10-日-人的一生是个大包裹" class="headerlink" title="12 月 10 日 - 人的一生是个大包裹"></a>12 月 10 日 - 人的一生是个大包裹</h4><p>一个人开始变得无趣的征兆是什么？是逐渐对未知失去好奇，变得傲慢、自以为知晓一切。尽管我们的终局都是一样的，但是在还能呼吸的时候，去尽可能多地探索这个世界才是我们的主要目的。远方不一定意味着离开你居住的地方，去到一个你不曾去过的地方，也可以是你从书本上读到的人类历史、想象在宇宙中某处运行着的天体、一种你从未尝试过的看问题的新角度，等等。我们每个人都是第一次来到这个世界，虽然生命有长有短，但是我们可以决定使用何种方式度过它。假如把每个人的一生看作是一个大包裹，在包裹的底部以及束口处的内容都是差不多的，但是中间这一大截的空间，每个人都不相同。在离开这个世界之前，你打算用什么样的内容去填充它？</p><h4 id="12-月-11-日-最强大的科技是大脑"><a href="#12-月-11-日-最强大的科技是大脑" class="headerlink" title="12 月 11 日 - 最强大的科技是大脑"></a>12 月 11 日 - 最强大的科技是大脑</h4><p>以前觉得人类的躯体太脆弱了，要是能实现科幻片里那样的人造器官就好了。想象一下，如果能够拥有豹子的肌肉、老鹰的眼睛、大象的骨骼密度，该多好。但是，开始玩轮滑之后我才逐渐意识到，人类最强壮的器官其实是大脑。我们身体的其他器官虽然还不够完美，但是大脑能够训练它们，使它适应不同的环境。比如肌肉记忆，其实肌肉并没有记忆，只不过大脑一遍遍地发送指令给特定部位的肌肉，使得神经链路传递信息变得更快，于是当我们想要做出某个重复了无数遍的动作的时候，几乎不再需要花时间思考，肌肉就能帮我们「自动」完成该动作了。除此之外，当我们身体的某部分发生了不可逆的损伤之后，大脑也会迅速调整身体的其他器官，使我们能够快速适应新的环境。我觉得人类的科技在某种程度上也是这种适应性的延伸。遗憾的是，到目前为止，我们制造出的人造器官和义肢无论如何还是无法媲美人体的原生器官，这也是因为我们的大脑无法和这些人造设备有机地整合在一起。大脑不能训练它们，它们也不能根据大脑获得的信息调整自己、自我更新。所以，人体才是真正强大的「高科技」产品，前提是我们知道如何利用自己的大脑，通过训练，每个人都可以拥有像远动员一样的躯体，而对于绝大部分人来说，保护好自己的身体、不滥用它才是我们首要的任务。</p><h4 id="12-月-12-日-疫情三年得到了什么"><a href="#12-月-12-日-疫情三年得到了什么" class="headerlink" title="12 月 12 日 - 疫情三年得到了什么"></a>12 月 12 日 - 疫情三年得到了什么</h4><p>今天看了陈兴杰老师的一篇文章（<a href="https://mp.weixin.qq.com/s/JkgkR1C__5pdoIk28eyPlw">疫情三年，我们该反思什么</a>），激起了我的一些思考，不仅仅是对文章中提到的权力对公共生活的侵蚀产生的共鸣，更多的是反思自己的这三年到底得到了些什么。我觉得我的生活是从 18 年换工作之后开始改变的，到 19 年底的时候，自己差不多已经已经习惯了新的生活节奏。除了工作之外，和同事交流不多，也不和过去的朋友联系，过上了真正一个人独居的生活。很难说是我主动选择了这样的生活，可能和当时的环境也有关系吧。来到了一个陌生的区域，虽然和新同事住在一起，但是在我入职后，陆续离职了好多人，唯一留下来的一位性格比我还闷，而且我和他也没有太多共同话题，所以也不太玩得到一起。直到疫情开始之后，大家都进入了静音模式，我也开始花更多的时间向内探索。我曾经一度以为这样的生活只是我人生中的一个阶段而已，经过那段时间的独处和反思，才慢慢意识到，其实这样的生活方式可能才更适合我。一直到后来换工作、搬家，虽然来到新的环境，一开始也以为生活会发生一些变化，但是后来发现并没有。如果人的心态没有发生变化，那么改变环境又有什么用呢？所以，可能这就是我的天性吧，无论如何我都会回到一个人生活的状态。其实在大学里就有这样的迹象，只不过那时候没有独居的条件。哪怕是和舍友，我也只是维持着最低限度的交流，大学后半段我大部分的课余时间都在图书馆和自修室中度过，而且我也非常享受一个人的状态。但是，有时候也会自我怀疑，还是应该出门去多交几个朋友的吧，毕竟未来总有需要他人帮忙的时候，人与人之间不就是靠着互相帮助才能生存得更好吗？也许可以先试着展示出自己的价值，多帮助其他人，慢慢积累起信誉，一段时间之后自然就能筛选出值得交往的人了。</p><h4 id="12-月-13-日-假如不用进食"><a href="#12-月-13-日-假如不用进食" class="headerlink" title="12 月 13 日 - 假如不用进食"></a>12 月 13 日 - 假如不用进食</h4><p>最近开始尝试早睡早起，但是由于睡前吃了东西，所以总是睡得不太好，早上醒来老是觉得肚子胀气。想回到以前不吃晚饭只吃早中饭的模式，但是又有点考验意志力，因为自从开始玩轮滑之后，体力消耗有点大，晚上习惯性地会吃点东西，然后第二天不吃早饭，这算是我的新的断食方式吧。有时候在想，假如我们能够不用进食就好了。对我来说，吃饭其实是个特别麻烦的事，假如我们能够实现像科幻电影中一样，每天只需要喝一点营养物质就能给身体补充足够的能量，那该多好。想想看，这会节约多少时间。我们现在的生活是被每天的三顿或者两顿饭隔开的，假如我们不需要进食，那么就可以用这些多余的时间做更多的事。假如能够实现这种补充能量的方式，那么，也许我们就能放弃 8 小时工作制了。对大多数人来说，一天中真正有效的工作时间，可能不超过 4 小时，其它时间基本都是在无意识中度过的。哪怕工作制度不发生变化，如果可以将原本用于进食的时间做其它事情，比如运动和阅读，那对我来说也是个不错的选择。</p><h4 id="12-月-14-日-有钱人也不轻松"><a href="#12-月-14-日-有钱人也不轻松" class="headerlink" title="12 月 14 日 - 有钱人也不轻松"></a>12 月 14 日 - 有钱人也不轻松</h4><p>昨天玩轮滑的时候听了一期故事 FM 的播客，讲述者是一个组织五千万资产为门槛的相亲会的年轻创业者。虽然没听完，但是觉得挺有意思的。一是没想到财富都到这种程度的人，居然也会被爱情所累。换作是我，拥有这么多的财富，可能根本就不会在意有没有爱情或者婚姻，因为后半辈子基本无后顾无忧了，即使什么都不干也能过上一个普通中产的生活。其次是，没想到有钱人也还是会那么在意外界的看法，原以为有钱人思维方式会更加理性，但是主人公甚至都没有认真考察女友的脾气、性格和品德，就打算和她结婚了，这样的人是怎么获得那么多财富的呢？有可能是爱情让人盲目吧。不过，这也足以可见每个人都有自己的局限性。哪怕你的工作能力很强，某方面能力特别出众，也总归还是会有自己的短板。还有就是，有钱的确可以让人活得更加从容，但是这并不能让一个人生活得更加快乐。假如一个人有钱之后开始追求错误的东西，比如外界对自己的评价，那么他/她永远也不可能获得幸福。我觉得普通人相比富豪的一个优势是，更容易获得内心的平静。当然，除非你是超级富豪，像巴菲特那样，当然就可以不用管外界的声音，专注于做自己想做的事。但一般的富豪通常需要花更多的时间维护和各种人之间的关系，而且还得像主人公一样，小心避免掉入各种各样的陷阱，以及防范那些纯粹想利用自己的人。这样的生活其实也不轻松，但这就是做一个有钱人的代价吧。富二代是最轻松的，但前提是你是一个胸无大志的富二代。不然，但凡有一点继承家业、把家族事业发扬光大的想法，你都不可能过得太轻松。</p><h4 id="12-月-15-日-理解自己"><a href="#12-月-15-日-理解自己" class="headerlink" title="12 月 15 日 - 理解自己"></a>12 月 15 日 - 理解自己</h4><p>有时候觉得，我们真的有可能被他人理解吗？两个相爱的人真的能够心灵相通吗？又或者只是因为喜欢对方，所以觉得自己能够理解对方。阿兰·德波顿说过，爱的标志之一是愿意尝试理解对方的真实意图。这可能也是因为，没有一个人能够真正完全懂得我们内心的想法，所以，我们才需要花那么多时间做沟通，需要彼此试探，需要去揣测对方的心意。假如抛开这一切，假如我们没有和对方相处几百上千个小时，我们还能感到对方是「懂」自己的吗？我有时候甚至觉得我自己都不能理解自己，所以又怎么能要求另一个人能够懂我呢？我们大多数时光都花在了和自己相处上，哪怕是极度外向的社交达人，假如算上睡觉、等待和处理私事的时间的话，一天中至少也有一半的时间是和大脑中的自己度过的，我们是每天发生在我们身上的事件和接触到的所有信息的总和。当然，我们如何处理这些信息和事件也非常重要，再加上基因和经历这两个要素，才有了我们这一个个行走在这个美妙世界上的独一无二的个体。</p><h4 id="12-月-16-日-《重症监护室》的启发"><a href="#12-月-16-日-《重症监护室》的启发" class="headerlink" title="12 月 16 日 - 《重症监护室》的启发"></a>12 月 16 日 - 《重症监护室》的启发</h4><p>最近，在看完<em>重症监护室</em> 这本书之后，我的生活态度发生了从「我的生活好无趣」到「活着就有希望」的转变。健康的人很少注意到原来人体有时候是这么脆弱，假如运气不好，我们离死亡其实只有一步之遥，而这一步的距离意味着重症监护室里数位医护花费人类积累了几十年上百年的智慧和经验，最终换来的可能只是让你保持「活着」的状态。<strong>挺住意味着一切</strong>不是一句空话。很多时候，家人需要我们，相比人死去后给活着的人带来的数十年的痛苦（假如你还很年轻），他们往往会选择无论如何都要继续尝试活下去的机会。但是，健康的人真的能意识到健康的价值吗？虽然每次看了类似的书都会让人重新意识到健康的重要性，但是过了一段时间之后，假如在生活中遇到了一些困难，我又会重新变得消极悲观，而忘记了自己此刻拥有的这一切。所以，<strong>真正难做到的是知足常乐吧，人总是想要更多</strong>。虽然生命中有很多东西是不会变得更多的，比如时间以及年轻时旺盛的精力和无忧无虑的心态。不过，好在人只要开始意识到这一点，就有可能改变自己的生活。既然我意识到健康的重要性，那么我就应该把它转换成行动，用充足睡眠、健康饮食、运动等来改善自己的健康状况。也许暂时看不出效果，但是只要意识到积年累月之后，这些习惯会改变我的身体状态，那么我就要继续做下去。尽管无论如何也改变不了我们最终都要死去的结局，但是至少我们在可改变的部分做到了最好，假如有一天我们也进入了重症监护室，医生会感谢我们对自己身体的尊重。</p><h4 id="12-月-17-日-慕强的根本原因"><a href="#12-月-17-日-慕强的根本原因" class="headerlink" title="12 月 17 日 - 慕强的根本原因"></a>12 月 17 日 - 慕强的根本原因</h4><p>人都有慕强的心态，不仅仅是外在上的强大，比如体格、能力、谈吐等方面，还有心理上的强大，比如自信和气度，比如百折不挠的韧劲，面对不利局面时的从容，回击他人嘲讽时的睿智，被羞辱时的自我控制力，哪怕是被鄙视也能够保持克制，等情绪冷静下来之后再分析他人的动机并自我反思。无论是外在还是内在的强大，都是一个人生命力的体现，意味着他/她能够不断学习、自我更新，因此不但能在这个复杂的世界中生存下来，也更有可能获得更多的资源。这大概是人人都慕强的根本原因吧。我们每个人都追求成为这样的人，但是很少有人能够达到这样的状态，这也是为什么我们每个人都需要不断修炼的原因。我们日常生活中做的每件事，无论是锻炼身体、工作、社交，还是阅读、学习、娱乐，其实都是在进行这种练习，尽管很多时候我们都意识不到。</p><h4 id="12-月-18-日-接纳焦虑和不完美"><a href="#12-月-18-日-接纳焦虑和不完美" class="headerlink" title="12 月 18 日 - 接纳焦虑和不完美"></a>12 月 18 日 - 接纳焦虑和不完美</h4><p>有时候早上起来心里总是感到一阵焦虑，明明知道今天没什么重要的事情会发生，也没有未完成的任务，但还是会感到一阵心烦，这可是一个美好的周末早晨啊。到底是谁在散播焦虑？我觉得其实我们每个人都有责任。我们都是一边制造焦虑，一边消耗这些焦虑。人为什么一定要最大限度地利用好自己的时间？我们为什么不能享受浪费时间的乐趣？低俗、性欲、猎奇、无聊，这些本来就是人性的一部分，为什么要异化它们，把它们看作是应该改变的东西？所以，可能还是因为没做到全然地自我接纳吧。不但如此，我还发现自己很容易有看不惯的人和事，有时候甚至在内心鄙视身边的人。其实大家都只是普通人而已，做不到超然一般的存在。接纳彼此都不完美、都有缺点，也许就不会有那么多的不舒服了吧。有一句话是我一直在重复的，那就是<strong>要相信每个人都在尽力而为</strong>。既然如此，我们就应该允许自己和他人做一些放松甚至是放纵的事，包括开一些无关大雅的玩笑，挥霍时间在自己喜欢的事情上，有一些不健康的爱好，为一些小事斗嘴，等等。有时候当我们展现出自己身上的这些缺点之后，才让我们更像一个可爱的人，不然的话，我们和科幻片里那些批量制造的机器人有什么区别呢？</p><h4 id="12-月-19-日-当下和未来"><a href="#12-月-19-日-当下和未来" class="headerlink" title="12 月 19 日 - 当下和未来"></a>12 月 19 日 - 当下和未来</h4><p>又快要到年底了，每到这个时候心里都会一阵开心，一阵焦虑。不过，从最近几年开始，好像焦虑更多一些。一方面是因为家人的催婚催恋，另一方面，我心里总觉得和家人的距离正在慢慢变远。可能是因为我自己身上发生的变化吧，因为家人们其实一直都没变。有时候觉得自己应该认真听一听他们的话，也许我的确要认真考虑一下找个人安定下来，过日子。但是，我很难说服自己。我喜欢自己现在的状态，可以自由自在地做自己想做的事，不用迁就另一个人，也不用担心自己的计划会影响到别人。虽然我也相信承担责任会让一个人变得更靠谱，但是在找到一个值得自己信任同时也愿意信任自己的人之前，我不想太早放弃眼下宝贵的自由。一直以来，我都觉得自己是个比较自私的人，但是只要没有影响到其他人，那别人就无权指责。家人对我很包容，因为他们爱我，我当然也想尽可能地满足他们的愿望，但是我毕竟只是个普通人，无法兼顾好所有。我也有缺陷，不过，我会努力让自己变得更好，不是为了满足其他人的愿望，只是为我自己。我想要开发出自己所有的潜能，做自己擅长且热爱的事，为世界创造价值。生活在这个时代的我们已经不再需要任何「主义」，「解放全人类」成了一句口号，真正需要解放的是我们顽固、贪图享乐、不愿思考的头脑。放下理想主义和偏见，行动起来，养成更多好习惯，这才是我们应该做的事。</p><h4 id="12-月-20-日-做无意义的事"><a href="#12-月-20-日-做无意义的事" class="headerlink" title="12 月 20 日 - 做无意义的事"></a>12 月 20 日 - 做无意义的事</h4><p>有时候总会觉得自己做的事毫无意义，因为相比那些很酷的人正在做的事，我所做的工作真的微不足道。我也知道自己不应该这样去横向比较，而是应该和过去的自己比。最起码我的工作能够帮助到一部分人，虽然这帮助非常有限。退一万步，至少我能通过这份工作养活自己，而不是当一只寄生虫，成为他人的负担。尽管如此，每个人内心都会希望自己所做的工作是有意义的。不仅仅是在微观层面上，我们希望自己能够帮助到自己的家人、朋友，然后是素不相识的陌生人，和自己生活在同一个国家的人，甚至是全人类。假如我们的工作能够影响到更多的人，让更多人生活得更加幸福和快乐，拓展人类的认知，发明新技术，或者新的工作流程，使得人们的工作效率得以提升，让人们得以去探索遥远、未知的新世界，假如能够做出这些贡献，一定会让人感到无比满足和自豪。但是，绝大多数时候，生活在这个星球上的绝大多数人，都只是一个普通人而已，做着一份普通的工作。假如运气不错，能够凭借技术和经验得到认可，生活得不错，把家人照顾好，就算很好了。哪怕是做买卖开公司，想要做大做强，也需要在各种条件都具备的情况下，承担许许多多的风险。至于像牛顿、达尔文，或者是福特、沃尔顿、乔布斯这样的人，在人类历史上也很少见，只有在正确的时间出现在正确的地点才能看到他们的身影。那么，这是不是意味着我们就不用努力了呢？我觉得我们努力的目的可以更加崇高一些。既然人类已经度过了繁衍求生的阶段，我们也基本不用担心自己的生存，那么我们就可以更加大胆一点，去尝试那些看上去不那么安全的道路，只要是有利于自己和他人的事，即使需要承担一点风险，那也值得去做。假如暂时没有方向，那就安心积累知识和经验，探索各种未知的事物，哪怕暂时没有结果也没关系，至少可以满足自己的兴趣和好奇心。</p><h4 id="12-月-21-日-《钢炼》书评"><a href="#12-月-21-日-《钢炼》书评" class="headerlink" title="12 月 21 日 - 《钢炼》书评"></a>12 月 21 日 - 《钢炼》书评</h4><p>这两天病毒肆虐，大家都居家办公了，由于我手头没什么要紧的工作，所以大部分时间都用来看书了。昨天看完了<em>钢铁是怎样炼成的</em> 这本「革命」小说，我还记得初中写作文的时候，这本书里的主人公保尔·柯察金经常成为大家的写作素材，似乎他是革命力量中一种毅力的象征。整本书看完之后，我发现我对革命生活并没有什么特殊的印象，反而对保尔小时候的经历，以及他进入疗养院之后发生的事情更感兴趣，尤其是结尾叙述他失明之后转而开始追求艺术创作的过程，真的很让人感动。有时候觉得生活在和平年代的我们容易感到无聊，可能也是因为一切都太一成不变了吧。主人公一生中经历了沙皇被推翻、卫国战争、内战，并且还参与了革命以及政权稳定之后共青团的组织工作。他的生命轨迹从一个默默无闻的穷苦小子，发展成为一名战士、肃反委员、团委书记，虽然最终身患绝症失去了工作能力，但是并不影响他继续发光发热，他在短短几年的生命中经历了别人一生都体验不到的事情。当然，这中间有极端环境给人肉体上造成的痛苦，也有高压带来的心理上的极度考验，这也是为什么主人公会如此年轻身体上却出现那么多的问题。虽说他把自己的生命献给了革命事业，但是我觉得更多的是因为他内心生出了一种信仰，他深深地相信自己所做的事已经超越了个人利益，并且要帮助更多人获得像在他身上发生的转变一样的机会，他信任他的工作伙伴和自己的党。我觉得能成为这样的人也是幸福的。我们常常会在工作中找不到意义感，也是因为面临的考验不够强烈，缺乏足够的动力去突破自我，所以，自然也就做不到像保尔一样，充满热情地去创造了。</p><h4 id="12-月-22-日-接受平凡的生活以及多安慰他人"><a href="#12-月-22-日-接受平凡的生活以及多安慰他人" class="headerlink" title="12 月 22 日 - 接受平凡的生活以及多安慰他人"></a>12 月 22 日 - 接受平凡的生活以及多安慰他人</h4><p>早上起来状态不是太好，总觉得自己应该利用这段时间做点什么，而不是白白浪费掉宝贵的时间。站在落地窗前发了一会儿呆，窗外阳光很好，只不过风有点大，地上的树叶随着风卷起的一个个小漩涡在肆意飞舞。突然看见右下角升起来一堆肥皂泡，随着气流不断上升，有的飘到很高的地方，然后又突然下降，最后落到小区中间的池塘里。不一会儿，看到从楼下右边门廊那里跑出一个小小孩儿，最多一岁出头，一会追逐飘到地上的肥皂泡，一会追逐不断移动的树叶漩涡，小孩的爸爸也从门廊里走了出来，被小孩的萌态逗笑了，站在楼上的我也笑了。他手里拿着肥皂泡枪，继续朝天空中射了几下，小孩嘴里兴奋地喊叫着，又开始追逐新的大泡泡。有时候觉得，普通人的日常生活就是这样平平淡淡的吧，越是想要做些什么让这一天值得被记住，反而会破坏当下的好心情。没有目标的确是件让人头疼的事，但是只要能过好当下的每一天，努力把自己该做的事情做好，该放松的时候好好放松，也就没什么好焦虑的了。我们都那么普通，大多数时候都只能改变自己，除了家人，对周围的其他人影响非常有限。既然如此，那就好好把自己的生活过好，然后尽可能多地给他人生活带去一点帮助和安慰，这样就很好了。</p><h4 id="12-月-23-日-家庭为什么重要"><a href="#12-月-23-日-家庭为什么重要" class="headerlink" title="12 月 23 日 - 家庭为什么重要"></a>12 月 23 日 - 家庭为什么重要</h4><p>下午去看了阿凡达：水之道，这部的剧情基本是围绕着家庭关系展开的，没想到哪怕是外星部落，一个智慧种族想要繁衍生存下去，依旧离不开家庭这个纽带。家庭是组成一个稳定的社会结构必不可少的部分，这也是为什么人类这个物种能够不断发展壮大，发明了语言和各种各样复杂的工具，将知识不断积累传递下来，最终主宰整个星球的其他生命，甚至还有机会去探索太空中的其他星球。诺兰在星际穿越中暗示爱才是人类的超能力，而形成和表达爱的最常见的场所是你出生的家庭，我们天生爱我们的父母以及兄弟姐妹。爱其实是一种最高级的合作能力，我们通过感受彼此的感受，帮助对方获得成长，也接纳他人对我们的帮助；我们彼此依赖，并且建立了牢不可破的信任关系；在极端情况下，我们甚至愿意为了对方牺牲自己的生命。因此，我们是在家庭中学会如何爱一个人、如何与他人互动和合作、如何处理矛盾与冲突的。除此之外，为了生活得更好，我们还离不开与家庭之外的其他人进行合作，组成部落并且选出最强壮、最有智慧的族长就是形式之一，然后我们还会发明新概念和新工具，加强我们和陌生人之间的合作。正因如此，我们每个人才得以做自己最擅长的事并且获得最大的回报，这就是现代社会分工合作的基础。而无论如何，家庭依旧是其中最重要的一环，组成人类社会的结构中离不开家庭，哪怕再过一万年，不出意外的话，家庭依旧会是组成我们社会关系中的最小单位。</p><h4 id="12-月-24-日-感染新冠后的感受"><a href="#12-月-24-日-感染新冠后的感受" class="headerlink" title="12 月 24 日 - 感染新冠后的感受"></a>12 月 24 日 - 感染新冠后的感受</h4><p>这应该是我经历过的最难熬的一个 Christmas Eve 了。昨晚半夜 2 点多发高烧醒来，然后就睡不着了，熬到早上感觉烧退了一些，然后起床出门买药。回来吃了药之后就在椅子里躺尸了，全身酸痛加一阵阵发冷，甚至忍不住想要发抖。睡了大概两个小时，烧退了，但是脑袋还是晕乎乎的，躺着难受，坐着也难受，于是尝试看美剧转移大脑的注意力，没想到真的奏效了，也有可能是药效起作用了。到傍晚的时候，感觉整个人恢复得差不多了，于是吃了点东西，还换衣服下楼玩了一小时轮滑。晚上洗澡的时候在想，我印象中过去应该只有一次有过这么难受的发烧，就是 18 年的<a href="https://ajiew.github.io/talk-about-change/">那次。</a>没法确定哪一次症状更严重，因为回忆的时候总是会觉得最近这次更难熬，我们总是偏向更鲜活的记忆。不过，可以肯定的，我不想再有这样的体验了。生病实在是太熬人了。而且最让人蛋疼的地方在于，国内同时有几种奥米克戎变种，也不确定自己感染的是 BA.1/BA.2 还是 BA.5，再加上没有 mRNA 疫苗和帕罗韦德，普通人很有可能会多次感染。不过目前好像也没什么好的解决办法，只有做好个人防护了，也就是戴好口罩、多洗手、多通风，少去人多的地方。每个人都要先照顾好自己，保证自己身体健康，然后才有可能去关心其他人。</p><h4 id="12-月-25-日-圣诞夜碎碎念"><a href="#12-月-25-日-圣诞夜碎碎念" class="headerlink" title="12 月 25 日 - 圣诞夜碎碎念"></a>12 月 25 日 - 圣诞夜碎碎念</h4><p>今天在房间待了一天，什么都没干，但感觉时间过得特别快。其实这几天都是相同的感觉，可能是一直待在家的缘故吧。今天感觉比昨天好多了，虽然早上起来还是有点发烧，但是吃了药之后也就恢复正常了，只不过没什么食欲。今晚是圣诞夜，坐在电脑前好久但却不知道该写什么，也没有什么特别想要送出的祝福，可能是因为过了那个年纪了吧。大多数人本来就没有过圣诞的习惯，学生时代是因为赶时髦才过，成年之后，除了情侣和小布尔乔亚们，其实大多数人其实都把这一天当做一个普通的日子。不过，对我来说，这一天还是有特殊意义的，因为在我心里它代表着家的温暖和幸福。可能是因为受到看过比较多的欧美电影和美剧的影响吧，我总觉得西方的圣诞节才是我喜欢的家庭聚会模式：一起装饰屋子，一起准备晚餐，彼此交换礼物，看孩子们表演节目等等。中式的节日传统虽然也差不太多，但是总感觉少了点什么，好像是少了一种平等的氛围吧。当然，这可能只是我个人的感觉，毕竟我只体验过一个家庭的氛围。但说回来，我还是很爱我的家人的，虽然他们表达爱的方式和我理想中的不同，但是他们始终是我的家人，而且我在这方面也并没有做得特别好。珍惜自己所拥有的一切吧。</p><h4 id="12-月-26-日-健康为何重要"><a href="#12-月-26-日-健康为何重要" class="headerlink" title="12 月 26 日 - 健康为何重要"></a>12 月 26 日 - 健康为何重要</h4><p>这两天进入了 goblin mode，在体验了新冠之后，我突然理解了为什么它能成为今年的年度热词。在家差不多一周了，虽然从上周六才开始出现症状，但是身体越是出现问题，我越是发现自己很难控制自己的注意力，经常什么都没干一个下午就过去了，有时候身体并没有不舒服，只是纯粹想要发泄什么都不做、挥霍时间的欲望。我不知道这背后有什么样的心理运行机制，但是我知道如果持续这样下去一段时间，人很容易就会变得消极沮丧，甚至变得厌世。我想要恢复正常的作息，但是身体不允许。缺乏睡眠、缺乏运动等导致人的注意力容易不集中，于是自控能力也会下降；自控力下降之后，进一步容易做出糟糕的决定，比如吃一些不健康的食物，容易情绪化等等，这样就会进一步让情况更加失控，甚至导致原本我们擅长的事情也出现了更多的差错，于是就走上了一个恶性循环。曾经看到过，大多数表现不佳的人其实不是因为他们不够聪明或者努力，而是他们缺乏一个好的基础条件，而其中一个重要的条件就是健康的身体。一个人身体健康，人际关系和谐，也没有严重的财务问题，他才有可能有足够的专注力去做好某一件事，并且取得成功。假如我们能够创造出这样的条件，那么才有可能最大限度地发挥自己的潜力。</p><h4 id="12-月-27-日-关注健康、不要生病"><a href="#12-月-27-日-关注健康、不要生病" class="headerlink" title="12 月 27 日 - 关注健康、不要生病"></a>12 月 27 日 - 关注健康、不要生病</h4><p>最近一周应该是我在这一年里过得最糟糕的一周吧，也再次让我意识到健康的重要性，哪怕只是一个毒性已经减弱了很多倍的新冠都能把一个原本健康的人折腾成这样，更不要说那些更严重的疾病甚至是罕见病了。等熬过这一段时间后，我会更加珍惜自己的身体，绝对不再滥用它。像上周那样还没完全康复就去运动的行为，此刻在我看来就非常弱智。</p><p>下午又体验了一次发烧，原本以为是体内残留的病毒，所以就没吃退烧药，想让免疫系统发挥作用。但是，苦熬了两个小时才逐渐意识到，再这么烧下去可能病毒和我的器官都得 game over 了，所以果断吃了退烧药。当时的经历过程是，首先全身感到一阵阵发冷，甚至会起鸡皮疙瘩，哪怕身上穿了厚厚的衣服。关节骨骼处感到微微发胀，肌肉开始酸痛，体温也逐渐升高。然后大脑像被灌了水泥一样，昏昏沉沉的，整个人一点都不想动，哪怕感到膀胱非常涨也不想站起来去上厕所。那种不舒服、难受光是此刻回忆起来都会觉得太折磨了，记录下它们是想提醒自己：认真对待自己的身体，最好不要生病，哪怕生病了也要照顾好自己，该吃药就及时吃药，把病养好了再去关心其它事。</p><h4 id="12-月-28-日-自由需要束缚"><a href="#12-月-28-日-自由需要束缚" class="headerlink" title="12 月 28 日 - 自由需要束缚"></a>12 月 28 日 - 自由需要束缚</h4><p>看了连岳的一篇文章<a href="https://mp.weixin.qq.com/s/l6qp6K-WAhoomx0e2gQAAw">自由很贵</a>，突然觉得自己和文中写信的人有点像，同样有点不安分，同样内心有很多想法，但实际行动上却畏手畏脚，缺乏说做就做的勇气，所以才需要写信咨询他人。不同之处在于，我选择了早早背上房贷，让自己那颗不安分的心提前安定下来。虽然有时候还是会有一些不靠谱的想法冒出来，但是我知道最终它们都只能停留在脑海的一角，然后逐渐消失。理性告诉我，自由是风筝，责任是线；没有了线，风筝就是飘荡在天空中的一张碎纸片儿。就像连岳说的，我们要学会拒绝这种低级的自由，学会给自己添加束缚。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约定</title>
      <link href="/2022-11/"/>
      <url>/2022-11/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/65CNtap6bow" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>这个月尝试了一些新技术，浪费了一些时间在关注新闻热点上，也重新开始审视过去习以为常的东西。人内心总是同时拥有两股力量，一股把我们推向前方，使我们能够守时、履约，做一个负责任的人，而另一股力量总是喜欢时不时地出来捣乱，给我们制造一些麻烦，让我们熬夜看剧、刷手机忘了时间、吃得太多、做出冲动的决定，等等。我们总是想要拥有控制后一种力量的能力，但往往发现这种控制是徒劳的，因为我们生来如此。越是控制它，这股力量反弹得越是厉害。唯一的办法是学会和它积极相处，讨好它，和它谈判，告诉它只要不在重要的时刻出来作妖，就能每隔一段时间享受到不被束缚的自由。就在我写下这段文字的时候，我能感觉到它已经迫不及待地想要出来了，因为它知道这段文字敲完发布之后就意味着它即将成为意识的主人。但是，正是因为有了这样的约定，我才能完成大部分自己想要完成的工作。</p></blockquote><span id="more"></span><h4 id="11-月-1-日-观念一致和低欲望"><a href="#11-月-1-日-观念一致和低欲望" class="headerlink" title="11 月 1 日 - 观念一致和低欲望"></a>11 月 1 日 - 观念一致和低欲望</h4><p>过去，我的观念是门当户对没那么重要，现在想法有点改变了。越来越觉得两个人如果要相处得融洽舒服，其实背景最好一致，因为只有这样理解彼此的概率才更高。我是农村长大的，我的很多习惯（比如消费习惯）就和某些城市中产家庭长大的小孩完全不一样。我比较喜欢省钱，也很少乱花钱，尤其是学会记账和做预算之后，哪怕是特别想买的东西，也会思考再三、各种比价后才下单，基本不会冲动消费。还有就是我对生活品质要求不高，衣服穿得舒服就行，从不追求大牌，以前穿几十块的 T 裇、100 多的外套，现在稍微好点了，也不过是迪卡侬和优衣库，而且我从来不觉得这有什么问题。不过好在我的工作环境比较包容，穿土一点也没啥关系，而且我觉得太精致的生活也不适合我这样的人。哪怕收入提高了，我过去的习惯也很难改变，节约已经深深地刻在了我的骨子里，有的时候根本就注意不到。况且和爸妈相比，我的省钱水平就差得远多了。而且一想到他们，我就更加不愿意乱花钱了。有时候觉得自己正在往吝啬的方向上发展，但是转念一想，欲望低是件好事呀，这意味着我能够控制自己的欲望，不会被物欲支配，能够延迟满足感，把更多的选择权留给了未来。而且随着经济实力的提高，人的底气也会越来越足。单身也不那么可怕了，哪怕一直单身下去，只要能够继续过我想过的生活，也就足够了。</p><h4 id="11-月-2-日-做意识的主人"><a href="#11-月-2-日-做意识的主人" class="headerlink" title="11 月 2 日 - 做意识的主人"></a>11 月 2 日 - 做意识的主人</h4><p>我们为什么做不到像学龄前儿童那样快乐？他们同样没有什么目标，生活还都是被别人安排好的，基本没什么自主性可言，但是他们可以非常快乐，哪怕只是放学后喂喂鱼，看着水上游泳的鸭子，也能很开心。我觉得最主要的原因是他们能够做到<strong>足够活在当下</strong>。哪怕是做自己每天都在重复做的事情，他们也能非常忘我，并且享受其中，而我们则很难做到这一点，总是容易心神不定，做着手头的事情心里却在想别的事。比如，再过几天要交房租了；要不要找上周认识的女孩聊天，该聊些什么；要想个什么理由拒绝参加公司的团建活动；愿望清单里的某样物品降价了，要不要下单；等等。当我们总是被打断，总是无法全情投入到当下的时候，每件事情都就不是纯粹的了，而是和另一件事相关的，于是我们就失去了单纯享受那件事物的乐趣。尤其是对于像我这样容易想得太多的人来说，很多东西，哪怕是一件美好的事物，都会因为我的过度思考而毁掉。所以，我总是闷闷不乐，因为负面、消极、内耗，让我容易失去享受一件事物的能力。这事有解吗？其实也有，那就是训练自己的注意力，让自己的思维集中在当下的事物上。<strong>冥想</strong>，感受内心积极正面的能量，感受任何事物中的美好一面，意识到他人的付出，<strong>学会感恩</strong>。所谓的活在当下，不是说要放纵我们自己，而是要将注意力放在当下这一刻，有意识地活着，而不是被不受控制的思绪牵引到其它地方。做当下这一刻的主人。</p><h4 id="11-月-3-日-如何摆脱孤独"><a href="#11-月-3-日-如何摆脱孤独" class="headerlink" title="11 月 3 日 - 如何摆脱孤独"></a>11 月 3 日 - 如何摆脱孤独</h4><p>昨晚看了一个讲<a href="https://www.youtube.com/watch?v=n3Xv_g3g-mA">孤独</a>的视频，突然意识到孤独其实只是人的一种心理状态。有段时间我常常感到孤独，但是最近似乎很少出现了，尽管我的社交生活并没有发生任何改变，只不过我找到了能够让我沉浸其中的事。所以，关键在于如何调整自己的心态吧。视频中说了「孤独是一种非常主观的个人体验」，而且也和一个人的社交技巧无关，也和财富水平、社会地位、名誉、美貌、讨人喜欢的性格无关。即使你拥有了很多很多，依旧无法阻止你感到孤独，这是一种人类生理上的设计缺陷。尤其是到了现代社会之后，随着交通工具的进步，人们可以更加容易的打破地理的隔阂，离开自己的出生地和原有的社群，去不同的地方接受教育、工作和生活，我们不断离开原本熟悉的圈子，加入新的部分或者全部由陌生人组成的团体。因此，当我们没有很好地融入新群体，与原有圈子的联系也越来越少时，我们就更加容易感到孤独。改变这种状态的办法是，意识到自己陷入了孤独。很多时候，当我们陷入长期的孤独状态，我们会变得暴躁易怒，容易分辨不出他人的真实情绪和意图，偏向于将他人的行为解读为有敌意的，于是我们变得更加封闭自己，并且陷入更加孤独的境地。所以，改变的第一步是把心态变得更加积极和开放， 接受他人对你的邀请，认真倾听他人并给予反馈，主动分享自己的故事。当你开始习惯性分享和接纳他人进入你的世界之后，你会发现其实孤独并不那么可怕，而且你会慢慢意识到自己的真实价值。这个世界如此广阔，而我们所拥有的时间，和过去的亿万年和未来更多的亿万年相比，只不过是一瞬间，好好珍惜自己的这一生，争取<strong>活得有趣、精彩、快乐</strong>才是我们应该追求的事。</p><h4 id="11-月-4-日-远方真的那么值得向往吗？"><a href="#11-月-4-日-远方真的那么值得向往吗？" class="headerlink" title="11 月 4 日 - 远方真的那么值得向往吗？"></a>11 月 4 日 - 远方真的那么值得向往吗？</h4><p>最近越来越意识到，其实远方的生活并不是我所向往的，真正的让人满足的生活只会存在与当下。为什么这么说？因为当我们从一个孩童成长为一个二十几岁的青年的时候，我们的人生观、世界观、价值观差不多已经固定下来了，我们的生活习惯、行为模式等也深深地受到了家庭关系、教育、社会制度和风俗等的影响，如果突然跳转到一个与我们所接触过的完全不同的社会，我们很难立马适应，哪怕是我们向往的生活，依旧会有感到种种不便的地方。虽然我并没有离开过我生长的环境，但是此刻的我认为，不一定要离开你的出生地或者你熟悉的环境，才能去感受另一种生活。现代生活最好也是最坏的发明之一是发达的网络媒体，如果利用好它们，我们可以用非常低的成本去体验在另一个国家的生活。我现在发现，当下的生活就是最好的，而且我也非常珍惜我所拥有的一切，我的家人，我独立生活的空间，我的工作和我的同事。生活本来就是琐碎而平淡的，但是，我相信一个人的态度和对待事物的方式才是决定他的生活质量的最重要的因素。学会感恩，学会注意到细节处的美好，学会享受当下，这些才是一个人获得平静和幸福的关键。</p><h4 id="11-月-5-日-我想要的和父母想要的"><a href="#11-月-5-日-我想要的和父母想要的" class="headerlink" title="11 月 5 日 - 我想要的和父母想要的"></a>11 月 5 日 - 我想要的和父母想要的</h4><p>有时候看着家人为自己的找女朋友的事操心，我心里是又郁闷又有点心酸，因为我知道他们是因为关心我、爱我才这样，正是因为他们是家人，所以才会来问我，哪怕有时候会让人觉得有点不舒服，但其实他们并没有恶意。我在想，我要用什么样的方式才能让他们能够理解自己呢？我知道人生有很多重要的选择，时机一旦错过可能就不会再出现了。但是，我也不想因为害怕错过最佳时机而做出自己不喜欢的选择，我觉得人还是要听从自己的内心的。有些事情 30 岁能做，40 岁也能做，在我的观念里恋爱、结婚也在这一范围内，所以，我并不着急。但是家人们并不这样觉得。他们希望你和大家一样，什么样的年龄做什么样的事，你落后了就说明你有问题。我有时候也在想，我身上到底有什么问题呢？想来想去，我觉得我工作认真负责，同事和老板也非常认可。虽然没什么朋友，但是熟悉我的人大多数都觉得我还是挺好相处的，只是话有点少，但是这并不影响我的生活。我有我自己的爱好，我喜欢电影、音乐、阅读，最近还爱上了轮滑，而且我觉得我现在的生活很好，我也非常感激我拥有的这一切，我觉得我不需要更多的东西了。也许这样的想法有点自私，但是，我觉得人还是应该自私一点，为自己而活。只要没有侵犯到他人，而且也做好了所有的结果都由自己来承担的准备，那就没问题。</p><p>可能我还是太年轻了吧，还没有遇到父母生病、养老需要人照顾，失业后没有收入，自己身体不舒服需要人照顾等等这样的需要另一个人搭把手的时刻。但是啊，生活本就没那么容易。两个人的生活也会产生许多羁绊，而不仅仅是外人眼里看到的那些幸福时刻。我选择独身，选择一个人面对这一切，但是我也拥有了平静的生活，而这正是当下的我需要的，也是我喜欢的生活。要怎样才能让他们理解我呢？</p><h4 id="11-月-6-日-西蒙和善美"><a href="#11-月-6-日-西蒙和善美" class="headerlink" title="11 月 6 日 - 西蒙和善美"></a>11 月 6 日 - 西蒙和善美</h4><p>昨晚熬夜看 YouTube，是我偶然发现的一对在意大利生活的情侣，<a href="https://www.youtube.com/channel/UCisni19FjShzFkL_ZRj1FdQ">西蒙</a>和<a href="https://www.youtube.com/channel/UCeT92x1vIa3UeJlcXRv_OGw">善美</a>。看他俩的频道，感觉他们的生活特别有趣，我经常看着看着就笑出了声，这点当然主要是因为主人公是东北人，口才特别好，而且也特别幽默。女主长得特别漂亮大方，他们一家人的关系也非常和谐。我也逐渐意识到，其实两个人在一起生活，免不了要和对方的家人打交道，除非你们两个人完全独立在一起生活。况且无论如何，父母始终会在我们的生活中占据非常重要的位置，无论你是男人还是女人。另外，我也意识到，其实我是个非常「独」的人，我本身就不喜欢和人打交道，也许和熟悉的人还好，但是在陌生人面前，我真的很难快速和他们打成一片。看到主人公和女主的家人和朋友相处地这么自然又融洽，我就觉得，这实在是太厉害了，而且还是在异国他乡，说着和自己的母语完全不同的语言。越想越觉得，太牛了。这得多爱一个人才能做出这样勇敢的决定啊。然而我还是母胎 solo，平时不太敢和女生说话，碰见漂亮的女生就更容易紧张了，也不知道该聊啥。明明知道自己这样的性格真的非常容易吃亏，但是又不想改变，因为一个人生活比较平静，也比较有安全感。但是，有时候还是会觉得，如果有个人陪伴的话，可能会不那么孤单？一个人很难改变自己的性格，但是可以尝试下改变自己思考和做事的方式，比如意识到其实我们并没有那么不同，以及变得更加积极主动。这样一点点行动之后，也许就会看到不一样的结果。</p><h4 id="11-月-7-日-避免无意识"><a href="#11-月-7-日-避免无意识" class="headerlink" title="11 月 7 日 - 避免无意识"></a>11 月 7 日 - 避免无意识</h4><p>晚上又去江边练轮滑，最近开始练交叉倒滑以及交叉步，感觉有点难度，但是也享受其中。虽然现在天气已经降温很多，但还是可以玩到一身是汗。中间休息的时候，望着街对面的居民楼发呆，上方是一轮超大超亮的月亮，而且周围景观灯都没开，所以显得月亮更亮了，街上有牵着手遛狗的年轻人，有一左一右牵着爸爸妈妈的小孩子，也有从我的视野中一瞬间闪过的骑行的人，还有独自缓缓散步的老人。有那么一刻，内心感到一阵孤独。但是转念一想又觉得，其实无论你和他人拥有多么深厚的关系，我们始终都还是会感到孤独的。无论如何，我们有一天都将孤独地离开这个世界。有时候想想，人生中的经历对我们来说的确非常重要。尽管我接受这平凡而又普通的生活，而且我也认为每个人都应该做好自己该做的事，包括生活中的琐事。除此之外，我们也有一些值得回忆的时刻，但每一个普通的日子也同样重要，因为正是这些日子的对比，才让那些特殊时刻显得更加珍贵。唯一需要注意的是，不要让这些平凡的日子在无意识中溜走，多问问自己：我今天干了些什么？我要怎么做才能让这一天更值得被记住？还有就是更多地和自我对话。感受当下，有意识地注意到这一刻自己脑海中的想法。哪怕仅仅是描述自己看到的东西以及此刻内心的感受，也会训练我们的心智，让其变得更加敏感，从而更能捕捉到那些平凡事物中所蕴含着的美。</p><h4 id="11-月-8-日-什么是爱"><a href="#11-月-8-日-什么是爱" class="headerlink" title="11 月 8 日 - 什么是爱"></a>11 月 8 日 - 什么是爱</h4><p>怎样才算是爱上一个人呢？经常想起她、在一起的时候想要逗对方笑，想让她一直开心，这些都算是吧。但是，爱似乎没有这么简单，因为喜欢上一个人的时候也会做出这些表现。有人说爱一个人意味着，即使你自己此刻并不开心，却依旧愿意去逗对方开心。如果按照这样的标准，我似乎从来都没有爱过任何一个人，可能是因为我天生就比较自私吧。另外，如果要把锅甩给原生家庭的话，我可以这么说：在我的原生家庭中，我很少看到父亲对母亲示爱的举动，在这种环境的影响下，我一直到现在都还没有学会如何去爱一个人。当然，这只是个玩笑而已，毕竟都是成年人了，不能把自己身上的问题全都赖在外部环境上。不过，不可否认的是，多多少少还是受到了一些影响。那么，我要怎么做才能改变这种「以自我为中心，同时又害怕表达内心的真实想法」的现状呢？</p><h4 id="11-月-9-日-如何对待害羞"><a href="#11-月-9-日-如何对待害羞" class="headerlink" title="11 月 9 日 - 如何对待害羞"></a>11 月 9 日 - 如何对待害羞</h4><p>昨天说到要学会表达爱，其实除此之外，我身上还有一个容易害羞的问题。想了想，解决这个问题其实也没那么复杂，害羞说到底只是一个人的特质而已。当我们感到害羞的时候，通常会有哪些表现？我一般会感到紧张、脸红，如果特别紧张的话，还会变得呼吸急促，然后满头大汗。感到害羞的时候通常没有什么预先的征兆，有时候是和一个陌生人对视了一眼，然后就突然感到一阵害羞。能预感到自己会害羞的时候，通常是在知道自己需要在公共场合发言的时候，比如站会轮流发言，上台演讲，年会上表演节目，去到一些在我眼里高大上的场所，等等。害羞是因为不自信吗？有些时候好像是的，比如当我遇到一个特别好看的女生的时候，我会特别容易感到害羞。此时，我的内心活动是：哎呀，对方长得真好看，像我这样的人肯定配不上她，我连喜欢她的想法都不该有。但是，假如我能转变一下思维方式，把对方当成一个普通人，那么，我就会明白，其实每个人都会喜欢这种被他人关注、被喜欢的感觉，所以即使对方发现你在看她也没必要感到尴尬，因为她可能早就已经习惯了。就像 Rubin 说的，美是一件事实，没必要添加其它更复杂的东西进去。即使你的内心产生了一些不那么纯粹的欲望，这也不代表你就是一个肮脏的人，这说明你只是一个正常的普通人而已。还有就是，不要把害羞当成是一件不好的事，而是要把它看成是自己的特点，虽然这个特点会让你自己感到不舒服。另外，我还有一个奇葩的观点，我觉得这也是一种让别人感到自己受到重视、对他人有特殊意义的方式，虽然这种「方式」有点奇妙，看起来像是在折磨那个人自己。</p><h4 id="11-月-10-日-不断更新信念系统"><a href="#11-月-10-日-不断更新信念系统" class="headerlink" title="11 月 10 日 - 不断更新信念系统"></a>11 月 10 日 - 不断更新信念系统</h4><p>一个人的信念系统，很大程度上会受到周围环境的影响。举个例子，抖音刚火起来的时候，由于我周围接触到的信息包括网友给我的反馈是：抖音是一个低俗的应用，上面没有任何有质量的内容，所有的视频都只是为了迎合大众和吸引眼球。由于我接触到的一直是这样的评价，所以我的偏见也越来越根深蒂固，一直到现在，抖音都已经火遍全世界了，我甚至都还没有注册过抖音账号，虽然我常常在其他平台上看到很多来自抖音或者 TikTok 的视频。这就是环境对人的影响。对于有的人来说，抖音就是一个消遣娱乐、打发时间的 app，而且现在上面也有很多有趣的视频博主在分享自己的生活和见识，但是一个人一旦在内心形成了偏见，就很难公正地看待一件事物。再比如酒精，每个人都知道酒精对人的身体是有坏处的，而且也有很多科学证据证明这种负面影响，但还是有很多人喜欢喝酒。难道是他们比较笨吗？听不懂专家们的解释？显然不是，是因为他们拥有不同的信念系统。那么，既然喝酒有这么多坏处，这是不是代表我们必须滴酒不沾呢？也不是，因为我们活着的目标不是竭尽所能活到 100 岁，而是尽可能多地享受自己的人生。这意味着我们有时候也可以做一些不那么健康的事情，而且对于人生整体来说，其实并不算什么。有时候，过分教条主义的人也是因为从小被灌输了一种必须时刻保持自律的观念。</p><p>我希望自己的信念系统能够一直更新下去，虽然此刻的我已经习惯了很多东西，但是每次看到一个信念被改变，虽然一开始并不舒服，但是过后看起来，其实是在成长。保持谦卑，保持更新。</p><h4 id="11-月-11-日-向安迪学习"><a href="#11-月-11-日-向安迪学习" class="headerlink" title="11 月 11 日 - 向安迪学习"></a>11 月 11 日 - 向安迪学习</h4><p>昨晚重新看了一遍肖申克的救赎，再次感叹，人活着还是要有点梦想的，哪怕是在监狱这种残酷的生存环境之下，一丝丝希望也会让一个人焕发出新生。虽然这只是一部虚构的作品，但是它能激励那么多人，我觉得也是有道理的。每当生活中遇到困难的时候，想起安迪，我就觉得自己的那点问题根本不算什么。一个人在那种情境之下都能生存下来，并且找到逃脱的办法，那我们这些比他幸运得多的人，又有什么理由去抱怨和摆烂呢？人只要还能够呼吸，还能正常行动和思考，那他就拥有自由。最怕的是变成老布那样，一辈子生活在高墙内，等到有一天能够离开了，却发现自己竟然无法适应高墙外的生活。所以，既然眼下的自己还有能力去改变自己和自己的生活，那就努力去尝试一下吧，即使结果不尽如人意，至少可以让未来的自己感到心安。</p><h4 id="11-月-12-日-知道自己想要什么"><a href="#11-月-12-日-知道自己想要什么" class="headerlink" title="11 月 12 日 - 知道自己想要什么"></a>11 月 12 日 - 知道自己想要什么</h4><p>越来越觉得，知道自己想要什么是非常重要的一件事，这样你就不会轻易被别人三言两语就带跑偏了。虽然现代社会看起来非常宽容平和，各色人等以及价值观都有容身之处，但是我觉得对于什么是成功的定义还是比较狭隘的。财富，学识，人脉，见识，谈吐，这些当然都很重要，但是真正重要的是活得健康和快乐。虽然每个人嘴上都这么说，但还是有无数的人，为了钱、权力、名誉等东西而放弃了它们。当然，这也无可厚非，因为这些东西的确都是值得追求的，它们能够满足我们的其它欲望，比如购买我们想要的东西，获得他人的尊重，感到被需要、活得有价值，等等。但是，我觉得非常重要的一点是，不要为了这些东西而放弃了自己的天赋，放弃了那些对我们的生命来说更重要的东西。对我来说，这样的「东西」是探索内心，探索世界，去做自己真正想做的事。虽然这听起来有点奢侈，因为大多数人都只是做一份自己并不喜欢也不讨厌的工作。但是，当一天的工作结束之后，哪怕再忙，我们都应该留出一点时间给自己，问问自己：我到底想要什么？眼下的生活是我想要的吗？</p><h4 id="11-月-13-日-周末刷街感悟：后生可畏"><a href="#11-月-13-日-周末刷街感悟：后生可畏" class="headerlink" title="11 月 13 日 - 周末刷街感悟：后生可畏"></a>11 月 13 日 - 周末刷街感悟：后生可畏</h4><p>周末下午照例去江边刷街，风有点大，加上天空中飘着毛毛细雨，体感温度其实是有点冷的。不过，还是坚持刷到过了复兴大桥到达闸站河，才停下休息。周围基本没有人，偶尔会有一个跑步的人经过，很多人都会跑到这里的跑道终点然后就往回跑。江面的波浪不停拍打着岸边的礁石，我望着江面以及江对岸的城市天际线，大口大口地喘着气，心里却感到特别平静，而且有种自己来到了一个陌生的城市的感觉，可能是因为我从来没在这个地方停下来过吧。回去的路上依旧没什么人，天空中下着的毛毛细雨偶尔会变成细小的雨滴，我的眼镜被打湿后呈现出毛玻璃的效果，通过这种视角看江边的景色也挺有趣的。不过我怕雨会越下越大，所以也没怎么停下来过，一路加速向前。等过了复兴大桥之后，雨又变成了毛毛细雨，我的蹆也差不多快蹬废了，只能放慢速度。忽然注意到了江边护栏上的壁画，好像去年的时候就有了，不过我一直没怎么认真观摩过。主题是庆祝第十九届亚运会，而且全是小孩子画的水彩画的风格，我猜可能是来自附近小学的低年级学生画的，因为有的真的画得非常萌，只有小孩子才能画得出来这种风格。有的还会写上一些祝福语，当我看到有一幅画边上写的是「快乐也是人生的意义」，不禁笑了出来，看来现在的小孩子还都挺有思想的。然后突然意识到一个问题，不知道他们这一代人成长起来之后会变成什么样？他们这一代人不但从小衣食无忧，得到非常多的关注以及父母长辈们的爱，而且也有兴趣和资源去发掘自己的好奇心，未来他们所能做的事、所能达到的成就，可能是我们这代人很难想象的。真是后生可畏啊。哪怕不去比较，仅仅是看着他们，我觉得像我这样的「老人」也应该继续努力学习下去。</p><h4 id="11-月-14-日-取悦他人以及保持真实"><a href="#11-月-14-日-取悦他人以及保持真实" class="headerlink" title="11 月 14 日 - 取悦他人以及保持真实"></a>11 月 14 日 - 取悦他人以及保持真实</h4><p>我发现让自己很难放下戒备的一个原因是，每当我发现自己在为他人做一些善意的事，或者说一些好听的话的时候，我总会觉得自己是在取悦别人。这可能说明我说的话以及我做的事并不是完全发自内心的。不过，长时间看 Rubin 的视频的好处是，我会经常问自己，我有没有在表达真实的自我。过去的我已经太过习惯于隐藏自己的真实想法，以至于当我想要改变的时候，我发现最佳的做法是逃避那些需要我表明态度的场合。也许暂时性的逃避也是一种让自己走向改变的方法，但是长期来看，这并不是一个好的策略。所以，我还是应该问问自己，我到底想要成为什么样的人。每个人最需要取悦的人只有自己，但是，这和取悦他人并不冲突。因为有时候我们只是在表达自己内心的想法，当他人感到我们所表达的是自己内心真实的想法之后，也能感到一种善意，并且也会回报我们的善意。如果每个人都这样做，这个世界一定会变得更加美好。这也是每个人都想要追求的最理想的状态吧。保持真实，保持谦卑。心怀善意，坚持做正确的事。</p><h4 id="11-月-15-日-学会感恩以及你选择的生活"><a href="#11-月-15-日-学会感恩以及你选择的生活" class="headerlink" title="11 月 15 日 - 学会感恩以及你选择的生活"></a>11 月 15 日 - 学会感恩以及你选择的生活</h4><p>我希望自己始终记得的一点是：我是个非常幸运的人，我已经拥有了很多东西，我需要学会珍惜它们。不管你愿不愿意承不承认，能够拥有一个自己不讨厌的工作，做自己喜欢做的事情，每天都有一点自己的时间，能够维持好自己的财务平衡，身体健康，家人幸福，这就已经是天赐的福报了，其他的，我真的不敢再要求更多了。我需要做的是，继续努力工作、学习下去，继续按照自己的想法去生活，探索自己的内心，探索周边的世界，去了解自己感兴趣的一切。假如能够保持这种状态下去一直到老，那我就非常满足了。其实都不用去那些更为穷困的地区，每当我看到那些生活不如自己的人，我都会在心里觉得有些过意不去，因为毕竟他们也非常努力，但是却并没有过上更好的生活。有时候会觉得这种心态不对，我有什么资格去怜悯他人？可能在有的人眼中，我的生活才是惨不忍睹，但我同样也不需要他们的关怀和照料。我的生活完完全全是我自己选择的，我努力的目的虽然是为了更好的生活，但是，我也享受这一过程。如果突然让我过上一种无比富足的生活，我反而会感到不安，会在心里问自己：我配吗？所以，关键在于把更多的注意力放在自己身上，让自己的行动和思维方式保持一致。</p><h4 id="11-月-16-日-相信一切会好"><a href="#11-月-16-日-相信一切会好" class="headerlink" title="11 月 16 日 - 相信一切会好"></a>11 月 16 日 - 相信一切会好</h4><p>今天早上很早就醒了，可能是昨晚吃了夜宵的缘故，肚子有点胀气。醒了之后也没再睡着，在床上翻来覆去地胡思乱想，想到最近舅妈给的「29 岁」红包，想到周末回家又会被爸妈问起的那些问题，心里还是觉得有些不太愉快。我知道这是我自己的问题，因为家人们也都只是在关心我而已，但是心里还是会有些抵触这样的关心。说到底，我终究才是自己人生的主人，只有我真正了解我自己，知道自己需要的是什么。当然，我也接受他人的建议，但是，他们始终无法替代我做决定。想明白这一点之后，心里就轻松多了。既然这样，那么我就得为自己负责。至于他人的幸福，我觉得我个人能力有限，也许只能尽到自己应尽的责任。但是，人生还很长，很多事情没必要太早盖棺定论，有时候走一步看一步也许才是最佳的选择。无论如何，我爱我的家人，我喜欢我现在的生活，也感恩自己拥有的一切，这是毋庸置疑的。另一方面，我也还会继续追求成为更好的自己，追求更好的生活，以及寻找生命的意义。未来会怎样我不知道，但是我对未知保持开放的心态，也相信一切都会越来越好。</p><h4 id="11-月-17-日-学会肯定自己"><a href="#11-月-17-日-学会肯定自己" class="headerlink" title="11 月 17 日 - 学会肯定自己"></a>11 月 17 日 - 学会肯定自己</h4><p>我常常告诉自己，我已经很好了，要<a href="https://mp.weixin.qq.com/s/H3EAq_y01tkQHCVrfjnBxQ">学会肯定自己</a>，但是有时候还是容易苛责自己。最明显的地方在于，我常常在想，假如我的个子不是这么矮就好了。但是啊，没有人是完美的，假如我的身高达到自己的期望之后，我可能又会嫌弃自己长得不够帅，家境不够好等等。说到底，还是没有完全接纳自己，还有就是学会珍惜自己已经拥有的。人有的时候真的需要学会夸奖自己，而不是一味地苛责自己。虽然我个子不高，但是至少身体健康。虽然我不够聪明，但是我至少还知道勤能补拙。虽然我不善言谈，但是我能够保持长时间的专注。虽然我家境一般，但是我和家人之间的相处和睦有爱。虽然我的工作和收入在同行中只是普通水平，但是我至少能让我维持不错的生活，也有时间做自己想做的事。虽然很多东西我都没有，但是我对我所拥有的已经感到十分满意。不过，还是要继续努力，不是为了获得更多的东西，而是为了更完整地体验生命，寻找自己生命的意义，更智慧地去生活。</p><h4 id="11-月-18-日-多谈论爱"><a href="#11-月-18-日-多谈论爱" class="headerlink" title="11 月 18 日 - 多谈论爱"></a>11 月 18 日 - 多谈论爱</h4><p>我觉得自己身上一个很大的问题是，明明非常想要但是偏偏要装做不要。没错，我说的是爱情。以前总觉得男人谈爱啊情啊的比较 low，但是这其实也是人的基本诉求，所以没什么好觉得不好意思谈的。我觉得抛开生理上的部分不说，我更在乎精神上的爱。过去的人忙于生存，加上风俗礼教的影响，根本就没有谈论爱情的机会。但是，生活在现代的我们就相对自由得多了，虽然长辈们依旧会念叨，但是在大部分情况下，选择恋爱和结婚的对象已经是我们每个人自己的事了。这当然是好的一面，但是，有时候人会忘记去利用好当下的这种优势。另外，既然我们有选择他人的权力，自然也就需要面对被选择的压力。所以，在任何情况下，最好的做法是不断提高自己的价值，让自己更值得被爱。爱虽然和个人价值无关，但是为了吸引到你爱的人，为了给彼此创造出更好的生活，这种自我提高就是非常必要的了，无关男女，也无关年龄。为了你爱的人，你自然而然地就拥有了动力，让自己变得更好。说得好像爱一个人好像是一件很苦的事。当你享受两个人的相处时光，当你看到对方开心的样子时，那种发自内心的喜悦是真实的，而爱一个人不过如此。</p><h4 id="11-月-19-日-朗读者影评"><a href="#11-月-19-日-朗读者影评" class="headerlink" title="11 月 19 日 - 朗读者影评"></a>11 月 19 日 - 朗读者影评</h4><p>昨晚重新看了一遍电影朗读者，心里总有种说不出的感觉。汉娜有罪吗？从不同的角度来看可能会有不同的结果。我不想再谈论战争和种族屠杀，如果我是被害者及其家人，我当然觉得她有罪，而如果她不是守卫，这样一个会被小说、诗歌感动到流泪的人，看到 300 人被大火围困，我觉得她可能不会见死不救。然而现实不是假设，她做了很多「正派人」都不愿意面对的事，即使在她眼里那只是一份工作，即使她只是在执行命令，那也无法洗清她的罪名。她始终是共犯之一，哪怕是在那个所有人都在做着疯狂事情的时期。最让人觉得唏嘘的是她的性格，要强到为了守护自己是文盲的秘密而选择背负不实罪名。</p><p>同样让人感叹的是她和米夏的关系。米夏一开始迷恋的是她的身体，后来当然也发展出爱情，再然后是知道真相后的同情，也许还有一点点不愿意承认自己对她的感情，因为汉娜无论如何都是罪犯，而自己即将成为法官。当米夏开始往狱中的汉娜寄送朗读录音带的时候，我觉得他可能也是想要延续过去那段最诚挚的感情吧，而且他知道她也需要它们。</p><p>汉娜出狱前的自杀自我看来也是挺合理的，因为她的性格不曾改变，依旧是无比要强，甚至有点好面子，而且她一定也不愿意变成米夏的累赘。但是，我不喜欢米夏对汉娜的诘问，因为那段台词差不多可以翻译成：你是否感到忏悔？我觉得这样的结尾让这部片子多了政治正确的味道，他要是真的在乎这个也不会一直往狱中寄录音带了。他对她其实一直都还有感情。但是，汉娜对米夏呢？她爱过他吗？我觉得是有的，结尾当看到米夏来探望她的时候的眼中的喜悦，以及误以为米夏问起有没有想起他们之间的过去的时候的神情，尤其是当米夏起身离开的时候，因为性格要强所以她只是淡淡地说了句照顾好自己，而米夏也只是说了句告别的话没有任何多余的表示，她眼中流露出的失望和落寞。</p><p>米夏内心其实一直非常纠结，从作为法学院学生看汉娜的审判的时候，到探监时候的中途离开，他其实不知道该如何面对心中的这份感情。他爱她，但是这爱明显是不合时宜的，年龄和身份上的差距，还有对于她所做过的事的芥蒂。汉娜的死对他俩来说可能是最好的结局吧。所以，当他带着自己女儿来到她的墓地的时候，差不多也意味着他已经能够面对这段感情了。</p><p>人年轻时候的经历到底会多大程度上影响一个人呢？我们不知道汉娜年轻时候经历了些什么，也不知道她为什么会选择应征党卫军的这份工作，假如她当初没有选择这份工作，后来的人生又会是什么样的呢？她可能会过着相夫教子甚至是子孙绕膝的生活吧。那样也就不会中年时独居并遇见 15 岁的米夏了，后来的一切也都不会发生。而米夏呢？假如他当初选择出庭当证人，说出汉娜其实不识字的真相，汉娜也就不会在狱中度过这 20 年了。反过来，如果这一切都没有发生，汉娜也不可能学会阅读。</p><p>所以，人生哪，总是充满了各种各样的巧合。我们不知道自己当初为什么会做出那样的选择，也不知道某一段经历会对自己产生什么样的影响。唯一可以确定的是，能够始终陪伴我们的，只有我们自己。所以，不要太依赖于某个人。即使再爱一个人，最好也把这份爱当成你自己的事。没有期望，也就不会有失望。而爱一个人，不一定要参与那个人的生活，有时候只是远远地看着那个人，知道他/她过得好，就足够了。</p><h4 id="11-月-20-日-如何度过自己生命中的最后时光"><a href="#11-月-20-日-如何度过自己生命中的最后时光" class="headerlink" title="11 月 20 日 - 如何度过自己生命中的最后时光"></a>11 月 20 日 - 如何度过自己生命中的最后时光</h4><p>我会选择如何度过自己生命中的最后一段时期呢？会这么问是因为早上看了<a href="https://www.youtube.com/watch?v=Ih59SiVF0Ps">一个视频</a>，讲的是一个不知身份的老人在爱尔兰的海边小镇结束了自己的生命。没有人知道他是谁，即使是在科技如此发达的现在。他使用伪造的身份入住当地旅馆，并且销毁了所有能表明自己身份的物品，在到达小镇的第三天晚上从一个海滩上走入海潮中结束了自己的一生。第二天被发现后，警察们也束手无策。最后通过尸检发现，原来他得了癌症，而且是晚期。他也因此成为了被网友们讨论的众多不明身份死亡的人中的一个。有人猜测他是不想连累到自己的家人，所以选择不积极治疗，而是找个没人认识他的地方结束自己的生命。也有人说他不像是普通人，从他隐藏身份的手段来看，有可能曾经当过特工，在发现自己得病之后，选择以这种不暴露自己身份的方式快速了断一生。但是，无论如何，我觉得他的做法都值得思考，我们到底应该如何面对自己生命中的最后时刻？</p><p>虽然看过<a href="https://book.douban.com/subject/26576861/">最好的告别</a>，也经历过亲人的离世，但是我其实很少思考死亡。可能是因为我还太年轻了吧，死亡对我来说真的太遥远了，很难把它和自己当下的生活联系起来。我曾经有段时间经历过骨折，感受过行动不便给生活带来的麻烦，所以更加觉得躺在病床上迎接自己的死亡真的是件无法想象的事情。如果有得选的话，我可能也会选择 Peter 的方式结束自己的生命。去到一个没人认识自己的地方，有好的风景和美食，选个自己喜欢的沙滩，然后，在某个夜晚，在月亮升起来之后，周围没有任何其他人，在海浪声和风声中，走向潮水，迎接死亡。最好在海水灌入肺部之前心脏病发作，这样就不用经历太多的痛苦。我会希望后人如何评价自己呢？老实说，我希望没人能够记得我——我来过这个世界，虽然什么也没有留下，但是我度过了一个完整而丰富的人生。</p><p>看起来这是个非常模糊的目标，完全以个人感受为主导，但是这就是我目前最真实的愿望。去爱，去感受，去体验自己没做过的事，哪怕会失望、后悔也没关系。人生就是这样，你不去冒险，不去尝试，不去体会失败的感觉，就永远也得不到成长。想做什么就去做好了。</p><h4 id="11-月-21-日-独居动物"><a href="#11-月-21-日-独居动物" class="headerlink" title="11 月 21 日 - 独居动物"></a>11 月 21 日 - 独居动物</h4><p>最近有个顿悟，这个世界上，有人是群居动物，有人是独居动物，而我属于后者。虽然过去在碎碎念中反复提到人是社交动物，我们只有在和他人相处的过程中才能感到自身的价值，才能有归属感。我也不止一次说过要下定决心改变自己的性格，变得更外向，掌握更多社交技巧，通过表达自己和他人建立起连接。但是，此刻的我想法又发生了变化。我觉得我们不应该逼自己去做自己不愿意做的事，违反一个人的天性的结果可能会让一个人失去自己的特质。我本性就不喜欢和人交流，也不喜欢闲聊，让我和一个没有太多共同点的人聊天简直就是在用刑。如果说是为了社交的话，但其实我并不需要太多社交，我可以一个人呆在房间一个礼拜也不感到无聊，我之所以喜欢我现在的工作也是因为我可以一整天不说话。我没有亲密好友，也根本不需要，因为我一个人就可以满足自己的所有需求。那么，亲密关系呢？曾经有段时间很想拥有一段亲密关系，但是现在想通了，对于像我这样喜欢和他人维持一定距离的人来说，想要遇到一个和自己差不多的人，可能性极低。此刻的我已经快要放弃这样的念头了，只能走一步看一步了，不会太刻意地去寻找，但是也不会完全放弃希望。那么，我为什么要改变自己呢？我一个人生活、娱乐也能过得很好，完全不需要依赖其他人。这一点当然要感谢现代科技，因为没有外卖员和快递小哥，我的生活可能会变得复杂很多。所以，那就维持这样的生活下去吧，同时也要保持好内心的平静。我这是在给自己心理按摩吗？可能吧。选择一种生活方式之前，首先要在逻辑上能自洽。</p><h4 id="11-月-22-日-地砖与良质"><a href="#11-月-22-日-地砖与良质" class="headerlink" title="11 月 22 日 - 地砖与良质"></a>11 月 22 日 - 地砖与良质</h4><p>晚上在江边的一个绿道驿站练轮滑，休息的时候发现地砖有两种不同的颜色，一种比较新，颜色也比较浅，另一种比较旧，明显是从其他地方拆过来的，不过旧地砖的数量明显少很多。初看以为新旧地砖是随便混搭在一起的，仔细观察后发现，其实旧地砖铺得也是有规律的，尽管看上去零零散散的。有的是从一个台阶连接到对面的另一排台阶，有的是沿着驿站周围的建筑一圈，大多数都铺出了有规律的几何形状，然后再零散地围绕图形周围一圈作为边框。旧地砖镶嵌在新地砖之中居然成了一种点缀，好像是我的世界里的作品：新地砖组成了画布，而旧地砖就是像素点。我也突然意识到，其实每一种工作都有发挥创造力的空间，哪怕是铺地砖这种看似和创造力没有关系的工作。任何工作也都会出现挑战，你的态度决定了你的工作成果会是什么样的。当地砖工人面对地砖数量不够、需要使用旧地砖充数的时候，他们没有抱怨，而是把它看作是一个发挥创造力的机会，所以才有了我眼中的旧地砖镶嵌在新地砖之中，但看上去特别和谐的结果。我觉得完成这份工作的人，心里也一定是有成就感的。他不一定看过《禅与摩托车维修艺术》，但是他一定是个身上有良质的人。假如我们每个人都是这样对待自己的工作的话，这个世界会变成什么样？</p><h4 id="11-月-23-日-如何找到热爱之事"><a href="#11-月-23-日-如何找到热爱之事" class="headerlink" title="11 月 23 日 - 如何找到热爱之事"></a>11 月 23 日 - 如何找到热爱之事</h4><p>最近看了一篇 David Perell 的文章 <a href="https://ckarchive.com/b/38uphkho973gd">Finding work you’re passinate about</a>，深有感触，说说我的感受吧。首先，我十分同意他在文章中提出的第一点 “Don’t wait; create”，对于大多数人来说，需要的不是灵感，而是行动。你只有开始行动之后，才能慢慢找到方向。如果你对什么都提不起兴趣，没有热爱的东西，很有可能是你什么都不擅长。而当你真正精通一样技艺之后，你会在这件事上得到非常多的乐趣，继而触类旁通，也会慢慢花越来越多的时间研究周边的一些知识，哪怕是离开了这个领域，你学到的知识也能迁移到其他学科、技能的学习中。对我自己来说，我想到的例子是滑板和轮滑。一开始练习轮滑的时候，我已经会玩滑板了，因此，我知道形成肌肉记忆的重要性。除了学会基础动作之外，我花最多时间练习的是如何通过改变重心的位置保持身体平衡，因为我知道这些最基本的经验都是通用的。其次是阅读，而且要有选择性地阅读。当你新进入一个领域的时候，大多数情况下，那个领域中一定有非常多前人的经验和优秀的最佳实践，优先选择那些经过时间检验的读物，比如出版次数最多的书籍，阅读量最高、最受好评的博客等。而当你跨过入门的这一阶段，进入专业/半专业的状态之后，如果你决定深入研究这一学科或技艺，继续精进，最好的方式是将你的学习过程记录下来，或者教给别人。你可以将自己的学习心得或者经历，通过文字或视频记录下来，这一过程本身就能加深你对知识的理解，然后再将它分享出去。如果从他人那里得到了反馈，那么这又是一个学习进步的机会。总而言之，找到自己热爱的事物不是一件容易的事，我们需要不停地尝试以及花更多的时间去打磨它，而一旦你找到了这样的东西，你所做的一切就都有了意义。人生本就是一场探索与尝试，尽情地玩耍吧。</p><h4 id="11-月-24-日-学会主动创造机会"><a href="#11-月-24-日-学会主动创造机会" class="headerlink" title="11 月 24 日 - 学会主动创造机会"></a>11 月 24 日 - 学会主动创造机会</h4><p>我们天生就讨厌被拒绝的感觉，有的人这种感觉特别强烈，哪怕是想到自己喜欢的人不喜欢自己也会觉得难受。我就属于这种人。回想下自己过去这二十几年的人生，可能就是这种对「不被接受、不被喜欢」的厌恶，促使我变成了现在的样子。从来都不喜欢主动，总是等着别人接近自己或是发起请求我才去回应，更不要说去创造认识他人、和他人建立联系的机会了。我这样的人获得某个机会完全就是靠运气。</p><p>虽然我对社交的态度已经发生了转变，但是<strong>学会主动创造机会</strong>这一点依旧是我希望达成的一个目标。不仅仅是因为这可以拓宽自己的选择面，更因为它可以让自己内心变得更强大，从而对不被接受甚至被讨厌也不再那么敏感。相比因为害怕被拒绝而放弃尝试，我情愿被拒绝而感到难受，因为我知道这种痛苦只是暂时的，而如果因为胆怯而放弃，总是会事后想起感到后悔，但机会一旦错过，就不会再有了。过去我已经犯过很多次这样的错了，我不想再次犯同样的错误。去丢脸吧，多丢几次就习惯了。</p><h4 id="11-月-25-日-生命是个奇迹"><a href="#11-月-25-日-生命是个奇迹" class="headerlink" title="11 月 25 日 - 生命是个奇迹"></a>11 月 25 日 - 生命是个奇迹</h4><p>生命是个非常神奇的东西，人类本身也是。我们原本只是一团原子，最后却能发展出智慧，如果真的存在某个至高无上的神的话，他可能也会感到惊讶。作为一个个体，我们的出生也纯粹是个偶然。为什么偏偏是我们？只因为我们运气比较好，比成千上万个同类抢先占据了有利位置，游得比较快，与母亲体内的卵子结合，并一步步从受精卵发展成胚胎，再从胚胎发展成胎儿，然后出生，然后经历一生，然后死亡。每次想到死亡，想到自己也会生病，想到自己躺在病床上无助的样子，难免感到有些凄凉。假如我能一直这样年轻下去就好了，假如未来人类的技术能够战胜所有的疾病就好了，假如未来生活水平大幅提高，再也不用担心医疗支出就好了。可是归根结底，人还是要回归现实，总有一天我也会躺在病床上接受治疗。直到某天，医生最后一次为我做完检查后，摇摇头轻声告诉我的家人，他们没什么能做的了，由你们来决定最后这段时间该如何度过。而如果有可能的话，我会选择姑息治疗。如果法律允许的话，在征求家人和医生的同意之后，我可能还会选择药物辅助自杀。看上去这一天还有点遥远，但是，我希望自己能尽早做好面对它的准备。就像乔布斯每天早上会问镜子中的自己：假如今天是我的最后一天，我会怎么度过这一天？如果我们也做好了迎接死亡的准备，那么生命中剩下的每一天感觉都像是礼物。<strong>只要还活着就值得感恩。</strong>死亡不可避免，那么趁自己还有时间和精力，去创造生活吧。</p><h4 id="11-月-26-日-幸运与学习"><a href="#11-月-26-日-幸运与学习" class="headerlink" title="11 月 26 日 - 幸运与学习"></a>11 月 26 日 - 幸运与学习</h4><p>有时候觉得自己是个极其幸运的家伙，有自己喜欢且适合自己的工作，有一点时间能够做自己想做的事，欲望不多所以也不用为了迎合他人或者满足物欲而去做一些自己不愿意做的事。能够拥有这一切是件多么奢侈的事。我只希望自己 10 年、20 年后依然保有这一切。</p><p>昨晚熬夜吃垃圾食品、刷剧、看视频，突然觉得，其实偶尔放纵一次也没什么大不了的，况且周末本身就是自我调整的时候。然后又想到，假如我不是一个人，可能就做不到像这样自由放纵了吧。不过，有时候又会觉得，这样是不是对自己太不负责任了？也许有了一个她，我可以做到更自律，对自己的健康、对家人、对工作、对社会也更加负责？也许吧，但是一个人如果需要凭借外力来督促自己，我觉得这说明他其实配不上自己当前的位置。一旦外力消失，他会怎样面对这个真实的自己呢？</p><p>我总是觉得，我们这个世代的人，花了太多时间关注外部世界，假如每个人都能花更多的时间关注自己，关注我的需求、我的内心，也许我们会活得更加开心。没错，在别人看来，我是个不苟言谈的家伙，对任何人都不会吐露心声。但是，正是因为我会通过文字记录自己内心的想法，所以我才不需要专门找一个人诉说，或者希望从他人那里得到安慰，我自己就是最好的倾听者。世界上也不会再有第二个人比我更了解我自己。这是不是意味着我们可以不用去和他人进行接触了呢？不是的，和他人交流是为了获得新的想法，产生思想上的碰撞。没有人是完美的，假如每个人都不去分享自己的观念和想法，不从别人那里吸收新知识，进步又怎么会产生呢？我只希望自己能保持身体和大脑的健康，不断地学习新知识下去，直到老得记不清自己是谁。</p><h4 id="11-月-27-日-多面的自我以及保持知觉"><a href="#11-月-27-日-多面的自我以及保持知觉" class="headerlink" title="11 月 27 日 - 多面的自我以及保持知觉"></a>11 月 27 日 - 多面的自我以及保持知觉</h4><p>我们每个人日常生活中看到的都只是一个人的某一面，就像我在碎碎念中表现出的只是我的人格中的一面而已，现实中的我给人的感觉，可能和碎碎念中的我完全不同。所以，凭什么要求别人就必须始终保持一致呢？尤其是通过社交软件认识的朋友，必须意识到对方在现实生活中可能是个非常不同的人，所以也就没必要因为这种不同而感到失望，要学会接受别人也有多面的自我。那么，我理想中的自我应该是什么样的呢？乐观、豁达、热情、幽默，理性与感性并存。然而现实中的我敏感多疑，遇事不决，容易退缩，逃避社交，害怕和异性相处，而且总是思虑过多。看起来好像和理想中的自己相差很大，但是没关系，我知道改变是个一生的过程。</p><p>虽然如此，我还是接受当下的自己的，改变也是因为我想要变得更好，能够更好地体验自己的人生。而且敏感也是件好事，只是需要我们善用好它。它可以让你内心更加充满好奇，感受世间万物的同时，提升你的共情能力。但是，假如我们将这种敏感放到过度关注自我上，却也会让一个人变得消极、自恋、自卑、充满嫉妒心。无论如何，时刻保持自知自觉始终是件好事。不要陷入无意识的状态，生活在于感受那些细节，无论是快乐还是痛苦，要始终保持对注意力和知觉的控制。</p><h4 id="11-月-28-日-我们这一代人的困难"><a href="#11-月-28-日-我们这一代人的困难" class="headerlink" title="11 月 28 日 - 我们这一代人的困难"></a>11 月 28 日 - 我们这一代人的困难</h4><p>总是忍不住去关注那些自己无法做出改变、也影响不了现状的事情，明明知道关注得越多只会增加自己的焦虑和不安，可还是无法控制住自己的双手和大脑。我们生活的时代同时存在着无与伦比的美以及让人容易分心的事物，假如一个人知道如何控制自己的时间和精力，那他就能学会任何自己想要学习的东西，也会生活得更加快乐。可是，有多少人能做到这一点呢？我们都是一边被打扰，一边分心，然后一边尝试做出一点工作成果。每个时代的人都有他们的困难需要面对，我们这一代人需要面对的是抵抗来自外界的噪音，做好自己想做以及该做的事。不过，很显然的一点是，我们这一代人相比过去的人幸运很多。至少在物质上不用担心太多，吃饱穿暖已经不是我们的追求了，我们追求的是活得更加快乐，获得人生中更多的体验，找到自己所爱之事与所爱之人，让生命更有意义。我觉得这就是进步。而未来的人类也会有他们的困难，他们的追求，我们作为前人，可能也会觉得理解不了他们，但是，我希望那时候的自己已经早早离开这个世界了。不知道人类最终能否战胜衰老和死亡，但是我觉得生命有始有终也挺好的。人总有厌倦的时刻，知道自己有一天会离开这个世界，我们也许会更有勇气去面对困难和挑战。因为我们最终都会被死亡带走，所以才更能以淡然的心态看待眼下的不堪或是幸福了。</p><h4 id="11-月-29-日-寻找合适的资料以及执行力"><a href="#11-月-29-日-寻找合适的资料以及执行力" class="headerlink" title="11 月 29 日 - 寻找合适的资料以及执行力"></a>11 月 29 日 - 寻找合适的资料以及执行力</h4><p>最近开始学习 iOS 开发，先是自学了 <a href="https://github.com/aJIEw/HeadFirstObjectiveC">Objective-C</a> 和 <a href="https://github.com/aJIEw/HeadFirstSwift">Swift</a>，今天正式开始看 UIKit 相关的知识。早上花了差不多半个早上的时间寻找教程，当终于发现一个<a href="https://www.kodeco.com/5055364-ios-storyboards-getting-started">不错的教程</a>之后，跟着教程一步步往下做，心里欣喜万分。有时候花多点的时间寻找合适的学习材料真的非常值得，我觉得这其实也算是一种技能吧，因为如果你能快速寻找到适合自己的学习资料和最佳学习方式，你的效率会提高很多倍。当然，这点也要归功于过去养成的搜集资料的习惯，再加上曾经走过的那些弯路，所以现在才能达到事半功倍的效果。这也让我意识到，问别人其实是非常低效的学习方式。因为除非你所处的位置是行业顶尖水平，否则绝大部分问题都已经有人遇到过了，而且很有可能还有详细的教程，你只需要在互联网上找到它们就行了。至少在软件开发行业，这个现象是存在的。不过，需要注意的一点是，有的时候也不要太过于关注信息的完整度以及追求资料的质量，因为只要你肯花时间，总是可以找到更好的。不要把时间花在做这种边际效益不高的事上，有的时候<strong>执行力</strong>更为重要。</p><h4 id="11-月-30-日-目标、价值观、木炭"><a href="#11-月-30-日-目标、价值观、木炭" class="headerlink" title="11 月 30 日 - 目标、价值观、木炭"></a>11 月 30 日 - 目标、价值观、木炭</h4><p>最近最大的感慨是，生活在当代的我们太缺乏目标了，照理说，物质满足之后应该开始追求精神上的丰富才对，但是大多数人却陷入了不停升级物质生活的怪圈，最后被物质生活绑架而不得不去做自己不喜欢做的事情，而且越是急于逃脱这样的环境反而容易越陷越深。有时候以为可能国外不是这个样子的吧，结果上网看了之后发现其实也差不太多。所以，我们这是怎么了？无论从哪个角度来看，我们现在的生活都比以前过得更好了，尤其是我们这一代人，但是，大多数人似乎都把更好的物质条件等同于幸福，把赚钱能力作为衡量一个人是否成功的唯一标准。当然，我发现至少在一二线城市，这个标准已经开始发生变化了。不过，对于很多像我一样从小地方来到大城市工作生活的人来说，还是很难在自己的亲友圈中表达这样的价值观，因为即使说了也很难被理解。有时候内心也会感到矛盾，因为我知道，还有很多人的确生活得比较辛苦，对于他们来说，赚更多钱的确能改善生活质量，这是因为我们的社会经济发展得不够均衡造成的，但大多数生活在一二线城市、大学毕业且有稳定工作的人，其实都应该思考下，我们到底应该怎样度过自己的人生。我不是鼓励大家躺平，而是觉得<strong>工作不是生活的全部</strong>。即使你做的是自己内心非常向往和热爱的事情，也需要细水长流才能保持住这份热爱。我们要做木炭，持续发光发热，而不是做一根火柴，火焰耀眼却维持不了多久。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接受自然的安排</title>
      <link href="/2022-10/"/>
      <url>/2022-10/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/ci67LphFIFM" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>这个月回了两次家，一次是国庆，一次是参加表妹的婚礼。每次回家都是一种抽离，也让我有机会感受下另外一种生活节奏。这次回家感觉爸妈好像和上次看到的时候不太一样了，白头发多了，皱纹也多了。有时候觉得这会不会是我的内心想法的投射，因为我觉得他们实在是太操心我的事了。不过，没办法，我改变不了他们的想法，也做不到完全顺从他们，更不能阻止他们变老。这是一个不完美的世界，我们也没有人是完美的。既然如此，那就接受这个自然的安排吧。努力过好每一天，做好手头的每一件事，这样就很好。</p></blockquote><span id="more"></span><h4 id="10-月-1-日-每一刻自有其意义"><a href="#10-月-1-日-每一刻自有其意义" class="headerlink" title="10 月 1 日 - 每一刻自有其意义"></a>10 月 1 日 - 每一刻自有其意义</h4><p>好多天没写碎碎念了，越是不写就越是觉得没有什么特别想表达的东西。以前节假日之前都会列一大堆计划，虽然最终完成的很少，但是这次好像连做计划的想法都没有了，第一次有种「有没有假期都无所谓」的感觉。不过，至少还是回家了，在家休息一段时间，尝尝老爸老妈做的饭菜，看看电影，玩玩游戏，放松一下也不错。昨晚躺在床上想，我们努力的意义不就是为了更好的生活吗？但是假如一个人没有了欲望，失去了追求更好的愿望，那才是真正可怕的状态。所以，无论怎样，还是要给自己定下一些目标的，无论是学习新语言，掌握新技能，新的兴趣爱好，哪怕只是听起来俗气的升职加薪，再大一点的目标比如恋爱结婚生子，我觉得这些都是可以去追求和尝试的。总之，要让自己感到：我有在努力地生活，我的人生是有希望也是有意义的。不过，也不要太在意，毕竟时空浩瀚，物换星移，我们这一生只不过是宇宙中偏僻角落里的一瞬间。我们应该把目光放到近处，把每一天的生活过好，把手头上的每一件事都做好，哪怕是无聊的时候也要试着去感受自己的呼吸。要相信，每一刻自有其意义。</p><h4 id="10-月-8-日-Don’t-take-it-for-granted"><a href="#10-月-8-日-Don’t-take-it-for-granted" class="headerlink" title="10 月 8 日 - Don’t take it for granted."></a>10 月 8 日 - Don’t take it for granted.</h4><p>假期结束，恢复正常作息，碎碎念也可以继续写起来了。这应该是我中断写碎碎念的最长的一段时间。应该怎样描述在家的生活呢？没有计划、作息不规律、无所事事，但是换个角度看，我觉得这其实展现出了我的本性，正因如此，我才需要养成更好的习惯，比如学会做计划和定目标。不然的话，我会一事无成，即使给我再多的时间，我也可以轻轻松松地把它们全都挥霍掉。另一方面，我也意识到，其实我并不是个自律的人。过去看上去显得自律，只是因为我营造出了一个很难让自己放纵下去的环境，再加上养成了习惯，所以生活中很少会有意外发生。如果换个环境，我可能很容易就会陷入一种充满危机的生活。所以，如果我想要尝试远程工作的话，我可能不会选择在家办公，而是去一个公共的环境。这样一对比，我觉得自己现在的工作简直太完美了，既有办公环境，又不用忍受太长时间的通勤，而且还享有一定程度的自由，比如中午回家午睡，这是离家近的好处。这也再次提醒了自己，要珍惜已经拥有的东西。很多时候，我们往往意识不到那些我们已经习以为常的东西，只有换了一个环境之后才能意识到，那些我们在平时生活中司空见惯的东西，原来是这么的宝贵。Don’t take it for granted.</p><h4 id="10-月-9-日-拒绝安逸，拥抱挑战"><a href="#10-月-9-日-拒绝安逸，拥抱挑战" class="headerlink" title="10 月 9 日 - 拒绝安逸，拥抱挑战"></a>10 月 9 日 - 拒绝安逸，拥抱挑战</h4><p>很多时候，我们都是被环境塑造的，就像最近，当我觉得一切都陷入停滞的时候，工作上遇到了一个新的挑战，然后我的学习欲望才重新被激发出来。假如没有这样的环境，我可能会一直懒散、消沉下去。所以，这也得感谢自己还有一份工作，如果没有它，我可能不会变成今天的我。王阳明说的事上练，表达的就是这个意思吧。因为人总是有劣根性，假如没有外界环境的督促，我们就会得过且过，追求享受，不再继续成长。但是，如果你面对的是一个持续给你制造出恰到好处的挑战的环境，你就会不断地被激发出自己的潜能，每次都能随着问题的解决而变成一个新的「我」，这样，几年之后，你的能力和水平就会超越当初的自己许多倍。这就是我理想中的环境。很可惜，不是所有人都能拥有这样的环境。我们要么面对的挑战远远大于自己的能力，因此只能感受到挫败而不是成长；要么，面对的环境过于宽松，于是允许自己养成了一些坏习惯，而且也没有面临过具有足够的挑战性的任务，久而久之，能力逐步退化，甚至连学习的能力也丧失了。总体而言，从小到大，我所面临的环境偏向于后者，但是偶尔也会遇到一些挑战，所以我还不至于完全没有得到任何成长。但是，从最近这段时间的经历来看，我似乎越来越习惯于轻松的环境，这也是让我感到担忧的地方。不过，好在这两天工作上的新任务让我及时发现了这个问题，所以，再一次提醒自己：不要选择安逸，哪怕只是出现一丝丝这样的想法，都不应该接受。人永远只能在挑战和逆境中获得成长，时刻准备好拥抱它们。而且，这样的人生才有意思。</p><h4 id="10-月-10-日-28-岁的-10-条人生忠告"><a href="#10-月-10-日-28-岁的-10-条人生忠告" class="headerlink" title="10 月 10 日 - 28 岁的 10 条人生忠告"></a>10 月 10 日 - 28 岁的 10 条人生忠告</h4><p>今天是我在这个世界上度过的第 28 个生日，那就记录下给未来的自己的一些忠告吧。</p><ul><li>照顾好自己是你首要的任务，你要时刻关注你的身体、头脑、情绪、意志是否健康。</li><li>始终要把个人的成长放在第一位，凡是不能让自己获得进步的，都不值得你花时间。</li><li>真正的财务自由是时间自由，所以，你要思考如何才能利用好自己的时间，去做自己想做且有价值的事。</li><li>要给自己立下目标，哪怕是微不足道的目标也能给你指引。漫漫人生路，你的目标就是你的前进方向。</li><li>重视过程而不是结果，即使没有获得想要的结果，至少还可以把它当成游戏的一部分去享受。</li><li>人生重在体验，当你把自己的所有经历都当做一种体验，那么就没有什么是无法忍受的了。</li><li>照顾好你爱的人，多花时间和家人以及爱人相处。如果你还没有找到你爱的人，请继续寻找，不要放弃。</li><li>我们无法控制变化，唯一需要确定的是：你能否适应变化。你需要不停学习、不断成长下去才能做到这一点。</li><li>快乐和幸福就在你心中，不要向外寻找，学会向内探索。</li><li>人生中的痛苦总是更多一些，要学会思考痛苦的来源，这样你会越来越能把控自己的人生体验。</li></ul><h4 id="10-月-11-日-停用交友软件"><a href="#10-月-11-日-停用交友软件" class="headerlink" title="10 月 11 日 - 停用交友软件"></a>10 月 11 日 - 停用交友软件</h4><p>有时候想想，我们为什么要用交友软件呢？明明每天身边经过那么多潜在的可以交往的对象，明明只要自己鼓足勇气，敢于上去搭讪就可以了，但大多数人却还是选择拿着手机，和远方的不怎么见面甚至从未在现实中见过面的人聊天。想想也是挺讽刺的。有可能我们天性就比较害羞吧。不过，我也在尝试放弃使用交友软件，因为实际上我通过交友软件认识的人当中，能够发展成为线下好友的，一个都没有。大多数都是聊着聊着就聊不下去了，最后只能删好友。当然，这方面最主要的原因在我，因为我从来不是个擅长聊天的人，尤其是在线上，我不知道从什么时候开始养成了不喜欢在论坛、群聊中发言的习惯。当然，这样也有好处，那就是内心特别平静。除了工作之外，也不用担心被其他自己不感兴趣的事情打扰。唯一的不足之处在于，和新认识的人以及和陌生人，我已经不知道怎么和对方建立起更深一度的连接了。还有就是，身边的朋友越来越少，节假日除了回家之外，几乎想不到其他可以一起玩耍的朋友了。想想也是挺悲哀的。有时候觉得，人生就是这样吧，年纪越大，身边可以说真心话的人就越少，大多数事情都只能一个人默默扛着。所以，我们才需要一个伴侣来共同面对这一切，排解寂寞，以及在需要的时候能有人来照顾自己。</p><h4 id="10-月-12-日-热爱生活"><a href="#10-月-12-日-热爱生活" class="headerlink" title="10 月 12 日 - 热爱生活"></a>10 月 12 日 - 热爱生活</h4><p>自从不下雨之后，最近几天的天气都很好，这应该是一年中最舒服的季节了。每天早上上班路上，看着身边经过的来来往往的人，再看看远处的天空，心情都特别好。中午时分的天空也特别好看，云雾逐渐散开，太阳正准备照进来，甚至想干脆不睡午觉了，去楼下的长椅上晒晒太阳。有时候想想，可能正是这些稀松平常的事物才容易被人忽略吧。幸福其实很简单，只要你用心去体会生活中那些常见但又让人觉得舒服、惬意的瞬间就好了。晚上轮滑刷街的时候，偶尔会注意到街边大树底下帮人修车的师傅，还有街边的小吃摊师傅，加完班准备回家的职场白领，每当看到他们，心里不由得拿自己和对方比较，虽然这种比较是不对的，但就算不去对比，我还是觉得自己是非常幸运和幸福的。生活就是珍惜当下，珍惜每一天的每一刻。虽然我们无法控制发生在自己身上的事情，但是我们可以选择以何种方式去诠释它们。你越是爱生活，就越是容易注意到生活中美好的一面；你越是厌恶生活，就越容易感到不顺心。毕竟没有一样事物是完美的，只要你愿意，永远都有可挑剔的地方。热爱生活总归是正确的选项，因为无论如何生活都会继续下去，而你的态度才是真正关键的。</p><h4 id="10-月-13-日-刚刚好的消费观"><a href="#10-月-13-日-刚刚好的消费观" class="headerlink" title="10 月 13 日 - 刚刚好的消费观"></a>10 月 13 日 - 刚刚好的消费观</h4><p>最近发现一个事实：只要你手里还有钱，你的消费欲望就不可能被完全控制住。这一方面是因为我们生活在一个商品经济时代，广告无处不在，你接触到的所有人、事、物都在提醒你，你应该拥有这个，你应该拥有那个，我们自然而然地接受了这些想法，所以，一有机会的时候就会觉得，我应该买这类产品。但是，仔细想想，你以为的某些「必需品」在它们被生产出来之前，没有人会觉得自己必须要使用它，没有它就无法生活了。大多数商品只是看起来方便了我们的生活，实际上离开它们，我们照样可以生活得很好。所以，更关键的问题在于，我们为什么要不停优化自己的生活？假如当下的生活足够好了，我们就会满足了吗？我怀疑这样的「足够好」的时刻永远也不会出现，因为人一旦走上了这样的优化之路，就很难停下来了。当然，我不是说每个人都应该回到男耕女织的时代：每个人都独立生产出自己所需要的大部分产品，也很少使用其他人提供的服务。我们没必要倒退到那种地步。而是，我们要学会反思，警惕自己陷入消费经济中的 rat race，珍惜那些真正能让自己感到快乐的事物，把时间花在真正重要的事情上，而不是为了消费而消费。</p><h4 id="10-月-14-日-关于-Web3-的反思"><a href="#10-月-14-日-关于-Web3-的反思" class="headerlink" title="10 月 14 日 - 关于 Web3 的反思"></a>10 月 14 日 - 关于 Web3 的反思</h4><p>昨晚看了百姓网创始人王建硕的一场<a href="https://www.youtube.com/watch?v=1QKbm3Sv2Uw">关于 Web3 的讲座</a>，给我扫盲了关于区块链和 Web3 的种种疑问，过去一直以为区块链是一种多么复杂的技术，看完讲座之后才意识到，原来并没有想象中的那么难。还有就是 Web3，一直以为这玩意就是圈钱用的，没想到其实是有非常大的价值的，只不过目前还没有找到合适的应用而已。经过这一轮扫盲，我也认识到，原来区块链的本质是解决了信任的问题，而且这种信任不是通过某个权威的中心来认证或者背书的，而是通过技术。这也让我意识到，原来一些新技术真的可以解决很多现实中无法解决或者很难解决的问题。回想下，现在大规模使用的技术，基本上都得依靠人来实现，这就需要大多数人达成共识才可以。我觉得从这个角度来看，Web3 还有很长的路要走，因为仅仅靠现在的这些技术爱好者是很难将它传播得太远的。但是，一旦度过了初始的摸索阶段，大规模应用也就不远了，这点哪怕是像我这样刚接触这一技术的人也是这么想的。还有一个感触是，还有多少像这样的新技术、新事物，过去是被自己嗤之以鼻的，而一旦了解之后才发现，其实不是像自己过去想象的那样的，而是非常有意义的？</p><h4 id="10-月-15-日-非大度的人"><a href="#10-月-15-日-非大度的人" class="headerlink" title="10 月 15 日 - 非大度的人"></a>10 月 15 日 - 非大度的人</h4><p>我一直不愿意承认的一点是，我其实并不是个大度的人，但是我总是喜欢装作很大度的样子。我本质上是个有点小气的人，比如有的时候会因为别人一点点的冒犯而生气，甚至内心里给对方贴上不值得交往的标签。这种幼稚的做法也导致了我身边的朋友越来越少。不过，正是这种孩子气让我保持了内心的平衡。我也很多次想过要改变这一点，但是现实中似乎很难做到。我过去也说过，我是个非常喜欢挑别人身上的刺的人，第一次接触对方我就能一眼看出对方身上有哪些最明显的缺点，有时候内心甚至会有点鄙视对方，然后觉得对方不值得我花时间和精力。有时候也有可能是自己的自卑心在作怪，因为对方很有可能在某些方面比我强很多，出于自卑，我为了让自己的内心保持平衡，就会强化对方的缺点，有时候甚至会将一些不值一提的小缺点夸张成非常严重的问题。时间长了之后形成了习惯，于是我结交新朋友的可能性也越来越低。大多数时候我会干脆避免和新人打交道，顶多也就是维持在熟人的水平。这差不多可以概括目前我和大多数人的关系，包括同事和室友。</p><p>我有时候觉得自己有病，有时候又觉得，自己可能就是这样的人吧。而且一直以来，一个人的生活也没出现什么大问题，工作也能完成得不错，和家人的关系也还行。虽然没什么要好的朋友，但是我活得还挺开心的，有自己的爱好，有书、电影、游戏、音乐的陪伴，就够了。虽然也会感到孤独，但是我并不觉得有一个人陪伴就能解决这个问题。地球孤零零的飘荡在宇宙中，我们也是孤零零地生活在这个世界上。没有人可以一直陪伴着自己，大多数时候我们都只能自问自答，某一瞬间的感受也只有我们自己才能明白。没关系，对我来说，健康、快乐地活着就足够了。</p><h4 id="10-月-16-日-目标和沟通"><a href="#10-月-16-日-目标和沟通" class="headerlink" title="10 月 16 日 - 目标和沟通"></a>10 月 16 日 - 目标和沟通</h4><p>缺少目标是当代人最大的问题之一吧，所以我们才会创造出那么多打发时间的娱乐手段，假如没有它们，我们的生活将会变得更加无趣。我也常常思考我们应该如何度过自己的每一天，才能让自己的生命更加有意义。除了丰富自己的人生体验之外，我觉得最好的人生意义来自于创造价值，以及帮助、激励他人。目前我最崇拜的人，除了像 Steve Jobs 或者 Linus Torvalds 这样改变世界的人之外，还有就是通过创作来激励他人的人了。虽然我离成为像他们那样的人还非常遥远，也许一辈子也无法成为他们，但是我还是相信我能在一定程度上影响他人。哪怕只是一两个人，我也觉得是有意义的。唯一需要解决的是驱动力不足的问题，我常常觉得自己做的一切都没有什么意义，且观点总是趋于负面。如果我自己都做不到成为一个积极正面的人，又怎么能保证对其他人有好的影响呢？还有就是我太过保守，不愿意表达自己的观点。虽然自己还不算完美，但是我也在不停成长，而且人也只有在行动中才能获得更快的成长。另外，阅读、写作都是非常有效的工具，但是也不要忘记多多与他人进行沟通交流。人是社交动物，在与他人无障碍地交换思想之后，我们才能获得更多新的视角和启发。</p><h4 id="10-月-17-日-下台阶"><a href="#10-月-17-日-下台阶" class="headerlink" title="10 月 17 日 - 下台阶"></a>10 月 17 日 - 下台阶</h4><p>今天晚上第一次尝试轮滑下台阶，成功学会了下三级台阶。发现其实并没有想象中的那么难，但是一开始还是花了差不多 20 分钟犹犹豫豫，最终才鼓起勇气冲了下去，而且第一次居然就成功了。那种从头兴奋到脚的心情真的很难用语言来表达。虽然后来尝试 5 级台阶的时候摔得很惨，只有两次没摔，但是，一个晚上就收获了成功下三级台阶的进步，对于这样的结果，我已经很满意了。晚上洗澡的时候，不停地回想自己第一次尝试之前的心理状态，我发现其实很多时候，我都会习惯性地把眼前的挑战想象得比实际更难，往往要等到自己真的尝试了一次之后才会发现「哦，原来不过如此」，我已经有过很多次这样的体验了，从自学编程到后来的找实习，从工作之后尝试的新技术，到学习滑板、滑雪以及现在的轮滑，我发现自己性格中始终都存在这样的「害怕未知、喜欢维持现状」的倾向。虽然每个人身上或多或少都有这样的问题，但是我发现随着年龄的增加，在这方面我并没有获得太多的成长。所以，一直以来我都非常羡慕那些勇敢无畏、总是表现得十足自信的人，可能这真的是天生的吧。昨天看的邓亚萍做嘉宾的<a href="https://www.youtube.com/watch?v=qjkrngJPAVQ">圆桌派</a>，我觉得自己缺的就是她说的那种始终自信满满的气质。但是，我不认为天生弱一点就意味着不可改变，我相信只要使用合理的手段进行训练，我也一样可以像运动员一样，变得自信、不服输且充满韧劲。</p><h4 id="10-月-18-日-如何面对消极想法"><a href="#10-月-18-日-如何面对消极想法" class="headerlink" title="10 月 18 日 - 如何面对消极想法"></a>10 月 18 日 - 如何面对消极想法</h4><p>最近注意到自己脑海中常常出现一些消极、负面的想法，比如自杀，明明表面上看来一切都很好，有充足的睡眠，还算均衡的饮食，每天维持一定量的运动，也会写碎碎念记录自己的想法。可能还是一切都来得太容易了吧，所以总是不懂得珍惜。看来要重新开始写每天让我感恩的三件事了。不过，我并不觉得出现负面想法就说明我们就是不知感恩的人。的确，我承认我有时候心态容易悲观，我承认我有时候会显得有些软弱。第一反应是想要逃，逃避那些无聊、琐碎、自己不想做的事，逃避痛苦、现实以及自己无法改变的东西。也许有的人可以做到总是积极向上，看到事物中美好的一面。我当然也希望自己能够成为这样的人。可能还是因为自己练习得不够多吧。说起来，一个人不自信的习惯可能也是这样养成的，总是喜欢逃避，总是喜欢幻想，然而就是不敢去面对真实的自己，久而久之，人就会变得习惯性自我怀疑，都不用等到别人否定自己，你自己先否定了自己，然后再用行动去「证明」自己是对的，这就是负面的自证预言。改变其实也不难，每天试着把自己能做的事情做得更好。每天进步一点点。当你开始越来越频繁地尝到一些小的成功的甜头之后，你的信心和勇气就会越聚越多。</p><h4 id="10-月-19-日-尝试改变自己"><a href="#10-月-19-日-尝试改变自己" class="headerlink" title="10 月 19 日 - 尝试改变自己"></a>10 月 19 日 - 尝试改变自己</h4><p>最近的天气不冷不热，所以越来越期待周末，这样就可以出去刷街、到处闲逛了。说起来，我真的是一个特别怕人的人，从来不喜欢和人打交道，但是现在却越来越喜欢一个人出去逛，无论是玩轮滑还是其他什么，只要能看到人就挺开心的。但是，我并不期待和陌生人发生对话，一个是因为我容易感到紧张，另一个是我知道即使聊了也很大可能聊不到一块儿去，所以干脆就让我们的关系停留在彼此眼神交接的那一刻吧：我看到你了，你也看到我了，感谢我们生命中共享的这一刻。</p><p>有时候我也在想，我为什么会这么讨厌人群呢？其实也说不上是讨厌，应该说是不喜欢吧。假如我是一个心理咨询师，我可能会说这是因为父亲这个角色在我成长环境中没有发挥出足够的影响力吧。因为小时候，我和爸爸的接触比较少，成年之后就更是如此了。小时候的我更依赖妈妈，而从妈妈那里我没有学会如何与他人相处，而这个任务通常是由父亲来完成的。比如我们小时候父亲会通过游戏教我们学会背叛和信任，学会谈判和妥协，学会竞争和说服，等等。我印象中我小时候去我妈上班的地方玩，妈妈的同事常常和我闹着玩，欺负我，但是我却无可奈何，因为他们大我太多了，我根本比不过他们，无论是体力还是智力上。所以，我猜想自己就是从那会儿开始觉得，他人是不可接近、不可信任的吧。</p><p>当然，我知道这些都是在过去发生的事，此刻的我完全有能力改变自己的心态和想法，以更积极的态度去和他人相处。不过，说起来容易做起来难，人一旦习惯了某种行为模式之后，想要改变真的不是一朝一夕的事。我在工作场景中已经习惯了做一个沉默寡言、不苟言笑的人，但私底下的我其实并不是这个样子的。我想要表现出自己真实的一面，但是又担心自己的突然改变会收到一些负面的反馈。</p><p>唉，改变难，但是不改变，更难。所以，还是尝试下改变吧。</p><h4 id="10-月-20-日-选择你的生活"><a href="#10-月-20-日-选择你的生活" class="headerlink" title="10 月 20 日 - 选择你的生活"></a>10 月 20 日 - 选择你的生活</h4><p>有时候觉得这个时代真是无趣，虽然物质生活相比过去已经极大丰富了，但是人却更容易觉得身边的一切都没什么意思。虽然我们都知道有意思的东西要靠自己去发现，但事实的确是，我们这个时代的人相比活在过去的人，更加容易感到无聊和感到无意义。我觉得这是因为科技太发达了，每个人只要掏出口袋里的一个设备就可以看到地球另一边的人的生活。零距离意味着神秘感的消失。只要你愿意，你可以花一晚上的时间追踪几千公里之外发生的某个和你毫不相关的新闻，而且你都不用离开自己的房间，就能挖掘出和这件新闻相关的所有人物、地点、事件经过的所有细节。这带来的后果是，能够引起我们兴趣的事物越来越少，我们容易接触到的讯息所使用的媒介变得越来越直接，从文本到图片再到视频；表达方式也越来越夸张，因为不这样就吸引不了人看。虽然我很努力地在抵抗这一潮流，但是终究还是受到了一些影响。我能做的，只有不断提醒自己：不要成为算法的奴隶，不要陷入坏习惯的循环，要努力做出自己的选择，即使有的时候很难分辨到底哪种选择才是对的。我记得我过去说过，我的目标是影响更多人，让他们摆脱对手机的依赖，成为自己的时间的主人。虽然我自己常常也做不到这一点，但是我相信，随着不断地练习和自我激励，我们一定可以让自己的生活重新回到正确的方向，从而按照自己的想法去生活。</p><h4 id="10-月-21-日-同理心和包容心、强者与弱者"><a href="#10-月-21-日-同理心和包容心、强者与弱者" class="headerlink" title="10 月 21 日 - 同理心和包容心、强者与弱者"></a>10 月 21 日 - 同理心和包容心、强者与弱者</h4><p>每个人都讨厌傲慢的人，但是有时候一不注意自己就会表现出傲慢的一面。说到底还是<strong>同理心</strong>不足吧，在你眼里十分明显的事情在别人那里不一定是这样，同样的，有的时候你理解不了的东西在别人那，很可能是一目了然的。还是要多多练习如何变得更加谦和吧。尊重他人，主动去理解他人。你要真正穿起别人的鞋子走路，才能明白一个人的想法为什么会是那样的。另外非常重要的一点是<strong>包容心</strong>，也就是允许别人和自己不一样，也允许别人犯错。己所不欲，勿施于人。对待亲近的人尤其要如此，有的人对待陌生人很有礼貌，反而是对待自己亲近的人，变得非常刻薄。这点在我身上也表现得特别明显，要改。还有就是对待地位比自己低的人，比如为我们提供服务的人，做到礼貌不难，但是做到<strong>平等</strong>却有点难。而对待地位高于自己的人，要做到<strong>不卑不亢</strong>，这又是非常难的。我们通常容易陷入崇拜心态或者盲目服从，而且也倾向于把平等看得太过重要，或者为了体现出彼此平等而把姿态摆的太高，心态上也容易觉得自己被「侮辱」了，这也是非常不好的。无论是强者还是弱者，我们的首要任务是与对方<strong>合作</strong>，理想的状态应该是：从强者身上学习，帮助弱者进步。这样，我们既能把事情完成好，又能让所有人都获得成长。这就是我理想的工作和生活环境。</p><h4 id="10-月-22-日-通才为什么变少了"><a href="#10-月-22-日-通才为什么变少了" class="headerlink" title="10 月 22 日 - 通才为什么变少了"></a>10 月 22 日 - 通才为什么变少了</h4><p>昨晚看圆桌派片段的时候想到，为什么我们这个时代很少再次看到像伽利略、达芬奇那样的精通多门学科的天才？立马联想到的原因是，我们生活的时代让人分心的事物实在是太多了。即使是普通人，能够接触到的知识也远远超过 300 年前的贵族阶层，何况是那些拥有更丰富的资讯获取渠道以及更广阔人脉的专业人士了。<strong>在学习这件事上，我们最大的敌人是自己，而不是他人。</strong>如何能做到长时间聚焦做一件事，专注于某一领域，这才是真正的考验，天赋其实都是次要的。第二点原因是，现如今无论是哪一门学科，无论是科学还是艺术，都已经分得非常细了，知识树上的主干和枝节都已经被前人完善得差不多了，任何人都很难再像过去的科学家一样做出重大突破，而是只能在树叶的经脉中去发现新的成果。当然，我们这个时代还是有不少让人兴奋的新科技的，比如人工智能、区块链技术、扩展现实（XR）、太空探索等等。至于互联网，当然是非常伟大的发明，是我们这个时代的基础。我曾经说过人类的历史可以用互联网的发明作为分割线，我现在也依旧这么认为，因为它开启了一个全新的时代，未来科技的发展、人们的生活都将随着这一发明快速进化下去。非常期待三十年后的世界。</p><h4 id="10-月-23-日-一句话想法"><a href="#10-月-23-日-一句话想法" class="headerlink" title="10 月 23 日 - 一句话想法"></a>10 月 23 日 - 一句话想法</h4><p>今天打算换一种写碎碎念的方式，用一句话写下自己的一些奇思妙想：</p><ul><li>你在街上遇到的每个人都在努力让自己生活得更好，每个人都想要过得快乐、充实且有意义。</li><li>我们大部分人注定都只能是普通人，做着普通的工作，过着普通的生活。所以，最重要的人是我们自己以及我们身边的亲人和朋友。</li><li>这世上很少的人才有能力去主动塑造自己的生活，大多数人一生中最重要的决定其实就只有几个而已：在哪里生活，从事什么样的工作，选择和什么样的人结婚。至于剩下的，都是人生的细枝末节而已，你的外貌、学历、爱好、三观、财富水平等等，统统都不重要，只不过它们会影响到你的这三个选择。</li><li>大多数人只在乎他们自己，我们有时候感到纠结、痛苦，其实完全是因为自己想得太多。换句话说，内心戏不要太足，想做什么就去做好了，也不要管别人怎么看。</li><li>自律说到底其实是养成了一种好习惯，有的人不是控制不了自己的行为，而是已经习惯了一种行为模式，改变的难度太大而已。</li><li>不要和别人比，因为比赢了你会被讨厌，比输了你会不开心。即使这种比较只发生在你心里，这也会让你失去看到一个真实的人的机会。每个人都有长处和短处，学习他人的优点，用他人的缺点提醒自己，这样你才能越变越好。</li><li>不要把性看得太过禁忌，恩格斯在《家庭，国家，私有制的起源》说过「性和性生活是人类文明得以延续的基础」，既然是如此重要的事，而且也是每个人都在做的事，有什么好感到害羞的呢？谈论它应该像走路、吃饭、阅读一样正常。</li></ul><h4 id="10-月-24-日-痛苦使人进步"><a href="#10-月-24-日-痛苦使人进步" class="headerlink" title="10 月 24 日 - 痛苦使人进步"></a>10 月 24 日 - 痛苦使人进步</h4><p>知道得越多会让人越痛苦吗？显然不是。虽然在短期内可能会让人感到一些不安和焦虑，但是长期来看，你拥有的知识越多，你做出有利于自己的选择的可能性也越大。因此，知道得越多，人就越幸福。那为什么有时候我们会感到痛苦呢？我想最主要的原因还是，意识到原来自己和别人相比有那么大的差距，内心感到惶恐。有些时候感到这种差距实在是太大，你永远也不可能追得上，所以才会感到痛苦。但是，反过来看，过去的你根本就没有意识到这种差距，当你看不见的时候，也就不会有痛苦。假如你看见了，也没有感到痛苦，那是不是说明你已经完全放弃了自己？当你觉得这种差距是正常的，自然也不会觉得有必要去缩短这差距。那么，后者这种应对方式是你想要的吗？所以，能够感到痛苦说明自己还有改变的可能，那就努力去行动吧。要知道，痛苦只是一时的，当你开始用行动改变自己的处境的时候，即使你知道永远也不可能消灭你和你的目标之间的差距，但是至少能缩短它。相比过去的自己，这就是进步。说到底，我们每个人都是在和过去的自己竞争。也只能如此。再次想到了李宗盛的和自己赛跑的人，「前方没有终点，奋斗永不停息」。</p><h4 id="10-月-25-日-专注于自己的生活"><a href="#10-月-25-日-专注于自己的生活" class="headerlink" title="10 月 25 日 - 专注于自己的生活"></a>10 月 25 日 - 专注于自己的生活</h4><p>昨晚洗澡的时候突然意识到一个问题，在现在的大多数网络社区里，绝大部分人都在默默潜水，真正非常活跃、经常发言的人，只占人群中的很小一部分。也就是说，90%的人在关注着10%的人（具体比例可能不对，但大概如此），看他们说了什么，看他们分享的日常生活，参与他们主导的话题，等等。我在想，为什么会这样？如果你是那 10% 可能还好，毕竟你享受着他人的关注。但是，长期来看，如果你想要获得足够多的共鸣的话，一定会希望看到足够多的人都能参与进来，每个人都能分享自己的想法，因为只有这样，你才能从他人那里获得新的想法和启发。我自己属于人群中的大多数，但是我并不希望参与其中，而是安静地过好自己的生活，这同样也是不容易的。因为大多数人都做不到不去理会外界的声音，都需要从他人那里寻求认可和赞同，这是人的本能。我希望自己可以摆脱这一点，完全依赖自己的判断，内心笃定地做自己认为正确的事，不需要依赖任何人或物也能获得平静和快乐。如果这事情恰好也能给其他人带去价值的话，那当然最好了。</p><h4 id="10-月-26-日-从细微处开始改变"><a href="#10-月-26-日-从细微处开始改变" class="headerlink" title="10 月 26 日 - 从细微处开始改变"></a>10 月 26 日 - 从细微处开始改变</h4><p>越来越确信孤独才是一个人的常态，因为没有人可以一直陪伴在自己身边，也没有人知道自己的真实想法，更没有人能够真正理解自己。即使你把自己内心的想法毫无保留地倾诉给另一个人听，你也无法确认对方是否真的听懂了，因为就连你自己也没法保证自己的表达是完全准确的。况且想法本身也在不停地发生变化，比如我们此刻的想法是 A，在外界环境的影响下它可能就变成了 AB；当你开始认真思考的时候，想法变成了 BC；经过内心梳理后，变成了 CD；当你用文字把这个想法写出来的时候，你发现它变成了 D，这已经偏离当初的 A 很远了，而如果你现在重新组织语言，再用口头语言表达一遍，意思可能又要相差很多了。光是一个想法就已经如此，更不要说人本身了。我们时时刻刻都在发生着变化。所以，没有人是在一瞬间完成转变的，我们都是慢慢从一个样子变成另外一个样子。而如果你想要离目标中的自己更近一点，只能从现在开始，从那些最基本的小事开始做起，一点一滴地积累。看一页书，学一个新知识，养成一个好习惯，改掉一个坏习惯，然后某一天你会突然发现，和 n 年前的自己相比，我已经发生了那么多的变化。</p><h4 id="10-月-27-日-容易忽视的择偶标准"><a href="#10-月-27-日-容易忽视的择偶标准" class="headerlink" title="10 月 27 日 - 容易忽视的择偶标准"></a>10 月 27 日 - 容易忽视的择偶标准</h4><p>我觉得一个很少被提到的择偶条件是：30 年后，你还愿意和眼前的这个人一起生活吗？ 如果目前和这个人在一起的生活细节中，有一些是你需要自己去适应、去忍受的，那么，你能保证自己一定能够适应，或者一直忍受下去吗？这也让我开始思考，在和一个人相处的过程中，有哪些东西才是真正重要的。首先，性格很重要，如果两个人的性格不适配，很难想象怎么能长时间待在一起。对我来说，比较重要的品格特质有：<strong>诚实</strong>，这是一个人最基本的品质，过去的自己常常会撒点小谎，现在我才意识到这种行为有多蠢；<strong>理性</strong>，这能够保证我们在共同面对问题的时候能够诉诸理性思考，而不是看谁的脾气大，然后一方迁就另一方，当然一定会有迁就的情况出现，但是我希望越少越好，而且最好是彼此轮流迁就对方；<strong>乐观</strong>，工作时间长了才发现，决定一个人成就大小的，有时候真的不是因为能力差距，而是一个人面对困难、挫折时的态度，假如一个人能够总是保持乐观，看到事物中好的一面，能够发现他人身上的优点而不是缺点，这样的人可以说是无敌的，他们总能完成自己的目标。只要满足以上这三点，我觉得其它的比如性格是内向还是外向，其实都不重要。我自己是性格内向的人，但是和性格外向的人相处起来也没什么问题。说起来，其实和任何人聊个三、五分钟，基本就能判断出他是否符合以上三点。好像有点像面试，基本上前面几分钟就决定了你能否通过这场面试。也希望自己能多多和人聊天吧，因为只有多尝试才有可能发现合适的人，很多时候都是自己错失了机会。何况只是了解一下又没有什么损失，顶多被拒绝后感到有些丢脸，那也只是一瞬间的事。多试几次，习惯了就好了。</p><h4 id="10-月-28-日-做一个内心善良、充满爱的人"><a href="#10-月-28-日-做一个内心善良、充满爱的人" class="headerlink" title="10 月 28 日 - 做一个内心善良、充满爱的人"></a>10 月 28 日 - 做一个内心善良、充满爱的人</h4><p>最近收到一个网友的私信，让我感叹，有些人真的是天生善良、内心充满爱，所以才能做到始终友好对待他人、关心他人。我觉得再多的金钱也换不来这样的品质，假如你恰好遇到了这样的人并且和他成为了好朋友，除了说明你运气特别好之外，真的没有别的原因了，要好好珍惜。我也在想，我要怎样才能成为这样的人？我有时候也会表现得热心肠，但是似乎并不总是表现得如此，有时候会显得特别冷淡和冷漠。如果能够稳定输出，我想我的人缘一定会非常好。说到底，自己还是太容易受到外界环境的影响了，有的时候其实不是我们自身的问题，而是境遇的问题。但说到境遇，那些在困苦得多的条件下成长起来的人，有的也长成了又坚毅又温暖的人。只能用奇迹来解释了。相比他们，我这样的人已经算是非常幸运了。拥有感恩的心也是十分重要的一环吧。回想起我生命中遇到的这些人，虽然我和他们中的大部分关系都非常浅，但是他们对我的影响依旧巨大，我的观念塑造、对生命的理解、如何看待自我，都受益于或者启发自他们。即使某些人是反面教材，也依旧让我感受到人性的力量，我们每个人都是自我教育的产物。人生路漫漫，未来还会遇到哪些人我不知道，但我会怀着感恩的心，和过去的他们告别，同时也带着好奇心去迎接那些新到来的人。</p><h4 id="10-月-29-日-探索自我"><a href="#10-月-29-日-探索自我" class="headerlink" title="10 月 29 日 - 探索自我"></a>10 月 29 日 - 探索自我</h4><p>明明知道自己最大的问题是想的太多、做得太少，但还是很难有所行动。每当这个时候就应该告诉自己，停下手头正在做的事，尤其是当自己在做一些纯粹是在拖延和浪费时间的事。仔细思考当下自己最需要的是什么，假如缺乏睡眠，那就好好睡一觉；情绪过于紧张，那就听一首舒缓的歌；需要让自己的身体亢奋起来，那就做几组深蹲或俯卧撑；如果有足够的时间，最好出门运动一会儿，跑跑步或者玩轮滑。如果感受到自己的思维像一团乱麻，最好的做法是静下来，冥想十分钟，然后把自己此刻的想法全都写下来。也可以录音，即使表达得很乱或者没有逻辑也没关系，重要的是让自己的情绪和思维有一个释放的出口，就像我此时正在做的。人的身体和大脑是一架构造十分精巧的生物机器，假如我们不懂得如何释放自己的情绪和压力，这架机器会折损得特别快。说到底，我爱我自己，我爱我身上的一切，无论是优点还是缺点，正是那些微小的特质让我确信自己是独一无二的。我在人群中容易紧张，我害怕他人目光的审视；我喜欢独处，喜欢阅读文字，对一切新奇、好玩的事物感兴趣；我能忍受很多看起来让人无法忍受的事物；我接受现状，不过偶尔也会尝试去挑战现状；我对未来没有清晰的目标，但是我知道我会不停学习下去，不断变得更好；我想要利用自己的生命为他人创造出更大的价值，尽到自己的责任，照顾好家人；我想要更多的体验，我觉得所有新奇、有趣的东西都是值得尝试的；我没有任何禁忌，并且也愿意不断突破自己的舒适区，去更广阔的世界中探索。</p><h4 id="10-月-30-日-婚姻是信仰一跃"><a href="#10-月-30-日-婚姻是信仰一跃" class="headerlink" title="10 月 30 日 - 婚姻是信仰一跃"></a>10 月 30 日 - 婚姻是信仰一跃</h4><p>昨天表妹结婚，去参加了她的婚礼。看得出来，双方家里都是花了不少财力和精力才把婚礼办得体面隆重有气氛的。有时候觉得只有农村里才喜欢搞得像这样这么铺张浪费，但是想到人的一生就只有这么一次婚礼，况且他们还都是独生子女，就觉得能够理解了。除此之外，每次只要我在，照例还是会被作为反面教材被长辈们催婚，然后告诉我要主动点，去和他们介绍的女生聊天什么的。但是说真的，要让我和一个陌生人尬聊，我真的不会。像我这样的人，就连和新同事都很难说上什么话，更不要说和陌生女生了，我觉得即使把我们单独关在一间屋子里都不一定有用。我喜欢慢慢相处，两个人待在一起时间长了，尤其是在同一个物理空间下，慢慢对彼此感到熟悉之后，才有可能聊上天，以及感到彼此是否合适。大部分人应该都是这样相识的吧，只不过不同人会通过不同的媒介，有的人是一支烟，有的人是一句简单的夸奖，等等。</p><p>有首歌里写道，「爱一个人，要怎么开始啊」，我觉得爱其实是从喜欢开始的，从彼此慢慢有了好感，到喜欢上对方，到习惯了彼此的存在，再到离不开对方，再到想要让对方感到快乐和幸福，这样就是爱了吧。在我的成长经历中，我喜欢过很多人，但是好像从来都没有爱过一个人。可能是因为我和大多数人的关系都比较浅吧。也有可能是我对爱的定义太过严苛了，可能对于有的人来说，只要和对方待在一块的时候感到舒服，这就是爱了。</p><p>不过爱这种东西，对于目前的我来说，真的不是非常必需。我有我的爱好，我喜欢独处，享受一个人的自由，也享受孤独，非常不喜欢时间被他人占去做我不想做的事。我爱我的家人，我喜欢我的工作，我的同事也都很好。我现在的生活很平静，我也非常珍惜这种平静。虽然一个人面对充满不确定的未来，偶尔也会感到忧心，但是我知道大多数人都只能依靠他们自己，况且我也不是一个人。我过去受到过很多人的帮助，即使未来没有人再来帮助我，我也相信自己能够挺过一切风雨。相比过去，我已经成长了许多，而且未来我也会继续不停地学习和成长下去。有没有另外一个人和你一起生活并不重要，这个时代已经给了我们这样的权力。我们唯一需要做的事情是想清楚自己到底想要什么，追求什么样的目标，以及如何度过自己的每一天。至于那些世俗的观念，比如结婚生子买房之类的，能做到当然最好，做不到也没关系，毕竟现代社会非常宽容，一个人只要肯努力，生活也不至于太落魄。</p><p>想清楚这些其实很容易，但是真正做到却非常难，你要有很强的心理调节能力，面对他人的议论，还有来自家人的压力，以及未来的养老，有时候还有可能会影响到你的工作。我不知道未来的自己会不会选择妥协，比如找一个各方面都合适的人结婚，来结束这种被他人议论和家人不理解的生活，我也不知道这样的选择是好是坏。也许有无婚姻对人的生活影响大于和谁结婚，那么，此时这种选择就是正确的。但是，假如婚后的我发现这样的生活不是我想要的，那么我要怎么办呢？所以，我有时候觉得这就是一场豪赌。可能，人有的时候真的需要一些信仰吧，那种纵身一跃的勇气，a leap of faith，并且相信之后的所有事情都会以最佳的方式运行下去。而如果你不去推动它，也并不是什么都不会发生，因为事情也有可能变得更加糟糕。</p><p>到底要怎么选呢？</p><h4 id="10-月-31-日-解决你自己的问题"><a href="#10-月-31-日-解决你自己的问题" class="headerlink" title="10 月 31 日 - 解决你自己的问题"></a>10 月 31 日 - 解决你自己的问题</h4><p>我发现大多数让我感到痛苦的时刻，无论是回忆起自己说过的话还是做过的事，又或者是某个没有被满足的愿望，究其根本，都是因为我不敢面对真实的自己。我越是害怕面对真实的自己，越是接纳不了自己，就越容易感到痛苦。只有冷静下来之后，才会意识到又陷入了自我消耗。其实每个人身上都有一些问题，当问题暴露出来的时候，我们会感到痛苦、想要逃避，但是并没有用，唯一的解决办法是去积极地改变自己。也许很难，但是尝试一下总比没有任何行动要好。也许在改变的过程中，我们发现自己慢慢接纳了这样的自己，那也不错。还有，只有你自己才能解决你身上的问题，不要把问题抛到其他人身上，每个人都只能对自己负责。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何度过今天</title>
      <link href="/2022-9/"/>
      <url>/2022-9/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/sURFD0vVQYo" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>这个月应该是我中断碎碎念写作次数最多的一个月，但是，无论是生活上的变故，还是自己情绪上经历的起落变化，我觉得都敌不过时间。时间本身是中性的，只不过我们站在了不同的角度。有时候它是友人，帮助我们忘掉痛苦和不幸，有时候它是敌人，杀死了我们的激情和活力。但我还是愿意相信，时间总体上是公平的，无论你是抱着手机刷视频，还是选择在自习室里学习一整天，又或者是和自己喜欢的人散步、聊天、吃饭，你们度过的这一天都只有 24 小时。所以，我们真正需要问自己的问题是：我今天有没有在用自己想要的方式度过这一天？</p></blockquote><span id="more"></span><h4 id="9-月-1-日-回顾过去以及阅读经典"><a href="#9-月-1-日-回顾过去以及阅读经典" class="headerlink" title="9 月 1 日 - 回顾过去以及阅读经典"></a>9 月 1 日 - 回顾过去以及阅读经典</h4><p>意识到一个问题，我们真的有必要每天阅读那么多资讯吗？偶然间打开笔记工具翻看过去的一些摘抄和随想，发现里面有很多内容其实已经解答了我此刻遇到的问题，或者有些问题我早就遇到过了，只不过那时候只是记录下来而没有努力去寻找答案，没想到多年之后又再次遇到了相同的问题。这样看来，回顾过去以及解决过去还没来得及仔细思考和解决的问题，也是很有意义的事。再有就是，不要花太多精力追求所谓的「新」资讯，阅读经典书籍往往比看最近新出的书更能解决你的问题。时间是检验事物真实价值的最佳工具。</p><h4 id="9-月-2-日-Resilience"><a href="#9-月-2-日-Resilience" class="headerlink" title="9 月 2 日 - Resilience"></a>9 月 2 日 - Resilience</h4><p>区分好的和坏的运动员标准是，好的运动员总是能及时回到正轨。这是一个极其重要的技能，因为这保证了一个人即使中断了某个习惯，也能将负面影响降到最低。我最喜欢的一个英文单词是 resilience，有点像是塔勒布提出的反脆弱概念，其实就是更进一步的 resilience。我觉得人一旦具有了这样的特质，那么，他就没有什么好害怕的了。尽管去做，发生任何事情都只是一种体验而已。生命不息，折腾不止。</p><h4 id="9-月-3-日-请回答-1988"><a href="#9-月-3-日-请回答-1988" class="headerlink" title="9 月 3 日 - 请回答 1988"></a>9 月 3 日 - 请回答 1988</h4><p>1988 快看完了，快到结尾的时候剧情突然快进了许多，想想也能理解，再往下其实也没什么可说的了，剧中人物的背景、角色间的关系都交代得非常清楚了，日常生活的细节也非常多，剩下的交给观众自己去想象就可以了。总得来说这是一部非常值得一看的剧，虽然有些地方煽情、说教的氛围比较浓厚，但是看了主角们的生活以及他们与自己的同学、家人的相处关系，人会不自觉地将自己带入进行对比。家人的爱真的是无形的，只有看了别人的生活你才能意识到，其实我的爸爸妈妈也为我牺牲了很多，能够拥有这样的家人，我是多么地幸运。还有就是，一切都是有代价的。这个世界上根本就不存在轻轻松松就能得到的东西，即使有你也会因为不重视而失去它，无论是爱情还是友情，都需要用真心去交换，而且即使拥有之后也还需要你不停地付出努力去维护好它。尽管有的时候你是付出最多的那个人，但是你得到的快乐却远远超过接受你的付出的人。对于普通人而言，家人才是最值得我们倾注最多精力的人，我们从工作中获得的成就感远远也比不上把家庭经营得充满温情，互相理解、信任，关爱彼此，这才是真正难做到的。</p><h4 id="9-月-5-日-反思自己的生活"><a href="#9-月-5-日-反思自己的生活" class="headerlink" title="9 月 5 日 - 反思自己的生活"></a>9 月 5 日 - 反思自己的生活</h4><p>连续几天没写碎碎念了，一旦中断一个习惯，想要重新开始的话，就得花费额外的努力。所以今晚下班后，换完衣服就出门跑步去了，既是为了恢复原有的习惯，也是为了借这个机会养成新习惯。最近常常反思自己，尤其是自己现在的工作和生活方式，和同事交流少，生活中也不喜欢和朋友交流，几乎没有社交，和家人的关系也比较淡，这样下去会不会活得太孤立了？转念一想，还是因为社会太宽容了吧，像我这样的人也能凭借一门手艺活下去，这就是专业化分工的好处。所以，也没啥好担心的，只要自己喜欢这样的生活，那就继续按现在的方式生活下去吧。况且，即使是一个人，我的时间也都被自己的爱好占满了，美剧、电影、跑步、滑板、轮滑、阅读，哪怕是平均分配到这些上面，也会觉得时间不够用。再加上我还有特别强烈的整理痞，网络上那么多的学习资料，除了技术之外，还有像写作、乐器、投资、旅游、历史、哲学等等，根本看不完，好的文章、播客、视频又源源不断地在增加，即使一天有 48 个小时我也觉得不够用。虽然有时（比如某个周末早上）还是会内心感到一阵迷惘，躺在床上不知道自己接下来应该干什么，但是，我觉得那只是因为自己暂时被无意义感击中了而已，人生中这样的时刻一定会不停地出现，所以我们才要不停地赶路，不停地追求新目标。接下来要做什么呢？</p><h4 id="9-月-6-日-新鲜感和探索欲"><a href="#9-月-6-日-新鲜感和探索欲" class="headerlink" title="9 月 6 日 - 新鲜感和探索欲"></a>9 月 6 日 - 新鲜感和探索欲</h4><p>散步的时候，想起了五年前的事，仿佛就在昨天，可是回忆十年前的自己，一切却又都是陌生的了。可能是因为五年前我刚毕业吧，那时候周围的一切对我来说都是新鲜的。而十年前的我，还在上高二，每天过着重复的生活，就像现在，所以也就没有什么特殊的记忆了。五年后的我，回忆今天的日子，记得的会是什么呢？十年后呢？都说随着人的年龄的增长，时间的相对流逝速度会变得越来越快，现在的我是能体会到这一点了。唯一的疑问是，我要怎么做才能让自己的每一天过得更加充实有意义，同时又有一些值得回忆的片段？知道应该要主动去制造出一些新鲜感，但是毕竟普通人的生活每一天都是相似的，而且随着年龄的增长对周围的事物会变得越来越习惯，也更加不愿意出现变化。要怎样克服这一点呢？</p><p>有时候在想，可能唯一能做到大幅改变自己的生活节奏的方式就是换个城市生活吧，只有全新的环境才能让自己大脑和身体变得亢奋起来，然后去探索和发现周围世界和自己已知的生活中种种不同的地方，直到慢慢适应之后才会重新回到原点。这也是为什么我们会喜欢旅行，每次去到一个不同的地方就是在体验另一种生活方式，当地人是怎么度过他们的一天的，还有去发现那些没见过的有趣事物，当地的美食和风俗等等。但是，说到底，这还是人的心态问题，假如我真的每天都要去探索新事物，那么身边就有很多东西值得探索。我没去过的地方、尝试过的事情还有很多很多，比如去一个陌生的公园逛逛，而且这些事情即使是下了班也可以去做，只不过我已经习惯了过一种按部就班的生活所以就不去做了。关键在于改变自己的心态。</p><h4 id="9-月-7-日-不要轻易放弃"><a href="#9-月-7-日-不要轻易放弃" class="headerlink" title="9 月 7 日 - 不要轻易放弃"></a>9 月 7 日 - 不要轻易放弃</h4><p>最近开始用 PowerSlide 练 powerslide，右脚已经能做出一个比较像样的 powerslide 了，尽管滑动的距离不是很远，而且速度也不敢太快，不过总算是学会了，一个人兴奋了好久。这是我的第一个 powerslide，对我来说也算是一个 trick，所以值得庆祝一下，hooray~ 在练习 powerslide 的时候，我也观察到了自己心理状态上的一些变化。一开始练的时候，是在小区外面的停车场，地砖比较凹凸不平，加上是下班的时间，来来往往的路人比较多，所以就来到了江边。在江边找了一个人少的地方，热身十几分钟，然后就从基础动作开始练习，先是原地前后切换，然后是单脚跳转刹停。练了一会儿，尝试加了点速度，但是每次总是直接一脚就刹停了，并没有 slide，这时候我心里就泛起了小九九。先是找借口，觉得一定是因为这里地面太粗糙了，轮子抓地力太强，所以滑不起来。然后又开始想是不是轮子太软了，或许我应该买一双大三轮，用大三轮练会不会容易一些？大概练了二十来分钟，一度想要放弃练习、打道回府。没想到偶然间的一次，在刹停的一刹那，轮子往前滑了几厘米，我顿时激动起来，又尝试了几次，滑动的距离越来越远，于是就这样学会了 powerslide。这也让我意识到，我有很多时候都会习惯性地陷入自我怀疑，通过内耗白白浪费了许多精力，其实只要再坚持一会儿，就能看到结果。想要改变这点也很简单，少想多做，还有就是不要轻易就放弃。可以给自己设定一个期限，只要还没到期限，那就要继续尝试下去，这样也不用担心自己投入太多而没有及时止损。</p><h4 id="9-月-8-日-重要的问题"><a href="#9-月-8-日-重要的问题" class="headerlink" title="9 月 8 日 - 重要的问题"></a>9 月 8 日 - 重要的问题</h4><p>看了彼得德鲁克的<a href="https://chenweixiang.github.io/docs/Managing_Oneself.pdf">管理自己</a>，印象中好像 13 年左右就看过一遍，还是从知乎上看到的，只不过那时候的知乎和现在的知乎完全不一样。那会儿我就像一个文盲刚学会识字一样，疯狂从知乎上阅读各种各样的文字，感觉打开了新世界的大门。不过，当时对德鲁克的这篇文章其实也并不是太在意，只知道非常牛逼，非常正确。但是，现在再看一遍，感觉的确不太一样了。就像文章中说的一样，我从来没有认真思考过这些问题的答案：我擅长什么、我做事的方式以及我最重要的价值观。好像一直以来都只是有个大概的模糊印象，但是如果要让我准确回答，我可能真的说不上来。我只知道我更喜欢解决那些需要一个人独自琢磨的问题，不太爱与人合作；与人沟通的时候我更喜欢文字；我喜欢接触一切新鲜有趣的事物，也喜欢做计划，喜欢确定的结果，不喜欢惊喜和意外；我认为每个人都应该追求自己的理想生活，即使这意味着要放弃或牺牲很多东西，以及付出巨大的努力。我觉得生命在于体验，我对未知感到好奇，我也认为每个人都应该努力丰富自己的生命体验，即使没有人知道你的生活。我正在努力让自己变得更加开放，对所有持有不同价值观的人保持开放的心态，从不同的人身上学习新知识，变得对不同的人的生活更感兴趣。我对未来持乐观态度，我相信科技进步会造福越来越多的人。尽管现在整个世界的经济都在遭遇寒冬期，但是我知道这些都会成为过去，而未来我们的生活会变得越来越紧密联系在一起。我知道我只是人类整体中渺小的一员，但想到即使是人类这个物种，在宇宙中都只不过是沧海一粟，所以也没必要太过严肃。好好生活，过好自己的每一天，努力让自己身边的人生活得更加快乐和幸福，让那些通过网络空间偶然与自己相遇的人得到共鸣和感到理解彼此。还有就是希望能够留下一点有意义的东西，这就是我的全部愿望了。</p><h4 id="9-月-9-日-轮滑与工作"><a href="#9-月-9-日-轮滑与工作" class="headerlink" title="9 月 9 日 - 轮滑与工作"></a>9 月 9 日 - 轮滑与工作</h4><p>昨晚又去江边练习 powerslide，自从学会这一招之后，感觉自己就像上了发条一样，一有机会就要刹一下，在各种光滑程度不一样的地面上都想试一试，这大概就是我最近生活中的「简单的快乐」了吧。轮滑其实是非常限制场地的运动，不 仅如此，你还需要准备一双合适的轮滑鞋，而且还需要花时间保养它们，轮子、轴承都是耗材，需要定期更换，更不要说学习它所需要付出的时间成本了，有的人会觉得它很难学，而且容易摔跤。我觉得提出这些质疑都无可厚非，但是，我想也正是因为在投入了足够的时间练习，学会了一个简单的动作之后，从内心感到的那种开心和满足，这才是它的魅力所在。其实任何一项运动都是如此，如果你想要变得擅长它，能从中得到快乐，所需要付出的努力远远超过仅仅将它作为一个爱好。延伸到一个人的工作其实也是如此。如果你热爱它，时刻想着它，不停地花时间打磨它，思考自己如何才能做得更好，工作就成了你的乐趣的来源。一旦你和自己的工作建立了这样的关系，工作就不仅仅是工作了，它是你生活的一部分，也是你自我的一部分，它会影响到你是如何看待自己与这个世界的，也会影响到你和他人的相处方式。看来人还是要有一个爱好的，哈哈。过去的我一直觉得工作就只是工作而已，要是没有玩滑板、轮滑，我可能不会像现在这样思考。感谢轮滑。</p><h4 id="9-月-10-日-中秋快乐"><a href="#9-月-10-日-中秋快乐" class="headerlink" title="9 月 10 日 - 中秋快乐"></a>9 月 10 日 - 中秋快乐</h4><p>今天是中秋节，节日快乐！这次中秋没有回家，因为上上周刚回过一次，再过几周就国庆了，所以想等国庆再回，虽然不能一家团圆，不过感谢现代科技，只要有手机和互联网，无论到哪里都能见到家人。我发现我现在越来越喜欢一个人了，有时候只是宅在家里看书、看视频，自从开始玩轮滑之后，也慢慢开始喜欢一个人出去刷街了，还在想以后要不要买辆自行车，然后一个人去更远的地方探索，就像我最近关注的 <a href="https://www.youtube.com/watch?v=M2GKtKH0_QI">vlog 博主</a>一样。已经放到自己的愿望清单里了，哈哈。我在想，人有时候可能会身在福中不知福吧，我现在的生活在刚大学毕业那会儿的自己眼中，一定太无趣了，但是此刻的我却觉得，这样就很好。有一点自己的时间做自己喜欢的事，生活节奏不快也不慢，有自己喜欢的工作，有值得探索的事，也有一个人生活的乐趣。虽然有时候会觉得有些孤单，但是，这可能就是我所需要付出的代价吧。轻松、自在、随意、安静的生活，这就是我想要的。至于其他的，随遇而安吧。</p><h4 id="9-月-11-日-独身主义"><a href="#9-月-11-日-独身主义" class="headerlink" title="9 月 11 日 - 独身主义"></a>9 月 11 日 - 独身主义</h4><p>我有信仰吗？答案似乎是 no，但是好像也不全是，因为我还是有自己坚持的东西的，比如我相信善行总会给人带来好运。我不想被强迫去做某件事，也不会强迫他人去做他们不愿意做的事。我知道这个世界上有很多种不同的生活方式，每个人都有权利选择以他们的方式度过自己的一生，只要不影响他人，没有哪种生活方式是应该受到指责的。平淡也好，冒险也好，哪怕有人放弃收入丰厚的工作去体验流浪汉的生活，我觉得只要是他自己做出的决定，那么其他人也没什么好评判的。我也渐渐意识到，我们这个时代是拥有无限多的选择的时代，但是选择多也意味着人们容易失去生活的方向。我们活着到底是为了什么？过去有宗教王权，现在呢？有政治，有体育和娱乐新闻，有银行账户，有数不清的奶头乐，但是，我们还是容易找不到意义。也许古老的教诲才是对的吧，只有家庭和责任感才是一个人最终的归宿。但是，现代人对家庭的信任感也已经不那么强了，而且各种花费包括子女的教育成本等等，也让人感到压力重重，这也是为什么越来越多人选择独身主义。我是其中的一员吗？算是吧，但是我的想法有些不同，我只是更喜欢一个人。听起来挺糟糕的吧，但是，我也暂时不想改变这一点，走一步算一步吧。</p><h4 id="9-月-12-日-学会表达感谢"><a href="#9-月-12-日-学会表达感谢" class="headerlink" title="9 月 12 日 - 学会表达感谢"></a>9 月 12 日 - 学会表达感谢</h4><p>昨晚看完了请回答1988 最后一集，看到结尾才意识到这部剧其实是以拍摄一个胡同里的年轻人的青春时光来赞美亲情、友情和爱情。怪不得这部剧那么受欢迎，普通人一生追求的不就是这几样东西吗？看完剧后我也在想，我要怎么做才能拥有像剧中人物一样的人际关系呢？那种彼此深深纠缠在一起的社区关系，依靠、依赖彼此的同时又彼此关心、照顾，从内心里希望对方能够过得幸福和快乐。其实能够拥有这样的家庭关系就已经很难了，更不要说和原本只是陌生人、没有血缘关系的邻居了。我觉得一个很重要的因素是，你们必须在很长的一段时间内陪伴过彼此，一起度过了风风雨雨，见证过彼此不堪、脆弱的一面，鼓励、支持过对方，非常了解彼此的性格和为人，再加上一点点机缘巧合，才能形成像剧中人物之间那样紧密的人际关系。当然，人也很重要，你们必须都是和善、有同理心、关心他人的人。看起来的确很难拥有这样的关系。哪怕人生中遇到一两个这样的人，和他们形成了这样的关系，那我也知足了。不过，我觉得还有一点非常值得向剧中人物学习的是，要学会<strong>经常表达自己的感谢</strong>，无论是对父母还是友人，感谢他们的付出，如果没有他们在我们背后的默默支持，我们可能不会变成今天的样子。虽然对于有的人来说，这样的情感很难用语言来表达，但是我们可以用自己的方式来表达，比如写邮件和文字消息。一旦想到某个人，想到他对你的人生产生的影响，哪怕只是朋友圈的一句话，你想要向对方表达你的感谢，那就要及时说出来，让对方知道。哪怕不是立即告诉对方，至少还可以写下来，然后将文字发送给对方。不要浪费自己内心的情感，而表达感谢是培养起心中的爱的最佳手段。</p><h4 id="9-月-13-日-如何训练美感：多看"><a href="#9-月-13-日-如何训练美感：多看" class="headerlink" title="9 月 13 日 - 如何训练美感：多看"></a>9 月 13 日 - 如何训练美感：多看</h4><p>昨晚看了一集圆桌派，讲的是审美，一个多小时的长度没想到自己居然从头到尾看完了。不过，看这些作家、艺术家一起聊天还是挺有意思的，挺长见识。我对美学这个话题其实没什么兴趣，因为就连我也知道美有很多种欣赏方式，即使是一坨屎也有创作空间，比如袋熊拉的便便是干燥的方糖形的。至于更广义的什么东西才能称为是美的，这个就更加见仁见智了。尽管如此，我还是认为品味是有高低的。因为品味说到底反映的是一个人的见识和个人修养，没有人会否认蓝色多瑙河远比某些流行歌曲更优雅、更雄浑有力，而且品味其实是通过比较才能体现出来的。不过说到底，想要拥有一双美的眼睛其实很简单，多看、多观察就好了。以油画为例，当你看过各个时期、各种流派、各位名家所做的无数的画作之后，你自然就学会了分辨什么是好的油画。当你看过无数时装杂志，见过各种各样的时装走秀，和很多优秀的时装大师一起工作，学习了很多服装设计知识之后，你对服装搭配自然就会变得特别敏感，也能立马分辨出什么是好的设计和搭配。看来一切都逃不开刻意练习，哪怕并不刻意，就算只是足够长时间地暴露在一种环境之下，你也会受到足够多的影响，然后变成那方面的专家。</p><h4 id="9-月-14-日-回忆与当下"><a href="#9-月-14-日-回忆与当下" class="headerlink" title="9 月 14 日 - 回忆与当下"></a>9 月 14 日 - 回忆与当下</h4><p>最近有点怀旧，时不时地会去翻过去的老照片，尤其是毕业前后刚工作那会儿的照片，也许是在怀念那时候的青春吧。但是回忆的时候，看到的都是美好的一面，看不到的是那时候的迷茫和内心的慌张，而照片上只有年轻和美好。其实每个年龄段都有自己的优劣势，现在的我相比五、六年前，变得更现实了，不会再去做一些不切实际的梦，但也对自己的能力有更清晰的认知。即使这样，我也明白，再过几年，我可能还是会觉得现在的自己太愚笨、太鲁莽，浪费了太多的时光。<strong>不要让回忆过去成为一种逃离当下的手段，要从自己的过往经历中得到经验教训。</strong>反思自己，如何纠正自己过去犯下的错误，看看自己能在哪些方面不断改进，如何变得更好，这才是我们应该要做的事。未来会怎样我不知道，此刻的我也暂时没有找到清晰的目标。但是，短期内的目标还是有的，那就是把手头的事情做好，过好自己的每一天，保证充足的睡眠，每天锻炼，合理饮食，保持断食的习惯，冥想、阅读。保持乐观，保持微笑，照顾好自己的身体、心灵、情绪和意志力。</p><h4 id="9-月-15-日-旅行的意义"><a href="#9-月-15-日-旅行的意义" class="headerlink" title="9 月 15 日 - 旅行的意义"></a>9 月 15 日 - 旅行的意义</h4><p>这两天晚上看了很多旅行 <a href="https://www.youtube.com/channel/UCrcDPAshreK6gXlDIrDgYjQ">vlog</a>，我觉得阳离子的视频吸引我的地方在于，总是能从一个特别的角度看到平凡事物的有趣、可爱、美好的一面，这也提醒了我，要学会转换视角，即使是身边那些已经习惯了的事物，也有其值得仔细观察的一面。其实旅行的意义在于去看自己过去不曾见过的东西，去体验自己没有体验过的生活，去认识平时生活中接触不到的人，去品尝每一种普通食物在另一个地方的味道，去和自己喜欢的人一起探索这个丰富多彩的世界。我觉得她重新教会了我什么是旅行。我也觉得，即使是一个人，也应该保持好奇心去探索自己身边和周围更广阔的世界，哪怕没法去到非常远的地方，但我对我生活的周边很多地方还不是非常熟悉，而且也有很多值得探索的地方。是时候打破自己的旧习惯，在某些个周末去独自探索这些地方了。</p><h4 id="9-月-16-日-奶奶去世"><a href="#9-月-16-日-奶奶去世" class="headerlink" title="9 月 16 日 - 奶奶去世"></a>9 月 16 日 - 奶奶去世</h4><p>昨天下午接到堂哥电话说奶奶过世了，今天下班后就和老姐、姐夫一起回家了。想起爷爷去世那会儿，我还在上初二，某天晚自习还没结束就被老爸接回了家，院子里摆满了酒席桌子，一群群的人围在一起打牌、聊天。那时候我们家住在大伯家隔壁，爷爷灵堂设在大伯家，老爸带着我进到大伯家大堂，给了我一柱香对着爷爷的遗像拜了三下，然后就让我去折元宝了。这次也是同样的流程，只不过人好像少了很多，可能是因为我们到家比较晚了吧，只有两桌人在打牌，然后姑姑、嫂嫂们围在一起在折元宝。我待了没多久就回家了，和家人们好像也没什么话可聊的了，可能是因为太久没见到了吧。晚上洗澡的时候在想，老爸现在应该是最需要关心的时候吧，毕竟，从现在开始，他没有爸爸妈妈了。我不知道对于他这样年纪的人，对妈妈的感情会是什么样的，但是我觉得内心里一定是会回忆起关于妈妈的最美好最柔软的记忆吧。我对奶奶的印象不多，小时候妈妈和奶奶的关系不怎么好，但是我并不讨厌奶奶，因为我到现在都还记得她在我放学后摘枳椇给我吃的样子。虽然她很少主动关心我们，但是每次去爷爷奶奶家，只是喊她一声，她都会笑得非常开心。他们那代人过得真的非常辛苦，老了之后有各种疾病缠身，活到 88 岁，走了其实也算是一种解脱吧。老爸嘴上虽然对奶奶很凶，但是我想他内心还是希望她能一直无病痛地生活下去的吧。只是到了她这个年纪，很多事情也身不由己了，腿脚不好需要人照顾，而且也得不到足够的尊重。人生啊，总是充满了苦难。想到自己未来也要度过这样的阶段，就不由得感到难过。但是，在那之前，我还是要振作起来，为自己爱的人，照顾好他们是我的责任。</p><h4 id="9-月-18-日-奶奶出殡"><a href="#9-月-18-日-奶奶出殡" class="headerlink" title="9 月 18 日 - 奶奶出殡"></a>9 月 18 日 - 奶奶出殡</h4><p>今天奶奶出殡，昨晚在沙发上躺到 1 点多，实在睡不着然后就起来了，一边折元宝一边练习冥想，想到昨晚封面的那一幕，心里还是有点忐忑，那是我最后一次碰到奶奶的头发吧，以后就再也见不到她了。到 4 点钟的时候，老妈来给大家烧早饭了，其他家人们也陆续起来了。吃完早餐后差不多 4 点半，八仙还没来，于是有人提议应该放火炮提醒一下大家。中间还出了一个小插曲，早餐包子不够吃，然后老妈叫我去给姐夫他们买小笼包，小笼包店刚开门，结果还没等他们做好就听到放火炮以为要出发了，姐夫开车来接我，于是匆匆忙忙去其它早餐店随便买了点什么，给老姐送去后再回去。到 5 点钟的时候，灵车来了，大家戴上了白帽，最后一次给奶奶上香，然后八仙抬着奶奶遗体上灵车。中间场面一度陷入混乱，因为在一片敲锣打鼓声中，大家没提前决定好哪些人坐灵车上，只能扯着嗓子贴着彼此的耳朵沟通。5 点半的时候，其余人也都准备好开车出发去火化场了。我们这辆车中途还走错了路，往市区绕了一圈。到了之后才发现，原来火化也这么繁忙，一波波人来，一波波人走，每个人脸上都写着疲惫，悲伤都排在第二位了。一小时之后，火化结束，大伯抱着骨灰罐，二伯拿着临行物品，老爸拿遗像，小姑父拿雨伞，我们对着奶奶遗像上完香，然后出发回家。回去路上，不停地看到前面车上撒下来元宝，过桥的时候还会撒硬币，老妈说这叫「过路费」。8 点钟回到大伯家的时候，大家都早就在等着了，火炮声不断，我们把花圈和花篮都搬到路边，所有人再一次对着奶奶遗像上完一柱香，然后正式开始出殡。由于我们村比较小，所以送葬队伍会绕着村子周围，去到村外的马路上绕一圈，然后再上山去公墓。我拿的是写着老爸名字的花圈，老爸和大伯们在抬轿，中途我回头望了一眼送葬队伍，一眼看不到尾。到了公墓，把骨灰盒放下之后，整个出殡过程就结束了，剩下的事我没看到，听说是会进行一些仪式，然后是封墓碑。接下来还有最后一个仪式，那就是迎奶奶遗像。结束之后，一看时间才 8 点半，此时的我大脑已经昏昏沉沉了。好不容易挨到中午，吃完午饭回去洗了个澡，然后就躺倒在床上了。无论发生什么事，都不要叫醒我。</p><h4 id="9-月-19-日-第一次尝试大三轮"><a href="#9-月-19-日-第一次尝试大三轮" class="headerlink" title="9 月 19 日 - 第一次尝试大三轮"></a>9 月 19 日 - 第一次尝试大三轮</h4><p>今天大三轮到了，花了半个小时装好底座，然后去楼下试滑，发现速度和续航真的比 80*4 的轮子好很多，迫不及待去江边刷了一圈回来，体验满分。以后刷街应该会更轻松了，而且也能去更远的地方了。</p><h4 id="9-月-20-日-小女孩给我的启发"><a href="#9-月-20-日-小女孩给我的启发" class="headerlink" title="9 月 20 日 - 小女孩给我的启发"></a>9 月 20 日 - 小女孩给我的启发</h4><p>今天晚上在江边玩轮滑的时候碰到一个小女孩，骑着一辆粉色的自行车主动过来和我搭讪聊天，告诉我好多关于她自己和她的家人的事。不过我现在都忘得差不多了，只记得她的名字。不由得感叹现在的孩子真的都挺外向的，我小时候在不太熟悉的亲戚面前都不怎么敢说话，可是她却可以很自然地在陌生人面前分享自己的一切。这也提醒了我，要向她学习，和人交朋友其实很简单，分享自己的故事，同时也对对方的一切感兴趣，这就够了。我们小的时候其实对身边的一切都很好奇，所有东西看起来都是那么的有趣，然而长大之后却一个个都带上了冷漠的面具，以为只有这样才像是个大人，但其实这样只会让我们显得更加无趣。如果你能把身边的所有人都看作是值得认识、了解的伙伴，那么，好玩的、有意思的事情就永远也挖掘不完。</p><h4 id="9-月-21-日-卡尔萨根的《宇宙》"><a href="#9-月-21-日-卡尔萨根的《宇宙》" class="headerlink" title="9 月 21 日 - 卡尔萨根的《宇宙》"></a>9 月 21 日 - 卡尔萨根的《宇宙》</h4><p>今天看了二爷的<a href="https://mp.weixin.qq.com/s/9Nh2u2ZbviM3iZ9mV3rAEA">一篇文章</a>，讲的是卡尔萨根的书《宇宙》，不由得又让我浮想联翩了。的确，相比整个宇宙，我们的生命，哪怕是整个人类的历史，在浩繁的宇宙中也只是沧海一粟，我所知道的一切，人类文明所有的高潮和低谷，那些历史上曾发生过的无数著名事迹，都发生在银河系偏远角落里的一颗蓝色星球上。这么看来，似乎一切都没有我们想象的那么重要不是吗？但是，光是能够意识到这点就让我感到神奇，毕竟我们身上的组成部分和无边无际的星际空间中的物质是一样的，也许有一部分能量正是来自它们。然而我们居然产生了意识，居然能够开始思考自己的起源，并且寻求进一步探索更多的未知。生命包括人类的智慧才是这个宇宙中最最神奇的事物。尽管如此，即使心中有再多的感慨，生活总归还是要继续。我觉得我们能从宇宙中学到的一点是，思考自己生命的意义，寻找生活的目标，不再被那些负面思维所困。当我们感到愤怒、悲伤的时候，一个有效的控制自己的情绪的方式是问自己几个问题：我是谁？我是一个碳基生命，由一颗人类的受精卵发育而来。我在哪？银河系猎户臂内测边缘的太阳系中的一颗蓝色星球上。我现在在做什么？无论我是如何不能接受现状，或者对发生在自己或他人身上的事不满意，这并不能改变现实，我只能改变自己。</p><h4 id="9-月-22-日-人的烦恼之源"><a href="#9-月-22-日-人的烦恼之源" class="headerlink" title="9 月 22 日 - 人的烦恼之源"></a>9 月 22 日 - 人的烦恼之源</h4><p>晚上去江边刷街的时候，再次碰到了前晚遇到的小女孩，又听她聊了很多，她的家人，她在学校发生的事，在画画课上遇到的人，等等，我虽然装作在漫不经心地听着，但其实内心还是觉得挺开心的，因为她差不多是我最近生活中唯一一个愿意这样和我毫无保留地分享自己生活的人。也有可能是我独居太久了吧，已经忘记了应该怎么和陌生人相处了。也不由得感叹，假如我们每个人都是这样和彼此相处的话，那么这个世界会变得多么美好。不过，仔细想想我也可能会讨厌那样的世界，因为我不想走到哪都被人「骚扰」，尤其是当我不想说话也不想听别人说话的时候。有时候我只想一个人安静地坐着，听着轻音乐，看着眼前的风景。这个世界总归是不完美的吧，一个人的时候想要找个人摆脱孤单，身边有朋友或爱人在的时候，我们又会嫌弃他们和自己没有太多共同话题，或者觉得他们太吵。除了身体上的病痛之外，人所有的烦恼都是由人际关系带来的。我现在特别赞同这句话。即使你过着一种完全独居的生活，也还是会因为人际关系而烦恼，也许这就是人的宿命吧。</p><h4 id="9-月-23-日-公正对待自己"><a href="#9-月-23-日-公正对待自己" class="headerlink" title="9 月 23 日 - 公正对待自己"></a>9 月 23 日 - 公正对待自己</h4><p>如何保持内心的平静？最近发现，其实快乐很简单，以乐观的态度看待身边的一切，多笑笑就可以了。然而在与其他人接触的过程中，还是会感到内心的平静被打破了。自我怀疑，觉得自己不会说话，或者说错了话让别人不开心，等等。我其实非常不擅长和人打交道，但总是装作自己擅长社交的样子；内心其实无比慌乱，但是表面上却又装作从容淡定；有时候让人觉得姿态太过清高，甚至到了难以接近的地步，但其实只有我自己才知道，这是因为我内心的自卑、虚弱在作怪。意识到这一点之后，其实问题就已经解决了一半。接下来要做的是，不去批判自己，不要在内心自我贬低，更不要嘲笑自己，<strong>要公正对待自己</strong>。是的，我们总是习惯了对别人客客气气的，有时候却忘记了对待自己也要足够公正客气，做的好的地方要及时表扬，做的不好的地方也不要揪着不放，下次改进就好了。只要你有心，你就能注意到自己的点滴改进和成长。还有就是，接纳自己的普通，但是要做一个普通而又自信的人。</p><h4 id="9-月-24-日-探索市区内的公园"><a href="#9-月-24-日-探索市区内的公园" class="headerlink" title="9 月 24 日 - 探索市区内的公园"></a>9 月 24 日 - 探索市区内的公园</h4><p>今天下午出去刷街，在地图上随便选了一个目的地然后就出发了。由于身上穿着厚厚的护具，加上背着个包，不一会儿就热得不行了，想找个地方休息，于是走了一条小路。虽然是在河边，但是绿道显得特别破旧，周边景色也是灰拉拉的。但是，过了一个桥洞上了一个小坡之后，景色居然完全不同了，河对面是刚建好以及正在建的错落有致的崭新办公楼，而这边是一个安静的小公园，草坪修剪得整整齐齐，河边一排排柳树的枝条在随风飘荡，河里的水体虽然有些混浊，但是水面波光粼粼，阳光下一切都显得十分美好。我找了一个爬满青藤的小亭子坐下来休息，周围没什么人，安安静静，我的内心也感到特别安宁。我特别喜欢城市里像这样的静谧无人的地方。突然意识到，我其实可以把探索市区的小公园作为自己短期内的目标。回来路上依旧选择走江边的路，有树荫，而且傍晚的时候人、车都比较少，累了还可以随时在路边的长椅上休息。当我望着江对岸发呆的时候，看着路边散步的老人，牵着手走过的情侣，带着孩子骑车的爸爸妈妈，突然想到，假如我不再需要工作了，我会选择如何度过自己的每一天呢？每天玩玩轮滑，或者尝试其它的运动，然后呢？我生命的意义是什么？我应该怎么做才能创造出更大的价值？没有答案，这样的假设本就是没有意义的吧。</p><h4 id="9-月-25-日-珍惜眼前的每件事物"><a href="#9-月-25-日-珍惜眼前的每件事物" class="headerlink" title="9 月 25 日 - 珍惜眼前的每件事物"></a>9 月 25 日 - 珍惜眼前的每件事物</h4><p>越来越觉得「想要更多」是打破内心平和状态的首要因素。这也是为什么我所接触的所有积极心理学都在告诉我们，要学会感恩和知足。当然，这并不是说我们就应该满足现状，不思进取，不再追求更好。虽然更好是最好的敌人，但是这的确是驱动我们行动的原动力。我想要达到的状态是，看什么是什么。当看到一个行动不便的老人时，我不会想到自己未来也有可能会因为衰老而不再能做很多事，而是只是看到他而已。他一生中有许多回忆，他有自己的老伴和子女照顾他，他也会感到幸福。这才是一个人的真实状态。每个人都会老去，这是生命的规律，我所能做的只有在有限的生命中创造出足够多的连接，为他人创造价值，迎接更多的挑战，用行动改变自己和所处的环境，为自己的生命增加更多的体验，去感受过去不曾感受过的思想和情绪。放弃那种负面思维，进行一些不必要的「同情」和为自我感到悲伤。只有这样，我才能以更加临在的状态面对我遇到的每一个人和每一段经历。环视一遍你周围的环境，每一件事物都自有其意义。多想想它们是如何取悦你，为你提供了什么样的价值，不要再想着「假如我拥有了某物则如何如何」。看到每件事物的价值，不去联想更多，这是一件需要不断练习的事。</p><h4 id="9-月-26-日-像小女孩一样开心"><a href="#9-月-26-日-像小女孩一样开心" class="headerlink" title="9 月 26 日 - 像小女孩一样开心"></a>9 月 26 日 - 像小女孩一样开心</h4><p>九月马上就要结束了，给自己的十月寄语是：希望自己能够每天开开心心，过一种简单而又纯粹的生活。</p><h4 id="9-月-27-日-过好自己的生活就是在帮助他人"><a href="#9-月-27-日-过好自己的生活就是在帮助他人" class="headerlink" title="9 月 27 日 - 过好自己的生活就是在帮助他人"></a>9 月 27 日 - 过好自己的生活就是在帮助他人</h4><p>除了学会感恩之外，我这两天也意识到自己身上的一个问题，那就是有时候容易陷入自责的情绪。有时候觉得自己不该过得这么「奢侈」，一想到我的家人或者远方的某些人还从来没有享受过我所享受的服务或者产品，就觉得我应该克制自己的欲望，过得再简单一些，然后把钱省下来留给他们或者捐出去。有时候还会想，自己做一些不产出任何价值、只是为了让自己开心的事，是不是有点太自私了？毕竟这个世界上还有人吃不饱饭或者营养不良。虽然我的时间、我的生命都应该由我自己来决定如何度过，但是另一方面我又觉得自己有义务为更多人奉献自己的时间和生命，毕竟众生皆苦。所以，关键是如何找到一个平衡点吧。一方面的确要学会感恩，珍惜自己已经拥有的一切，从身边的简单事物中找到快乐；另一方面，也要意识到，地球上生活了 80 亿人，需要帮助的人太多太多，而我们也只是普通人，品德、见识、能力都有限，只能先照顾好自己后再去考虑他人的幸福。还有就是活在当下，不要明明过着眼前的生活但却又在担心生活在其它地方的其他人，这样帮不到任何人。该享受的时候就好好享受，你只有把自己的生活过得更好才能帮助到更多的人。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我爱轮滑</title>
      <link href="/2022-8/"/>
      <url>/2022-8/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/jbPLUrBzNFs" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>夏天马上就要结束了，如果要为这个夏天打分的话，我觉得可以给它打 7 分吧，关键词有：烈日下的柏油路、车库里的轮滑印、带着冰霜的绿豆雪糕、柳树荫之下水面之上成群的蜻蜓、不同饱和度的粉色晚霞，以及流汗、流汗还是流汗。如果要用一句话总结的话，那应该是：我终于可以出门刷街啦！</p></blockquote><span id="more"></span><h4 id="8-月-1-日-行动第一"><a href="#8-月-1-日-行动第一" class="headerlink" title="8 月 1 日 - 行动第一"></a>8 月 1 日 - 行动第一</h4><p>越来越意识到一个自己身上的一个问题，那就是我所知的很多东西其实并没有转化为实际行动。比如我认为热爱自己的工作应该是一个人最基本的人生信条，但是我自己却并没有这样做。的确，从某些方面来看，我是喜欢自己的工作的，但是，远远没有达到热爱的程度。再比如，我认为每个人都应该养成自我表达的习惯，但是实际上我却是个非常不愿意表达的人。我和身边人的关系，只能说只是维持了基本的相互间尊重而已，我并没有深入了解对方，而且我内心也并不是真的对对方感兴趣。之前写过几次知易行难的话题，我觉得行之所以难，是因为我们从知道到最终付出行动，往往还有很多步要走，而有的人在行动之前又容易想得太多，所以凭白给自己添加了很多困难。我觉得对于像我这样的人来说，需要重新学习的一件事是，如何做到直截了当地去做事，在脑海里各种想法出现之前，先行动起来，看看会发生什么，这样就不会因为思虑太多而错失机会了。很多事情都是要等你勇敢迈出第一步之后，才能迎来后续的成功，或者失败。如果你连第一步都迈不出，那么连成功的可能性都不会有。</p><h4 id="8-月-2-日-为健康的身体而感恩"><a href="#8-月-2-日-为健康的身体而感恩" class="headerlink" title="8 月 2 日 - 为健康的身体而感恩"></a>8 月 2 日 - 为健康的身体而感恩</h4><p>怎样才能让自己更加感恩呢？记住人的生命并不是永恒的也许会有帮助，还有就是人本身的脆弱性，一个人很容易就会失去身体健康，但是往往健康的人很少会去思考这一点，普通人只有当遭遇了某种疾病或者事故之后才会感到原来健康是多么的宝贵。因此，学会感恩要做的第一件事是感恩自己拥有一个健康的身体，对于身体有残障的人来说，则可以把注意力放在自己已有的能力上。我有时候会幻想，假如我失去了身体某部分的正常功能之后，我要如何生活。其实，失去任何一种身体功能都将会对人造成毁灭性的打击，更不要说失去了很多项功能的人，这点真的要切身体会之后才能明白。比如之前我左手摔骨折的那次，仅仅是不能正常完成使用双手才能完成的事，就已经让我感到非常无助了，更不要说失去更重要的能力了，很难想象得到那种孤独和绝望。所以，一个人一定要首先照顾好自己的身体，不但要保持健康，还要让它变得更加强壮。不但要让自己变得更健康，还要去帮助那些需要帮助的人。只有当社会上更多的人开始意识到这一点，意识到残障人士的不容易，我们才能保证万一自己失去了健康，也会得到相同的照顾。毕竟，即使没有意外，我们每个人也都是会走向衰老的，人衰老的过程就是逐渐失去身体基本能力的过程，耳朵听不见，眼睛看不清，行动能力下降等等，所以，我觉得尊老、爱老真的是个非常好的传统，每个人都能从中受益。</p><h4 id="8-月-3-日-成为一个温暖的人"><a href="#8-月-3-日-成为一个温暖的人" class="headerlink" title="8 月 3 日 - 成为一个温暖的人"></a>8 月 3 日 - 成为一个温暖的人</h4><p>普通人即使做不到为社会整体做出巨大的贡献，但是至少可以做到成为一个负责任且温暖善良的人，这点是我这两天在看《请回答1988》时候的最大的感想。剧中几个家庭，虽然彼此无亲无故，只是邻居，但是几家人的相处真的如同亲人一般，小到平时互相分享自己家中做的菜，大到别家有事时互相帮助、照顾，几个家庭的孩子也相处地很好，像兄弟姐妹般，这样的邻居真的太难得了。我觉得他们能相处成这样，最大的原因是，这几家人的家长都是心地善良的人，而且都见过彼此穷困、落魄的一面，所以都能体谅彼此的不容易，而这种互帮互助是让彼此感到温暖的最佳方式。我觉得孩子在这样的环境下长大，成为一个坚强、独立、有爱、温暖的人是大概率的事。剧中的每个孩子虽然都有自己的缺点，但是基本上都具有前面说的那些优点，这样的人即使未来无法成为一个大人物，无论如何也都一定会成为一个负责任又温暖的人。这样的人代表着一个幸福的家庭，也一定是一个好伙伴、一个好员工。我的目标就是成为这样的人。我从来都不是一个温暖的人，至少从外表上看不出来，但是，我内心也希望成为一个可以勇敢表达自己态度的人，为爱的人做自己想为对方做的事。而且，我从来不擅长表达，尤其是语言上的表达，但是，有时候表达爱和喜欢往往并不需要多么丰富和华丽的辞藻，简单的一句话也能体现出你对他人的注意、关心和爱。所以，难的还是变得有同理心，有一颗真正能够体谅他人想法的心才是我最需要学会的事。</p><h4 id="8-月-4-日-一切经历自有其意义"><a href="#8-月-4-日-一切经历自有其意义" class="headerlink" title="8 月 4 日 - 一切经历自有其意义"></a>8 月 4 日 - 一切经历自有其意义</h4><p>回顾过去，我最重视的能力是什么呢？应该是在任何情况下都能保持平静的能力。但是，不得不承认，我并没有做到这一点。不过，我觉得我最大的优点是乐观，而且是一个理性的乐观主义者。我知道这个世界上造成人与人之间的差别的，不完全是因为一个人的出身或者与生俱来的某些特质，而是他具有的信念。我相信人是可以成长的，并且大多数技能都是可以习得的，只要你投入足够的心力和时间。那么，造成我们之间差异的原因也正是因为有的人愿意投入足够的时间和精力去学习某些他感兴趣的事物，而有的人却认为自己天生不是那块料。所以，有的人可以不断挑战新事物并且从中获得智慧，哪怕只是一些经验和感悟。人活着最重要的也是这一点，去不断收获新的体验，去不断尝试，拓展自己的能力边界，在这一过程中认识自己以及这个世界。幸福和痛苦都是正常的现象，但是只要我们抱着体验的态度，那么，这一切又有什么关系呢？事后回想起来，那些只不过是我们人生的一个片段而已。只要始终抱着学习的态度，则一切经历自有其意义。想想看，假如你对待你所做的每件事情都采用这样的态度，你的生活会发生多么大的变化。</p><h4 id="8-月-5-日-高雄心、低期待"><a href="#8-月-5-日-高雄心、低期待" class="headerlink" title="8 月 5 日 - 高雄心、低期待"></a>8 月 5 日 - 高雄心、低期待</h4><p>任何生理和心理上的不适应，都可以通过练习来解决，既然如此，为什么我们还是不能始终都感到幸福和快乐？如果一个人已经尽可能多地训练了自己，尝试了所有可能的练习，弥补了自己所有的短板，但是，却依旧无法获得幸福，那么，很大的可能是，他并不是真的相信自己可以获得幸福，所以，他会更加努力地去寻找自己身上那些无法被改变的缺点，以此来证明自己是不可能获得幸福的。不要做这样的人。虽然我们每个人都不完美，但是始终都具备获得幸福的条件，没有人是例外。哪怕是极端不幸的人也可以获得幸福，只要他愿意放弃和其他人去比较，专注于自己能做到的事情上，珍惜自己已经拥有的东西，学会感恩，那么，快乐和满足自然就会降临。花尽量少的时间去甄别出那些自己改变不了的事情，然后在自己能够改变的事情上拼尽全力，不要在意结果，享受努力的过程。就像 James Clear 说的，有雄心是好事，但是也要学会降低自己的期待，这有利于让自己保持动力、行动果敢，同时也容易感到满足。</p><h4 id="8-月-6-日-用行动抵抗消极和虚无"><a href="#8-月-6-日-用行动抵抗消极和虚无" class="headerlink" title="8 月 6 日 - 用行动抵抗消极和虚无"></a>8 月 6 日 - 用行动抵抗消极和虚无</h4><p>时隔多年，再次体验了通宵是什么样的感觉，我以前以为我可能再也不会通宵了，因为没有什么事是值得我牺牲一晚睡眠的，但看来我还是低估了沉迷对人的影响。不过也好，这也算是一种体验吧，而且让我收获了以往没有的看待事物的视角。人是被各种各样的故事驱动的，当我们自己不再相信过去深信的某个故事的时候，我们就会感觉到，人生好像突然失去方向一样，我们会不知所措，所以开始去寻找替代品，以满足自己内心的空虚以及摆脱惶恐的情绪。包括我们喜欢看电视、电影、小说也是一样，我们喜欢从他人的故事中寻找真实感。一个好的故事总是让我们感到满足，也能让我们在情绪上感到放松和舒适。然而正是这些我们碰巧遇见的有时候是无意有时候是有意的选择，将我们造就成了此刻的样子。所以，当我们觉得自己需要改变的时候，也会参照过往这些故事中的人物，去为自己寻找可能的人生路线。但是，事实上，没有人知道我们应该如何度过自己的一生。我们到头来可能会发现自己年轻时所追求的一切其实并不是自己真正想要的，虽然眼下的人生也算符合世人眼中的幸福，但是我们的内心还是会隐隐觉得不对劲，可能这就是人生最大的悖论吧。如果一个人做不到坚定地选择一个方向，去努力探索发现他心目中的「良质」，他就永远也无法感到自己是在有意义地活着，甚至经常会有如上所说的那种感觉。所以，我觉得关键还是要做到足够投入啊。对于眼下的一切，如果感到不满足，那就要付出更多的努力，而不是勉强接受现状而又懒于改变。行动起来吧，这是我们面对消极和虚无时的唯一正确的解决方案。</p><h4 id="8-月-7-日-每一天都是新的一天"><a href="#8-月-7-日-每一天都是新的一天" class="headerlink" title="8 月 7 日 - 每一天都是新的一天"></a>8 月 7 日 - 每一天都是新的一天</h4><p>经过一天的休息和调整，今天总算是恢复过来了，这也让我感到年轻是真好，哪怕是通宵，也只需要一天的时间就能恢复。昨天从早上开始睡觉，睡到下午 3 点多自然醒，写完碎碎念热完身之后去车库玩轮滑，中间休息的时候发现今天是阴天，也不怎么热，所以决定去江边刷街。虽然出了一身汗，但是感到全身舒适，看着自己轮滑有进步真的很开心。这样看来，其实每天都是新的一天，无论你前一天过得多么不堪，只要第二天能够以全新的态度去积极面对，照样可以过得充实而又活力十足。我也明白了，其实人生并没有那么复杂，找到自己想做的事，充满热情地去过好自己的每一天，仅此而已。至于爱，我不知道它是什么，我觉得没有人能说清它是什么。但是，我知道喜欢和爱的区别，对一个人好不是爱，爱是希望对方好，希望对方过得快乐、放松而又满足。我虽然不知道如何爱一个人，但是我知道喜欢上一个人的感觉。不过，目前来看，我更愿意将时间花在自己身上，花时间去取悦自己。其实，我内心还是相信爱情的，所以我愿意花时间等待。我也知道自己并没有想象中的那么好，所以还是要继续努力，去充实自己，去变得更加乐观豁达，去让自己能够承担起更大的责任，只有这样，才会有能力去爱一个人，并且让对方过上彼此都想要的生活。也许很难，但是人生不就是为了解决各种各样的难题吗？毫无目标和压力的生活还是留给别人吧。</p><h4 id="8-月-8-日-反对反对视频"><a href="#8-月-8-日-反对反对视频" class="headerlink" title="8 月 8 日 - 反对反对视频"></a>8 月 8 日 - 反对反对视频</h4><p>最近看到一条推，大概意思是要避免任何形式的视频内容，看了之后有点不认同，但是又不知道该如何反驳。的确，我刷推有时候也会看一些无聊的搞笑视频，而且在 YouTube 上看的很多视频其实对我来说并没有什么用。但是，我依旧认为视频是我生活中很重要的一部分，完全抛弃掉视频的话，可能会失去很多乐趣。比如我一直在追的《我住在这里的理由》，基本上每期都会完整地看完，我觉得自己还是能从中得到一点东西的。虽然这样的记录片记录的只是别人生活中的一小部分，不能看作是完全真实的生活，但是，我觉得任何一种艺术创作都是这样，尽是真实也就失去了真实。我们生活在一个物质丰富的时代，所以大多数人并不会满足于日常的生活，还会想要尽可能多的体验，但是，并不是所有人都有足够的金钱和时间去亲身体验这些自己没有做过的事，所以，通过他人记录下来的视频就是非常好的替代方式了。我觉得这就是视频的意义所在。包括所有的电影、电视剧、戏剧和小说，其实都是这样。通过艺术化的创作，讲述一个故事让你去体验，至于你能从中得到什么，就要看你自己了。我的过往经历会影响到我解读某个事物或某个行为的方式，反过来，从这些艺术创作中，我也能收获到一些新的视角，从看待事物的方式到以何种态度去生活，哪怕只是获得了一时的快乐和满足，如果这就是你当初想要追求的目标，那也足够了。所以，我觉得没必要去批判视频这种媒体形式，无论是何种类型的视频，只要你觉得自己能从中有所收获，那就没问题，没必要太在乎别人怎么说。</p><h4 id="8-月-9-日-阶级重要吗？"><a href="#8-月-9-日-阶级重要吗？" class="headerlink" title="8 月 9 日 - 阶级重要吗？"></a>8 月 9 日 - 阶级重要吗？</h4><p>看到一篇文章，<a href="https://mp.weixin.qq.com/s/ICIekY9VTa8Htzk5VAzcmw">为什么有的人没有阶级意识</a>，的确，我应该就是作者所说的没有阶级意识的人，但是我非常不赞同作者的结论以及叙事方式。阶级是否存在？当然存在，但是我认为你所在的阶层只是限制了和你交往的人，并不会限制你的生活方式，普通人依然可以活得幸福快乐。而且阶级说白了只是人与人之间的差异，这种差异是由经济水平、教育水平、思维方式、行动能力、社会关系等决定的，无论社会如何发展，只要我们还活在市场经济中，这种差异将永远存在。然而，就像我前面说的，这种差异并不会影响你选择何种生活态度或者生活方式。虽然经济条件差的话意味着你会失去很多选择权，但是你依旧可以过得幸福和快乐，这点在大多数普通人身上就可以看到。按照这篇文章中的阶级分法，大多数人应该都属于底层社会，只有一小部分人才有可能往上迁移，我也位于底层社会中的 7 级，然而现实是，这并不影响我的生活，我甚至还感到非常自在和满足。因为我知道，无论一个人处于什么样的状态，如果不能享受当下，欲望大于能力，那么他永远也不会感到满足，等待他的将是无止境的为了权力和金钱的忙碌、奔波。我并不想要这样的状态。虽然我眼下的生活，由于经济能力、社交关系等原因，我的选择比他们少很多很多，有很多事我没法去做，但是我并不会因此就感到苦恼，因为我只要能做好我能做也想做的事就可以了。至于那些无法满足的欲望，其实对我来说并不会造成那么大的困扰，因为它们在我眼里永远都有替代品。还有羡慕甚至是嫉妒的情绪，我觉得这就是人性的本来面貌，我可以训练自己，让自己变得没那么敏感，也可以选择只关注自己影响圈范围之内的事物。无论如何，我觉得人的首要任务是认识自己和了解世界，还有就是寻找幸福和安宁。幸运的是，在我们当下这个时代，无论你处于什么样的阶级，都有可能实现这三点，唯一需要的是你个人的努力，以及拥有一颗充满好奇但又始终保持理性的平常心。</p><h4 id="8-月-10-日-平常但值得珍惜的事物"><a href="#8-月-10-日-平常但值得珍惜的事物" class="headerlink" title="8 月 10 日 - 平常但值得珍惜的事物"></a>8 月 10 日 - 平常但值得珍惜的事物</h4><p>有时候觉得生活太无趣了，但这显然是我自己的问题，因为是我选择了这样的生活。但转念一想，固定的生活节奏其实也有好处，那就是更容易获得平静。有时候也会想要一些意外和惊喜，但现实中往往是以不那么好的方式出现的，普通人只能祈求少出点意外，平静度过每一天就是最好的。所以，我真正需要培养的习惯是，从平静生活中寻找到幸福，那些只有你认真反思之后才能意识到能够拥有它们是多么幸运的事。我能立马想到的有：健康的身体、爱你的家人、聊得来的朋友、喜欢且有一定挑战性的工作、有意思的爱好、美食、好电影、好听的歌。这些平凡普通的东西，往往才是最值得珍惜的东西，因为等到失去它们的时候，你才能明白它们对自己的意义。所以，我们每天都应该提醒自己，多花时间和注意力在这些自己平时容易忽略的事物上，感恩自己此刻还能拥有它们。由此，你才能意识到自己是多么的幸运，也才容易感到幸福和满足。</p><h4 id="8-月-11-日-设定更好的目标"><a href="#8-月-11-日-设定更好的目标" class="headerlink" title="8 月 11 日 - 设定更好的目标"></a>8 月 11 日 - 设定更好的目标</h4><p>最近发现自己越来越难坚持阅读这个习惯了，晚上洗完澡之后就开始刷 YouTube 或者上小 P 站解压放松，联想到这两天看的文章，一篇是关于<a href="https://www.nytimes.com/2022/08/07/opinion/media-message-twitter-instagram.html">社交媒体对人的注意力的侵蚀</a>，另一篇是 Steve Pavlina 的<a href="https://stevepavlina.com/blog/2022/08/how-to-win-against-your-favorite-distractions/">如何战胜让你分心的事物</a>。我觉得社交媒体方面自己做的还算不错，基本上已经断绝了使用，只是偶尔才打开一下用来打发碎片时间，但是，我觉得这个习惯也得改，哪怕只是碎片时间使用也会让人逐渐习惯这种高多巴胺分泌的事情。Steve Pavlina 提出了一个解决方法，那就是意识到这些让你分心的事物到底占用了你多少时间和精力，让你失去了完成很多项目和计划的可能性。我们应该给自己制定更好的目标，让自己始终把这些目标放在心中的第一位，这样一来，那些让自己分心的事物对我们来说就不再具有那么强的吸引力了。简单来说就是通过设立更有吸引力的目标，建立意义感，从而让自己不再容易感到分心。我觉得这是非常有效的建议，很多时候，一些让我们分心的事物其实算不上多有趣，我们只是想要通过它们逃离当下，或者只是为了打发时间，避免让自己感到无聊、尴尬、不舒服等等。如果我们明确地知道自己想要做的事有什么样的意义，如果我们的目标足够有吸引力，那么，我们完成它们的意愿会强于一切，也就不会想要在那些让我们分心的事物上花费太多的时间了。</p><h4 id="8-月-12-日-以记录的态度去分享"><a href="#8-月-12-日-以记录的态度去分享" class="headerlink" title="8 月 12 日 - 以记录的态度去分享"></a>8 月 12 日 - 以记录的态度去分享</h4><p>越来越觉得分享其实在于一个人的心境。当你越是觉得自己没什么东西值得分享的时候，就越会习惯于有所保留。其实你遇到的一切都值得分享：你工作中遇到的难题以及解决方式，你觉得有意思的事情或一些小玩意儿，你看待事物的方式，日常的感悟，还有那些让你感到开心、难过、郁闷、兴奋、激动的时刻。也许你会觉得这些东西是你一个人的事，但是如果你能养成分享的习惯，无论是通过文字、声音还是视频，那么你的表达就会被记录下来，被他人看到，那么就有可能对他人造成影响。我们每个人都只是在经历自己的人生，对一个人影响最大的也是最近一段时间内的生活，如果你不去刻意记录，那么这一段人生就会悄无声息地溜走。这也是我当初选择创建数字花园的初衷，用来记录自己的一切。虽然我们每一天的生活都有相似之处，但是每一天又都是独特的，我们有一些新的感悟，遇到了新的人，发生了一些新的事，记录下我们的应对方式、思考过程，也许对自己和他人都能造成一些有意义的启发。所以，尽可能多地去分享吧。</p><h4 id="8-月-13-日-热爱和找到与现实世界的联系"><a href="#8-月-13-日-热爱和找到与现实世界的联系" class="headerlink" title="8 月 13 日 - 热爱和找到与现实世界的联系"></a>8 月 13 日 - 热爱和找到与现实世界的联系</h4><p>越来越觉得热爱的重要性，最近看到一个关于给想学配音的人的建议的<a href="https://www.youtube.com/watch?v=d6cqTmsNMoI">视频</a>，我才意识到，原来做你喜欢的事是这么重要，哪怕你需要面对的是异常激烈的竞争，以及需要面对非常严苛的条件，只要你是真的热爱它，那么，无论处在何种环境中，最终你都会找到办法去实现它。这也更加坚定了我的信念，不要做一个随波逐流的人，不要受世俗观念影响去追求那些看起来理所应当的东西，比如房、车、金钱。当然，这些东西很重要，但是远不如有一件自己热爱且愿意无条件为之付出的事情来的重要。虽然我现在依旧不知道自己热爱什么，但是我知道自己能做什么，我可以以它为基准，去付出更多的时间和精力，把它做得更好。创造出更大的价值是我的目标。人生看似很长，但是如果你想要把自己喜欢的事情做好，那就得付出大量的努力。我们不应该追求安逸享乐，因为那只会败坏一个人的品格，懒惰、贪婪、欲望会逐渐吞噬人的一切美德。只有不断付出辛劳的汗水，无论是精神上还是肉体上，哪怕是看似重复无趣的劳动，最终，我们也能从中找到意义。</p><p>过去我常常在虚拟世界中寻找意义，比如通过游戏和电影，但是，此刻的我却觉得，除非我们可以将整个大脑上传，能够模拟人类所有的神经元活动，包括思考和感受情绪的能力，我们始终无法摆脱对现实世界的依赖，我们依旧需要照顾好自己的肉身才能活得快乐。我们必须像我们的祖先一样去奔跑跳跃，和同类面对面地接触交流，去流泪流汗，才能让自己不丧失人性以及保持理智。我们和动物的优势在于，我们不用为食物发愁，甚至可以选择什么都不做也不至于饿死，但是，我们的理性思维能力却驱使我们去不断迎接新的挑战，去行动、探索、发现这个世界。我们不应该把自己置于任何生物之上，但是，我们却可以用行动改变自己、他人甚至是另一个物种的未来，我们应该利用这种能力去造福我们的同胞和其它生物。</p><h4 id="8-月-14-日-与他人的关系"><a href="#8-月-14-日-与他人的关系" class="headerlink" title="8 月 14 日 - 与他人的关系"></a>8 月 14 日 - 与他人的关系</h4><p>过去我常常觉得自己和他人不一样，所以总是很难做到共情，现在觉得其实是自己观念的问题。虽然我们看待事物的角度、追求的目标有些许的差别，但是这并不影响我们在当下相处的那一刻感受彼此的善意和真诚。要知道，我们每个人都经历了从出生到孩童时期，再到青少年时期，最后才走向成人阶段，虽然此刻的我们身上有着许多的差异，比如外表、谈吐、见识、审美、学识等方面，但是这些并不能改变我们都是凡人这一事实，我们最终都将走向死亡。既然如此，没必要感到太骄傲，无论你是谁；也没必要感到自卑，其实对方和你一样。也许我最需要的就是这种豁达的态度吧，理性看待自己与他人的区别，但是又不至于太过执着。要意识到我们都只是一样的人类，既然能在此刻遇到彼此，那就是缘分，好好珍惜当下的关系。做真实的自己，而且也希望对方能表现出他们最真实的自我，尽量让彼此都能享受这一片刻的轻松，能做到这样就很好。一直以来，我都把和他人的相处看得太严肃了，其实放松点就好，毕竟我们都没那么重要。当然，工作时表现得严肃一点是正常的，只不过没必要一直保持这样的姿态。如果放松太难的话，那就保持沉默吧，当个耐心的聆听者也不错。</p><h4 id="8-月-15-日-新闻的意义"><a href="#8-月-15-日-新闻的意义" class="headerlink" title="8 月 15 日 - 新闻的意义"></a>8 月 15 日 - 新闻的意义</h4><p>昨晚又不小心打开了一个讨论乌克兰的视频，然后去看了在战争中心生活的 youtuber 的视频，心里感到同情的同时又感到庆幸，还好这样的事没有发生到自己身上。我一直觉得，新闻的意义就是让大家知道在另一个地方发生的事情，但是，新闻媒体永远也不会告诉你真相，而是会选择一个立场，然后以此为出发点来描述事件。如果你真的感兴趣的话，应该自己去到当地，才能知道到底发生了什么。所以，我从来都不觉得看新闻有什么用，把时间花在自己身边的人以及你所能影响到的世界才更有意义一些。不过，看到这样不幸的新闻有时候会让人觉得应该珍惜当下，我们所拥有的一切都不应该被认作是理所当然的，要思考为什么自己能够比别人拥有得更多，只是因为幸运吗？如果是这样的话，那么我们就应该更努力地工作，来让自己对得起这份幸运。还有就是，永远不要因为他人的不幸而过度担忧，要相信事情总是向着好的方向发展的。如果失去了乐观，那么你的生活也会变得一团糟。除此之外，也要多多关注那些美好的事物，比如一些各地旅游的 vlog，要认识到这个世界是多么的广阔，你没去过的地方那么多，这个世界上生活着几十亿人几千种不同的文化，所以我们才要更加努力，以后才能有机会去见识这些有趣的人和事。</p><h4 id="8-月-16-日-听取多方意见"><a href="#8-月-16-日-听取多方意见" class="headerlink" title="8 月 16 日 - 听取多方意见"></a>8 月 16 日 - 听取多方意见</h4><p>表达自我以及和他人建立联系与维持独立思考这两者之间是否矛盾？前者意味着我们要把自己的观点表达出来，然后学会聆听和接受他人的观点，而这一过程中你的观点有可能会与他人观点有出入，所以你会修改，甚至会放弃原来的观点，转而接受新观点。更常见的情况是，你从他人那里听到了一个新观点，你还没有来得及对其仔细思考就接受了他人的观点，并且因此埋下了偏见的种子。很多时候，尤其是在我们还比较年轻的时候，我们从被自己仰望的「明星」那里听到了一些新的观点，但是这些观点不见得都是经过反复推敲、被充分论证过的，但是我们却像信仰一样毫不迟疑地接受了它们。也许等到多年以后，当我们的阅历增加，或者通过阅读学习之后才会意识到，原来当初的想法是这么地初级、幼稚，也许还充满偏见和刻板印象。而且我相信有很多人正是因为在年轻时候就被植入了很多这样的偏见，又没有得到独立思考能力，所以才会慢慢变得容易激动，尤其是在听到不同观点之后。所以，我觉得我们在年轻的时候，一定要养成<strong>听取多方观点</strong>的习惯，像查理芒格一样，用正反两方的观点相互博弈，最终胜出的才是你应该采纳的观点。这种策略在做决定的时候尤其有用，你要比你的对手更清楚一个决定的弊端在何处，然后才有可能规避掉绝大部分的风险，从而增大获得成功的可能性。</p><h4 id="8-月-17-日-生命短暂，活出价值"><a href="#8-月-17-日-生命短暂，活出价值" class="headerlink" title="8 月 17 日 - 生命短暂，活出价值"></a>8 月 17 日 - 生命短暂，活出价值</h4><p>每当感到感伤的时候，我就会翻出 Leo Babauta 的这篇 <a href="https://zenhabits.net/fleeting/">On the Shortness of Life</a> 看一看，提醒自己，虽然生命中充满了各种各样的不如意，但是要记住，每一天都是宝贵的，你应该珍惜它，利用好它，而不是去抱怨。即使我们面对的是不堪和琐碎事务，那又有什么关系呢，我们的肉身即是一个道场，只要还活着，我们就可以掌控自己。相比过去，活在这个时代的我们已经非常幸运了。既然如此，那就好好活，不但要让自己和家人生活得幸福和快乐，还要努力让身边所有人都因为我们而受益，这才是值得追求的长远目标。</p><h4 id="8-月-18-日-轮滑与心流"><a href="#8-月-18-日-轮滑与心流" class="headerlink" title="8 月 18 日 - 轮滑与心流"></a>8 月 18 日 - 轮滑与心流</h4><p>这两天玩轮滑再次感受到了心流的状态，一个很重要的原因是学会了使用跳跃式切换倒滑，而且左右两边都掌握了，所以常常跳来跳去，虽然很累，但是真的乐在其中。昨晚下了雨，车库地面被进进出出的车子沾得很湿，只能找到一小块比较干的地方练习倒滑，然而就是这样在一小块地方练了一小时的倒滑和切换，让我感受到自己的倒滑技巧有了很大的进步，这也再次让我感受到了刻意练习的作用。晚上洗完澡后又看了很多进阶的视频，比如倒滑 T 刹、反向 Powerslide、倒滑 Crossover 等等，不过，目前还是要先学会更多的刹车技巧，比如 powerslide 和 soul slide，然后是 power stop，magic stop 和 parellel stop。随着一点点进步，还想着要把自己的装备慢慢升级，不过我觉得还是得防止自己一心沉迷于升级装备，因为我发现过去大多数的爱好最终都变成了研究装备的游戏，爱好本身反而被搁置了。不过，好像不止我有这样的「困扰」。总而言之，运动对我来说是一种放松，而且也很少有运动能够像轮滑一样，带给我这么多的快乐的同时也能让我体会到酷的感觉，每天迫不及待想要做的事之一就是晚上去玩轮滑，就是不知道这样的热情还能维持多久，希望能尽可能地久一点吧。</p><h4 id="8-月-19-日-尽可能多地探索"><a href="#8-月-19-日-尽可能多地探索" class="headerlink" title="8 月 19 日 - 尽可能多地探索"></a>8 月 19 日 - 尽可能多地探索</h4><p>晚上看了一个视频 <a href="https://www.youtube.com/watch?v=Mmdxs_0yYwc">cycling home from China</a>，看完之后发了很长时间的呆，内心也想要去做这样疯狂的事，虽然明知道不可能。而一旦意识到自己永远也不可能做出这样的决定之后，内心会感到一阵沮丧。我回想了一下自己过去二十几年快三十年的人生，似乎并没有像这样称得上是「疯狂」的事件。但是，我觉得更关键的问题在于，我虽然不是一个从众的人，也知道听从自己的内心很重要，但是我似乎没有什么特别伟大的目标，比如一定要完成某件事或者成为某种类型的人。没有人生目标听起来好像不是什么大问题，但是仔细想想还是挺可怕的，尤其是在看了这样子的视频之后。只是觉得人这一生总要做点什么吧，虽然没法改变什么，但是总得让人觉得自己的生命是有意义的。对我来说，意义来自于哪里呢？用自己的技能为他人创造出更大的价值？获得更多的体验？提升自己和家人的生活质量？与爱人共同养育后代？这些可能都算是吧，但是目前来看，对我吸引力都不是太强，而且实践起来似乎也都很困难，很难从每天按部就班的工作和生活中获得这些，尤其是对一个独居且性格有点孤僻的青年来说。不过，我觉得我能做的，只有尽可能多地去探索，虽然时间和资源都有限，但是这并不能阻挡一个具有好奇心的人。</p><h4 id="8-月-20-日-「农民阶级」的生活态度"><a href="#8-月-20-日-「农民阶级」的生活态度" class="headerlink" title="8 月 20 日 - 「农民阶级」的生活态度"></a>8 月 20 日 - 「农民阶级」的生活态度</h4><p>发现自己有点讨厌「中产阶级」这个词，我从来都不认为自己是其中的一员，我的父母一直属于半工半农的群体，我记得我小时候家里有猪圈，养着农村里经常见到的猪、鸡、鸭等，我妈那时候下了班之后还得去打理菜园子，然后我就屁颠屁颠地跟在后面，后来我们搬了新家，虽然没了猪圈，但是爸妈还是在后院的空地上种上了各种各样的菜，一直到现在，他们下了班之后最常去的地方还是菜园子。我虽然生活在城市里，工作是办公室里写代码的程序员，但是我依旧不喜欢中产阶级这个词，因为这个词在我的脑海中通常是一个人爱抱怨、不懂得人间疾苦、欲望随着收入水平而不停上涨的代名词。我虽然已经不像我爸妈一样能劈柴种菜，但是由于我从小见惯了这些又脏又累的体力活，所以底子里还保留着人必须能够吃苦耐劳、从简单事物中获得快乐和满足的观念，这是我和中产阶级最大的区别。虽然我知道人性本来就好逸恶劳，但是由于我有我的父母，我知道我这辈子都不会完全走向那种不知感恩、只会及时行乐的作风。我并不想批判任何人，因为我知道每个人都有权利选择自己的生活，但是我只是觉得那样子的生活会让人失去很多东西，比如明白自律和感恩的价值。我希望自己能一直保持这样子的生活态度。</p><h4 id="8-月-21-日-应对意外的心态"><a href="#8-月-21-日-应对意外的心态" class="headerlink" title="8 月 21 日 - 应对意外的心态"></a>8 月 21 日 - 应对意外的心态</h4><p>看了昨天的碎碎念，语气好像有点欠揍，想删掉但最终还是决定保留下来。我觉得无论是什么样的言论，只要写出了自己当时内心的真实想法，那就没必要太在意，反正是写给我自己看的，也许 5 年、10 年后的我看了会觉得好玩呢。周末在家又开启了疯狂刷剧模式，昨晚看 1988 的时候想到一个问题，如果我发生了意外该怎么办？第一，我身边没有要好的朋友，也没有相处得好到可以照料彼此的邻居或室友，可能只有麻烦爸妈了吧。这么一想就觉得好惨。也有点担心万一以后自己玩轮滑真的摔成了重伤要怎么处理。我想这就是独身久了的坏处吧。我也开始理解为什么长辈们都劝我们要关心自己的终身大事了，毕竟我们都是依赖他人才能生存的物种，哪怕你的身体非常强壮，从不生病受伤，那至少也会慢慢老去，等到身体机能衰退的时候，总归会有一些需要他人的照料的时刻。也许是我想得太远了吧。虽然道理如此，但是毕竟此刻的自己还不用担心这些，不要因为这些还未发生的事情影响了自己的好心情。未雨绸缪是对的，但是如果因此而变得胆小怕事就没必要了。我觉得自己此刻能做的，首先是相信自己能够独自抗过一切，哪怕是再大的困难，只要能做到不放弃自己，积极寻求解决办法，无论是求助他人还是靠信念支撑，最终都能熬过去的。再有就是不要怕犯错，既然意识到了问题，那就去寻找躲避这种风险的方法。毕竟人只要是真的想改变，最终一定是可以做得到的。要对自己有信心。最后就是不要忘了享受当下，珍惜自己此刻拥有的一切，不要去和他人比较，因为那根本没意义。活在当下，学会感恩，这才是过得幸福的关键。</p><h4 id="8-月-22-日-探索式旅行"><a href="#8-月-22-日-探索式旅行" class="headerlink" title="8 月 22 日 - 探索式旅行"></a>8 月 22 日 - 探索式旅行</h4><p>昨晚睡前看了一个 <a href="https://www.youtube.com/channel/UCrcDPAshreK6gXlDIrDgYjQ">YouTuber</a> 的视频，主要是一个美国女生和中国老公在中国的各种偏远地带游玩探索的 vlog，可能只有我觉得是偏远地带吧，反正对我来说只要往北超过北京，往西超过成都，往南到云南和广西的南部地区，就都算是比较偏远了。我去过的地方很少，基本都是和小伙伴出去旅游的时候才能接触到祖国的大好河山，所以每次看这些视频的时候都有种开眼界的感觉。不过，真要让我去过那种不停旅行并且生活在路上的生活，我可能也不太喜欢，主要是食物、睡眠、金钱等，而且我也不太擅长处理突发事件，按部就班的生活可能更适合我一些。所以，我还是更喜欢看旅行 vlog， 既能享受到开阔视野和体验当地风土人情的目的，又不用承担前面提到的那些额外的负担，再加上偶尔也可以亲自出门去旅行探索，对我来说这就足够了，这就是我认识这个世界的方式。不过，我也意识到，其实旅行时的心态很重要，如果你是带着看美景的愿望，那么很多时候可能会失望，因为美景永远要结合天时地利才能看到，但是，如果你是带着探索的心态，那么任何你在日常生活中较少接触到的事物就都是旅行的一部分了，这点我觉得这个 vlogger 就是个典范。所以，我也在培养自己这种探索的心态，哪怕只是去探索这个城市中我没去过的地方，那也是一种旅行，也会有很多好玩的事情发生。</p><h4 id="8-月-23-日-积极主动"><a href="#8-月-23-日-积极主动" class="headerlink" title="8 月 23 日 - 积极主动"></a>8 月 23 日 - 积极主动</h4><p>昨天碎碎念中说到要学会探索身边的世界，然后晚上就看到了一条实操的<a href="https://www.youtube.com/watch?v=OAb3zkwdpF8">视频</a>，视频中小妹妹说的差不多就是我想要表达的观点：一个人也可以享受独处时光。不过，我觉得自己和其他人不一样的地方在于，我对在现实中交朋友的态度有点偏消极。我觉得大多数朋友都只是一起消磨时光而已，称不上是可以交心、坦诚表达自己所有观点和过往的朋友，所以，我更喜欢一个人，无论是做自己喜欢的事情还是一个人消化负面情绪，而且我也不会觉得特别孤独。虽然偶尔会有这样的感觉，但基本上都是因为其它事情导致的，比如工作上、生活中遇到了一些挫折和困难。当然，我并不排斥交友，因为我在网上遇到过很多非常好的人，虽然从来没有见过他们，但是我知道如果他们在我的生活中，我一定会经常向他们倾诉和请教一些问题。不过，我也意识到这样的态度其实并不好，因为很多时候其实是因为你并不了解对方。只有在日常生活中经常接触，你才能知道对方是什么样的人。所以，不要放弃接触新朋友，多参加一些线下的活动，克服害羞和恐惧的心理，学会主动搭讪。只有这样，才能慢慢扩展自己的朋友圈，认识到更多有趣的人。我的目标是每年都要认识 10 个新朋友。嗯，加油，行动第一。</p><h4 id="8-月-24-日-中文的口头表达"><a href="#8-月-24-日-中文的口头表达" class="headerlink" title="8 月 24 日 - 中文的口头表达"></a>8 月 24 日 - 中文的口头表达</h4><p>不知道为什么，总觉得我的文字表达和口头表达隔着一道屏障，每次看自己写的文字总是觉得太书面化了，我想要达到的目标是文字和口头表达使用的是相同的语言，让人看了就像是在听另一个人说话一样。可能中文的确很难做到这一点吧，因为中文里有很多词汇是在口头表达中不会使用到的，而且在写作的时候，人会不自觉地想要使用正确的语法，这样一来和口头表达的区别就很明显了。还有就是中文天生就更适合书面表达，因为文字所包含的信息更多，能表达同一种意思的方式也更多，为了准确表达自己的意思，你的用词也必须足够准确，这样一来，所需要的思考时间也就更长，所以通常更适合一个人安静地写作。另外，很容易观察到的一个现象是，在对复杂的概念进行阐述时，说中文的时候往往不如使用其它语言表达来得流畅，当然也有一些能流畅表达自己想法的人，但是总体来说，要达到那种程度，需要更多时间的练习。我也联想到，这可能就是使用中文进行喜剧创作更难的原因。我在看一些脱口秀的时候，听英文的脱口秀笑的频率明显高于中文，哪怕两段脱口秀的质量和笑点数量都差不多。我猜这也是为什么郭德纲这么受欢迎吧，因为的确能让人开口笑。当然，喜剧表演需要掌握的不仅仅是语言，还有对观众心理的把握。说来说去，我觉得这些都是借口，最主要的原因还是自己练得太少，因为有的人就可以做到把写出的文字像说出的话一样，而且通俗易懂、简单明了，比如阮一峰。我还要很长的路要走哪。</p><h4 id="8-月-25-日-对时间的感知的差异"><a href="#8-月-25-日-对时间的感知的差异" class="headerlink" title="8 月 25 日 - 对时间的感知的差异"></a>8 月 25 日 - 对时间的感知的差异</h4><p>在连续十几天 40 多度的高温天气之后，昨天终于降温了，所以，我也终于不用在地库玩轮滑了。下了班换上鞋子就往小区外冲。沿着新浦河绿道来到江边，路上有点湿滑，不过这基本是去江边最快的路了。来到最近的绿道驿站练倒滑和刹车，精疲力尽、又累又渴之后才决定回小区，路上还负气地和电瓶车比速度，结果那老哥故意超过我又在我快追上时再加速骑一段距离，也是个挺爱玩的家伙。回到小区，在楼下练了会儿前后切换才上楼，一看时间，居然才过了 40 分钟。如果是在地库，玩相同的时间可能才刚刚感到热身结束吧。这让我想到，在不同的情境下，人对时间的感知真的是不一样的。所以，每天重复相同的生活的确会让人觉得时间过得很快，而如果我所做的事情总是带着新鲜感和挑战性，我对自己生命的长度的感知可能也会完全不同。其实就是想提醒自己，不要过重复的生活，每天都要尝试做一点不同的事情，哪怕是非常微不足道的小事，这样既能提高自己的生命质量，也能变相提高生命的长度。</p><h4 id="8-月-26-日-如何面对无意义感"><a href="#8-月-26-日-如何面对无意义感" class="headerlink" title="8 月 26 日 - 如何面对无意义感"></a>8 月 26 日 - 如何面对无意义感</h4><p>虽然经常提醒自己要知足，但是有时候还是会被突然袭来的无意义感包围，我也知道意义感来自于责任感，并且也可以从很多种渠道获得，比如家庭和工作，但是夜晚一个人的时候还是会忍不住瞎想。看影视作品、听歌、看书、跑步、冥想，无论从事什么样的活动，当你无法聚焦在当下的时候，你就不是真的在做某件事，而是通过它转移自己的注意力。人的注意力是最宝贵的资源，当你无法好好利用它的时候，你就会感到特别沮丧。可能就像辉哥说的，我们都需要 something bigger than ourselves 才能更好地生活下去。无论如何，至少还可以用「活好每一天」作为自己的目标，因为我知道这种时不时的无意义感会一直伴随着自己。所以，至少对于今天这一天，我要照顾好自己的身体和心灵，锻炼、阅读、完成好自己的工作，然后用剩下的时间去做能让自己享受、沉浸其中的事。</p><h4 id="8-月-27-日-一些值得思考的问题"><a href="#8-月-27-日-一些值得思考的问题" class="headerlink" title="8 月 27 日 - 一些值得思考的问题"></a>8 月 27 日 - 一些值得思考的问题</h4><p>昨晚和老姐、姐夫、表妹一起回到了家，已经两个多月没回家了，这次趁着这两天下雨降温所以回来过个周末。每次回家对我来说都是一种抽离，从原来习惯了的生活中抽离出来，重新审视我自己和自己周围的一切，我的工作、生活、和其他人的关系等等，这些都是一个人在习惯了某种生活节奏之后，很少会主动去思考的东西。我觉得我现在的一切都很好，也不想要任何改变，但是家人不一定同意我的看法。讽刺的是，有些特别爱折腾的人，他们的家人只希望他们能好好地过日子。所以，这世上根本就不存在完全让人满意的状态吧。降低期待，过好自己的生活，不要随意评价他人，尊重每个人自己的选择，这大概就是我能做的全部了。我也常常提醒自己，你没法满足所有人的期待，有些话默默听着就好了，不要让它们影响到自己。一个人的幸福只能靠他自己的努力才能获得。</p><p>你的思考方式、积极的行动、默默的付出、积累的善行，哪怕是在无所事事中度过的时间，这些最终都会反映到你的身上，此刻的你是过去的你所做出的无数选择造就的，所以，想要改变就得从此刻开始。想清楚自己的优劣势，我要怎么做，才能在维持独立的同时，兼顾好自己的身心健康；在获得成就感和意义感的同时，也能让他人受益？我应该给自己制定什么样的目标，我应该如何度过自己的人生？我要如何分配自己的时间和精力？什么东西对我来说是最有价值的，我最珍视的是什么？我生命中最重要的人是谁？我要怎么做才能增加他们的福祉？我喜欢什么，讨厌什么，让我感到恐惧和焦虑的是什么，我要如何战胜它们，或者要怎样才能和它们和平相处？我已经取得哪些成就，我需要继续努力的地方又有哪些？对于人生的重大课题，工作、交友和爱，我要怎样做才能更好地拥有它们并维持好平衡？这些都是很难回答但是又是每个人不得不面对的问题，在接下来的几年里，甚至很有可能一生都要不停地面对它们，我能做的，只有鼓起勇气，直面挑战。从书本中，在他人的帮助下，去不断经历，持续学习和反思自己，才有可能慢慢找到答案。</p><h4 id="8-月-28-日-感恩生命"><a href="#8-月-28-日-感恩生命" class="headerlink" title="8 月 28 日 - 感恩生命"></a>8 月 28 日 - 感恩生命</h4><p>虽然我经常提醒自己要心怀感恩之心，我有很棒的家人，不错的工作，有时间做自己喜欢的事，能过上自己想要的生活，这样就已经非常幸福了，但是有时候还是会忘记这些，会感到苦恼和沮丧，这些负面情绪都是不必要的。我也开始意识到，其实我是个非常幸运的人，并没有付出太多的努力但是就已经拥有了这么多，这点最主要的原因是卵巢彩票，我出生的这个时代、这个国家、这个家庭，所以才有了现在的结果。虽然人生总是很难，有各种各样的痛苦，但是也有各种各样的让人感到欣喜和幸福的时刻，每每想到它们就让人觉得这一切都是值得的。很高兴能来到这个世界，能够见到这个五光十色、绚丽多彩的世界是我的幸运。所以，人生的关键在于你是如何看待自己和这个世界的吧。无论是什么样的经历，无论是好是坏，即使再苦再难的日子，也是一种体验。我享受我的人生，我爱我遇到的每个人，虽然不是每一段经历都是好的，也不是每一个人都值得我付出时间和精力，但我还是爱他们，为我们的相遇，为我们彼此人生中有过的相似的经历，为此刻我们共享的时空。过去看过很多讲灵性和博爱的电影，我从来没有真正看懂过，现在也不懂，但是，我觉得以「我们本质上都是一样的生命」的态度，去对待自己身边遇到的所有人，这就是我此刻最为坚定的信念之一。</p><h4 id="8-月-29-日-胸怀宽广"><a href="#8-月-29-日-胸怀宽广" class="headerlink" title="8 月 29 日 - 胸怀宽广"></a>8 月 29 日 - 胸怀宽广</h4><p>听过很多智者的教诲，要在正确的年龄做正确的事。对我来说，此刻最需要的思考的问题是，要不要找一个人安定下来？我想过一些场景，两个人的确需要花很多时间磨合，会产生很多矛盾，彼此的生活会深度缠绕在一起，除了工作之外，你所有的时间也不再是可以自由支配的了。但是，两个人的生活也有很多幸福之处，比如一起探索周围的世界，分享彼此的一切，感到孤单的时候至少还有个人可以倾诉，无论发生什么事都有对方一起分担，共同抵御风险和未知的未来，等等。唯一的问题是，我内心其实非常害怕把自己分享给另外一个人，害怕不被接纳，也害怕自己无法给对方幸福。虽然我知道这种害怕是不必要的，人每时每刻都在改变，我也有不错的学习能力，况且有很多人并不比我厉害，但是却也能给他们爱的人幸福，所以我也不应该太过担心。可是，内心还是无法说服自己。不过，无论怎样，我觉得自己应该改变，首先是要变得更加 social，不要太封闭自己。我想要变得更加活跃，和其他人度过一些轻松快乐的时光，而不是在社交上显得非常笨拙。我想要认识更多有趣的人，无论性别和年龄，我想要更加广泛地体验这仅此一次的人生。但是，这些都需要我打破过去的习惯，变得更加开放和胸怀宽广，也只有这样，我才能容纳更多人进入自己的生活。</p><h4 id="8-月-30-日-工作焦虑"><a href="#8-月-30-日-工作焦虑" class="headerlink" title="8 月 30 日 - 工作焦虑"></a>8 月 30 日 - 工作焦虑</h4><p>害怕打开自己的另一个原因是对自己的能力的怀疑，表现形式之一就是对自己工作的担心。我觉得自己的工作不怎么好，虽然收入足够我的生活，但是我并不为自己的工作感到自豪，也就是并不十分热爱自己的工作。所以，我就没法很自然地和别人谈论自己的工作，我心里总是觉得未来一定会有更好的机会，但是内心十分清楚，可能性并不大。而且我对自己的职业生涯也没有特别清晰的规划，总是觉得走一步算一步吧，这样一来，当工作上遇到难题的时候，我很容易就陷入焦虑的情绪。想要改变这点，但是又不知道从哪里开始。我没有什么具体的目标，短期内也看不到更好的选择，所以只能维持现状。但内心其实明白，这种现状是不稳固的，总有一天会被打破。然后像以往一样，被逼着去反思和做选择，而这种情况下做出的选择，其结果往往并不是我想要的，因为并不是我主动追求的，但是又苦于没有更好的解决方案，所以只能接受它。打破这种循环的方式其实我早就知道了，那就是去拥抱现实，哪怕这现实会让自己感到痛苦，主动去尝试新的可能性，追求自己想要以及可能实现的目标。过去我总是喜欢逃避，一旦获得了一个看似不错的结果就不再前进，所以我总是一次次被痛苦倒逼着去思考下一步。这一次，我想要改变这种习惯，勇敢去尝试、创造新的机会和挑战。</p><h4 id="8-月-31-日-学会合作和分享"><a href="#8-月-31-日-学会合作和分享" class="headerlink" title="8 月 31 日 - 学会合作和分享"></a>8 月 31 日 - 学会合作和分享</h4><p>一直以来，我都是一个 lone wolf，习惯独自行动，一个人完成工作，但是时间久了也会觉得不对劲，因为这样一来，我所做的工作都是一些不大的项目，如果是一个特别大的项目，需要与很多人合作，我反而会觉得不适应了。这也是我想要改变的理由之一。人终究是社交动物，需要与他人的合作才能获得进步和成长。虽然我现有的工作方式比较适合我，但是其实有时候也可以尝试下不同的模式，也许能带给自己新的启发也说不定。还有就是要以客观公正的态度看待自己，不要看不起自己，也不要高看自己。我的真实能力是怎样，我的优点有哪些，我的缺点又有哪些，我要如何扬长避短？如何才能最大程度发挥出我的优势，如何让更多的人因为我的工作而受益？我要怎么做才能克服胆怯，去主动分享自己所知的并帮助到更多的人？越是思考这样的问题，就越是能发现，其实很多问题都是相通的，无论是工作和家庭，职场和交友，其实都需要我们展现出自身价值，帮助他人解决问题，变得更加宜人才行。反过来，当你需要帮助的时候，他人也会主动伸出援助之手。一旦你创造出了这样的环境，你会发现一切都会变得非常舒适，任何人都可以是你的伙伴，你的生活会也变得容易许多。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Choose Positivity</title>
      <link href="/2022-7/"/>
      <url>/2022-7/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/gY2ekm_krNU" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>七月，感觉时间过得非常缓慢，但是回忆的时候，就只剩下在车库练轮滑的画面了。有时候觉得自己阅读了太多的文章，看了太多的视频，如果那些时间不是这样被「荒废」掉，也许就能产出更大的价值，比如完成自己早就想要完成的开源库，看完只看了一半的书，安静地听一首歌，学会一个新的单词或短语。然而，说到底，不浪费自己的时间的想法就是一个妄念，无论一个人处于什么样的阶段，只要他做的事不是被视为最有价值的，只要他内心还在自我怀疑，那他就永远也不会感到满足。为自己做一些无意义的事真的是在浪费时间吗？真的很难说。但是，维持个人基本的纪律和养成好习惯还是有必要的，如果不加限制，每个人都希望生活在无止境的放纵中，一个人懒惰、贪婪、暴虐的本性也就会逐渐滋长。</p></blockquote><span id="more"></span><h4 id="7-月-1-日-获得独立和进步"><a href="#7-月-1-日-获得独立和进步" class="headerlink" title="7 月 1 日 - 获得独立和进步"></a>7 月 1 日 - 获得独立和进步</h4><p>我真正的目标是什么呢？虽然说不出什么具体的目标，但是我觉得<strong>获得真正的独立</strong>应该算是吧。除此之外，每天都要问问自己，我是变得更狭隘、更无知了，还是在不断进步？我是否具备足够的勇气去承认自己的不足？我有没有在努力克服自己的缺点？变得更好是一条永无止境的路，成为一个更好的人意味着要：具备更强的能力 -&gt; 接受更大的挑战 -&gt; 创造更多的财富和知识 -&gt; 激励他人 -&gt; 让我们所生活的社会变得更好。这就是我所追求的目标和人生。</p><h4 id="7-月-2-日-改变自己"><a href="#7-月-2-日-改变自己" class="headerlink" title="7 月 2 日 - 改变自己"></a>7 月 2 日 - 改变自己</h4><p>我最大的缺点是什么呢？不擅长沟通应该算是一个，而且自从换工作之后，我似乎越来越不愿意与其他人交流，所以也导致了自己身边朋友越来越少。哪怕是和每天都要接触的室友和同事，我也和他们亲近不起来。我知道这是我自己的原因，因为我总是觉得彼此身上的差异太大，有时候是不喜欢对方身上的某个特质，又或者是觉得对方同样会无法忍受我身上的缺点，与其如此，那还不如彼此保持距离。我甚至做不到和大家闲聊自己感兴趣的话题。这也让我想到，我至今还单身应该也是因为我这样的性格吧。一是太过封闭自己，二是不愿意冒险。总是喜欢按照既定的道路去走，喜欢选择最安全的方式去和他人沟通，害怕过多的表达会暴露自己的缺点，也害怕被他人讨厌。如果继续按现在这种方式生活下去，虽然没什么问题，但是我永远也不可能获得真正的独立。我的影响力仅限于一个很小的圈子内，我只能为他人工作而不是为自己工作。我永远也不能和任何人建立起有意义的连接，我也不会获得任何长期的亲密关系。我想要改变这点，而且我也知道，我只能从自己身上那些微小的地方开始改变。比如，学会更频繁地向他人分享、表达自己的想法和观点；多帮助身边的人；学会和陌生人聊天；哪怕是和自己不那么喜欢的人，也要学会用积极的态度看待对方，发现对方身上的优点而不是缺点；对于他人的冒犯或者是挖苦，不要太放在心上；在他人说话的时候，耐心倾听，保持微笑；多鼓励他人，真诚地赞美他人。能做到这样，就已经很了不起了。</p><h4 id="7-月-3-日-挑战自己"><a href="#7-月-3-日-挑战自己" class="headerlink" title="7 月 3 日 - 挑战自己"></a>7 月 3 日 - 挑战自己</h4><p>最近情绪能量有点低，哪怕是周末也不是很想动，花了很多时间刷剧，但没有一部是完整看完的。我觉得可能是我又进入了一个新的懈怠期了吧。这次要怎么爬出来呢？看书是一个方法吧，但我觉得最根本的问题还是得先解决自己的人际关系问题。我需要在现实中建立一个能够彼此交流、有共同话题的圈子，毕竟一个人待久了容易出事。有时候会感到无聊，甚至到了有点心慌的程度，觉得无论做什么事都没什么劲儿。想到了之前连岳公号的<a href="https://mp.weixin.qq.com/s/ay3SjnorowCVh2hi2OnutA">一篇文章</a>，我现在的状态差不多就是那样的。好像什么都有了，但就是缺乏激情。其实我内心还是对自己感到认可的，可能只是需要从外界得到确认吧。也许是我想要的太多了吧。我更愿意把它看作是一种修炼。人的修炼方式有很多种，有的人是通过和其他人相处，有的人是和自己相处。而我过去和自己相处的时间足够长了，所以也许应该换个方式了。尽可能多地和其他人接触，挑战自己的能力边界，去做让自己感到不舒服的事，如果一段时间之后还是感到不习惯，至少可以从中学到一些技巧性的知识，从而让自己能够应付相似的场景。就像玩轮滑一样，一开始可能站都站不稳，但是经过一段时间的练习之后，就可以自如地加速、转向甚至是做出复杂的动作了。</p><h4 id="7-月-4-日-行动大于理论"><a href="#7-月-4-日-行动大于理论" class="headerlink" title="7 月 4 日 - 行动大于理论"></a>7 月 4 日 - 行动大于理论</h4><p>行动比理论重要得多，很早之前就知道这个道理，但是真正理解却是在最近。我已经不是第一次有这样的感受了，以为自己知道但其实并没有真正理解其含义，只是自以为懂得。只有将道理转变为行动之后，才能检验你的理解是否是正确的。行动之所以重要也是因为，大多数理论，哪怕是非常复杂的理论，也是人在行动的过程中，在反复的尝试、失败、总结经验之中，逐渐形成的。这个世界上，除了部分理论物理是只能依靠人的理论经验来指导其未来的发展之外，绝大部分都是通过行动来推动理论取得进步的。我觉得造成这种结果的原因是：现实世界中的事物实在是太复杂了。哪怕是看似简单的做一张木头桌子。根据理论，我们需要的部件只是一块桌面，四条桌腿，几个拼接构件和螺丝钉就可以了。但是实际上，如果要完全靠自己做出一张桌子，远远比拼装一张桌子难得多，我们需要考虑桌面的平整度和重量，拼接构件的设计，桌角的设计，结构稳定性，打磨和上漆，等等。很多事情我们觉得简单，只是因为现代化分工将很多细节都隐藏起来了。再比如做饭，如今大部分人都不需要自己做饭，因为手机上点个外卖比一个人为自己做一顿饭简单多了，其实就是因为我们把做饭的细节交给了别人，我们拿到的只是最终的产品，最多只需要自己再用微波炉加热一下就可以了。而实际上做饭的步骤非常复杂，哪怕是煮一碗普通的面条，涉及的步骤也有把水煮开、下面条、加调味料、继续煮几分钟、尝咸淡以及是否煮软、出锅。即使你知道每个步骤，然而如果你没有亲自实践过，当你真正动手的时候可能还是会手忙脚乱。</p><h4 id="7-月-5-日-不要一个人午餐"><a href="#7-月-5-日-不要一个人午餐" class="headerlink" title="7 月 5 日 - 不要一个人午餐"></a>7 月 5 日 - 不要一个人午餐</h4><p>上一次单独和其他人一起吃饭是什么时候？应该是两个月前，在去老姐新家参观完后一起去吃面。会这么问是因为昨晚在看反脆弱的时候看到一句话，一个人是否活得幸福和财富的多少关系不大，更重要的是，你的身体是否健康，是否经常参加体力劳动或锻炼，是否有一个扁平的小腹，和周围的人的关系是否融洽，是否经常开怀大笑，经常与朋友推心置腹地交流想法，从不感到无聊，有充足的睡眠和阅读的时间，以及，<strong>从不一个人午餐</strong>。老实说，我目前最大的问题是没有朋友，而且我内心也不太渴望交朋友。我觉得一天的工作结束之后，有时间去锻炼一会儿，然后还有书本陪伴，对我来说就已经足够了，我每天中午的午餐时间也基本都是在阅读中度过的。但是，我也开始意识到，其实和他人的交流还是很重要的。因为与他人对话可以在活跃彼此思维的同时，也让你的心情变得更加愉悦，尤其是与能和你产生共鸣的人的交流。之前也看到过高少的建议，不要独自吃饭，因为吃饭是一个非常好的增进彼此了解的机会。所以，也许我应该改变一下自己的午餐习惯了，不过，可能要等到我牙齿矫正结束之后了。</p><h4 id="7-月-6-日-写作就是在反脆弱"><a href="#7-月-6-日-写作就是在反脆弱" class="headerlink" title="7 月 6 日 - 写作就是在反脆弱"></a>7 月 6 日 - 写作就是在反脆弱</h4><p>我常常在碎碎念中发现自己身上有各种各样的问题，而且也给自己诊断并开药，我十分清楚地知道自己应该如何做，但是到目前为止，让我真正付出行动并且坚持下来的有多少呢？除了养成了运动和阅读的习惯之外，其他好像都已经被我放弃了。说起来真的有点惭愧。但是啊，我觉得哪怕仅仅是这两个习惯，也已经带给我非常多的回报了。我现在需要做的是继续养成更多的好习惯。对我来说，冥想似乎很难坚持下去，但是我的睡眠状况已经改善很多了，只要能坚持不熬夜，基本上还是可以保证每天有 7.5 个小时以上的睡眠的。至于其它方面的习惯，比如随时随地表达自己，改善自己和他人的关系，在任何人面前都能保持真实的自我，这些依旧需要练习。而且，这些是一个人在生活中形成的长期习惯，也不是一时半会儿就能改善的。我能做的，只有对自己更加耐心一点。说到底，这些都只是增进自己生活幸福度的手段。如果我们能做到和周围人都能融洽相处，自己的内心也感到安全、无负担，我们就能生活得更加快乐。而且，这也是在增加一个人的反脆弱能力。最近看完了反脆弱这本书，对个体而言，我觉得反脆弱能力其实就是在压力中成长，使人能够在面对未知时也保持较大的韧性；对组织而言，就是在混乱中找到秩序的能力，能在风险和挑战中对自己进行轨迹纠偏。这样说来，其实写碎碎念也是在强化一个人的反脆弱力。短期内也许看不到太大的回报，但是长期来看，一定会慢慢让一个人养成敢于面对未知、不怕犯错的习惯，因为人只有在这样做之后才能不断获得成长，而这就是我们作为一个寻求成长的个体应该一直追求的事。</p><h4 id="7-月-7-日-筛选你的信息源"><a href="#7-月-7-日-筛选你的信息源" class="headerlink" title="7 月 7 日 - 筛选你的信息源"></a>7 月 7 日 - 筛选你的信息源</h4><p>我相信文字具有自我抚慰的功效，但前提是你表达的东西必须是真实的。翻自己过去写的碎碎念，可以看得出来，其中至少有一部分不是我当时的真实想法，而是我想要让自己「看起来」是那个样子的，可能是为了让自己显得更加聪明、更加理性、更加善良吧。但是无论如何，那都不是真实的我。我写作的目的是为了能够更加诚实地表达自己。不过反过来想，即使我们真实表达了自己的想法，那又如何？一个人的想法最终还是会发生变化。我们当下所具有的信念，反映的只是我们在某段时期内受到的外界环境的影响是什么样的，并不能代表彼时的那些想法就是我们自己的。当然，也有可能我们会产生一些原创性的想法，但是那也是在外界各种信息的刺激下才产生的。所以，我们唯一能够控制的是我们接触的信息来源，我们日常生活中接触到的人、事、物，这些才是让我们成为今天的自己的原因。自我反省意味着你要批判性地接受你每天阅读到的文字、听到的言论，还有就是要有意识地挑选你接触到的信息源，只有这样，一个人才能真正掌控自己的人生。</p><h4 id="7-月-8-日-选择积极而非消极"><a href="#7-月-8-日-选择积极而非消极" class="headerlink" title="7 月 8 日 - 选择积极而非消极"></a>7 月 8 日 - 选择积极而非消极</h4><p>本来不怎么关注新闻，而且我觉得每个人都应该只关注自己的影响圈之内的事，但是，看到这两天大家都在讨论的事情，还是会让人感到有点焦虑。我觉得人有的时候可能真的是受负面力量驱动的吧，没有了那些不好的事情，整个世界一片积极美好，大家反而失去努力向上的动力了。这样看来，负面、消极的消息也自有其意义。但是，我还是反对每天花时间去追逐最新的负面新闻，因为人很难做到不受消极能量的影响。更进一步，我觉得我们每个人都应该每隔一段时间就反思一下，自己是不是花了太多的时间和精力去关注生活中的负面信息。工作可以让我们获得收入，你的工作也会影响到一部分人的生活，所以我们要充满热情地做好自己每天的工作。但是，工作也不是生活的全部，我们还应该留出一点时间给自己，去关注生活中那些美好的事物，去运动，去放松，去享受简单事物给自己带来的快乐。我们和周围人的关系不仅仅是互相竞争的关系，我们也是彼此的伙伴，我们应该帮助彼此，哪怕是为陌生人做一些力所能及的小事，也能让我们感受到快乐。我们的乐观和积极也许并不能消除这个世界上的所有负面的东西，但是至少能够影响我们自己，让自己生活得更加快乐和健康。最终，这会像涟漪一样，一层层将我们的影响力传递到更远处，从而让更多的人生活在一个积极而非消极的世界中。</p><h4 id="7-月-9-日-以服务他人对抗孤独"><a href="#7-月-9-日-以服务他人对抗孤独" class="headerlink" title="7 月 9 日 - 以服务他人对抗孤独"></a>7 月 9 日 - 以服务他人对抗孤独</h4><p>昨晚轮滑刷街回来，洗完澡坐在椅子里发呆，听到隔壁中医院大学操场上传来唱歌的声音，应该是新生在军训吧。于是想到自己刚上大学军训那会儿，想到自己第一次一个人穿过几条街去超市，想到跑完步回宿舍时看到的月亮下的树影，想到从书店出来抱着书在大街上漫无目的地走着的自己，想到穿梭在教学楼之间找自习室的自己，想到在城市各个角落穿梭参加面试的自己，再看看此刻坐在椅子里的自己，时间真的过得太快了。不过，相比那时的自己，现在的自己好像并没有发生太大的变化。虽然已经工作了几年，去过了一些地方，认识了一些新朋友，甚至买了房开始还房贷，但是，我还是那个时候的我。过去，我觉得这个世界上没有人可以理解自己，现在我的想法依旧没变。也许书籍、电影、音乐可以让人感到不那么孤独，但是，忘记孤独并不能填满心中渴望被理解的那份空缺。无论一个人拥有什么样的过往，也无论他拥有多少财富、什么样的地位，受到多少人的喜欢和爱戴，都不能改变他始终是一个人的事实——我们自始至终都只能和自己成为形影不离的伙伴。所以，<strong>爱自己，成为自己的朋友才是唯一重要的事情</strong>。只有学会爱自己之后，我们才能学会爱他人。尊重自己，对自己严格要求，让自己学会承担责任，学会鼓励、安慰自己，选择有意义的目标，提升自己的能力，发挥出自己作为一个人应有的作用。爱他人，不仅仅意味着爱那些和我们亲近的人，也意味着要爱我们的同胞和同类，同情、帮助、理解、服务、抚慰你身边的所有人。只有这样，我们才能真正摆脱孤独，享受幸福和快乐。</p><h4 id="7-月-10-日-太空探索及未来"><a href="#7-月-10-日-太空探索及未来" class="headerlink" title="7 月 10 日 - 太空探索及未来"></a>7 月 10 日 - 太空探索及未来</h4><p>昨晚看了<a href="https://www.youtube.com/watch?v=b1dJOpzFw_Y">一个视频</a>，讨论的是为什么人类 50 多年前就能登月，但是在阿波罗项目结束之后就再也没有登月了，以及未来开发月球可能的步骤。我也第一次意识到，月球才是人类走向太空的第一站。人类只有在月球建立了太空基地之后，我们才能逐渐掌握开采其他星体上资源的经验。所以，我觉得未来几年机器人一定会迎来很大的发展，因为在太空中，人类离不开机器人的帮助。其实现在火星上的几个探测器就可以看作是机器人的雏形了，只不过未来我们还会让它们具备更多的能力。</p><p>未来我们的生活会因为这些大规模外星探索发生多大的改变呢？除了机器人，可能还会有更多从昂贵走向廉价的太空资源，伴随着逐步发明出的新材料，更高效率的发动机，更好的电池技术，等等。忍不住在想，未来我会从事什么样的职业？也许那时软件开发对我来说不再有趣，也有可能整个行业被人工智能或者新技术颠覆，所以我不得不去从事新的工种。对我来说，太空相关的一切都很有趣，也许我会投身制造业，从事航天材料的开发和制造。不过，目前民用航天业才刚刚起步，现在讨论这些还有点早，至少要等到 SpaceX 将人类送上火星之后才能迎来行业的大发展吧。想到有生之年就能看到人类开始移居其它星球，哪怕只是实验性质的一小部分人，这也已经足够让人兴奋了，而且我们是第一代见证这一时刻的人。</p><h4 id="7-月-11-日-爱也需要学习"><a href="#7-月-11-日-爱也需要学习" class="headerlink" title="7 月 11 日 - 爱也需要学习"></a>7 月 11 日 - 爱也需要学习</h4><p>昨晚再一次被介绍了相亲对象，虽然只是加个微信而已，但内心还是会觉得有些抵触。其实，大可不必，把它当作是一次接触和了解陌生人的机会就好了。仔细想了想，其实让我感到讨厌的不是相亲，而是被家里人介绍相亲这件事。因为在我的小脑瓜中，总觉得他们这是在干涉我的人生，而我想按照我自己的想法去生活。也许是我太理想主义了，毕竟，家人、亲戚们只是关心你的幸福而已。的确，有的时候这种关心会让人感到不舒服，但是这需要你去适应它。虽然也许你自己并不在乎是否还单身这件事，但是在他们的眼中，可能这就意味着你不会过得太幸福。说起来，恋爱结婚之后就能过得幸福吗？我并不觉得。我觉得<strong>个人成长是重要的</strong>，这种重要性和有一个你爱她、她也爱你的人完全不同。虽然这两者也有一些共同点，比如都需要一个人付出努力，并且是持续不断的努力。也需要不停地学习，比如学会适应新角色，学会在外界环境变化之后应对新的挑战，等等。我虽然没有经历过真正的爱情，但是我还是相信爱情是存在的，听起来有点天真，但是，我相信两个人可以从陌生人到逐渐认识彼此，发展成为亲密无间、彼此信任、爱对方超过爱自己的人生伴侣的。虽然这需要花费很多的时间学习和彼此适应，中间也一定会有让人感到挫折和受伤的时刻，还有可能出现你喜欢的人并不喜欢你或者分手的情况，但是我觉得这就是人生的一部分，认真感受每段经历中的细腻美好之处，去无怨无悔地付出自己的努力，能做到这样就很好。</p><h4 id="7-月-12-日-第三次变革"><a href="#7-月-12-日-第三次变革" class="headerlink" title="7 月 12 日 - 第三次变革"></a>7 月 12 日 - 第三次变革</h4><p>昨天偶然发现一本在线书，<a href="https://worldaftercapital.gitbook.io/worldaftercapital/">World After Capital</a>，其中提到我们目前正在经历第三次巨大的社会变迁，也就是从工业社会时代走向知识经济时代。前两次变革对人类生活造成的改变是空前的，从狩猎采集到农耕文明，全世界人口迎来了第一次大爆炸。第二次是从农耕文明走向工业时代，同样造成了巨大的社会影响，全世界的人口再次翻了几倍，且人们的生活水平也大幅提高了，虽然中间发生了很多不幸的事件，比如两次世界大战，但是总体而言人类是在往前进的。这一次变革，是由数字科技带来的，也就是从互联网的发明开始，人类走进了一个新的时代，知识的获取、信息的流通、沟通的成本都变得极其迅速且廉价，稀缺的不再是资本，而是人的注意力。任何一个人只要能有效控制好他的注意力，并且使用恰当的行为将其所学转化成现实或虚拟的产品，他就能获得成功，至少是财务上的成功。而且这一次，互联网把所有人的关系都拉平了，虽然特权阶层继续存在，但是他们所能享有也只是一部分「特权」而已，知识的获取依旧向所有人开放且接近于免费。这种现象在过去是不可能出现的，但是现在却出现了。我们正站在一个变革的起点，未来一大批让人预想不到的新技术和产品正在酝酿之中。虽然这本书我还没看完，但是我基本同意书中的观点，我们现在所处的工业社会正在面临巨大的变革，未来一段时间将会是技术大爆炸的时代，这也让我对未来满怀期待。我所能做的，只有让自己跟上时代的步伐，学习一切有意思的东西，同时照顾好自己的身体健康，也许我参与不了，但是至少可以去见证它。</p><h4 id="7-月-13-日-热爱你的工作"><a href="#7-月-13-日-热爱你的工作" class="headerlink" title="7 月 13 日 - 热爱你的工作"></a>7 月 13 日 - 热爱你的工作</h4><p>最近几天的气温差不多都在 40 度上下，走在路上感觉自己就在烤箱里，奇怪的是，当你换一种心态，想象这会儿是在冬天，用心感受，好像吹在脸上的风就变成了暖暖的风，而不是燥热的裹着你而来的热空气。当然，这种想象只适合当你刚走出空调房的时候，长时间呆在户外的情况下就不管用了。因为天气太热，最近下班基本不去跑步了，改为去地下车库练一小时轮滑。每天练一会儿，于是能感觉到滑行、单脚支撑、前后滑切换都有了进步。灵光一闪想到：轮滑比走路有趣多了，这世上还有哪些事是既有趣又能给自己带来好处的呢？我甚至在想我以后可以尝试开一家轮滑和滑板店，兼职做教练，既好玩又能让更多人都参与这项运动。唯一存疑的是赚不赚得到钱，还有就是启动资金。一谈到钱的话就很难开心起来了，而且我们好像默认都以为赚钱是无趣的。但是，这世上也有很多人热爱他们的工作，不但能把工作做到极致，还能得到很多乐趣。我能想到的例子有，比如蹦床、滑雪、游泳、跳伞教练，宠物训练师，外交官，纪录片摄影师，职业品酒师，等等。不过，即使没能做让自己感到有趣的工作，至少还可以热爱自己的工作，并且尝试把它做到极致，这样的人同样值得尊敬，这也是普通人都可以努力做得到的。</p><h4 id="7-月-14-日-牢记「我有可能是错的」"><a href="#7-月-14-日-牢记「我有可能是错的」" class="headerlink" title="7 月 14 日 - 牢记「我有可能是错的」"></a>7 月 14 日 - 牢记「我有可能是错的」</h4><p>在聆听不同的观点上，输赢、对错、强弱都不重要，重要的是在耐心听完后做出自己的评判。可惜的是，大多数人都习惯先给一个人贴标签，或者在一开始就建立了一个先入为主的偏见，然后再对他进行反驳和批判，更有甚者，当他察觉自己无法辩倒对方时，还会对他进行人身攻击。这也是为什么越来越多的人选择了沉默——我们应该把时间花在那些愿意倾听不同观点的人身上。反过来我们也应该这样要求自己，允许其他人有不同的观点，也愿意倾听对方是如何形成这样的观点的。在听到他们的真实想法后，站到他们的立场上去尝试理解对方，即使做不到能够完全理解对方，但是至少允许这样的声音在自己身边出现。因为，你永远也不知道自己的观点未来是否会发生变化，到时候你可能就站到了对方的一边，这就是允许不同的声音的意义所在。每个人都有可能犯错，因此，我们首先要先承认自己有犯错的可能性，始终要把「我有可能是错的」这句话记在心里。同理心也是建立在这个基础之上的。</p><h4 id="7-月-15-日-行动改变处境"><a href="#7-月-15-日-行动改变处境" class="headerlink" title="7 月 15 日 - 行动改变处境"></a>7 月 15 日 - 行动改变处境</h4><p>最近发现生活过得有点过于单调了，几乎每天都保持着相同的生活节奏，上班，下班，轮滑，娱乐，看书，睡觉，前一天就能猜到明天的这个时候我会在干什么。有时候觉得这样也挺好，毕竟规律的生活意味着平静的生活，而这也是我追求的目标之一，保持内心的平和。但是，另一方面也觉得，这样似乎太过无聊，我还这么年轻，难道不应该追求一些刺激的东西吗？比如有丰富多彩的社交生活。看了辉哥昨天的<a href="https://mp.weixin.qq.com/s/k-kUqiaXjXVWQrxycyqMBQ">一篇文章</a>，我也是内向者，特别能理解题主说的那种感觉，渴望一个人待着，但同时也渴望能和其他人有更多的连接，这种感觉其实并不矛盾，只是我们会特别孤独，因为很难找到一个同类。我需要学习的，可能是主动和他人建立联系这件事吧。没想到一个人居然要到二十多岁的末尾才发现自己的问题所在。不过，也许我应该感到庆幸，因为毕竟让我感到苦恼的事只是这一件并不严重影响我的生活的小事，我需要做的只是改变自己的态度，以及付出更多的行动，就能解决。但仔细想想，一个人需要面对的大多数问题都需要这样的态度吧，<strong>唯有通过自我改变才能最终看到问题被解决的可能性</strong>。但是，真正难的是行动，而这也是导致我们走上幸福和不幸福的分化之路的主要原因。Action leads mood. Just do it.</p><h4 id="7-月-16-日-不怕孤单"><a href="#7-月-16-日-不怕孤单" class="headerlink" title="7 月 16 日 - 不怕孤单"></a>7 月 16 日 - 不怕孤单</h4><p>昨晚睡前看了一个<a href="https://www.youtube.com/watch?v=EYncNbM9HMs">小视频</a>，讲的是我们因为害怕孤单而付出的代价，比如和一个不合适的人在一起，长时间磨合后依然无法得到彼此想要的关系，于是在这段关系中积累了越来越多的不满甚至是愤怒，最终，它变成了一段彼此消耗而不是滋养两个人的关系。只有那些勇敢的人才能做到不怕孤单，也不怕他人的嘲笑，始终坚持做自己，不贸然进入一段关系，但是也愿意去接触和了解有可能合适的对象。这样的人有很强的生活自理能力，也有不错的社交技巧，经济上和精神上也都比较独立。这就是我想要成为的人。另外，不害怕孤单也意味着一个人有更多的选择权，他可以选择去参加各种不同的活动，也可以选择自己一个人待着。只有拥有了更多一个人的时间，你才能真正学会和自己相处，才有时间去了解自己：我喜欢什么，讨厌什么，什么让我感到痛苦，又是什么让我感到幸福和满足。就像写日记，把自己的想法写下来，这就是我了解自己的方式。阅读是，冥想是，发呆也是。普通的生活并不可怕，缺乏激情和自我激励、失去好奇心和想象的生活才是我应该避免的，而如何保持对生活的热爱、激情和好奇，则需要一个人在漫长的自我相处以及在不断地探索和尝试中，才能找到答案。</p><h4 id="7-月-17-日-探索人生的可能性"><a href="#7-月-17-日-探索人生的可能性" class="headerlink" title="7 月 17 日 - 探索人生的可能性"></a>7 月 17 日 - 探索人生的可能性</h4><p>看了最新一期的<a href="https://www.youtube.com/watch?v=BKyj1El2I9k">我住</a>，拍的是草根时尚博主雯方，觉得很受触动，想写点什么，但又不知道要从哪开始写。首先，很佩服他的勇气，出现一个想法之后立马付出行动，然后再通过反馈不断改进和优化，而且从结果来看，好像效果还不错，至少获得了一定的名气和收入。其次，有自己长远的目标。他喜欢时尚，对时尚也有自己的理解，所以可以为之付出全部的努力并且力求在不出众的条件下做到最好。还有就是他选择回到自己的家乡，这一点是最最触动我的。他毫不避讳自己的出身，虽然可以拥有更好的生活条件，但是他选择回到自己长大的村子，回到父母身边。虽然就像他说的，在农村他可以更自由地进行创作，但我觉得更主要的原因是他想要回到父母的身边。我会这样理解是因为，我也想过回到农村、回到父母身边的可能性，但现实是，我很难回去了，也不愿意回去。不过，如果未来父母愿意的话，我想让他们来到我身边，但我不会强迫他们。</p><p>其实，我挺羡慕雯方这样的人的，因为他们通过行动告诉大家，在这个时代，一个人是可以通过自己的努力来改变自己的人生轨迹的。也许你拥有的东西很少，也许你过往的经历非常灰暗，但是，你依旧可以选择从苦难和不幸中站立起来，通过寻找到自己的特色来表达出自己的态度，通过语言和行动展现出非凡的个人毅力，让世界看到你真实而又顽强的一面。也许说的有点夸张了，但是我觉得，这就是一个人在选择做真实的自己之前需要做好的心理准备，而且需要付出的代价可能比想象中的还要大。但是，这一定是值得的，通过<strong>做自己</strong>获得的满足和自信是任何其他事情都替代不了的。虽然我还没有过这种感受，但是我也还在不断学习，通过观察这个世界上的其他人，我学到了很多过去从来没有感受过的事，也对过去那些只能从书本上看到的东西有了更深层的理解，比如开放和包容，做真实的自己，为自己坚信的东西付出努力，什么是爱，什么是生活，等等。其实，人生就是不断学习未知和更新已知的过程，这也恰恰是人生有趣的地方：你越努力，付出越多，得到的东西也越多，不仅仅是物质上还包括精神上；相反，你越是恐惧，越是逃避痛苦，你就越容易觉得人生是无聊的和难以忍受的。希望越来越多的人都可以走上探索式的人生道路，发掘出越来越多的人生可能性。</p><h4 id="7-月-18-日-我何以成为我"><a href="#7-月-18-日-我何以成为我" class="headerlink" title="7 月 18 日 - 我何以成为我"></a>7 月 18 日 - 我何以成为我</h4><p>人生最根本的问题是什么？我觉得找到你想过的人生应该算是吧。很可惜，目前来看，我还没有答案。但是，我觉得可以把我过去这二十几年的人生经历都看作是努力尝试寻找答案的过程。也许过去的我并没有意识到这个问题，但在我经历了所有这些经历之后，它们把我指引到此处，我也就成为了此刻的我。没错，我依旧是一个再普通不过的人，但是我觉得此刻的我和过去的我已经发生了非常大的变化。十年前，我可能还在纠结自己的未来，我应该从事什么样的工作，成为什么样的人。十年后，虽然还是会纠结未来，也还在继续探索自己未来的职业发展道路，同样也还是不知道自己应该成为什么样的人，但是，我知道我已经成长了很多。我学会了识别和掌控自己的情绪，学会了养成规律的生活习惯，知道节制自己的欲望，能够看清自己的优缺点，也知道自己是个什么样的人，虽然偶尔还是会感到恐惧、迷茫、焦虑，但是我已经知道应该如何与它们相处。我还知道我没法满足所有人的愿望，我也承认自己的能力短板，并且我也接受这样的自己。除此之外，我还觉得我是个非常幸运的人，我对我此刻拥有的一切都感到非常满意。我拥有健康的身体，家人的关心，每天都能有几个小时的独处时间，我能阅读到我喜欢的书，还有喜欢的电影和音乐。我知道有一天我会失去它们，所以在还拥有它们的时候，我珍惜每一刻与它们相处的时间。幸福对我来说是很容易的事，因为我所要求的并不太多。我希望我在乎的所有人都能拥有幸福。</p><h4 id="7-月-19-日-为自己的人生做决定"><a href="#7-月-19-日-为自己的人生做决定" class="headerlink" title="7 月 19 日 - 为自己的人生做决定"></a>7 月 19 日 - 为自己的人生做决定</h4><p>有时候我会陷入思考，父母真的是爱我们还是只是想要控制我们？有的时候往往很难界定其中的区别，但我觉得不管怎样，爱的成分一定更多一些。而且控制也是爱的一种表现，因为可能在他们眼里，他们并不是想要「控制」你，而是希望你能够走上一条更安全、更有保障的人生道路。就像我的父母催促我恋爱结婚，其实本质上是希望我能够生活得幸福，因为在他们眼里，一个人生活不可能过得幸福，所以他们会担心和催促。我不想讨论独居是否能生活得幸福，但是我觉得我应该学会理解他们。不过，我不会改变自己的想法，不会随便找个合适的对象恋爱结婚，我也不奢望他们会改变想法。但是，这样下去的结果是，未来一段时间内我们都会过得很痛苦。好的一面是，他们给了我很大的启发，那就是要有自己的人生，这样你就不会把未来寄托在下一代人身上了。你能控制的，只有自己的大脑和身体。把自己的生活过好，不干涉别人的人生，这是一个人能做到的最好的修养。至于谁对谁错，现在来看，还很难说。也许早点结婚对我真的有好处也说不定，但是，我还是希望自己做决定、自己承担后果，只有这样，未来我才不会将责任推给别人，也不容易感到后悔。为自己的人生做决定，承担一切后果和责任，这是我最根本的人生信条。</p><h4 id="7-月-20-日-成为自己的好朋友"><a href="#7-月-20-日-成为自己的好朋友" class="headerlink" title="7 月 20 日 - 成为自己的好朋友"></a>7 月 20 日 - 成为自己的好朋友</h4><p>昨天聊到了我与父母关于恋爱、婚姻的观点的区别，这应该是我最近生活中最大的烦恼了吧。不过，我觉得人只要还活着，就一定会与其他人产生矛盾和冲突，人是活在族群之中的，从出生到死亡都无法逃脱自己所在族群的控制，最多从一个族群跳到另一个族群。在经历了和父母、师长、同学、朋友、恋人、爱人、同事、领导，甚至是和陌生人之间的矛盾之后，我们才会意识到，其实我们永远都不会是一个完全独立的个体，因为我们都依赖其他人的帮助才能生活下去。但是另一方面，我们也始终都是一个人，即使是最了解你的人也不能完全理解你的想法和思维过程，所以我们是孤独的。过去，我总觉得孤独是一件丢脸的事，觉得这意味着你缺少友情、爱情还有自爱，但是，现在的我却觉得，其实孤独才是一个人真实的状态。既然如此，为什么不承认并且拥抱这个事实呢？最关键的是，你要成为自己的好朋友。在没有人理解你的时候，你要学会在心中默默安慰、鼓励自己，在没有人支持你的时候，你要为了自己而强大起来，因为没有人比你更了解你自己。你要让自己活得好，无论是物质上还是精神上。你必须拥有一个饱满、充实、丰沛的灵魂，才能勇敢无畏地独自走在这片广阔无边的大地上。</p><h4 id="7-月-21-日-黑镜剧评：玩好你的游戏"><a href="#7-月-21-日-黑镜剧评：玩好你的游戏" class="headerlink" title="7 月 21 日 - 黑镜剧评：玩好你的游戏"></a>7 月 21 日 - 黑镜剧评：玩好你的游戏</h4><p>昨晚重看了科幻经典，黑镜第一季第 2 集：一千五百万点。看的时候心里就有个声音在问：这是在讽刺现代社会中的职场白领吗？虽然我是程序员，但是应该也属于白领吧。这一阶层现在面对的困境就是，明明不喜欢自己的工作环境但却无法逃脱，因为他们找不到更好的选择，或者不敢去尝试。虽然还不至于一天到晚蹬自行车获得收入维持生存，但是现实中的确有很多人的确就是过着和影片里差不多的生活：日复一日做着相似或重复的劳动，身边都是和自己一样麻木而又无趣的人，没有人有一个清晰有意义的目标，我们要么为了获得他人的注意力而活，要么在奋斗在这条路上时逐渐丧失了自我。主人公原本以为自己爱上了一个可爱又有生命力的女孩，所以想要帮助她实现梦想，这是让他感到自己还活着的唯一动力。但是，在看到梦想破碎之后，他选择必须要让世界听到自己的不满，他要控诉这个让他们做着无意义劳动的肮脏下流的制度。一番努力之后，最终的结果是，他向这个制度妥协了，制度将他从一个被剥削者的位置提升到了既得利益者的位置，而他也得到了自己想要的一切。</p><p>这部片子虽然讽刺了当下的现实，不过却没有提出解决方案。我觉得解决方案是有的，那就是玩好你的游戏。既然制度告诉你只有向上才能过上你想要的生活，而且你对当下的生活也没有更多的激情，那么，你就顺着游戏规则玩好它吧。如果你打算就此躺平，也是可以的，但是要记住，生活在不停地发生变化，即使是一成不变的生活也是一样，你的身体也会因为随着年龄的增长而发生变化，如果你到时候没有能力去适应这些变化，你会感到更加痛苦，也许还会感到后悔。所以，一开始就要做好准备。只有这样，你才能有能力应对一切可能出现的变化。</p><h4 id="7-月-22-日-黑镜剧评：保持诚实和势均力敌"><a href="#7-月-22-日-黑镜剧评：保持诚实和势均力敌" class="headerlink" title="7 月 22 日 - 黑镜剧评：保持诚实和势均力敌"></a>7 月 22 日 - 黑镜剧评：保持诚实和势均力敌</h4><p>继续聊黑镜，第一季第 3 集：你全部的历史。讲的是未来若干年后，有一种在人眼中植入设备的科技，可以使一个人将所有看到的东西都记录下来，配合植入人脑的记忆芯片还能做到实时回放的功能。但是这个故事是围绕着一个多疑的男主展开的，他怀疑妻子偷情，结果通过记忆回放的功能还真的找到了证据。在和妻子离婚之后，由于沉浸在往事的痛苦回忆之中，最终他把自己的记忆芯片给挖了出来。不去谈这种技术实现的可能性，我觉得这一集给我最大的启发是，一定要做真实的自己。即使现在还没有这样的技术，我始终觉得谎言是无法自圆其说的。要想不被人发现你做了某件事，唯一的做法是别去做那件事。而且一旦你撒了谎，最终一定是会影响到你自己的，尤其是那些为了个人利益而撒下的谎。所以，无论什么时候，保持诚实是最佳的做法。另一个启发是，谈恋爱一定要找和自己相匹配的人，不要奢望高嫁或者高娶，因为这一定会给自己带来某种程度的不平等，比如你在两人相处中的地位，你的潜在的可替换对象不如对方多，你对对方的依赖程度高于对方对你的依赖程度，等等。但是，我并不是说爱情就一定是充满了比较和算计，而是出于生理学和人性本质的原因，遵守这些基本的规则的人才更容易获得幸福。</p><h4 id="7-月-23-日-年中盘点"><a href="#7-月-23-日-年中盘点" class="headerlink" title="7 月 23 日 - 年中盘点"></a>7 月 23 日 - 年中盘点</h4><p>最近又隐隐觉得自己的状态不佳，所以也许该停下来复盘一下了，刚好也到了一年的年中，差不多是该总结一下。</p><p>首先是这半年的工作，主要的工作有三部分，分别是网易数创项目的维护，AVP 导航项目，以及现在还在开发中的新版拾米课堂。Ndip 的维护工作到现在差不多已经结束了，从年初开始，一直在处理一些小问题的修复、H5 发布新功能后的打包测试等。至于 AVP 项目，差不多年初就着手在开发了，一开始没有设计稿，所以只能根据原型和功能描述文字来开发。不过，通过这个项目学到了不少使用 Mapbox sdk 开发定制化地图的经验。项目虽然从 1 月初就立项了，但是主要的开发工作还是集中在春节后的 2、3 月份，到 3 月底，主要功能点基本开发完成，不过由于客户方数据采集的问题，到现在还没有完成对接。这个项目完成之后出现了一段空档期，由于在项目中接触了搭建 mock 服务器，再加上使用 ownCloud 搭建私有云的时候，感到自己对很多 Linux 命令和 Bash 脚本都掌握得不是很好，所以专门花时间去复习了一下 vim 和 bash 的知识，还创建了一个库 <a href="https://github.com/aJIEw/HeadFirstBash">HeadFirstBash</a>。觉得这种笔记加练习的方式挺好的，既可以用来整理自己学到的知识，又可以作为记录，而且还有可能给其他人作为参考。从 4 月初开始，实现了一个 Flutter 版本 <a href="https://github.com/aJIEw/jithub_flutter">Jithub</a>，算是温习了一下 Flutter 开发吧，毕竟从 Ndip 项目之后就没有再开发过 flutter 应用了。中间还接触了一下图像文字识别，使用谷歌的 <a href="https://developers.google.com/ml-kit">ML-Kit</a> 做了个简单的 Demo。5 月份是修修补补的一个月，在维护 Ndip 的同时也给 Avp 导航做了一些优化，另外，还复习了下 Compose UI。由于五一回了趟家还被居家隔离了几天，看了很多文章和谈话类节目，花了很多时间练习轮滑。到了 6 月初，首先解决了管控软件上的一些 bug，然后发布了新版本，收到客户反馈的问题之后，又花了点时间彻底排查了项目到期后管控未失效的问题，最终总算解决了这个潜伏已久的大问题。然后开始做新版本的拾米课堂，从可配置首页到考试、培训项目等页面的改版。目前已经开发了一个多月，UI 部分差不多已经完成，剩下的就是接口数据以及测试了。预估到 8 月底的时候应该可以完成所有的开发和测试工作。</p><p>OK，回过头来，把时间拉长到一年前，从那时候到现在，我已经在新公司待了一年多了，在这一年多的时间里，除了尝试了新的技术栈 Flutter，接触并完成了几个新项目，包括原生和跨平台开发的项目，对我来说，我自己身上最大的变化是，我变得越来越习惯一个人的生活了。虽然依旧是每天两点一线的生活，但是我学会了如何掌控自己的生活，以及如何让生活变得有条不紊，这应该是我这一年多来最大的收获吧。一个人的成长从来都不是线性的，但是只要我还在呼吸，我就会不停地尝试新东西、不停学习下去，这也是一个人得以确认自己存在以及变成一个更完备的人所要做的。除此之外，我想我还应该学会变得更知足和感恩，不要以为自己此刻所拥有的都是自己应得到，有的时候你只是比其他人更幸运而已。因此，我应该更加努力，去回报那些帮助过我的家人、亲人、师长和朋友，同时也让自己生活得更加富足和幸福，只有这样，我才能对得起自己的幸运。</p><h4 id="7-月-24-日-感恩、改变；行动宜速，享受宜缓"><a href="#7-月-24-日-感恩、改变；行动宜速，享受宜缓" class="headerlink" title="7 月 24 日 - 感恩、改变；行动宜速，享受宜缓"></a>7 月 24 日 - 感恩、改变；行动宜速，享受宜缓</h4><p>看了我住最新一期，拍的是一位<a href="https://www.hezhimeng.cn/videoDet.html?videoId=017129059fb5d0d246894d1d77a9a05f&code=061nlfml21zAA94L1Qol2UoXuw4nlfm3&state=weixin_state">视障人士的工作</a>。刷牙的时候对着镜子在想，我其实已经拥有很多了，身体健康，工作不算太忙，有时间做自己喜欢的事，家人也都很好，但是，我有时候还是会陷入焦虑和负面情绪之中。人有时候真的是自己给自己制造了很多的烦恼。的确，虽然我依旧是一个人，但是我也享受了一个人的自由，为什么要盯着自己没有的东西呢？学会感恩其实很简单，珍惜你已经拥有的东西就好了。这样想之后人的情绪上会立马变得积极快乐起来。不过反过来，我觉得人其实也不能太容易满足，因为这样就容易感到颓废和无聊，感恩的同时还是得努力奋进的，否则人生就会开始走下坡路，就像肌肉长期缺乏锻炼就容易萎缩一样。所以，关键是如何把握好度的问题。我觉得帕累托改进在这里依旧适用，我们可以用 20% 的时间用于珍惜、感恩自己已经拥有的事物，然后再用剩下的 80% 去努力寻求改变，争取让自己变得更好。还有，要记住：烦恼和痛苦是永远都会有的。人生长久而快乐短暂，行动宜速，享受宜缓。</p><h4 id="7-月-25-日-摔跤与世事无常"><a href="#7-月-25-日-摔跤与世事无常" class="headerlink" title="7 月 25 日 - 摔跤与世事无常"></a>7 月 25 日 - 摔跤与世事无常</h4><p>最近运气有点背，先是在车库玩轮滑的时候摔到膝盖内侧，才刚刚好一点没多久，今天又摔倒在厕所门口，因为没看到地面有水踩上去的时候鞋底打滑了。最惨的是，感觉自己玩滑板和轮滑那么久，摔了那么多次跤，可是摔跤经验并没有长进多少，还是喜欢用手撑地面，然后一屁股坐下去。唯一的进步好像是学会了转移重心，用半个屁股和大腿侧面坐到地上，可是，还是很疼啊。所以，今晚也就没能去玩轮滑了。不过，这也让我更加确信，身体真的是一个人最重要的本钱，失去了健康，什么财富啊，快乐啊，理性啊，通通都不重要了，全都会瞬间消失得一干二净。还有就是，人真的非常脆弱，不要以为自己年轻就可以肆无忌惮地挥霍自己的身体和时间，你终将会得到报应的，要么是等到年长的时候旧病添新病，要么就是落下终身残疾，甚至发生意外突然死去也是有可能的。昨晚和老妈视频听说他们车间有个同事，家里煤气罐爆炸受伤，送医院后进来重症监护室，不但要卖房子凑医疗费，而且还不一定能救得回来。还有最近心肌梗塞去世的邻居。有时候想想，真的是世事无常。也许我应该去买个保险，虽然我现在没什么负担，但唯一的牵挂就是爸妈了，万一我有个什么三长两短，至少还能保证他们未来的养老无忧。</p><h4 id="7-月-26-日-牛逼的二舅"><a href="#7-月-26-日-牛逼的二舅" class="headerlink" title="7 月 26 日 - 牛逼的二舅"></a>7 月 26 日 - 牛逼的二舅</h4><p>昨天看了一个<a href="https://www.bilibili.com/video/BV1MN4y177PB">视频</a>，讲的是一个 up 主的农村二舅是如何在被命运捉弄之后，不但没有屈服，还越活越勇敢，也逐渐找到了生命的意义，最终，他活成了其他人（至少包括我）的榜样。每次看到这样的视频和文字，都会觉得自己遇到的那点问题真的不值一提。不过，同样的感觉在看《活出生命的意义》的时候有过，在看一些励志的电影和纪录片的时候也有过，但是，这样的感觉通常都不会持续很久。可能就像和菜头说的，当你是在拿自己的经历和他人比较的时候，你是很难真正做到共情的，只有当你自己也经历了苦难之后，你才能明白，一个人在显得那样「顽强」和「励志」的背后，他的内心到底经历了些什么。所以，只能说我还是太幸运了。但是，每当看到这样的人的时候，我们还是会被感动到的，因为他们让我们看到了希望，那就是一个人只要有足够的决心和毅力，终将熬过所有的苦难。所以，只要还活着，就不能选择放弃，要有与苦难与绝境抗争到最后一口气的勇气。在这一过程中，我们的人生经历就成了磨练我们意志的工具，也是我们给自己的唯一的也是最好的礼物，我们见证了自己从一个懦弱的人成长为一个勇敢而又不惧失败、也不会轻言放弃的人。写得像鸡汤了，但是我愿意喝。谁知道未来有一天我会不会刚好需要这样的鸡汤呢？</p><h4 id="7-月-27-日-传递积极的信号"><a href="#7-月-27-日-传递积极的信号" class="headerlink" title="7 月 27 日 - 传递积极的信号"></a>7 月 27 日 - 传递积极的信号</h4><p>最近重新过上了白天上班、晚上刷剧的快乐生活，上一次体验这样的生活应该是两年前的夏天了吧，哦，对去年夏天的记忆只剩下晚上跑步时经过各种一片漆黑的小路了。不过，夏天的时间真的过得很快啊，本来还在期待这个夏天会发生什么有趣的事，没想到这么快已经过去了一半。好在此刻的我已经学会了降低自己的期望，我相信人生中避免痛苦比追求快乐更重要。每天下班后还能有时间去地下车库玩会儿轮滑，然后吃根冰淇淋，洗完澡后再吹着空调、吃着西瓜刷剧，这样的生活就让我很满足了。这两天去楼下散步的时候都会在湖边的草坪上看到一只白色的家鹅，就那么一动不动地站在草坪中央，定定地望着远处的某个方向，不知道它在想什么。我每次路过它的时候都忍不住回头多看几眼，觉得这个画面太好玩了。有时候在想，动物其实和我们一样也是有情感的吧，也许它们没有复杂的思考能力，但是也会体验到恐惧、无聊甚至是焦虑。人和其它动物的区别是，我们还有想象能力，并且还能因此影响到自己的情绪。我觉得我们每个人要学会的是，怎样让自己的大脑维持在一个适度活跃的程度下，尽量产出一些对自己和他人有价值的东西，比如产生让自己感到快乐、喜悦又或者是安宁的情绪，然后再通过行动去传递出更多的积极信号，这也是在造福这个世界了。</p><h4 id="7-月-28-日-请回答1988"><a href="#7-月-28-日-请回答1988" class="headerlink" title="7 月 28 日 - 请回答1988"></a>7 月 28 日 - 请回答1988</h4><p>这两天晚上在看《请回答 1988》，也是一部很早就标记了但没看的剧，刚好看到奈飞上有，所以就开始刷了，一集差不多一个半小时，一个晚上刚好可以看完一集再睡觉。说实在的，看完第一集的时候就意识到，其实生活中不可能有这样的角色和角色关系，虽然现在才看到第 4 集，而且我也承认，剧中的几个角色都塑造得非常成功，尤其是德善、善宇这样的人，简直就是完美的青春期男女都喜欢的隔壁班同学的样子。但是，我觉得在现实中，这几个人永远也不可能凑在一起。不过这也正是虚构剧的好处，只要用一个邻居的背景就把他们全都框在一起了。这两天每天晚上看完一集之后，也会回想自己的校园生活。我们那会儿其实都是顽童，在农村粗鄙的环境下长大，基本上年纪越小的就越放肆，一直要到上了初中之后，才开始慢慢变得绅士、淑女起来。而且我那会儿也特别早熟，小学三四年级的时候就知道男女有别了。我到现在都还记得一个画面，每当周一第二节课下课开晨会的时候，穿过人群急急忙忙从楼梯跑到操场的升旗台下等待升旗仪式开始。和我一起升旗的是一个长得很好看的女孩，我那时候手脚很笨，动作又慢，所以每次从护旗手的手中接过国旗的时候，基本上都是她负责把旗杆上的线绑到国旗一边的木棍上，我只要抬着国旗的一端就好了。有时候我的手不小心碰到了她的手，她会立马弹开。而且她从来都不会用正眼看我，每当准备好之后，她都会把自己藏在国旗下面，我到现在都还记得她脸上那种非常不情愿的表情，眼睛望向国旗的另一边，眉头紧锁，嘟着嘴的样子。不过我还是觉得她挺可爱的。想想也挺有趣的，小学四年级就有这样的想法了。不过，即使这样我也不会说出口，因为那时候的小男生都不敢和女生一起玩，怕被其他男生笑话。一直要到 5、6 年级的时候，我们班的男生才会和女生在课后一起追逐打闹。想到这就觉得，那会儿可真好，没有什么心理负担，喜欢就是喜欢，不喜欢就是不喜欢，从来不会想太多，最多也就是把学习搞好就行了，哪像现在，认识一个人之前就得先掂量掂量自己，要能供得起什么样的房才能被对方父母看好，要开什么样的车才能不在对方亲戚面前丢面子，自己颜值、身高、学历、收入怎么样，能和对方匹配得上吗？每个人都觉得这样太累，但是每个人默认又都接受了这样的选择。但是，这也无可厚非吧，因为人人都希望过上优渥又让人艳羡的生活，只是有的人不愿意承认而已。不过，人始终还是有得选的。经济空前繁荣的背后就是无聊的比较，如果你不想参与这场游戏，而且你也比不过别人，那至少还可以按自己的想法去过好自己的生活。</p><h4 id="7-月-29-日-记忆中的人"><a href="#7-月-29-日-记忆中的人" class="headerlink" title="7 月 29 日 - 记忆中的人"></a>7 月 29 日 - 记忆中的人</h4><p>回忆小时候的经历总是会让人平静下来，不过这好像是年纪大的人才会经常去做的事，像我这样年纪轻轻就开始回忆童年的人，可能是当下的生活过得不够幸福吧，所以想要从童年记忆中寻找一点安慰。我的童年谈不上多么难忘，也并没有过得非常开心，即使有也只是一些记忆中的片段。但我想，有这些就已经足够了，足够我用一生的时间去回忆。而且人的记忆并不准确，加上大脑不停地在根据自己的喜好去「修饰」记忆，它们会随着我生活的变化而被美化得越来越美好，等我到了中老年的时候，这些记忆就成了我可以随时取用的、用于逃离当下生活中的痛苦时刻的资料库。我现在觉得，其实那些能留在你脑海中的人，不一定是对你最好的人；给你留下深刻印象的记忆，也并非是你与家人度过的那些美好时光，很多时候，反而是一些微不足道的人和小事长久地留在了你的记忆之中，这点总是让我感到最最惊讶。比如，我到现在都还记得幼儿园园长牵着我的手送我回家的画面，也记得坐在舅舅的三轮车后面看到一个个空油瓶掉出车外的场景，还有我在雪地上跑来跑去、外公坐在厨房门口一边烤着糍耙一边看着我的画面，还有老爸背着我走过路口时从他头顶望出去的画面，老妈收衣服的时候被我不小心翻倒的晾衣杆砸到时的表情。最近才意识到的一件事是，我记忆中的这些人在现实中都在慢慢地发生变化，而且我对一些人的记忆已经逐渐开始模糊了。可以肯定的是，我在别人的记忆中也在发生变化，唯一不同的是，我正在逐渐走向我的壮年时光，而他们正在慢慢老去。我在想我能做些什么去增加这个记忆库，因为我不想未来等到我老去的时候，留下的还是这些未更新的记忆。除了陪伴，陪他们出去旅游应该也是一个比较好的选择吧。</p><h4 id="7-月-30-日-付出努力才能得到的快乐"><a href="#7-月-30-日-付出努力才能得到的快乐" class="headerlink" title="7 月 30 日 - 付出努力才能得到的快乐"></a>7 月 30 日 - 付出努力才能得到的快乐</h4><p>最近看到小孩都会觉得好可爱啊，好想要一个，但是一想到半夜被吵醒换纸尿裤、无止境的哭闹、哄娃、溜娃就觉得，还是算了吧，而且完成这一步之前还得先完成恋爱、结婚、备孕、陪产等等。我连恋爱都不想谈。其实也不是不想谈恋爱，只是觉得太麻烦，而且我已经习惯了一个人的生活。当然，有时候也会幻想和另一个人一块生活的样子，但我想，两个人的生活可能还是麻烦更多一点。幸福时刻也会有吧，但是日子总归不会像单身时候过得那么轻松。不过，我觉得所有高级的快乐都是需要付出一点努力的，就像一个人要在学校里待十几年才能学会基本的自我控制一样，掌握一门技能，学会在社会上生存，做好自己该做的事等等，都是这样。大多数简单的快乐其实都很无趣，唯有付出努力之后得到的东西，才会让人真正感到满足。哪怕是性这种最基础的欲望，两个相爱的人的缠绵在一起也比手冲获得的快感要更让人满足一些（我猜是）。我觉得自己喜欢轮滑也是这样吧，轮滑比跑步有趣多了，但是要掌握好却要付出多得多的努力，虽然我已经玩了 4 个多月了，但是也才刚刚达到入门的水平而已，想要变得和那些街滑高手一样，还有很长很长的路要走。但是，我知道我只要花更多的时间，总有一天我会慢慢接近他们，慢慢达到我想要达到的状态，而且我也非常享受这个一点点进步的过程。所以，热情+乐趣+进步能给人带来的满足，远远大于不需要付出努力而获得的感官刺激。</p><h4 id="7-月-31-日-柚子离开-amp-反省自己的问题"><a href="#7-月-31-日-柚子离开-amp-反省自己的问题" class="headerlink" title="7 月 31 日 - 柚子离开&amp;反省自己的问题"></a>7 月 31 日 - 柚子离开&amp;反省自己的问题</h4><p>看了最新一期我住，柚子离开和之梦之前的最后一个视频，没想到她在中国待了 6 年，一个人在异国他乡生活了 6 年然后离开，会是什么样的心情？可能只有亲身体会过的人才能知道那种感受吧。不过我觉得她的这段经历还是挺值得的，拍了那么多的主人公，也在中国体验了和日本完全不一样的生活，这段经历对她以后的人生也是非常宝贵的回忆吧。而且在她离开的时候，有那么多人给她送上了祝福，还有公司的同事准备的充满情谊的礼物等，看了还是挺让人感动的。虽然我也工作了 5 年多，待了三家公司，离职两次，但是从来没有过这样的待遇，所以，她的人缘真的很好，能收获这样的友谊也值了。说实在的，我觉得我真的应该反思一下自己，为什么有的人可以收获友情和爱情，而我却还是一个人。看1988的时候心里也有同样的感觉，为什么有的人可以拥有那样的友情而我不行。其实原因我自己也能猜得到，那就是我在和其他人相处的时候太过自我了，总是把自己的感受放在第一位，很少去主动考虑他人的感受。除此之外，我最大的毛病是无法接纳别人的不同。有的人可以和很多人相处得很好，因为他们不介意他人身上和自己不一样的地方，而我总是喜欢关注那些不同，然后再用自己的偏见去强化我们的不同之处，这样我就没法完全接纳对方，也阻止了对方去了解自己。如果我改不掉自己身上的这个缺点，那我可能还是更适合一个人吧。不过也没关系，至少我还可以努力让自己接受这样的自己，然后继续自己的生活。虽然有点孤单，但是，这个世界上有很多种获得幸福的方式，我们至少还可以去探索属于自己的幸福之路。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心力</title>
      <link href="/2022-6/"/>
      <url>/2022-6/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/Qn_pDASw0-I" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>六月了，夏天也来了，又一次迎来了这个午后的天空和云都特别好看的季节，坏处是天气闷热起来之后会让人只想待在空调房里不想出门，好处是又可以一边吹着空调喝着冰镇饮料，一边看自己喜欢的书和电影了。过去我总觉得自己可以逃脱年龄定律，也就是永远也不会因为到了某个年纪而去做一些事情，但是，最近我的想法却发生了一些变化。人多少还是会受到自身生理上的一些影响的，到了一定的年龄，激素水平、身体器官的工作状态都会发生变化，因此心理状态也会连带着发生改变，再加上人自身的想法也在不停发生变化，你的价值取向和过去也不再相同了。所以，很多事情在你眼里的重要性会产生一些微妙的改变。我以前觉得一个人也没什么问题，只要有事做、有期待就可以了，至于有没有人爱，关系不大。现在觉得，可能后者的重要性一直在被我刻意忽略了。不过，既然明白了这一点，这也算是改变的开始吧。</p></blockquote><span id="more"></span><h4 id="6-月-1-日-孤独"><a href="#6-月-1-日-孤独" class="headerlink" title="6 月 1 日 - 孤独"></a>6 月 1 日 - 孤独</h4><p>如何面对孤独？除了刘瑜说的「一个人要像一支队伍」之外，我觉得可能不同人之间的确也存在差别。就像有的人天生长的高一样，有些人天生更擅长抵抗消极情绪，这是来自基因的优势。那没有这方面优势的人怎么办呢？只能靠后天的学习来弥补一些了。首先，孤独是什么？查了之后发现，<a href="https://baike.baidu.com/item/%E5%AD%A4%E7%8B%AC/594">百度百科</a>上对孤独的解释有两层含义，一个是生存空间和生存状态的自我封闭，脱离社会群体生活在一种消极的状态中，第二个是一种主观上觉得自己与他人或社会隔离与疏远的感觉和体验；<a href="https://zh.wikipedia.org/zh-hans/%E5%AD%A4%E7%8B%AC">维基百科</a>上的解释是：对社交孤立的一种复杂而不愉快的情绪反应，包括与他人缺乏联系或沟通，或是将来会与他人失去联系或沟通的焦虑感。我觉得这些解释对于我当下的状态都很符合。所以，解决办法不是消极面对，更重要的是走出去，去和他人沟通，建立连接，看到他人身上和我们的共同点，敞开心扉吐露内心的想法，关注自己的表达是否真实而不是他人如何反应，宽容对待他人犯的错，也允许自己犯错。如果能够做到这些，那么你所遇到的所有人都可以是自己的朋友了。</p><h4 id="6-月-2-日-感恩"><a href="#6-月-2-日-感恩" class="headerlink" title="6 月 2 日 - 感恩"></a>6 月 2 日 - 感恩</h4><p>每次心念活动趋向负面的时候，我就告诉自己，放下手头的事情，停下来休息一会儿，感受自己此刻的呼吸。如果条件允许的话，去户外走一走，看看周围的花草建筑，草地上的鸟儿，水里的鱼，天边的云，远处的大楼。用心观察身边的世界，你才会发现原来一切都是那么地美好，而你却总是忘记要感恩自己此刻所拥有的这一切。我觉得最值得感恩的首先是我还活着这一事实，以及我能看、能听、能说，也能跑、能跳、能思考，这些都是值得感恩的事，物质上的享受和这些相比真的一点都不重要。一个人只要还拥有这些，那他就是幸福的，其它所有的不幸都是他自己造成的，诸如无法控制自己的欲望，精神上对他人的依赖，不愿意为自己负责，被恐惧支配，等等。今天和过去的每一天都不一样，也都一样。不一样在于你整个人对于即将发生的事是未知的，也许你会重复过去做过的事，但是你没法重复任何一天的生活，也没法安排好每件事。一样的地方在于，你依旧是你，而不是其他任何人。想象你最快乐的一天是怎样度过的？其实让你感到快乐的，除了那时所做的事之外，最大的不同是你当时的心态。如果那时的你能感受到快乐，那么，今天的你也同样有能力获得快乐。如果当下的环境让你感受不到快乐，那么你至少还可以用平静的心态去接受它。</p><h4 id="6-月-3-日-痛苦"><a href="#6-月-3-日-痛苦" class="headerlink" title="6 月 3 日 - 痛苦"></a>6 月 3 日 - 痛苦</h4><p>真正的哲学问题只有一个，那就是自杀。我觉得所有人都会在人生的某一时刻，在脑海中闪过自杀的想法，因为人只要活着就会有痛苦，人本能地会想要远离痛苦，而当痛苦无法避免的时候，最后的选项就是通过自杀来寻求解脱了。但这并不是说我们就是一个软弱的人，因为绝大多数人最终都会选择直面痛苦，并且尽全力去想办法解决问题。而且人对死亡的恐惧是最原始的，不到非不得已，没有人会主动选择放弃自己的生命。况且如果一个人连对死亡的恐惧都能战胜，那还有什么困难是不能面对的呢？这也让我联想到，除了死亡之外，有什么样的痛苦是我绝对不能接受的？身体上的极限其实大家都差不多，普通人如果没有经过训练，对极冷极热等极端环境都无法忍受太长的时间，我觉得真正造成差别的是我们的心理承受能力。你能承受多大的压力，你面对挑战时的态度是怎样的，你对自己无法控制的事持什么样的态度，你面对他人的负面评价作何反应，不被他人理解、不被接受甚至是被侮辱时，又会采取什么样的行为，我觉得这些才是考验人的地方，也是我们需要不断修炼自己的原因。理想情况下，我们当然希望自己生活在一个无压力、平等友爱、互帮互助的环境中，但是现实是我们必须学会在充满矛盾和冲突的世界中保持内心的镇定，锻炼自己在压力下处理各种事件的能力，这其实也是对我们的考验。当然，我们还是应该尽量避免压力过大的环境，因为长期处于压力和焦虑情绪下，对人的心理和生理健康都会造成很多不好的影响，但是，适度的压力可以使我们成长，让我们变成一个更好的人。人作为一个社交动物，免不了需要和他人打交道，如果你没有学会用合适的方式去处理上面提到的种种问题，你的烦恼只会越来越多。</p><h4 id="6-月-4-日-全裸导演"><a href="#6-月-4-日-全裸导演" class="headerlink" title="6 月 4 日 - 全裸导演"></a>6 月 4 日 - 全裸导演</h4><p>昨晚熬夜追剧看全裸导演第一季，是基于村西透的自传拍的。说实话，一开始其实我是冲着情色主题去的，还有就是有点好奇造福了全世界男人的日本 AV 产业当初是怎么发展起来的。那个年代的日本其实和其它东亚国家一样，性压抑还是比较明显的。主角外表上是一家之主，然而跑业务的时候却需要装得比谁都孙子，而且妻子背地里一直在瞒着他出轨，甚至连他的孩子也瞧不起他。但是，由于过去成长过程中的对贫穷的记忆，使得他不得不在承受压力的同时，也默默接受着这一切。直到最后，当他发现妻子在家中出轨，而原因竟然是自己满足不了她，主角情绪彻底崩溃，在机缘巧合下成了色情录音带的推销员，并且一步步从开成人杂志店到自己拍摄并出版成人杂志，最后分店遍布整个北海道，甚至还被同行大佬排挤入了狱，出狱后又从头开始，从一个色情片导演一步步发展成为色情片大王。让我印象最深的是他在一开始卖色情录音带时说的一句话：<strong>我要贩卖人类的性欲。</strong>看到男主满眼放光的那一刻，突然意识到，其实人一旦找到自己的目标，他就会变得充满斗志。性也只是生活的一部分，但那时候的大众刚刚走向性解放，需求巨大，主人公只不过提前嗅到了这个机会并且全情投身其中。没想到看这样的剧也能让我联想到人生的使命感，其实每次想到这个话题就挺焦虑的。不过焦虑也没什么用，先把自己的工作做到最好吧。在职场中发挥自己的价值也没什么不好，大多数人其实并不适合做生意或者创业。</p><h4 id="6-月-5-日-假期碎碎念"><a href="#6-月-5-日-假期碎碎念" class="headerlink" title="6 月 5 日 - 假期碎碎念"></a>6 月 5 日 - 假期碎碎念</h4><p>端午假期的最后一天，好好珍惜。这应该是我最近几年里第一次没在公共假期回家。这两天都没怎么出门，而且假期的时间好像总是过得特别快：早上起得比较晚，运动完看会儿书就中午了，吃完午饭看几个视频，下楼练会儿轮滑，再随便干点什么，马上半天就过去了，晚上再看看剧和电影，一天就这么过去了。所以啊，没有计划的生活会让人一事无成。不过，我好像还挺享受这样的生活的。但我最近似乎一直处于这样的状态，心里难免会有点紧张，担心自己一直这样放松下去会失去竞争力。所以，可能还是得仔细想想自己的未来到底要如何发展吧。我现在的工作，压力不大，平常也有自己的时间，薪资虽然不算高，但是至少还是和自己的付出成正比的。但是未来呢？我从去年一来到这里，我就知道自己不可能在这里待得太久，但是，我也不知道未来应该去哪。大公司内卷严重，小公司又很难抉择。就像现在的公司，我能完成好自己的工作，但是总觉得少了点什么，可能是因为我和身边的同事相处得不是很好吧，心里始终有种融入不进去的感觉，我不喜欢他们，也不爱和他们聊天。我知道很大一部分原因出在我自己身上，所以也不确定换了一家公司之后就能解决这个问题。还有就是，我觉得我是一个不那么自律的人，我需要外界给我一定的压力才能发挥出最佳表现，但是现在的环境太宽松了，让我变得有些懈怠，能力上的提高反而没过去那么明显了。</p><p>不知道这些是不是我给自己找的理由，因为人总是想要为自己解释开脱，把责任推到外界环境上，然后自己就可以心安理得地继续过着得过且过的生活了。真正需要改变的是我自己，而我内心又不愿意行动，所以妄想跳槽之后就能解决自己身上的问题。想想那些境遇不如自己的人，凭什么你比别人拥有更多却还是这么不满足？当然，努力奋斗是应该的，但是能不能不要老是想着自己，多想想自己的每次决定能为身边的人带去什么。也许只有这样，内心的那些纠结才会消失吧。尽量为更多的人创造价值，即使不能为自己获利，至少可以让自己变得更好。</p><h4 id="6-月-6-日-有期待"><a href="#6-月-6-日-有期待" class="headerlink" title="6 月 6 日 - 有期待"></a>6 月 6 日 - 有期待</h4><p>对生活保持期待是非常重要的一件事，有的时候感到情绪失落大都是因为觉得没什么可期待的。比如有时候下班之后，如果下雨天没法出门跑步，也不想去楼下玩轮滑，而且也没有什么想看的书或者电影，当一个人觉得自己没啥可忙的时候，就特别容易感到失落，好像生活失去了方向。所以，我也突然特别能够理解爸妈的心情了，他们催我恋爱、找对象，我觉得很重要的原因之一是——他们的生活中没有其他可以期待的事了。而且他们这一辈子基本上都是围绕着子女转的，已经习惯了，想让他们停下来是很难的。只要我还没成家，那他们就还有所期待，也就有事可操心了。尽管我有时候觉得这挺可悲的，但是，又很不忍心去戳穿他们。我也知道他们很难去改变自己，现在去劝他们活出自己的人生也有点晚了，毕竟他们的人生已经走过一大半，所以我只能尽力去安抚好他们。不过，内心还是觉得，我的人生是我自己的。况且我过去的绝大部分选择都是自己一个人做出的，包括高中文理分科、高考完选专业、大学毕业后的择业等，这点当然要感谢父母的不干涉，不过对于感情生活，我当然还是希望由自己做决定。要不要谈恋爱，要不要结婚，什么时候谈，什么时候结婚，这些本来就是一个人自己的事情，只能由他自己决定。即使他选择一辈子单身，虽然他的家人会不理解、会伤心，但是和其他任何人都没有关系。我觉得我还是很幸运的，我对我现在拥有的一切都很满足，至于能不能遇到一个相处轻松又彼此合适的人，只能看运气了。有的话最好，没有的话我也能接受，过好每一天最重要。</p><h4 id="6-月-7-日-养成好习惯"><a href="#6-月-7-日-养成好习惯" class="headerlink" title="6 月 7 日 - 养成好习惯"></a>6 月 7 日 - 养成好习惯</h4><p>想要让工作变成爱好，但是好像这太难了，尤其是状态不是太好的时候，每天上班就像在坐牢。早上看完微信公众号文章，跑下昨天的代码，然后随便修修补补，一个上午就过去了。下午好不容易写了点功能代码，到 4、5 点的时候，就忍不住想要去逛下论坛、看看文章解闷，再加上有时候同事在边上电话会议，就更加不想写代码了，看技术文档也不太看得进去。下班之后也完全不想碰代码，跑完步、洗完澡坐到椅子里就只想看看视频、刷刷社交网络，让大脑彻底放空。冷静下来的时候也会感到焦虑，觉得如果保持这样的状态下去，最终可能连工作都保不住了，更不要说做其他事了。能意识到这点已经算是改变的开始，接下来就是要付诸行动。尽量回到过去效率最高的时候的状态，定时远离手机和社交网络，按计划在规定的时间内学习或者看书。保持充足的睡眠和适当的运动，该休息的时候好好休息，该专注的时候要像入定一样地专注。只要养成习惯了，就不需要再靠自我或他人的监督来维持了。</p><h4 id="6-月-8-日-愉快相处的秘诀"><a href="#6-月-8-日-愉快相处的秘诀" class="headerlink" title="6 月 8 日 - 愉快相处的秘诀"></a>6 月 8 日 - 愉快相处的秘诀</h4><p>最近看了很多情感问答，发现其实谈不谈恋爱都会遇到很多问题，而谈的时候如果你的对象不能很好地和你沟通，或者你让自己的情绪陷得太深，你面对的痛苦可能比单身时候遇到的问题更大、更难以忍受。因为毕竟单身时候遇到的问题是比较单一的，如果你无法靠自己一个人的力量解决，那通常就只能放弃了，但是两个人的时候就没那么简单了，你情不自禁地就会把自己的想法投射到对方身上，当对方无法理解自己的时候，矛盾就产生了。恋爱其实就是把自己的一部分交给对方，两个人合二为一，所以，我们很难保证自己不会对对方产生过高的期望。有时候明知道这种期望是无法实现的，但是还是忍不住把它投射到对方身上，或者是投射到两个人的关系上，但实际上没有人能够完全满足我们的这种期待。</p><p>两个人相处也需要为彼此保留一定的空间，只有这样，两个人的关系才能更加健康、长久地发展下去。你的恋爱对象曾经也只是一个陌生人，想想你是怎么对待陌生人、你的同事和身边朋友的，你就应该如何对待你的对象。也许你会觉得爱一个人就应该毫无保留地展示出真实的自己，但是对方终究不是自己，不可能时时刻刻都能完全忍受这样的自己，所以还是要学会像对待普通人一样去和对方相处。尊重彼此，保持风度和一定的社交礼仪。</p><p>说了这么多，然而我还是单身。不过我觉得知道这些是有用的，即使不是谈恋爱，和任何人相处都要保持这样的态度。不要完全把自己交给另一个人，但是要总是站在他人的角度思考问题。爱一个人就是要让对方幸福，但也不要因此造成你自己的牺牲。互利共赢不仅是人类发展的主旋律，也是个体之间长久和谐相处的秘诀。</p><h4 id="6-月-9-日-学会大方"><a href="#6-月-9-日-学会大方" class="headerlink" title="6 月 9 日 - 学会大方"></a>6 月 9 日 - 学会大方</h4><p>偶然间看到一句话：一个人到了 30 岁左右，要学会如何变成一个大方的人，否则就容易陷入被动。这里的「大方」主要是指花钱大方，比如和人吃饭的时候主动买单等。反思了一下自己，的确，我从来都不是一个大方的人，即使是已经毕业五年的我，也很少花钱在请人吃饭或者送礼上。当然，这一方面是因为我没什么钱，加上朋友也很少。其次，也因为我比较喜欢和周围的人划清界限，什么东西都喜欢分得比较清楚，而这就导致我和身边人的关系更加冷淡了。虽然有时候也知道花点钱也没什么，但是心里多少还是会怀疑这值得吗，甚至觉得自己是在向对方谄媚。不过，我并不觉得自己是一个抠门的人，至少我对自己还是比较大方的，虽然很少冲动消费，但是大部分真正想要的东西都会毫不犹豫地掏钱。至于对待别人，我好像的确没那么大方，哪怕是家人。我到现在给爸妈买的东西，加起来也不超过一万块，至于其他亲戚朋友，那就更少了。我也在反思，是什么导致了我这样的性格？家里老爸好像还算出手大方的人，但是老妈就比较「小气」了，以前常常听到老妈埋怨老爸「打肿脸充胖子」，因为老爸经常借给别人钱然后又要不回来。但是，老妈对待家人还是很大方的，比如我们小时候从来没觉得自己家穷过，虽然长大之后才意识到，原来自己家和别人家相比，其实是算不富裕的。而且老妈那会儿又非常勤劳能干，有时候还常常「照顾」亲戚家的小孩。所以，老妈其实也算是个「大方」的人。但是到我这里，我怎么就变成这样的人了呢？我觉得节约是好事，但是学会花钱也很重要。那么，就从更大方地为自己的家人花钱开始吧。不要管他们怎么说，没有人会讨厌收礼物吧？还有就是改变心态，如果能够通过花钱改善你和你在乎的人的关系，加上对方开心了，你也开心了，那这不是超值吗？</p><h4 id="6-月-10-日-同理心"><a href="#6-月-10-日-同理心" class="headerlink" title="6 月 10 日 - 同理心"></a>6 月 10 日 - 同理心</h4><p>看了老钱的<a href="https://mp.weixin.qq.com/s/XAXvIcJfcWJi-YlvPljX4A">一篇文章</a>，一个深圳小老板在工厂倒闭之后依旧保持良好心态，甚至在路边发现了新需求，给人免费补电动车上的座椅破洞，然后留个微信二维码，就这样还真的收到了不少的转账收入。特别同意老钱说的，发现新商机需要的不是智商而是同理心。能不能发现别人的痛点和需求，关键在于你是否习惯将自己带入他人的视角，而不是坐在那异想天开。当你有了同理心，你才能知道什么是让多数人在乎的或者感到烦恼的，而又有什么是你能够做的，并且能在多大程度上解决他的烦恼。再进一步，有多少人有相似的烦恼，你是否有能力创造出一个产品去一步到位地解决这个问题。我发现程序员当久了容易有个错觉，那就是觉得身边的人都是傻瓜，明明有更好的做法却不肯去做，所有的问题都是他们自己造成的。这种想法本身就是缺乏同理心的表现，如果站在对方的角度思考，你会发现其实如果你是他，你可能也会做出类似的选择，而且也不一定能够比对方取得更好的结果。即使在某个场景下你是对的，但是你是否就能保证自己不会犯相似的错误呢？拥有同理心的意思是，你要放下自我，放下傲慢与偏见，穿上别人的鞋子去走一段路，只有这样，你才能发现不一样的世界。</p><h4 id="6-月-11-日-平静对待一切"><a href="#6-月-11-日-平静对待一切" class="headerlink" title="6 月 11 日 - 平静对待一切"></a>6 月 11 日 - 平静对待一切</h4><p>参加了堂哥的婚礼，有很多感触，对我自己来说，又一次感到：我真的应该像成年人一样思考问题了。说起来，我年纪也不小了，但是思维还是非常简单。也许是自身经历太过单薄吧，所以为人处世方面还是很不成熟。但我想，到了这个年纪，人的优点和缺点都已经非常明显了，认识你的人都知道你是个什么样的人，也不需要过多的解释了。而和不认识你的人交往，保持相互之间的尊重就好，相处得来那就聊一会，如果聊不来也就不要勉强了，除非你有求于对方。虽然很功利，但是只要是基于彼此都认同的规则，做一些利益交换也没什么不对。</p><p>我一直在想，如果我继续按目前方式生活有什么风险？除了被人说闲话，内心偶尔感到迷茫、孤独，其他好像也没什么。人最重要的是做到能够逻辑自洽，只要他能形成一套解释自己和世界的逻辑，那么，即使外界如何变化，甚至是自身发生变化，也都是可以接受的。另外非常重要的一点是，人一定要学会爱自己，即使世界上没有人爱自己也一样。我知道我是个非常幸运的人，我得到过父母无条件的爱，但是有的人因为从小经历过被父母抛弃或者是有条件的「爱」之后，很难培养起这样的意识。但是，人总是会成长的，当到了一定的年纪之后，如果还是无法培养起这样的能力的话，我觉得可能更主要的还是他自己的问题，因为也有不少处境更艰难但是最终还是学会如何爱自己的人的例子。说到底，人生在世不过短短几十年，我们都是这个星球的过客，学会一些东西，经历一些事情，爱过，痛过，伤心过，也会拥有一些值得回忆的幸福时刻，然而我们最终的结果都是一样的——孤身一人离开这个世界。那么，不妨早点接受这个结局。至于中间会发生什么样的事，那就取决于我们自己了，还有就是能否交上好运。总之，平静对待一切吧。</p><h4 id="6-月-12-日-Kurt-Caz’s-Vlog"><a href="#6-月-12-日-Kurt-Caz’s-Vlog" class="headerlink" title="6 月 12 日 - Kurt Caz’s Vlog"></a>6 月 12 日 - Kurt Caz’s Vlog</h4><p>下午回到小区，整理完东西就躺在椅子里刷手机，由于下雨没法出门运动，所以一不小心就又刷了一晚上的油管视频，看了一个博主在巴西里约和当地一个贫民窟出身的 Jujitsu 冠军一天生活的 <a href="https://www.youtube.com/watch?v=aM-jEC6tMNQ">vlog</a>，还有同一个博主在委内瑞拉的 <a href="https://www.youtube.com/watch?v=cOScCHtNWYM">vlog</a>。不知道为什么，突然觉得蛮感动的，这个世界虽然很大，但其实无论我们生活在哪里，虽然我们拥有不同的文化背景，不同的经济条件，但是我们作为生活在社会群体中的一员，本质上其实并没有什么不同。哪怕是住在贫民窟里的人，同样可以过得很快乐。虽然他们拥有得并不多，有的时候甚至还要面对非常不安全的居住环境，但是只要一家人能够开心地生活在一起，或者生活中有值得追求的目标，加上背后能有支持自己的家人、师长和亲友，就可以生活得非常幸福。所以，我也不由得开始思考我生活中幸福的来源有哪些。</p><p>绝大部分时候，我都过着独居的生活，除了偶尔一个月回一次家。除了同事之外，我生活中很少和其他人交流，我没有私人的社交圈，和过去的同学、朋友基本不再联系。所以，我能够获得的社会支持很少很少。但是在精神上，我是一个能够自给自足的人。以前也有感到烦恼、苦闷的时候，但是现在的我基本能够接受这样的生活了。我也经常反思自己是否应该改变，去努力结交更多的朋友，但是最终好像总是会又回到一个人的状态。也许，这样的生活才是最适合我的吧。我选择斯多葛主义作为自己的生活哲学，我觉得幸福只能向内探索，同时也在学习如何变得更知足。我觉得保持内心的平静才是最重要的，但是，也不放弃努力探索未知。我知道追求更好是为了完善我们自身，而不是实现某种外在的目标。但是，矛盾的地方在于，有时候我也会想要和这个世界创造出更深、更有意义的联系。说到底，人还是一种社交动物，精神再富足的人也还是需要和他人保持一定的交流。生活中没有可以深度交流的人，总会让人感到失望。也许是我想要的太多了吧。好在还有互联网，至少我还有一个通道去表达自己内心的想法，并且偶尔也能获得一些共鸣。既然如此，那就先努力改变自己、提升自己，让自己变得更有价值吧。</p><h4 id="6-月-13-日-尊重事实"><a href="#6-月-13-日-尊重事实" class="headerlink" title="6 月 13 日 - 尊重事实"></a>6 月 13 日 - 尊重事实</h4><p>越来越觉得，其实我本质上是非常在乎他人评价的人，比如我会特别在意他人的眼光，在意自己在别人眼中的形象，所以才会害怕出现在公众场合，害怕当众演讲，害怕自己出错，害怕被他人嘲笑。理智上我会认为他人的观点不重要，即使是负面评价也并不能伤害到我，但现实中还是很难做到。我相信一个人的本质不会发生改变，我是什么样的人，不会因为他人的评价而变化。尽管现实中存在一些恶人，他们以贬损他人为乐，以此抬高自己的地位或者获得某种满足感，但是这样的人毕竟是少数。绝大多数人的评价其实只是他自己的观点，有的是积极的，可以帮你看清自身的缺点，有的不那么客观，但是也是从他们的立场出发得出的，所以也没必要苛责对方。有则改之，无则加勉，这就是最好的做法。也许我永远也做不到完全不在乎他人的评价，但是至少可以把自己修炼成一个对各种评价都能做到淡然处之的人。尽可能地尊重事实，不要因为他人的贬损或者赞美而失去对自我的真实评价。</p><h4 id="6-月-14-日-对出错的心态变化"><a href="#6-月-14-日-对出错的心态变化" class="headerlink" title="6 月 14 日 - 对出错的心态变化"></a>6 月 14 日 - 对出错的心态变化</h4><p>这几天又在处理管控软件的问题，各种问题不断，由于项目代码陈旧，所以只能反反复复调试代码。最难受的地方在于没有可以测试用的真机，于是只能在客户的线上环境测试，还得和客户一对一沟通。不过，好在我们的客户还是高中生，算是最好沟通的对象了，既有耐心又还保持着对权威的一丝尊崇。最终总算是定位到问题并且解决了问题，但我总觉得这样的经历似曾相识。我的第一份工作中有过这样的经历，第二份工作则是在一开始的时候就在线上环境酿成过事故，这次算是我来到拾米后遇到的第一次比较大的挑战吧。心里总觉得这样的事故会给自己的形象造成负面影响：发生了这样的事，我在同事、上司眼中的形象可能就没那么「完美」了。但是，转念一想，程序员这个职业应该是世界上最容易犯错的职业吧，毕竟任何一行代码的改动都有可能造成程序运行出错，所以，我们才需要那么多测试人员，就是因为程序员连自己写的代码都测试不过来了。再加上其实很多项目根本就没有花太多时间做测试，尤其是小公司的项目。我工作到现在接触的绝大部分项目连单元测试都没有，更不要说集成测试了。当然，我也知道是因为自己水平太一般，接触不到那些厉害的公司和厉害的项目。</p><p>不过，我也注意到这次事件中我自己心态的变化。过去，当遇到问题或者发生事故的时候，我总是想要先推脱责任，当推脱不了的时候才会认怂，而等事情过去之后心里又会感到非常自责，觉得自己真的太差劲了，以后一定要更加认真工作来弥补自己的错误。但是这一次，我的心态特别平和，有一刻甚至觉得「反正问题迟早都会被解决的，现在有什么好着急的」。这次毕竟不是因为自己写的代码而导致出现问题，不过既然我已经接手项目了，这锅也应该由我来背。可能就是因为这样才导致我心态上的变化吧，现实中总会有意外发生，世界上不存在完全可控的风险。这是不是意味着我已经变成老油条了？我甚至有种想法，觉得这毕竟只是一份工作而已，没必要用它来惩罚自己，生活总归还是要继续的。是的，如果非要总结的话，我觉得自己最大的变化是我已经越来越能把工作和生活分离开来了。这没什么不好的。每个人当然都想让工作变成自己的爱好，然后全情投入其中，但现实是，想要做到这样，很难很难，只有非常幸运和努力的人才可以。不过，正是因为这样，我们才应该更加努力，因为不努力的话，你的境况甚至会变得更差，选择也越来越少。</p><h4 id="6-月-15-日-反脆弱"><a href="#6-月-15-日-反脆弱" class="headerlink" title="6 月 15 日 - 反脆弱"></a>6 月 15 日 - 反脆弱</h4><p>再一次拿起《反脆弱》开始看，这次是抱着只看自己喜欢的部分的心态去看的，没想到这样反而更容易看得下去了。我觉得我自己就是一个反脆弱的例子，从小成长在一个容易受打压的环境中，但是我居然变成了一个挺乐观也不容易气馁的人，即使遇到了他人的讽刺和挖苦，我的反应一般也就是装作没听懂，或者选择转移话题从而避免尴尬和不舒服。但是这样也有缺点，那就是我特别害怕和别人起正面冲突。当遇到别人生气了或者发怒了，我会选择用嘻嘻哈哈的态度糊弄过去，而不是正面处理冲突。我也不知道这样是好是坏。因为虽然可以避免当下的冲突升级，但是却有可能助长对方通过发怒让你妥协，而不是通过理性沟通寻找到有利于彼此的解决方案。我身上另外一个反脆弱的地方是，我从来不认为我会屈服于他人的压力之下，尤其是权威。这点和我的成长环境有关，但是我也不知道是什么时候形成这种习惯的。有可能是在上小学的时候，有一次我发现原来老师也会犯错，而且犯了错之后还不愿意承认和改正自己的错误，我第一次意识到：嗯，没必要全部都听老师的。那么，反脆弱带给了我什么呢？第一，我不是特别在乎外界环境是否和自己的愿，因为我知道无论什么样的环境我都能适应它。第二，我也不在乎能不能得到他人的认同，因为他人的观点对我来说并不重要。真理往往掌握在少数人手里，并不是你得到了大多数人的赞同就拥有了真理。我觉得这是我从反脆弱思维中收益最多的两个点。</p><h4 id="6-月-16-日-阅读倾向"><a href="#6-月-16-日-阅读倾向" class="headerlink" title="6 月 16 日 - 阅读倾向"></a>6 月 16 日 - 阅读倾向</h4><p>我们应该阅读什么样的书籍？回顾了下我过去看过的书，发现其实根本没什么规律，一来是因为我基本上都是从别的地方看到某本书，觉得挺有意思就去买来看了。一开始的时候还是比较迷信所谓的「经典」的，但是后来就慢慢意识到自己的阅读倾向最重要，所以基本就不会仅仅看了别人的推荐就去看书了，而是会问自己是不是真的感兴趣，或者这本书是否能解决我某方面的疑惑。当然，你关注的人也很重要，只有真正有品味而且也有良心的人才能推荐好书。我就是因为很早的时候关注了连岳、吴主任、菁城子等才开始喜欢经济学，尤其是奥派，一开始看罗斯巴德看得迷迷糊糊，后来才开始看更易读的一些经济学读物，比如一课经济学、经济学的思维方式、巴斯夏的看得见的与看不见的，才开始大概知道经济学是怎么一回事。所以，其实很多时候你关注的人会给你打开一扇窗，让你看到更广阔的世界，但最终还是要靠你自己去奔跑探索才能发现真实世界是什么样的。一旦你走进了阅读世界的大门，你的世界会变得异常宽广，一切东西包括你熟悉的和不熟悉的，都会变得有趣起来，所有东西都值得探索和讨论，所有东西都可以去尝试和学习。我觉得这才是生为人最快乐的地方：有理性，能思考，能学习。即使无法改变我们身处的世界，但是至少可以让自己生活地更好，以及丰富自己的精神世界。</p><h4 id="6-月-17-日-玩好你的游戏"><a href="#6-月-17-日-玩好你的游戏" class="headerlink" title="6 月 17 日 - 玩好你的游戏"></a>6 月 17 日 - 玩好你的游戏</h4><p>我现在在玩什么游戏？简单来说就是，通过自己的技术能力为他人服务，与其他人合作创造出符合客户预期的产品并且按时交付。这样的模式其实在软件开发行业非常常见，唯一不同的是，有的公司开发的是自己的产品，有的公司则是为其他人开发，他们的产品不是直接面向最终的用户而是中间委托他们开发产品的甲方。回顾自己的职业生涯，虽然只待过三家公司，但是其中有两家都是后一种模式，虽然大家都对这种技术外包公司评价很低，但是我却觉得，其实他们没有什么本质上的不同。抛开这两种模式不谈，我觉得其实我还是挺擅长玩这种游戏的，而且除此之外，我也不知道自己还能玩什么样的游戏了。市场上本质的工作只有三种，一种是创造，一种是销售，还有介于创造和销售之间的服务。本质上来说，所有人做的都是服务工作，只不过最后一种是直接服务他人，要么是服务于前两种人，要么是服务客户。程序员应该属于创造类工作，因为我们需要从无到有地创造出一件产品。项目/产品经理属于服务人员，他们负责保障项目/产品按照预期交付。老板的主要角色之一是销售，他需要了解市场，了解什么样的产品能够解决市场上的哪一类问题，并且协调产品的开发，保证最终的产品能够接触到目标客户并且产生利润。哪怕离开软件行业，其它行业也是一样，甚至是不同的领域，比如政治界、学术界、艺术界、演艺界、体育界等等也都适用，只不过标准和准入门槛有所不同。有时候会瞎想，假如我在另一个行业，我会做什么样的工作，过着什么样的生活，我能玩好它吗？</p><h4 id="6-月-18-日-银翼杀手2049"><a href="#6-月-18-日-银翼杀手2049" class="headerlink" title="6 月 18 日 - 银翼杀手2049"></a>6 月 18 日 - 银翼杀手2049</h4><p>昨晚重新看了一遍银翼杀手2049，看的过程中，对未来那种先进科技与被严重破坏的环境相结合形成的氛围，真的喜欢不起来。过去一直觉得赛博朋克很酷，现在却觉得，其实这是对未来的科技与生活的一种悲观的想象。我觉得科技一定是会最大程度地造福所有人的，尽管会有些弊端，但是这些弊端更多是由人类自己造成的，而不是科技。如果说科技对人类生活的改变，仅限于使人获得一些能力上的提升，比如人手一台高性能计算机，随时和地球上任何一个人联系的能力，而无法让人生活得更加健康、感到更快乐和幸福，反而让人沉迷于虚拟世界、思考能力退化、情绪波动大、生活得更加孤独，这一定不是因为技术的原因，而是技术的使用者。当然，银翼杀手这部电影讨论的内容其实已经超越了科技，已经触及到我们是什么的问题。人类到底是什么？只是一具肉身结合一颗能够学习和思考的大脑吗？如果人类能够创造出这样的肉身和大脑，并且使得他们比自然出生的人更加强大，那么，他们还是「人」吗？他们是否应该平等享受「人」所具有的权力？我们应该如何和这样的「人」相处？如何保证他们不会凌驾于我们这样更弱的「人」之上？其实科技发展到一定程度之后，都需要面对这样的道德问题，同样的道德困境还存在于机器人身上，甚至是不存在物理实体但是和人一样能够思考和拥有情感的云端人工智能。科幻小说中喜欢把机器人视为比人更为低下的种族，但是我倒觉得，如果人真的能够改良自身，那说明这其实是人类未来进化的方向，我们不再需要通过繁衍来让文明继续向前发展。但是这又涉及到另一个问题，那就是人是否应该像其它动物一样，接受自然死亡的结果。当我们可以做到不断替换自己的器官而达到永生，那么，那时的世界会变成什么样？科技还在不停地发展，但是不再有或者很少有新的人类诞生。而且死亡的代价太过高昂，为了避免死亡，人类可能会变得越来越保守，不再追求探索和发现新世界。所幸我所生活的世界暂时不需要面对这样的问题，我们这一代人应该可以毫无意外地走向死亡结局，让未来的人们去解决这些问题吧。</p><h4 id="6-月-19-日-建立个人垄断"><a href="#6-月-19-日-建立个人垄断" class="headerlink" title="6 月 19 日 - 建立个人垄断"></a>6 月 19 日 - 建立个人垄断</h4><p>昨天下午去矫正复查，足足等了一个半小时才终于轮到我，心里暗骂自己是傻X，当初就不应该选择这家诊所和这个医生。但是等待的过程中也有了一个顿悟，那就是我们都需要在网络上建立起自己的好名声，这样你的客户就会源源不断地来找你，当然前提是你有自己的核心竞争力。那么，我的核心竞争力是什么？如何才能在网络上建立起个人品牌？又想到前几天看到的 David Perell 说的在网上建立<a href="https://twitter.com/david_perell/status/1259539005097426944?s=20&t=swUNh-b0ojDrlE60hjKjNQ">个人垄断</a>的方法，找到只有你能做的利基市场，然后在网络上分享你的知识和经验。想了很久，似乎还是没想出有什么事是只有我能做。也有可能是我对自己的认识还不够全面吧。虽然我的确很普通，但是我真的相信其实每个人身上都有他和其他人不一样的地方。世界上没有两个完全相同的人，每个人的优点和兴趣爱好都有不同，加上自身的成长经历和后天的学习，遇见过的不同的人、看过的书籍和电影，这些都会把我们造就成独一无二的人。我们需要慢慢发掘出自己身上的特性，找到闪光点，通过将独一无二的兴趣和技能组合在一起，并且从中找到能够对这个世界和其他人所产生的价值，再通过慢慢培养起更大的兴趣，不断打磨它，也许就能让自己成为一个具有自身特色并且也对他人有用的人。而且我们也不再需要担心与他人的竞争，因为我们只是在做自己，而没有人可以比我们更好地做自己。虽然暂时还没能找到自己身上这样的特点，但是我相信，只要不停地思考和尝试，最终总会有一个比较好的结果的。</p><h4 id="6-月-20-日-绝命毒师"><a href="#6-月-20-日-绝命毒师" class="headerlink" title="6 月 20 日 - 绝命毒师"></a>6 月 20 日 - 绝命毒师</h4><p>昨晚开始熬夜看绝命毒师第一季，不得不承认，剧情让人感到荒诞的同时又会觉得非常合理，谁能知道一个绝望的、原本是高材生的高中化学老师会用他生命的最后期限来干什么呢？走投无路自杀是可能的，去制造病毒也是可能的。看评论说这部剧大火的原因之一是，这是一个人中年危机的体现。对自己即将死去的恐惧和不甘心；明明自己的世界都已经崩塌了，但是还是要在家人面前装作一切都很好，因为你是他们的支柱，而且也不想让家人为自己担心。现实中每个人都会遇到这些问题，只不过当我们到了一定的年纪之后，这些问题会集中显现从而让我们倍感压力。身体逐渐显现出衰老的迹象，同时还得承受照顾家人的责任；面对上有老、下有小的责任，出于经济上的压力不得不妥协去做一些过去不愿意做的事；再加上身体和心理上的双重压力，于是乎中年人迎来了他们的中年危机。不知道未来我会如何应对它，但我想提前做一些准备是有必要的吧。其中必须要做的是做好财务上的规划，量力而行，不要过度消费。我觉得这部剧中的一个大前提就是 Walter 的财务危机。不得不承认，现代社会，只要有钱基本就能解决 90% 以上的烦恼。所以，努力拓宽自己收入来源是很重要的事，越年轻的时候越要认识到这一点。其次，始终要把个人的幸福放在第一位。爱家人很重要，但是不要为了家人去牺牲自己的幸福。只有你自己生活得幸福之后，你才有可能为家人创造出更大的幸福，包括去影响他们。你个人的不幸福最终一定是会影响到你的家人的，而且如果你为了家人而牺牲自己，一旦家人发现之后，他们只会感到更大的压力。</p><h4 id="6-月-21-日-算法题和编程"><a href="#6-月-21-日-算法题和编程" class="headerlink" title="6 月 21 日 - 算法题和编程"></a>6 月 21 日 - 算法题和编程</h4><p>看到 HN 上的一个问答，关于 <a href="https://news.ycombinator.com/item?id=31802502">leetcode</a> 的问题，简单来说就是 OP 觉得自己解不了 leetcode 中等以上的问题，他更喜欢开发出实际的产品，但是刷 leetcode 又是进入大公司的必经之路，而且参与大公司的产品，能够获得的影响力更大工资也更高，所以 OP 很沮丧。老实说，我曾经也有过这样的疑问，为什么一定要刷算法题，明明实际工作中根本用不到？为什么要问那些网上可以搜到答案的问题，编程技巧和解决问题的能力明明更重要吧？但是我后来也想明白了，大公司其实是用算法题作为门槛来筛选求职者的，毕竟有那么多候选人都想要加入，最简便的方法就是设置一道门槛，能够通过的再来继续往后筛选。如果你连这种只是需要刷时间而且模式固定的东西都搞不定，那要怎么相信你能解决更困难的问题呢？程序员的核心能力，说到底就是通过编码解决实际问题，还有就是沟通、协调、合作等各方面的软技能。当然，算法题也不是完全没有用，它还是可以锻炼一个人的思维能力的。虽然大部分开发工作中都用不到复杂的算法，但是知道怎样解决复杂的算法问题，可以帮助你培养起编程的思维方式，还有就是让你对各种数据结构有更深的掌握。比如，汉诺塔问题，那么几行代码就可以解决一个用正常思维很难描述清楚的问题，你只需要理解递归是什么就可以解决这样的问题了，不得不让人感叹程序的神奇和精妙之处。至于求职问题，关键是要想清楚你想要什么。如果你要进入大公司，那么刷题就是必须要过的一关，别想太多，熬时间就可以了。但是，如果你只是喜欢编程，那就用空余时间去做自己喜欢的产品，保持对编程的热爱。千万不要因为解不了算法题而觉得自己不适合编程，那只是编程中的一部分而已。软件工程说到底和计算机科学还是不一样的，而且我并不觉得前者就比后者更简单。</p><h4 id="6-月-22-日-比恋爱和婚姻更重要的事"><a href="#6-月-22-日-比恋爱和婚姻更重要的事" class="headerlink" title="6 月 22 日 - 比恋爱和婚姻更重要的事"></a>6 月 22 日 - 比恋爱和婚姻更重要的事</h4><p>晚上看了一个<a href="https://www.youtube.com/watch?v=R4tknoHRkd8">跟拍视频</a>，一个互联网高管居家办公的一天，很喜欢视频中采访对象的生活态度，也羡慕她对自己的工作能有这么高的热情。其实是否谈恋爱或者结婚都不能解决「我们应该如何度过自己的人生」这个问题，即使找到了生命中的另一半，我们还是得独自面对这个问题。有的人拥有自己的热爱之事，并且可以凭借它来丰富自己的物质生活和精神世界，那么对这样的人来说，至少在经济和精神上，他已经是可以自我满足的了。虽然不结婚会需要承担一点来自外界的压力，但是只要能保持住一定的收入水平，加上量入为出、适度消费，再学习一点财务知识，在理财方面谨慎一点，不追求高回报，只求跑赢通胀，那么，最终他在城市中过上一种和普通人差不多的生活还是不难的（这点要感谢现代分工合作的社会制度）。当然，我并不是说我们都应该如此「独立」，爱情当然是美好的，有一个你爱他而且他也爱你的人，和你一起生活、分享彼此的一切、共同面对未来等等，这是世界上任何其它关系都替代不了的。所以，无论如何，我们每个人都应该勇敢地去追求爱。我想表达的是，当你还没有遇到这样的人，或者没有准备好进入一段亲密关系的时候，不用太紧张，更不要感到自卑或者觉得自己有什么问题，其实你只要能做到把自己的生活过好就没什么问题。为物质上付出努力是应该的，但是也不要忘记建设好自己的精神世界，尤其是当你还是一个人的时候。要有自己的所爱之事，照顾好自己的身、心、灵，感受身边一切事物的美好之处，多帮助他人，保持积极快乐的心态，这些和恋爱、结婚与否都无关，无论什么时候都应该把重要性放在第一位。</p><h4 id="6-月-23-日-性别认同"><a href="#6-月-23-日-性别认同" class="headerlink" title="6 月 23 日 - 性别认同"></a>6 月 23 日 - 性别认同</h4><p>看了一集<a href="https://www.youtube.com/watch?v=EPu4Y-K5Qf0">锵锵</a>，讨论的是那年李银河澄清自己和她同性男友之间关系的一篇博客，嘉宾们聊了自己对于同性恋和身边同性恋朋友的看法。不过在这件事里比较特殊的地方在于，李是异性恋，她男朋友虽然生理性别是女性，但是实际上喜欢的也是异性恋的女性。我也第一次意识到，其实同性恋并没有自己过去想象的那么了不得，其实就是两个人彼此喜欢并且在一起了。当然，当中有像李这样，两个人彼此性别角色不同但生理性别相同的情侣，也有性别认同相同但是依然彼此喜欢的同性情侣。另外，节目中也提到了一个问题：我们应该如何划分一个人的性别，仅仅根据一个人的生理器官吗？但是这样的话，遇到上面那样的问题其实就不适用了，比如被外界认为是同性恋，但其实对于他们二人来说，彼此都是异性恋，只不过其中一人的生理性别和心理性别不一致而已。另外，男性和女性除了生理器官的不同，最主要的差异在于社会对这两种性别的人有不同的期望。比如整体而言，我们期望男性应该是阳刚、坚毅、有男子气概的，而女性应该是温柔、优雅、散发阴柔之气的。但是，当一个人表现出和他的生理性别不符合的行为时，外界就会对他评头论足。不过，好在这种现象已经越来越少了，很多人已经能够接受一个人表现出和他性别不符的行为了，比如对异装癖的接受（至少在有些地方是这样）。况且我也觉得，其实每个人偶尔都会表现出另外一种性别的行为，即使他的性别认同和他的生理性别一致。比如，一个男性在某些场合下会表现得很有男子气概，但是在面对他的领导或者家中长辈时，又会表现得有些女性化，比如说话特别温柔和孩子气等。其实每个人都会表现出适应他所在环境的行为，我觉得这是非常正常的现象。一个人只要能够接受这一点，那他就应该能够接受不同的性别认同。</p><h4 id="6-月-24-日-生命只有一次"><a href="#6-月-24-日-生命只有一次" class="headerlink" title="6 月 24 日 - 生命只有一次"></a>6 月 24 日 - 生命只有一次</h4><p>偶然发现一个挺小清新的<a href="https://space.bilibili.com/410213892">烹饪视频博主</a>，遗憾的是他已经去世了，他在最后一个视频中解释了自己的过去，但是没有说离开的原因。心里长叹一口气，真的太可惜了，非常好的一个人就这么没了。忍不住猜测他离开的原因，是因为性取向？还是因为成长过程中受到的创伤？又或者只是厌倦了生活？但是，他的每一个视频表现出的态度都是要好好生活，热爱生活中的每一个瞬间，这样的人又怎么会选择离开这个世界呢？想不明白。我觉得我们的教育中缺失的一环是教人热爱生活的同时，也学会去寻找自己生命的意义。生命只有一次，死亡将切断我们和这个世界的一切联系，因此，任何人都不应该自行结束生命，除非当他处于极大的两难困境之中，比如为了挽救另一个人或另一群人的生命。唯一合理的死亡时机应该是在我们垂垂老矣的时候，而且最好是前一天依旧过着正常的生活，走路、吃饭、劳作，然后在某一天的夜晚，在睡梦中，无任何感知地离开这个世界。这是最好的死亡方式。</p><p>我觉得我们应该干预那些想要尝试自杀的人，不仅仅是因为死亡是一件无法挽回的事，也因为尝试失败后它会让人面对更加困难的处境，比如身体上的残疾和心理上的耻辱感等。也许有人可以通过濒死体验来重新获得对生命的尊重，但那些自杀成功的人却永远失去了这样的机会，他们无法因为后悔而重新来过，也无法再次热爱上生活，后果却是深爱他的亲人们一生都要生活在他已经离去的痛苦之中。想到之前有个<a href="https://www.youtube.com/watch?v=IfHWE36B1go">程序员博主</a>放弃直播决定加入一家开发线上心理咨询产品的创业公司，起因是他自己以及他的家人中都有人受到抑郁症的困扰，所以他觉得自己应该去帮助更多的人走出抑郁症的阴影。查了下 WTO 的<a href="https://www.who.int/zh/news/item/17-06-2021-one-in-100-deaths-is-by-suicide">数据</a>，全世界每 100 个死亡人口中就有 1 个是自杀身亡的，而且男性自杀率是女性自杀率的 2 倍以上。虽然现在各国自杀率总体呈下降趋势，但是每一万人中就有一个人因为自杀死亡，这样的比例还是太高了。</p><p>那么，我能做些什么呢？虽然连我自己也会有那么几个瞬间，情绪低落到想要结束生命，大多数时候都是因为觉得内心的苦闷无处诉说。但是，我知道自己相比大多数人，已经算是非常幸运的了。所以，我想要通过自己的行动去帮助那些不如我这么幸运的人。也许可以先从小事做起吧，比如真诚、友善地对待身边的每一个人，多包容理解他人。传递善意和爱心就是在帮助他人，也是在改变这个世界。</p><h4 id="6-月-25-日-Self-pep-talk"><a href="#6-月-25-日-Self-pep-talk" class="headerlink" title="6 月 25 日 - Self pep talk"></a>6 月 25 日 - Self pep talk</h4><p>早上在整理这个月的碎碎念，过去每次读自己的碎碎念的时候都会慢慢感到心安，但是这次却不是，可能是因为我还是没找到一个清晰的目标吧，所以内心会感到焦虑和沮丧。既然情绪出现了，那就想办法解决它吧。先接受有情绪的自己，然后再看看有什么是我能做的。首先，学会欣赏我已经拥有的东西。我有一个健康的身体，我有爱我的家人，我有一个能让我保持经济独立的工作，我还有时间去阅读和思考，我接触得到我想要信息和知识，我能保持人格的独立，我还能做我喜欢做的事。假如失去了其中任何一件东西，我的处境都会变得糟糕很多，但是，即使失去了它们，我也会努力让自己生存下来，而且我知道一定会有一天，我将失去其中的一两样东西，所以，尽量让自己不要把它们看得太过重要。我真正所拥有的，只有我自己，我的身体和我的大脑，而我所能真正控制的，只有我的思想。所以，在极端情况下，哪怕身体器官的能力退化到只剩下大脑的思维能力，这对我来说也是可以接受的。这么一想，周遭发生的一切都是可以接受的了。一个人并不可怕，没有人可以诉说内心的想法也没关系，至少我还可以通过写作来表达自己的想法。我还很年轻，依旧有很多时间去尝试，也还有很多潜能等待着我去挖掘。我不是不可改变的。任何一个人，只要他愿意，在任何年龄下都可以改变他自己。我所需要的是，不要放弃希望，既然有人可以战胜比我面对的困难大得多的挑战，那么，我也一定可以做得到。重要的是要有坚定的信念，始终不断地尝试下去。</p><h4 id="6-月-26-日-掌控自己的人生"><a href="#6-月-26-日-掌控自己的人生" class="headerlink" title="6 月 26 日 - 掌控自己的人生"></a>6 月 26 日 - 掌控自己的人生</h4><p>最近一直在思考一个问题，我是真的喜欢一个人还是不得不一个人呢？虽然和身边的同事、熟人打交道没什么问题，哪怕是和陌生人也能聊上天，不过一直以来我都觉得自己是个偏爱独处的人。但是，现在的我开始产生怀疑：这真的是我的本性吗？因为当我一个人呆着什么都不做的时候，还是会感到无所适从。Naval 说过 “To measure the quality of your life, simply do nothing, and see how it feels.” 当我一个人静下心来的时候，我能感受到自己内心各种各样的未被满足的欲望，还有就是焦虑，明知道有的焦虑完全没有必要，因为它们不太可能会发生，但还是会忍不住幻想事物会往不好的方向发展。所以，我觉得这个世界上真正困难的事是把心放到正确的位置，既不为还未发生的事担心，也不去纠结已经发生的事，全心全意地活在现在。这对我这样的人来说尤其困难。但是，我愿意尝试去改变自己。首先，学会接纳现状。这意味着我要停止向外寻求认同，接受自己本来的样子。其次，改变自己能够改变的部分。我的容貌、身高、过去都无法被改变，但是我可以从改变自己的身材，丰富自己的头脑，努力创造新的生活方式等，开始着手改造自己的生活。一个人生活也许不是我的本意，但是我可以让自己的每一天变得更具有挑战性，去尝试更多自己没做过的事，去释放自己的天性，去挖掘出自己身上更多的潜能。总之，要活得更有意识，而不是被动地接受外界的刺激。我真正想要的是要能完全掌控自己的人生。</p><h4 id="6-月-27-日-对这个夏天的期待"><a href="#6-月-27-日-对这个夏天的期待" class="headerlink" title="6 月 27 日 - 对这个夏天的期待"></a>6 月 27 日 - 对这个夏天的期待</h4><p>夏天终于到了，会这么说是因为我已经连续两天早上被热醒了。醒来后起来打开风扇，调好角度，然后再继续睡一会儿懒觉。我对这个夏天有什么样的期待呢？工作上，把手上的几个项目完成好，然后还希望能和同事相处得更加融洽一些；生活上，希望能多看完几本书架上没拆封的书，再学会一点新东西，尝试一两件自己没做过的事，吃几种没吃过的冰淇淋，多感受这个夏天的美好。说起来我真的是个比较容易满足的人吧，照理说我这样的人应该过得很快乐才对，但现实生活中我好像看不出来有多快乐，也许快乐的人不一定会通过外在形式表现出来吧。突然想到一个问题，我有什么性格上的缺陷吗？有很多，比如不会说话，尤其是在自己不喜欢的人面前。有的人可以伪装得很好，但是我却做不到。还有就是太过自我，假如一件东西不合自己的意，我会转头就走，从来不会想着「要不等等看，也许之后会有不同？」，也就是缺乏「用发展的眼光看事物」的能力。再有就是太喜欢伪装，明明自己很想要一件东西，但却喜欢装作不在乎的样子。最根本的原因还是无法诚实面对自己的欲望吧。不自信，这应该是我最大的性格缺陷了。不过，我觉得自己需要的倒不是「相信自己，你能做到的」那种自信，而是用理性的态度看待自己，清楚地知道自己的能力，然后合理地规划自己的行动，而不是应该争取的地方没去争取，对做不到的事却又错误地估计了自己的实力。对自己有更清晰的认知，这是我要努力做得更好的地方。</p><h4 id="6-月-28-日-想要但得不到的东西"><a href="#6-月-28-日-想要但得不到的东西" class="headerlink" title="6 月 28 日 - 想要但得不到的东西"></a>6 月 28 日 - 想要但得不到的东西</h4><p>当一个人得不到一样东西的时候，就会在潜意识中把那件东西对自己的重要性降低，这是我最近才明白的事。这可能也是一种自我保护吧，让我们能够避免因为得不到而感到痛苦。我也在反思，我生活中遇到的哪些东西是可以归为这一类的。我常常告诉自己一个人也可以过得很好，这没错，但这是不是也在某种程度上掩盖了我其实并不擅长经营一段亲密关系的缺陷？事实是，我其实并不知道如何处理情感问题，也不知道应该如何与异性相处。甚至，我的潜意识中认为自己是不值得被爱的，所以才会选择逃避作为处理方式。意识到这一点后其实才是改变的开始。首先，要承认自己并不完美，但是有缺陷并不代表不值得拥有爱和被爱的权力。其次，任何技能都需要通过学习获得。哪怕是爱一个人其实也可以看作是一种技能，喜欢上一个人很简单，但是学会如何用合适的方式关心对方，花时间让对方感到开心，甚至是和对方聊他喜欢的话题，都是需要练习之后才能掌握好的事情。所以，我要做的很简单，接纳自我，然后寻找足够多的机会去尝试和练习，时间长了之后就会变得越来越擅长处理自己的情绪，包括学会如何与自己喜欢的人相处，还有如何在取悦对方的同时也让自己享受其中。</p><h4 id="6-月-29-日-承担选择的后果"><a href="#6-月-29-日-承担选择的后果" class="headerlink" title="6 月 29 日 - 承担选择的后果"></a>6 月 29 日 - 承担选择的后果</h4><p>有时候在想，我此刻最担心的事是什么呢？心里最大的一个声音是：害怕自己会一直一个人下去。这种害怕来自哪里呢？最主要是外界环境给我的反馈，让我觉得好像一个人是个不正常的现象。但现实是，只要你能自食其力，有一定的工作能力来获取收入，那么，一个人生活也没什么不对。我们赋予了恋爱、婚姻太多额外的意义，好像不恋爱、结婚、生子就是在虚度人生。但现实是，很多人即使结了婚生了孩子，也依旧找不到生活的目标。我承认创造新生命是一件非常有意义的事，这是两个相爱的人的爱的象征，一个新生命也能给生活添加很多新的乐趣、激励和目标，陪伴孩子成长还能给我们重新成长一次的机会，这个过程也是学习、感悟、理解生命的途径之一。但是，我并不认为这是每个人都必须要走的路。而且事物都有两面性，在陪伴孩子成长的过程中虽然能收获很多，但是作为父母也会失去一些东西，比如你们的生活必须为了孩子做出很大的调整，你们会失去很多两个人相处的时间，会失去很多尝试新事物的机会，甚至会为了孩子而闹矛盾。也许有的人觉得，这些问题和孩子给他们带来的快乐相比，不值一提。但是，我还是觉得，每个人都应该有自己的选择。我选择单身或者不婚，当然有我自己的问题，而且我会失去人生很多特有的体验，但是，我选择去面对这样的结果，也愿意承担一切后果。也许未来我会后悔，但是至少我面对的是我自己做出的选择，相比听了他人的建议而又生活幸福，我觉得前者对我来说更重要一些。</p><h4 id="6-月-30-日-保持开放且不太执着"><a href="#6-月-30-日-保持开放且不太执着" class="headerlink" title="6 月 30 日 - 保持开放且不太执着"></a>6 月 30 日 - 保持开放且不太执着</h4><p>看了这两天的碎碎念，好像有点前后矛盾，但想了想觉得，我这应该算是在给自己心理按摩吧，去努力追求自己想要的东西是对的，但是保持平常心就好，这样的话就算最终没有看到想要的结果，也不至于太过失望。这应该就是我想要达到的状态，就像我在自己博客首页说的：保持开放的心态，但又不执着于任何事物。通过努力得到了自己想要的东西当然很好，但是假如无法获得想要的结果，我也能接受这样的自己。虽然会感到失望，但是我希望自己只会失望一小会儿，我对自己的人生整体上还是非常满意的。而且我自己本身也在不停地发生变化，只要在不断地变好，暂时达不到理想的目标又有什么关系呢？人生嘛，<strong>学会知足</strong>是很重要的，这也是获得幸福的必要条件。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在写作中成长</title>
      <link href="/2022-5/"/>
      <url>/2022-5/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/KOQQjucbIOg" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>在碎碎念这个分类下写日记满两年了，这两年来，虽然换了工作，搬了家，也尝试了新技术和新项目，但是我觉得自己最大的收获无疑是创建了这个碎碎念分类。每天写作真的完全改变了我的生活，虽然偶尔有几天是敷衍了事的，或者是第二天补写的，但是每一段文字都是自己当时真实想法的记录。翻看过去写下的文字，有的感觉非常熟悉，就像是昨天写的，有的也让我感到惊讶，原来那个时候的自己就有这样的想法了。无论如何，我觉得这是件非常有意义的事，也让我有了很多收获。写作是抵御孤独的武器，也是使人保持思考的动力，我会努力坚持下去。</p></blockquote><span id="more"></span><h4 id="5-月-1-日-保持内心的安宁"><a href="#5-月-1-日-保持内心的安宁" class="headerlink" title="5 月 1 日 - 保持内心的安宁"></a>5 月 1 日 - 保持内心的安宁</h4><p>每次回家都会感到内心的平静被打乱了。我想这也是我喜欢一个人呆着的原因吧，我太容易受到外界环境的影响了。虽然表面上看不出来什么，但是内心好像有个高压水管爆了一样，各种想法不停地在脑海中产生、碰撞、交织在一起。也许是因为最近太久没有练习冥想了吧。我觉得每次回家都是一次抽离，从我的世界跳到了父母的世界。我很想淡化我们身上的差异，但是无论怎么努力，差异永远摆在那里，不是你蒙上眼睛它们就真的会消失的。我知道他们很爱我，我也很爱他们，但是这不代表我们能真正理解彼此。也许是我的期望太高了吧。其实说到底，这都是因为我无法接纳自己。唯有降低期待，不去和他人比较，专注于当下的生活，才能真正获得内心的安宁。不去关心自己影响圈之外的事，做好自己眼下能做的事，一切顺其自然，并且时不时地问问自己到底想要什么，什么样的目标才是值得自己去追求的，然后，勇敢去做就好了。保持尽量简单的生活和人际关系。我觉得这就是获得幸福和安宁的秘诀。</p><h4 id="5-月-2-日-理性的悲观者"><a href="#5-月-2-日-理性的悲观者" class="headerlink" title="5 月 2 日 - 理性的悲观者"></a>5 月 2 日 - 理性的悲观者</h4><p>有时候在想，我们和家人的关系是不是也是相互利用的关系呢？比如子女小时候离不开父母的养育和照料，换来的是子女的爱和陪伴；父母帮助子女成家立业等，从而获得延续家族血脉的机会，以及未来自己年老或者生病的时候能够得到子女的关心和照顾。说出来似乎有点冷酷无情，但事实上的确暗含着这样的关系。但是啊，我觉得人生真正值得我们付出爱和陪伴的，也只有我们的家人了。未来也许还会有爱人，但我其实已经不抱太大的希望了，我觉得我可能一辈子也无法找到适合自己的爱人。而如果能遇到一两个可以交心的朋友，那我也已经非常满足了。所以，我真的是个非常悲观的人吧。不过也没关系，反正我自己就能给自己足够的陪伴，也能创造出我一个人的幸福，不用依赖他人也挺好的。但是，人终究还是社交动物吧，我们一定还是会希望身边有人能够理解自己、陪伴自己，光有精神上的满足是不够的。无论如何，活在当下吧。向内探索自己，向外探索世界，不断接触和学习新事物，克服自己的弱点，不要逃避现实，直面痛苦。外界如何变化变化我们控制不了，唯有不断改变自己。</p><h4 id="5-月-3-日-自以为的束缚"><a href="#5-月-3-日-自以为的束缚" class="headerlink" title="5 月 3 日 - 自以为的束缚"></a>5 月 3 日 - 自以为的束缚</h4><p>人一旦闲下来就忍不住多想，比如在家的这几天我就在思考，我的家庭环境对我造成了什么样的影响。虽然家人为我提供了很多很多，但是，我也因此有了许多束缚，比如没法按自己的想法去做一些事情了，我需要考虑，如果这样做我的家人是否会反对，或者即使他们不反对，这会对他们的生活造成什么样的影响。有时候觉得，有些事如果现在不做，等到我年纪再大一些，想要再去做可能就做不了了，或者难度会大上许多。所以也在想要不要豁出去算了，尝试一下总没关系，大不了就再退回来。我可能还是个比较追求稳定的人吧。回顾过去，我觉得我所做的一切都是为了拓展自己的眼界，对赚钱其实没有太大的执着。当然，我也很爱钱，而且生活上也比较节约，想的就是让自己未来能有多一点的选择。不过，既然我不擅长赚钱，工作也马马虎虎，所以那就只能在人生的广度和自我精神的发展上多追求一点了。</p><h4 id="5-月-4-日-青年的定位"><a href="#5-月-4-日-青年的定位" class="headerlink" title="5 月 4 日 - 青年的定位"></a>5 月 4 日 - 青年的定位</h4><p>昨晚看了集圆桌派，聊到了佛系青年的话题，我在想我是属于什么系的呢？好像没法用单一的某个「系」来圈定自己。在生活方面，我当然是个佛系青年，生活越简单越好，对吃穿用度都没什么要求。在工作上，我似乎又是一个儒系青年，觉得人必须努力工作，努力提升自我价值，为他人创造价值，修齐治平才是正道。在人际关系上我又是一个法系青年，凡事照章办事最好，不喜欢复杂的人际关系，更不喜欢欠别人人情。但有时候也是个2B青年，因为缺乏社交的锻炼，所以常常不知道在一些场合中应该如何表现或者该说什么样的话。不过，我觉得这才是一个真实的人的表现吧，每个人都不只具有一面，想要真正了解一个人往往需要很长的时间。我觉得这种分类有一个好处，就是给自己寻找定位，让自己有归属感，然后可以和其他人抱团取暖。另外就是，人需要给自己一个解释，只有这样我们才能从内心觉得自己的行为是合理的，让自己感到心安。</p><h4 id="5-月-5-日-和谐的夫妻关系"><a href="#5-月-5-日-和谐的夫妻关系" class="headerlink" title="5 月 5 日 - 和谐的夫妻关系"></a>5 月 5 日 - 和谐的夫妻关系</h4><p>昨晚 10 点多老姐打电话给我说老爸又喝多了，回来之后和老妈吵了一架，然后摔门出去，老妈担心他又去赌博输钱，就去棋牌室找他把他拉回了家。回来后老爸吐得到处都是，而且一直对老妈出言不逊，于是老妈更生气了，赌气说她也不去打扫地面，让他明天自己去清理。老姐打电话向我抱怨老爸，可是我也不知道该怎么安慰她。我们俩都在外面工作，很多事情只能靠他们自己去解决，尤其是他们两个人之间的矛盾。其实说实话，我真的非常不喜欢他们之间的关系，老爸似乎从来没有在我们面前说过任何老妈的好话，总是各种讽刺、挖苦和挑不是，老妈有时候也是咄咄逼人的，这样下去，两个人的关系只会越来越差。作为子女，从小在这种关系中长大，其实受了很多不好的影响，我甚至可以不负责任地说，我现在不敢谈恋爱的一部分原因就是因为自己父母关系的不和谐。我害怕陷入类似的关系，那种互相消耗、不停伤害彼此的相处模式。生活已经这么难了，家原本是个让人放松做自己的地方，但我很少感受到他们对彼此的爱和温暖。那么，他们还能改变吗？我觉得是不太可能了。只能劝老爸以后少喝点酒，别在闹出这样子的风波，那就算很好了。</p><h4 id="5-月-6-日-熟人和陌生人社会"><a href="#5-月-6-日-熟人和陌生人社会" class="headerlink" title="5 月 6 日 - 熟人和陌生人社会"></a>5 月 6 日 - 熟人和陌生人社会</h4><p>聊聊熟人和陌生人社会吧。我记得自己小时候是生活在一个熟人社会中的，因为好像无论走到哪里，都会遇到村里人，然后家长就会和对方闲聊上几句，而且无论谁家发生些什么事，马上就会在整个村里都传开了。再后来慢慢长大一些了，上了小学，连我们自己也开始追求这种熟人社会的相处规则，那就是比看谁认识的人多，你认识的人越多说明你越牛逼，而且这样也就没人敢欺负你了。再后来，上了初中，情况开始出现变化，我认识的人成了所有同学中的很小很小的一部分，大家说的方言也不一样，让我感觉自己到了别人的地盘，然后我的圈子也小了很多，我只会和我觉得比较友善的人相处、交朋友。上了高中之后，这应该是我第一次独自一人接触陌生人社会，而我也变得更加谨慎小心了，我也是从这个时候开始变得更加内向，也不太愿意主动和其他人交流了。不过，我也是从这个时候开始认识到，原来只要你做好自己该做的事，并且变得更加强大，就没有人敢欺负你了。经过大学的四年，我已经完全适应了陌生人社会，有时候回到家里甚至感到不太适应，觉得为什么一点点事情就能传到其他人的耳朵里，即使对方是亲戚也没必要知道吧？我觉得陌生人社会的好处是，每个人都能最大程度保持独立，我们可以选择和哪些人分享，以及分享到什么程度。哪怕像我这样，零社交，也没有什么朋友的人，绝大部分事情都可以自己独立搞定，也活得很好。不过，陌生人社会的坏处也很明显，那就是每个人都像一座孤岛，如果你是个不愿意分享，也没有主动交朋友的习惯，你会活得越来越孤独。不过，我觉得有的人可能更适合一个人生活吧，而且一个人也会有更多的时间做自己喜欢的事，习惯之后其实也没什么大不了的。</p><h4 id="5-月-7-日-两极"><a href="#5-月-7-日-两极" class="headerlink" title="5 月 7 日 - 两极"></a>5 月 7 日 - 两极</h4><p>昨天逛了一下一些优秀大学的 OJ 网站，发现在竞赛中得奖的居然有很多是高中生，然后才意识到自己和这些优秀的年轻人之间的差距有多大。接着想到自己也有个上高中的表弟，他甚至可能都不知道 OI 或 ICPC 是什么，未来要怎么和这些更加优秀的同龄人竞争呢？有可能是我多虑了吧，其实每一代人都有这样的问题。信息差永远都会存在，顶尖的优秀人才和普通人差距巨大也是非常正常的现象，只不过有点担心未来这种差距会越来越大。转念一想，由于马太效应的存在，理论上来说这种情况却又是必然的。代际间教育、文化、技能、物质的积累和传递，必然会使得一部分人从小在眼界、学识、能力、身体素质等方面远远超过其他人。所以，作为普通人中的一员，除了努力提升自己之外，也没有别的办法了。现实是普通人越来越沉迷于奶头乐，而那些热爱学习的人则不断突破，学习积累越来越多的知识，不断创造出新的理论、发明新的工具，改善所有人的生活。此刻的我们可能完全无法想象未来我们生活的世界会变成什么样，只是希望无论处在哪一极的人都能彼此和平相处吧。</p><h4 id="5-月-8-日-放弃比较"><a href="#5-月-8-日-放弃比较" class="headerlink" title="5 月 8 日 - 放弃比较"></a>5 月 8 日 - 放弃比较</h4><p>不幸都是在比较中产生的。但是，活在人群中，想要不去和其他人比较，需要非常大的定力才行。小时候我们和别人比学习成绩、比家境、比谁更酷，现在比谁有钱、比生活品质、比人脉。我可以预感到，假如未来我结了婚，可能还要和人比房子大小、车子价格，比谁的老婆更漂亮，谁的孩子更聪明，等等等等。虽然看起来低俗，但这就是许多人的生存现状，似乎大家都需要通过和其他人的比较来展现自我价值。你要么把别人比下去，要么就被别人比下去。我可不可以选择不玩这样的游戏？当然可以，不过，这同样需要你有非常大的心理承受能力，而且需要面临的压力可能比直接参与这场游戏更大。因为你哪怕是完全不参与，他人可能会说你只不过是害怕比不过，认了怂。关键是，只要你们还处在同一层级下，谁也没法证明自己。唯一的选择是，你可以完全把自己隔绝于这样的社交圈之外。这也是我现在正在做的。既然我改变不了我身边的环境，那我至少还有选择独处的权力。虽然知道这个世界上一定存在适合我的圈子，但是那样的圈子我暂时还接触不到，而且我也不一定有能力融入进去。所以，至少我还可以选择不要圈子，过我自己的生活，这样也算是在表达自己的态度了。</p><h4 id="5-月-9-日-何以自处"><a href="#5-月-9-日-何以自处" class="headerlink" title="5 月 9 日 - 何以自处"></a>5 月 9 日 - 何以自处</h4><p>有时候觉得我是不是离社会群体太远了？转念一想，也暗搓搓为自己感到庆幸，因为只有生活在这个时代，我这样的人才能存活下来。现代社会非常宽容，即使是像我这样的人也能有一份工作，并且可以生活得很好。一个人只要能做好他的工作，他就可以选择自己的生活方式，其他任何人都没有权力指责他或者让他改变，除非他自己想要改变。换在过去，这样的人可能会被迫改变自己去适应社会。但转念一想，我难道一点都没有改变自己吗？当然有，但是这改变不算太大。如果保持本真的代价是孤独的话，那么，对我来说，这代价完全可以接受。我觉得自己唯一需要面对的问题是如何克服自我怀疑的问题。那种老是觉得自己不正常，觉得自己这样的生活方式有问题的想法。其实就是何以自处的问题，一个人如何做到逻辑自洽。我觉得除了认清事实和现状，接纳自己的一切之外，最重要的一点就是为未来做好规划。假如要维持这样的生活，包括要让 3 年、5 年、10 年后的自己不后悔，并且能够继续按照自己的想法去生活，此刻的我需要做出什么样的努力？</p><h4 id="5-月-10-日-专注自身"><a href="#5-月-10-日-专注自身" class="headerlink" title="5 月 10 日 - 专注自身"></a>5 月 10 日 - 专注自身</h4><p>看完了叔本华的人生的智慧，觉得他的哲学很符合我现在的人生观。人生其实没有什么幸福可言，尽可能减少自己的痛苦，保持生活的平静和内心的安宁，不需要面对那些由匮乏带来的烦恼，尽可能少的疾病和苦难，这样的一生就是幸福的一生。也许有点悲观，但是我觉得对于绝大部分普通人来说，这就是人生的真相。我们从小到大，有过多少不切实际的幻想，甚至成年之后，依旧会迷恋超能力。当我们感受到痛苦的时候，又时不时地会想到以结束自己的生命作为解脱。我觉得仅从这两点来看，就可以说明人是多么滑稽又懦弱的物种。但是，一旦远离了危险和痛苦，他就会把这些不好的记忆抛在脑后，觉得自己又可以去追求幸福了。其实，只要认识到避免痛苦是人的本能，并且不需要通过追求欢愉来获得幸福，我们才可以真正开始生活，也更容易感受到幸福。首先，我们会更加珍惜自己已经拥有的一切，以欣赏的目光去看待周围的一切。其次，我们的期望会降低，不再奢望获得那些能够刺激自己从而让自己感到愉悦的东西，而是去寻找那些能够长久让自己感到满足的事物，比如专注于创造。一个人所能拥有的，只有他自己。通过关注自身、完善自我所获得的满足感，可以支撑我们在任何环境下都能获得平静和幸福。</p><h4 id="5-月-11-日-书和实践"><a href="#5-月-11-日-书和实践" class="headerlink" title="5 月 11 日 - 书和实践"></a>5 月 11 日 - 书和实践</h4><p>有时候看别人的故事总觉得自己的生活经历太少了，所以很多观点就缺乏足够的现实经验来验证它们。最近我也开始反思自己，为什么看了不少书但还是感觉长进不大，我觉得一个主要原因就是我看书之后缺乏总结和思考，还有就是应用得太少。书说到底只是前人的知识和经验，作者提供了一个思维框架，就像是在地图上给你指了一条路，但是最终要不要去走这条路，以及路上会遇到哪些事，这些就需要你自己去慢慢发现了。如果你自己不去实践书上所说的东西，那就算你读完了这本书，最终它和你也没多大的关系。当然，文学类书籍不在我说的这种书的范围内，因为文学类书籍的作用是启发人或者给人心灵按摩。不过，即使是文学类的书，至少也有一个故事主线，而不同的人也能根据自己的生活经验获得不同的理解，有的可以让人感受到美好，有的让人反省自身。所以，其实大多数书籍都是会影响到我们的生活的，只不过这种影响是潜移默化的。</p><h4 id="5-月-12-日-人生的以终为始"><a href="#5-月-12-日-人生的以终为始" class="headerlink" title="5 月 12 日 - 人生的以终为始"></a>5 月 12 日 - 人生的以终为始</h4><p>真正的以终为始是：假如你能活到 100 岁，你觉得到时候的自己会如何回顾自己的一生？过去科学不那么发达的时候，我们会寄希望于来生，或者希望自己死后升入天堂。但是，现代人已经不再迷恋死后的世界了，所以有必要变得更加现实一点，人的生命只有一次，我们没有过去，更加不会有来生或者死后的另一个世界，我们能做的只有把握好这唯一的一次机会。这才是真正的不浪费自己的时间。我对自己的期望是，除了平静度过这一生之外，也要尽可能过得充实。这需要我做到以下几点。首先，不需要为了生计奔波，也就是有一定的谋生手段，能够让我维持最低限度的生存，同时也有时间去做我想做的事。鉴于我目前还没有清晰的人生目标，所以此刻的我就需要尽可能地做好已有的工作，维持一定的产出价值的能力。其次，照顾好自己的家人。我觉得到目前为止，我还是有能力做到这一点的，而且幸运的是，这个时代让普通人也可以不用付出太大的代价就能做到这一点。总体而言，我和我的家人都算是比较独立自主的人，所以暂时看起来也没什么大问题。最后，我需要能够不断更新自己。对我来说，更新自己最佳的方法除了阅读之外，就是去学习自己感兴趣的东西。我希望自己一直到死之前都能保持这样的能力。</p><h4 id="5-月-13-日-依旧迷茫"><a href="#5-月-13-日-依旧迷茫" class="headerlink" title="5 月 13 日 - 依旧迷茫"></a>5 月 13 日 - 依旧迷茫</h4><p>由于黄码被迫居家隔离了几天，看完了一本书，看了好多集谈话节目，突然对自己的未来感到有些迷茫，就是那种不知道自己应该干什么的迷茫。可能是因为身边没有人可以交流，情绪上有些压抑吧。不过还是会每天下楼玩两个小时轮滑，让自己流点汗，听着歌，什么都不用想，这对我来说就已经是一种解压和放松了。我所要求的东西并不多，而且我也知道自己是一个普通但是也有点特别的人，普通是真的很普通，能力、智商都不算突出，有很多欲望，有缺点也有优点；特别的地方在于我特别能独处，而且也不太在乎有没有社交，我觉得自己一个人就能过得很开心。既然如此，为什么还是会感到迷茫？人生很长，可以追求的东西也很多，我觉得人应该创造价值，去折腾，但是有的时候就是会觉得一切都没什么意义。可能还是过不了心里的那道坎吧。<strong>死亡是宿命，但是这中间的几十年用什么东西来填满确实是每个人最重要的抉择。</strong>我觉得还是得自己去探索发现吧，抱怨、迷茫都会过去的，也许未来的我会追求财务自由、追求享乐主义，这些都没什么问题，但归根结底还是要找到一个支撑自己活下去的理由，创造价值是一个，追求理想和真理是一个，哪怕只是养育后代、享受生活也是理由之一，关键看你如何能对自己有个交代。</p><h4 id="5-月-14-日-充满目标感的人生"><a href="#5-月-14-日-充满目标感的人生" class="headerlink" title="5 月 14 日 - 充满目标感的人生"></a>5 月 14 日 - 充满目标感的人生</h4><p>最近在思考目标感的问题，回顾下自己这二十多年的生命，我虽然还没有找到具体的目标，但是基本的价值观还是可以确定的，比如保持身体健康、照顾好自己和家人、帮助他人、创造价值、尽可能多地阅读、认识自己和这个世界、注重过程而不是结果、活在当下、保持内心的安宁等等。我觉得除了人生目标之外，其它所有的东西，比如工作、婚姻、物质生活的享受等等，都是次要的，核心还是要找到自己的人生目标。很多人正是因为缺乏目标，所以才会过得不快乐。还有很多人误以为自己有人生目标，其实他们并没有，那些所谓的目标只不过是外界灌输给他们的。有的人比较幸运，在还很年轻的时候就拥有了一个比较积极的人生目标，创造出了好的产品并且获得了影响力，随后又因为遇到更多同样优秀的人，他们互相影响，最终创造出了更多卓越的产品，甚至因此改变了整个世界。也许不是每个人都有这样的能力和机遇，但是我觉得我们至少可以用这些人作为自己的榜样，以追求改善他人的生活作为目标。只有拥有了更终极的人生目标，我们才不会陷入所谓的内卷，因为我们明白自己工作的意义不仅仅只是为了谋生。如果所有人都能认识到这点，工作是为了发挥出自己的优势，为他人创造价值，这世界上还会有不想工作的人吗？</p><h4 id="5-月-15-日-降低欲望和接纳现实"><a href="#5-月-15-日-降低欲望和接纳现实" class="headerlink" title="5 月 15 日 - 降低欲望和接纳现实"></a>5 月 15 日 - 降低欲望和接纳现实</h4><p>看了昨天的碎碎念，觉得自己有点过于理想主义，目标感固然重要，但是对于处于不同人生阶段的人来说，目标也会发生变化。许多人也想创造价值，只不过生活逼着他们去做一些赚钱谋生的事，此刻的我能够轻松地坐在这里谈价值创造，那是因为我还没有面临到像他们那样的压力。所以，真正重要的问题是，10 年、20年、40 年之后，我还能保证自己有一定时间去做自己想做的事，而不是把所有的时间都用于谋生等世俗事务上吗？可能很难。但是我觉得一个保险的办法是，降低自己的欲望。当你可以接受过一种清贫的生活的时候，只要能够维持健康，并且每天能够有一两个小时做自己想做的事，其他时候被迫去做自己不想做的事，当你能够接受过这样的生活的时候，那就没必要感到害怕了。相反，如果当下用太多的时间去思考未来，你会什么都做不了，你会被他人的看法影响，你要考虑自己的责任和义务，还要符合社会规范，而这些都是非常浪费时间的东西。如果你能做到不被这些影响当然很好，但是即使不得不为了未来考虑去做了一些事情，其实想通了也没关系，因为人最重要的是要和自己的内心达成一致，不要把有些事看作是自己不得不去做的，而是要看成是自己必须要做的。接纳它们的同时，也有利于释放出更多的心理空间，只有这样，我们才能去面对真正的困难。</p><h4 id="5-月-16-日-自我怀疑和倦怠期"><a href="#5-月-16-日-自我怀疑和倦怠期" class="headerlink" title="5 月 16 日 - 自我怀疑和倦怠期"></a>5 月 16 日 - 自我怀疑和倦怠期</h4><p>有时候会突然有种觉得自己在浪费自己的生命的想法，比如可能在工位上看了一篇公众号文章，然后就闪过了这样的一个念头。有很多种解读方式，比如我的工作还不够饱和，所以才有时间瞎想。这的确是一个因素，如果我非常投入地工作，事情很多，可能就不会有时间去东想西想了。另一方面，我也觉得，可能自己最近的确又进入了一个倦怠期了吧。技术上没什么长进，也没有继续前进的动力。虽然收藏了很多资料，有很多东西可以学，但是由于我的大脑里灌输了太多的信息，各种噪音交织在一起让我没法坐下心来静心学习。还有就是有点怀疑自己现在做的事的意义。没错，我可以仅仅把它当作是一份工作去完成，只要能让自己从中学到东西就行，但是一想到未来，想到假如我一直在做这样的事，那么我能接受这样的自己吗？我和那些流水线上的工人的区别是什么？我能不能创造出自己的产品？虽然我也知道现在的工作允许我在工作流程和局部细节上进行一些创造，但是我总是觉得自己其实还是没有主动权。说到底还是内心的焦虑在作怪吧，我不知道自己未来该走向哪里，也没有具体的目标，所以每隔一段时间都会感到自我怀疑。哪怕我把工作完成得很好，也依旧不会感到非常开心。这是我自己的问题，只能通过慢慢调整心态，学会转换视角来看待工作和生活。</p><h4 id="5-月-17-日-多问为什么"><a href="#5-月-17-日-多问为什么" class="headerlink" title="5 月 17 日 - 多问为什么"></a>5 月 17 日 - 多问为什么</h4><p>人一旦习惯了某种生活方式，就容易变得麻木。如何保持对生活的思考呢？除了经常反省，非常重要的一点是尽可能多地从外界获取信息，无论是通过阅读还是和其他人的交流，总归要让自己获得从另一个视角看待自己的生活的方式。另外也要意识到，我们此刻的生活只是这个世界上正在发生的事情中的一部分，而改变我们自己的生活就是在改变世界。还有就是要多问为什么。有时候我们习惯了以某种方式去面对一个问题，但是从来没有想过问问为什么，我为什么要继续忍受事情是这个样子的？我为什么不能优化它？为了改变它，有什么是我能做的？问题的本质是什么？每次这样问了之后，即使事情还是无法被改变，但是至少我们可以获得一个看问题的新视角。</p><h4 id="5-月-18-日-斯多葛"><a href="#5-月-18-日-斯多葛" class="headerlink" title="5 月 18 日 - 斯多葛"></a>5 月 18 日 - 斯多葛</h4><p>最近在读 Seneca 相关的文章，刚好也在看 Stoic 方面的书，心里产生了一种「我们必然会相逢」的感觉。Seneca 的观点是斯多葛中的典型代表，也就是强调人应该发挥出自身的作用，这是一种积极入世的态度。斯多葛虽然源自犬儒，但是它对人的指导行为却和犬儒派截然相反。这让我想起了中国的道家和儒家，我觉得道家是出世的，而儒家更入世，从修齐治平就可以看得出来，因此，儒家与斯多葛强调的人生观更为接近。我觉得斯多葛受人追捧的另一个原因是它强调获得内心的安宁，也就是保持平和的心态，没有焦虑、忧愁、悲伤、愤怒的情绪，转而追求内在的愉悦，一种不依赖外物，通过自身的心灵也能获得满足的状态。这和禅宗的思想又是如出一辙。所以，我在想也许那个年代真的是百花齐放，人类思想的大跃进时代吧。在东方，我们有诸子百家，还有印度次大陆的佛家，在西方，有苏格拉底、柏拉图、亚里士多德，以及后来芝诺创立的斯多葛。很难说这些人类思想是彼此间完全独立的，因为多多少少能从一种思想中窥见到另一种思想的影子，所以，我觉得它们是人类社会发展到一定阶段之后的产物。我们需要解释自身，也需要用新的方式去认识这个世界，所以才诞生了这么多的哲学思想和宗教。我觉得哲学是每个人都应该学习的学科，因为只有哲学才能回答我们应该如何自处的问题，而像斯多葛这样，强调在生活中去实践的哲学，就是一个非常好的开始选项。</p><h4 id="5-月-19-日-读经典"><a href="#5-月-19-日-读经典" class="headerlink" title="5 月 19 日 - 读经典"></a>5 月 19 日 - 读经典</h4><p>塞内卡曾经说过「我有什么进步呢？我开始成为我自己的朋友了。这的确就是进步，这样的人从来都不会感到孤单，而且你可以相信他是所有人的朋友。」所以我也在反思，我有没有做到成为自己的朋友，我是不是自己的好朋友？这样一想立马就意识到自己身上还是有很多问题的，有时候对自己太宽容，有时候又对自己太严苛。一个好朋友应该是始终如一地对待自己的。但转念又觉得，一个人在对待自己的时候会扮演不只一个角色，比如有时候需要扮演好朋友来安慰、鼓励自己，有时候又需要像一个长辈一样督促、指导自己，有时候还会像爱人一样去温柔地倾听和尝试理解。以儒家的标准，交友讲究「仁义礼智信」，做人要「温良恭俭让」，品德上的自我要求则是「忠孝廉耻勇」，即使放到现在，这些价值观也还是有参考价值的，只不过局部可能需要转换成用现代的方式去解读。所以，读经典真的非常有用，尤其是关于为人处世方面的知识。无论是西方还是东方的经典都值得一读再读。任何一本流传了上千年的经典书籍，其价值都不会随着时间的流逝而降低，即使是宗教书籍也一样。所以，有机会的话，我还想去读一读圣经，因为它也是前人积累的智慧，而且也能从中学到西方文明的历史，帮助自己理解西方文明，以及它为什么会发展成为今天的样子。</p><h4 id="5-月-20-日-珍惜每一刻"><a href="#5-月-20-日-珍惜每一刻" class="headerlink" title="5 月 20 日 - 珍惜每一刻"></a>5 月 20 日 - 珍惜每一刻</h4><p>一个人想要坚持做自己真的很难，无论他如何努力保持独处的状态，终究还是要和周围的人产生一些互动，并且因而受到环境的影响。人，说到底是很难逃脱自身的限制的。除此之外，我们还会忍不住想要从外界寻求反馈，获得认可，只有这样才能在内心得到满足。我可不可以摆脱这种模式？也许需要付出很大的努力，但是我愿意花时间去尝试。为此，一个人首先要做到经济独立。然后就是不停的问自己一些问题：我有没有在做我想做的事？我所做的事对我自己和他人能产生多大的价值？我是否得到了我想要的？当一个人认为自己付出的超过了他所得到的时候，这个人就不会感到不满足，他当下的状态就是幸福的。当他开始思考自己的未来，如果他对未来感到悲观，也就是认为自己无法在未来得到更多自己想要的东西，或者有可能失去此刻自己已经拥有的东西的时候，他就会感到焦虑，进一步，如果他觉得自己无法改变这种状况的时候，他的内心就会产生更多的负面情绪，比如愤怒、悲伤、忧虑，继而产生痛苦。我经历过这样的时刻，而且也知道自己未来可能会继续经历这些，但是，现在的我已经不再感到那么担心了。每个人的生命只有一次，我们都是初次探险，很难说哪种人生就是好的或者坏的。有的人运气比较好，得到的比别人多一些，但是他们所要面对的精神上的挣扎和痛苦，一点也不比其他人少。过去我给自己定下的目标是健康地活到 120 岁，现在想想觉得其实即使活不到那么久也没关系。一方面是因为经济问题，到时候我不一定能负担得起养老所需的各项支出，我也不想给子女造成太大的负担或者让政府用纳税人的钱养着自己；另一方面，人生充满各种各样的意外，能安全撑过每一场考验的几率其实并不大。其次，我觉得即使活得足够长久，也不代表我就能把所有我想要了解的东西全都了解完。这个世界太大了，值得花时间探索的东西也太多了，光是人类历史就有那么长，未来可能出现的新事物更是多到让人眼花缭乱，我觉得哪怕是活到一千岁，我也不会知足的。所以，<strong>关键在于培养起珍惜当下每一刻的意识，把每一天的时间都安排好，少浪费时间在自己不感兴趣的东西上，尽量让自己的每一天都过得有意义。</strong>不要去追忆过去或者感伤未来，活在当下才是正确的人生态度。当然，这并不是说我们不应该做计划，只是说我们要更有意识地活着，不要为了未来「牺牲」现在，更不要纵情于那些没有意义的、只为满足自己虚荣心或者是刺激荷尔蒙分泌的事情上。无论是贫穷或者富有，都不影响我们在当下感到快乐和满足，只要你觉得「我可以忍受一切，无论发生了什么，它都是我生命的一部分，我要去体验它，而不是被动地去接受它」。</p><h4 id="5-月-21-日-目标内在化"><a href="#5-月-21-日-目标内在化" class="headerlink" title="5 月 21 日 - 目标内在化"></a>5 月 21 日 - 目标内在化</h4><p>最近看到一个很有意思的观点，我们都知道目标很重要，但是有的时候追求错误的目标往往会给自己造成很多困扰，比如让你爱的人也爱你，假如一个人把它作为目标，结果将会是很悲惨的。因为无论一个人多么富有，多么有才华，多么幽默，外表多好看，都无法保证她爱的人也能一直爱着她。当你把控制自己快乐的权力交给了别人，你的所有行动都会受到这个外部因素的影响。而假如我们换个思维方式，把目标转变成如何让自己变得更好，保持自己的吸引力，以及如何更好地爱对方，那么，我们就把主动权控制在了自己的手上。也许你付出了很多努力，但是对方最终依旧对你失去了兴趣，但是，你也不是完全没有得到任何东西，你让自己变得更好了，你学会了如何更好地爱一个人，你依旧可以用这份经验去爱下一个人。这样的思维方式被称为<strong>目标内在化</strong>。我们可以将这个技巧应用到生活中的很多方面，尤其是那些自己无法完全控制其结果的事情上。除了刚刚提到的「让你爱的人也爱你」之外，还有比如「获得公司上司的青睐」「交到自己喜欢的朋友」等等问题，都可以用目标内在化去解决。</p><h4 id="5-月-22-日-Connecting-Dots"><a href="#5-月-22-日-Connecting-Dots" class="headerlink" title="5 月 22 日 - Connecting Dots"></a>5 月 22 日 - Connecting Dots</h4><p>昨晚看完了 William Irvine 的《像哲学家一样生活》，这算是我和斯多葛的第一次正式接触吧。过去虽然也听到过斯多葛，偶尔也会在社交网站上看到一些斯多葛相关的言论，但是从来没有想过可以把它作为一种生活哲学，而且在看了这本书之后，我才想起来其实我已经看过斯多葛哲学家的书，马可奥勒留的《沉思录》，前段时间看的叔本华的《人生的智慧》，其实和斯多葛的生活哲学也有很多相似之处。所以，我觉得人生真的是由点到线再到面的过程，你所做的每一件事都有可能在未来与另一件事发生关联。</p><h4 id="5-月-23-日-努力探索意义"><a href="#5-月-23-日-努力探索意义" class="headerlink" title="5 月 23 日 - 努力探索意义"></a>5 月 23 日 - 努力探索意义</h4><p>今天下午看了 Paul Graham 的一篇文章 <a href="http://paulgraham.com/hwh.html">how to work hard</a>，晚上洗澡的时候想了很多，那种迷茫到不知所措的感觉又回来了。不停地问自己：生命的意义是什么？我活着的目的是什么？我所做的是有意义的事情吗？我很清楚地知道自己没有抑郁症，心里会产生这些问题是因为我的确想知道这些问题的答案。但是，像人生意义这样的问题从来就没有一个标准解，即使看再多的书、问再多的人也没什么用。对当下的我来说，最需要的，可能是一个足够具体的目标吧。我没有赚很多钱的欲望，也不觉得认识更多人或者交个女朋友就能够解决我当下的困境。当然，如果能够找到和自己想法相似的人沟通交流，肯定会有帮助，不过，我知道最终还是要靠自己来解决它。我无法一下子说出自己最感兴趣的事，也看不出自己在哪方面有特别的天赋，这应该是我感到迷茫的最大的原因之一。如果每个人一生下来就知道自己的特长，并且从小就往那个方向去培养起兴趣，如果可以这样的话，那就太棒了。可惜现实是，我们都要从头开始。有的人天生运气比较好，由于开窍早或者成长环境的影响，让他们早早走上了一条自我发现和价值创造之路，而大多数人，可能到了二、三十岁甚至一辈子都不知道自己最擅长做的事是什么。不过，我想我也不是什么都没有。我对我拥有的一切还是感到感恩的。虽然偶尔还是会感到迷茫，但是毕竟还算年轻，还有几十年的时间去探索。即使最终结果也只是庸庸碌碌地度过这一生，至少死之前可以不带遗憾地说一句：我努力过了，也尝试过了，我对我的人生非常满意。</p><h4 id="5-月-24-日-不断地尝试下去"><a href="#5-月-24-日-不断地尝试下去" class="headerlink" title="5 月 24 日 - 不断地尝试下去"></a>5 月 24 日 - 不断地尝试下去</h4><p>说到迷茫，这事可能就挺无解的吧。有的人会说，作为一个普通人，能做的只有过好自己的日子，多赚点钱，才能在未来抵御风险和意外。没错，很有道理，但是有的时候，人就是很难面对这样的现实。每个人年轻的时候都以为自己未来能够改变世界，再不济怎么着也得成就一番事业吧，可惜现实是，除非你既努力又运气不错，否则哪怕是过上一个还不错的生活都很难实现。说到底，依旧是选择和努力的问题。无论何时，保持思考的习惯以及积极地尝试是好的，至少可以让自己暂时摆脱迷茫和不知所措的状态。我不知道自己的兴趣和天赋，但是我选择不断地去尝试，去在行动中获得反馈，而不是坐着空想，这样就很好。未来会怎样我不知道，我也不抱有任何幻想，更不会对自己有过高的期望，每天做好眼前能做的事。学会感恩，学会与痛苦做伴，学会享受孤独，能做到这些，才有可能获得心灵上的安宁吧。</p><h4 id="5-月-25-日-争取不做痛苦驱动的人"><a href="#5-月-25-日-争取不做痛苦驱动的人" class="headerlink" title="5 月 25 日 - 争取不做痛苦驱动的人"></a>5 月 25 日 - 争取不做痛苦驱动的人</h4><p>有时候真的会觉得好可惜，因为把时间和精力都浪费在自我消耗上了，如果能集中精力做自己喜欢且有意义的事，哪怕只是一会儿，也比这样空耗强吧。就算是把时间花在谈恋爱上，也比坐在电脑前刷视频、刷手机有意义吧。不知道该怎样改变这种局面。说到底只是改变习惯的问题，但是看上去就是有那么困难。明明知道该怎么做，但就是做不到，那种无力感真的会吞噬一个人。可能是因为没有尝到什么苦果吧，等到不改变的坏处开始逐渐显现出来，并且影响到日常的生活，到那个时候我才有可能真正下定决心去改变吧。但是人为什么一定要让痛苦驱动自己的行动呢？我们为什么不能一开始就按照好的方向去行动、去发展自我呢？所以，大多数人都是那么的普通也是正常现象，因为真正能学会自制，学会给自己制定合理可行的目标的人，永远是少数。不过，也不用气馁，能意识到这一点就已经算是进步了。我需要的，是不断地改变，哪怕是今天比昨天早起了 10 分钟，今天比昨天多看了 1 页书，也是有意义的。</p><h4 id="5-月-26-日-日省和改进"><a href="#5-月-26-日-日省和改进" class="headerlink" title="5 月 26 日 - 日省和改进"></a>5 月 26 日 - 日省和改进</h4><p>这两天一到晚上精神状态就不是太好，为了缓解焦虑的情绪，在一些论坛和 APP 里瞎逛，最大的感触是其实每个人都有自己的烦恼，大家并不是都活得那么轻松。看着不同年龄段、不同性别、不同背景的网友们的倾诉，突然觉得自己的那点问题显得非常可笑。我已经算是非常幸运的了，还有什么好感到不满足的呢？既然找到自己喜欢且擅长的事比较难，那就先把自己不讨厌也能做好的事做得更好吧。人只能一步步地发展，即使是寻求改变也得慢慢来才能长久。多想想自己当天的目标，每天结束时回顾下自己是如何度过这一天的，有哪些地方做得好，哪些地方做得不好，有什么是自己可以改进的。如果能做到这些，想不变好都难。世上无难事，只怕有心人。其实作为一个普通人，重要的不是学历多高，懂得多少道理和知识，只要能把这些基本的做人做事的态度摆端正了，该有的最终都会有，至于能否成就一番事业，就要看他的运气了。但是，这世上除了有踩狗屎运的那种运气，还有靠自身实力获得的运气，比如被苹果砸中的牛顿，后一种运气才是值得我们追求的。</p><h4 id="5-月-27-日-与人合作的能力"><a href="#5-月-27-日-与人合作的能力" class="headerlink" title="5 月 27 日 - 与人合作的能力"></a>5 月 27 日 - 与人合作的能力</h4><p>越来越觉得自己与人合作的能力似乎在不停地退步，最简单的比如与人沟通的能力，由于长时间自己一个人做事，无论是项目中还是项目之外，我几乎不需要和其他人进行太多的交流，加上自己本身不喜欢聊天，所以更是得不到锻炼的机会了。但是，每当看到一些人可以非常流畅地表达自己的想法，尤其是在人多的场合下的时候，我就会生出一种既羡慕又为自己感到悲哀的情绪。我也知道自己应该有意地去练习，然而我总喜欢给自己找各种各样的借口，所以总是迈不出第一步。其实身边练习的机会很多，比如和身边的同事、室友，还有上下班经常碰到的人，哪怕是小区门口的保安也可以每次多聊上几句话，次数多了就熟了。再有就是感情方面，说到底也是和人合作，最开始两个人互有好感，然后随着相处时间的增加，觉得彼此适合在一起生活，等到彼此磨合到比较舒服的状态之后，除了愿意分享彼此的快乐，也愿意和对方一起面对未来，于是决定结成终身的伴侣。但是，对我而言，我还远远达不到这样与人深度合作的能力。虽然也知道应该一点点培养起这种能力，但是似乎找不到什么动力，我已经习惯了一个人的生活，甚至会有点恐惧生活中出现另外一个人。一想到要麻烦别人或者需要迁就别人，需要为了另一个人改变自己的生活方式，放弃某些自己喜欢做的事，可能还得花时间陪对方做一些我不喜欢做的事，而且两个人都会有这样的取舍，我就会感到怀疑，这样做真的值得吗？虽然明白得到一些东西也就意味着失去一些东西，但是这种交换真的是有利于我的发展吗？还是说只是为了让自己看起来和别人一样才去做的呢？</p><h4 id="5-月-28-日-为自己负责"><a href="#5-月-28-日-为自己负责" class="headerlink" title="5 月 28 日 - 为自己负责"></a>5 月 28 日 - 为自己负责</h4><p>周末又一口气看了好多集圆桌派，老实说其实看这类节目并没有多大营养，最大的作用无非就是解闷，我没有这样一群价值观相差不大、可以坐在一起聊天的朋友，所以看着别人坐在一起对一个话题发表自己的意见还是挺有意思的。一档这样的节目能够吸引我，最主要的是因为我的价值观和主持人和嘉宾们基本一致。这其实和交朋友、谈恋爱是一样的，我们的价值观决定了我们能否彼此认同，而这是理解彼此的基础。比如这次看的几位比较不同寻常的嘉宾，唐小雁和李小牧，虽然他们各自的经历都非常复杂，但是我觉得他们的人生观和价值观还是非常正面的，值得普通人借鉴。如果他们能够在那样的环境下求得生存，把劣势变为优势，我们普通人为什么不行呢？当然，我们也许做不到使用比较特殊的手段来达到自己的目的，但是，就像李小牧说的，只要不违法，你是为了生存，那又有什么关系呢？像唐小雁这样的人，如果你不靠自己奋力求生，那么很有可能我们永远也看不到她的故事了。说到底，<strong>人生是你自己的，你选择如何度过自己的人生是你自己的事，只要你有始终为自己做决定的魄力，也有承担后果的勇气，那就没什么好害怕的了。</strong>我们所面对的社会，虽然依然有很多不公和不幸，但是大体上而言，一个人还是有选择自己人生的权力的。不要去抱怨，因为越是底层，通过抱怨改变现状的可能性越小，你只有通过努力，通过改变自己，才有可能获得一点点向上的机会。</p><h4 id="5-月-29-日-两个世界"><a href="#5-月-29-日-两个世界" class="headerlink" title="5 月 29 日 - 两个世界"></a>5 月 29 日 - 两个世界</h4><p>每个人都活在两个世界里，一个是他所在的真实世界，另一个是他感知到的世界。前一个世界很好理解，每个人从出生到死亡，经历的所有事情，遇见的所有人，都在这个真实世界中发生，而后一个世界则完全由这个人自己决定。出身相同、经历相似的两个人，所感知到的世界有可能完全不一样。活在真实世界中的我们，会根据自己过去的经历、记忆以及根据记忆形成的认知来诠释我们所遇到的一切，并且凭借这些经验和认知慢慢积累出所谓的「知识」，最后再用这些「知识」为自己的内心世界添砖加瓦，一点点拼凑出我们认识到那部分世界的样子。每个人所看到的，只是这个世界的一小部分，而且这上面还残留着他经过个人眼光过滤后的东西。所以，当一个人谈及对某个事物的看法的时候，其实从来不存在什么完全理性客观的看法，我们每个人都受自身经历、学识和思维的局限，而且有的时候「知识」「经验」越是丰富的人，越是难以摆脱这种局限，因为他们很难放下已有的认知，用全新的眼光去看待未知。日常生活中，我们在这两个世界中待的时间也不是完全均分的，有的时候在真实世界中待久了就会想要撤退到内心世界，花更多的时间在内心世界中修修补补，比如正在写这些文字的我；而有的时候，去真实世界中采风、走遍天南海北、和外界沟通的愿望又会无比强烈；我们就是这样在两个世界中来回穿梭，并且小心翼翼地保持平衡，只有这样才能保持住理智。我觉得那些精神失常的人，只不过是花了太多时间在他们的内心世界中，以至于脱离了真实世界，到最后走不出来了。其实，我有时候会觉得自己离精神失常只有一步之遥，只不过每次当我觉得自己快要失去控制的时候，我会及时往回退一步，去看看真实世界，去小区门口走一走，感受一些烟火气，然后在心里提醒自己，千万不要一个人走得太快、太远，也不要忘记自己来自哪里。</p><h4 id="5-月-30-日-时间和注意力"><a href="#5-月-30-日-时间和注意力" class="headerlink" title="5 月 30 日 - 时间和注意力"></a>5 月 30 日 - 时间和注意力</h4><p>周末看完了<a href="https://movie.douban.com/subject/35436582/">爱死机</a>第三季，感觉像是给大脑洗了一个澡，有各种各样的想法冒出来，但是冷静下来之后又觉得有点失望，因为还是要面对现实的生活。也许未来人类将在其它星球建立殖民地，但是那都和我没关系；也许未来某一天人类会因为自身贪婪而走向毁灭，但至少现在我还活得好好的；也许历史上某个人经历了非比寻常的考验，并且彰显出了个人的勇气和智慧，但是这对我个人的激励最多只能维持一周。有时候觉得，单独某一部影视作品对人的影响真的有那么大吗？我觉得并不见得，除非你反复思考故事背后的蕴意，品味其中的细节，直到把这个故事变成你自己的故事，你才能从故事中获得一些有益的思考。但是，事实上，绝大多数影视作品都只是娱乐而已，而且观众也只是想要看到更新、更有趣的故事，并不想放入太多个人的思考。所以，好作品永远是少数。不过，至少个体还是有选择权的，你可以选择只看那些值得自己花时间看的作品，并且从中慢慢回味就好了。其实生活中的一切都可以采用这样的态度，绝大部分事物都是无关紧要的。所以，你要花时间思考哪些东西值得你花费自己的时间和注意力。</p><h4 id="5-月-31-日-如何面对恐惧"><a href="#5-月-31-日-如何面对恐惧" class="headerlink" title="5 月 31 日 - 如何面对恐惧"></a>5 月 31 日 - 如何面对恐惧</h4><p>又看了一遍 Steve Pavlina 关于 Courage 的那篇<a href="https://stevepavlina.com/blog/2004/10/the-courage-to-live-consciously/">文章</a>，再一次开始思考是什么让我感到恐惧。和女生搭讪？在陌生人面前演讲？失去工作？感觉这些都算是吧，但是我觉得真正让我感到恐惧的还是死亡以及虚度自己的一生。但仔细思考的话，我又想不出死亡这件事哪一部分让我感到恐惧，是走向死亡的过程还是结果？如果突然死去呢？还是会害怕的吧，既害怕父母会伤心，也为自己没来得及做的事感到遗憾。至于虚度年华的恐惧，可能每个人都有吧，而且奇怪的是，在你意识到这一点的当下，你反而不会去做浪费时间的事。但是即使如此，也很难确定自己到底有没有在「虚度」，唯一的审判是当你变得很老很老的时候，只有到那时回顾一生，你才能知道自己这辈子做的事到底有哪些是有意义的，而哪些只是在浪费时间。恐惧说到底只是人在面对未知时所产生的消极想象，我们害怕未知的事物，害怕受到伤害，但是一旦你足够频繁地暴露在你所恐惧的事物面前，反复思考你所恐惧的东西的方方面面，当你获得了足够多的信息，恐惧就不是无法战胜的了。识别恐惧，渐进式训练，获得足够的知识，这就是战胜恐惧的方法。还有，在恐惧面前，行动永远比退缩要好。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不要怕啊</title>
      <link href="/2022-4/"/>
      <url>/2022-4/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/JbvY1Ig9iVg" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>四月，工作上非常清闲，于是也重新拾起了阅读。文字是最能抚慰人心的，尤其是阅读哲学类的书，除了让自己的心安静下来，也让我开始学会接受现状，逐渐发现独处的意义。另外一个转变是，月底的时候重新开始在网上阅读他人的信件以及给人写回信。通过解答他人的问题，透过他人的视角看待自己的生活，让我意识到其实每个人都有自己的问题。说到底，我们都是孤独的灵魂。这个世界上，除了我们自己，没有人可以真正理解我们。向外寻找答案是没有用的，一些最根本的问题只有靠自己去想明白了，才能有勇气去面对生活。而生活有趣的地方在于，你越是觉得困难重重，越想逃避，出现新问题的可能性也越大；相反，如果你选择直面困难，迎难而上，恐惧的情绪消失之后，剩下的就只有轻松以及眼前具体的问题。</p></blockquote><span id="more"></span><h4 id="4-月-1-日-Routine-的重要性及其风险"><a href="#4-月-1-日-Routine-的重要性及其风险" class="headerlink" title="4 月 1 日 - Routine 的重要性及其风险"></a>4 月 1 日 - Routine 的重要性及其风险</h4><p>有时候早上写碎碎念的时候，总会有种昨天没过好的感觉，尤其是前一晚熬夜了之后。不过，我觉得只要养成了几个日常的习惯就可以纠正自己。比如我每天早上都有自己的一套 routine，所以即使第二天晚起了，我依旧可以按照平时的习惯去完成剩下的我能做的事然后再去上班。每次这种情况发生之后，我都更能意识到这些日常习惯对我的意义，尤其是那些没来得及完成的 routine，而且也因此有机会去优化它们。我觉得流程化之后，很多问题都会自动解决，即使一天中的某一部分你没有完成，你依旧可以将剩余的部分按照流程去完成。也没必要为自己感到羞愧，毕竟人不是机器。但是，我也在想，过于流程化的生活会有什么样的风险？比如，可能你会无法接触到太多新鲜的让自己感到刺激的体验，或者你会习惯当下的一切而对改变感到恐惧和慌乱。所以，我觉得定期去做一些自己平时不会做的事很重要，其中一个方式就是去旅游，通过去到不同的地方，主动去打破平时的生活节奏，从而获得看待自己过去生活的新视角。</p><h4 id="4-月-2-日-碎碎念中的我和现实中的我"><a href="#4-月-2-日-碎碎念中的我和现实中的我" class="headerlink" title="4 月 2 日 - 碎碎念中的我和现实中的我"></a>4 月 2 日 - 碎碎念中的我和现实中的我</h4><p>有时候总觉得碎碎念中的自己和现实中的自己是完全不同的两个人，在碎碎念中我是一个头脑冷静，善于分析问题，无论面对什么样的情境都能妥善处理的人，但是现实中的我，瞻前顾后、多疑、笨拙、不善言辞，完全表现不出我在碎碎念中的那一面。所以，我常常觉得文字是非常高级的伪装。经过思考、修改、润色之后呈现出来的东西，和当下本能做出的应答，往往后者更能表现出一个人的真实样子。但是，这并不是说文字表达就完全是虚伪、无意义的，只要一个人愿意记录下自己的真实想法，那也是有意义的，只不过很多时候，在工作和生活环境中，我们面对的问题经常需要你立刻做出反应，而这依赖你在过去很长一段时间内形成的直觉。那些你最近才学会的东西，往往需要更多的时间才能真正为你所用，需要不断地重复才能变成无需任何思考而做出的默认行为，也就是变成一个人的潜意识。所以，还是要给自己多一点耐心吧，相信那些长期有价值的东西最终一定会慢慢转换为你自身的一部分。在那之前，还是要不断重复下去，等待量变引起质变时刻的到来。</p><h4 id="4-月-3-日-少想多做"><a href="#4-月-3-日-少想多做" class="headerlink" title="4 月 3 日 - 少想多做"></a>4 月 3 日 - 少想多做</h4><p>每次回家看到爸妈心里都会有种无力感。不过，想那么多没用，还是多看看自己能做些什么。承担起自己的责任，不要抱怨（这点我做得还算不错），尽可能多地理解他们，减少内心的批判，全身心地陪伴。还有，对自己和他人都要再多一点耐心。</p><h4 id="4-月-4-日-永不妥协"><a href="#4-月-4-日-永不妥协" class="headerlink" title="4 月 4 日 - 永不妥协"></a>4 月 4 日 - 永不妥协</h4><p>每次回家都能感到爸妈的焦虑，他们在意的只是「讨老婆」这件事，在于结果，而之后发生的事情，他们并没有想过。他们觉得只要完成这件事，后面的其他事情也都能顺利进行下去。我们对亲密关系的定义也完全不同，我想要的亲密关系中，两个人是合作共赢的伙伴，是相互支持的朋友，是并肩作战的战友，是无话不谈的灵魂伴侣，是一起探索世界、自我完善的相互见证人。听上去似乎要求有点高，但是我觉得这是一段婚姻得以维持下去的基础。人生说短也长，我们有几十年的时间去认识这个世界，去完成一些目标和创造出一些价值，工作、陪伴家人、繁衍后代、发现自我，如果我们不能按照自己的想法去生活，这是对自己的不负责任，也是对生命的浪费。为了保证自己散发出的是正义、积极、善良的能量，我们必须始终坚持自己的信念，永不妥协。</p><h4 id="4-月-5-日-诚惶诚恐的心态"><a href="#4-月-5-日-诚惶诚恐的心态" class="headerlink" title="4 月 5 日 - 诚惶诚恐的心态"></a>4 月 5 日 - 诚惶诚恐的心态</h4><p>每次回家之后的睡眠质量都不是很好，老是很早就醒来，然后就开始胡思乱想。今天清晨醒来之后又睡不着了，想起很多往事，比如高中时候看小说连续多次被班主任发现之后被叫了家长的事。我依稀记得那是一个普通的工作日下午，很难想象当时老爸是以什么样的状态从我家小镇上骑一个小时的摩托车赶到县城的学校的，估计内心无比忐忑吧，不知道自己的孩子在学校犯了什么错。我记得那天他来办公室见到我之后，我依旧是一幅无所谓的态度，不过心里多少还是有点害怕，所以尽量避免和他产生视线接触。突然意识到，我最大的问题就是这种「无所谓」的态度，过去的我一直是以这种散漫的态度对待一切的，周围的人、事、物在我眼中都是可有可无的存在。就拿高考来说，有的人在毕业多年之后还会梦到考场上的场景，但是我对高考几乎没有任何具体的印象了。直到工作之后，我才开始变得小心翼翼起来。当发现自己运气还算不错，已经拥有我过去想要的绝大部分东西之后，更是变得诚惶诚恐起来，觉得自己应该更努力一些，让自己配得上这一切。是的，过去的我缺少就是这种诚惶诚恐的心态。</p><p>我虽然是个极其普通的人，但是我总觉得自己的运气比大多数人都要好一些，而过去的自己一直都不自知，甚至时常陷入自我埋怨、自我哀伤甚至是绝望的情绪之中。那时的自己还是太幼稚和无知了吧。庆幸自己能够及时清醒过来，而且至少现在也不算太晚。尽管此刻的自己已经走到了 20 多岁的最后几年，我依旧觉得未来还是有无限可能，我想要用自己的生命去探索和发现这个世界。</p><p>我想这就是生命历程的一部分吧，看似无意识的生活，但是当你某天回首过去，突然发现某段经历对自己的意义，然后在那一刻发现自己获得了成长，或者和过去的自己变得有点不一样了。我也渐渐开始能理解那些历经苦难并且从中发现正面意义的人，经历并存活下来是一回事，之后如何诠释它们又是另一回事了。对于绝大部分人来说，苦难仅仅就是苦难，而有的人则把它看作是一种淬炼。我希望当自己未来某一天遭受苦难的时候，不但能够熬过去，而且也能用后一种人的心态发现其对自己的意义。</p><h4 id="4-月-6-日-人生计划和改变自己"><a href="#4-月-6-日-人生计划和改变自己" class="headerlink" title="4 月 6 日 - 人生计划和改变自己"></a>4 月 6 日 - 人生计划和改变自己</h4><p>昨晚睡前又想了很多，关于父母养老，关于我自己未来的人生规划。虽然爸妈现在还年轻，基本上能照顾好自己，但是再过十年呢？老爸性格急躁又固执，平时没事还喜欢喝酒，等年纪再大一些，身体上各种小毛病一定会慢慢开始显现出来。老妈也是，过去虽然没有什么大碍，但是未来难免会有因为肥胖带来的各种各样的疾病，这些都是需要提前做好规划的，比如定期做检查、陪他们去看病并叮嘱按时吃药，还有高质量的陪伴等等。所以，最好的做法是让他们和我一起住，而一起住之后我们一定会有许多需要磨合的地方，比如生活习惯、沟通问题等等。不过，我觉得这些都可以靠相互迁就来解决，最重要的还是：如何才能让他们适应城市生活？城市里不能种菜和养鸡，他们能习惯吗？无聊了怎么办？有哪些事情是适合他们做的？当然，我知道他们最想要的是有个孙辈需要他们照料，但是这个事我估计短期内应该是不太可能实现的。说到情感的话题，我现在开始觉得也许过去自己犯的最大的错误就是，太早放弃了自己喜欢的人。不过缅怀过去完全没用，我应该思考的是如何开始认识新朋友，发展潜在的恋爱对象。首先，我需要认清现实，我只不过是一个普通农村家庭出生的人，过去不是学霸，现在也没有前途大好的事业，未来也可能仍旧只是一个普通的打工仔，加上身高的劣势，而且相貌、口才、人脉都没有什么突出的优势。我能做的，只有改变自己能够改变的，提升自己的工作能力，在技术上花更多的时间，好好锻炼自己的表达能力，慢慢提升自信心，建立自己的人脉圈。但是，我知道所有的改变都需要时间。慢慢来，总会有进步的。</p><h4 id="4-月-7-日-最基础的习惯"><a href="#4-月-7-日-最基础的习惯" class="headerlink" title="4 月 7 日 - 最基础的习惯"></a>4 月 7 日 - 最基础的习惯</h4><p>情绪真的是一把双刃剑，所以说我们应该尽量不要在情绪低落的时候做任何决定，因为往往这个时候做出的决定都是不够明智的。但是人总会有情绪低落的时刻出现，我们应该思考的是如何让自己从这种情绪中恢复过来，还有如何才能学会在任何时候都保持乐观积极的态度。我觉得保持好的生活习惯非常重要，其中最重要的一点是充足的睡眠。只有每天睡 7~8 个小时以上，才能保证大脑有足够的时间休息好，我们的身体才能恢复活力。其次是养成运动的习惯，无论什么样的运动，只要是能让自己坚持下去的，就是适合自己的运动。对我来说，跑步是一项最简单的运动，起步简单，也不需要特殊的装备和场地，穿上一双舒适的跑鞋出门跑起来就可以了。最后是饮食，吃得健康其实并不难，多吃水果和蔬菜，少吃油炸食品，有能力的话尝试下间歇性断食。还有就是多喝水，想要让大脑保持活跃就离不开补充水分，而且工作间隙多起身接水也可以防止我们因为坐太久带来的眼睛和身体疲劳。我觉得这些是最最基础，而且是每个人都能做到的习惯，我们的幸福是建立在这些日常基础习惯之上的，因为只有把自己的身体健康照顾好了，才有机会谈其他。</p><h4 id="4-月-8-日-渺小和伟大"><a href="#4-月-8-日-渺小和伟大" class="headerlink" title="4 月 8 日 - 渺小和伟大"></a>4 月 8 日 - 渺小和伟大</h4><p>人真的是非常渺小的物种，相比宇宙，我们只不过是微尘，相比大自然，我们只能依赖它、保护它，而不是一味地索取。这样一想之后，人的心胸自然而然就会变得开阔起来。绝大部分人每天花费时间和精力所做的事，无非是为了维持自身的生存，处理好身边的人际关系，让自己和家人过得开心快乐以及保持内心的平静安宁。但是，每当想到广袤天地间，除了人类之外，还庇护了其它无数生灵的大自然，想到星空深处被黑暗笼罩着的远古星光都不曾到达过的遥远星系，我的心中就会升起一股敬畏之情。无论多伟大的人物，也只是存在于人类族群漫长历史中的某一页，他们活着的时候也都体验着普通人也会有的各种困惑、自我渺小感和无意义感，也感受过那些让自己心潮澎湃的伟大时刻。也许只是通过静坐，也许只是看着一朵花，也许是在望着身边追随、热爱自己的人们的时候。我觉得每个人都应该成为这样的人：既能认识到自身的渺小，也愿意去创造出独属于我们自己的「伟大」。</p><h4 id="4-月-9-日-独自生活的幸福"><a href="#4-月-9-日-独自生活的幸福" class="headerlink" title="4 月 9 日 - 独自生活的幸福"></a>4 月 9 日 - 独自生活的幸福</h4><p>今天周六，早上睡到自然醒，又接着睡了一会儿懒觉，然后刷手机刷到手酸才起来。拉开窗帘，窗外阳光明媚，有些刺眼，伸了个懒腰，转身再去洗漱。谁说必须早起才能拥有一个充满活力的一天？此刻的我就觉得自己充满了能量。我觉得自己已经拥有了曾经想要的一切，我感到感恩并且觉得自己是幸运的。还有什么是比这种状态更好的呢？幸福就是所有的欲望都得到满足并且不再寻求其它改变时出现的空当。既然如此，那就好好珍惜这一刻吧。越来越觉得这样一个人的生活状态真的挺好的，不需要依赖其他人，只需要为自己负责。所以，我可能真的比较适合一个人生活吧。也许两个人生活也能达到这种状态，但是难度会大上许多。</p><h4 id="4-月-10-日-以人生目标为导向的生活"><a href="#4-月-10-日-以人生目标为导向的生活" class="headerlink" title="4 月 10 日 - 以人生目标为导向的生活"></a>4 月 10 日 - 以人生目标为导向的生活</h4><p>昨天说到一个人生活的好处，那今天就说下一个人生活的坏处吧。我觉得最大的坏处就是有时候会感到内心空虚，不是贤者时间的那种空虚，而是不知道自己应该干什么的空虚。虽然现实中有很多事情可以做，我可以用各种各样的事务填满自己的所有时间，但是，当我一个人真正安静下来，感受周围环境，聆听自己呼吸声的时候，还是会感到一种无所适从的感觉，继而想到未来，自己有可能始终保持这样子的生活状态，然后会问自己这真的是我想要的吗？可能还是内心不够强大吧，所以还是会觉得如果有另一个人陪伴着的生活，可能就不会像这样感到恐惧和迷失方向了。但现实是，没有人知道你真正想要什么以及什么才是适合你的，你只能自己去寻找到目标，并且只有去尝试过，才能知道自己应该怎么做。突然想起之前推友说国外有的大学的办学资金的一大来源是已毕业的校友，其中有很多是非常成功的校友，他们终身不婚不育，死后则把自己的几乎所有资产都捐给了母校。我想这样也挺好的，我们努力的目的，不是为了证明自己，也不仅仅是为了贪图个人的享乐，而是因为我们想做自己喜欢的事，并且能够从中找到为他人产生价值的方式。财富只是衍生品，生不带来，死不带走。既然如此，有什么理由不去把自己的学识和财富交给下一代人，让他们同样能够去做自己想做的事，并且为这个世界创造出更大的价值呢？即使拥有了无与伦比的爱情、友情和亲情，到最后我们还是要独自面对我们自己，既然如此，为什么不一开始就去寻找自己真正想做的事呢？良好的人际关系应该是在这一过程中逐渐获得的副产品。</p><h4 id="4-月-11-日-相信会变好"><a href="#4-月-11-日-相信会变好" class="headerlink" title="4 月 11 日 - 相信会变好"></a>4 月 11 日 - 相信会变好</h4><p>有时候莫名感到心慌，经常觉得时间总是不知不觉就过去了，然后才发现还有那么多要做的事没来得及做。内心一面会谴责自己的拖拉和容易分心，另一方面又觉得，为了体会到生命充盈的感觉，那些看似无用的事也是值得做的。但是，过后内心还是会感到焦虑。看了那么多关注当下的文字，结果还是无法做到全然当下。不过，虽然很难，但是还是要不停地尝试下去。反复练习，相信总会慢慢变好的吧。另外，今天是王小波逝世 25 周年。虽然他的书我还没有全部看完，但是以后总是有时间的吧。再过 17 年，我就和他去世时的年龄一样大了，不知道到时候回过头再看他写的文字，会是什么样的感觉。</p><h4 id="4-月-12-日-No-one-but-you"><a href="#4-月-12-日-No-one-but-you" class="headerlink" title="4 月 12 日 - No one but you"></a>4 月 12 日 - No one but you</h4><p>我们能控制的只有我们自己，需要经常提醒自己这一点。</p><h4 id="4-月-13-日-新习惯"><a href="#4-月-13-日-新习惯" class="headerlink" title="4 月 13 日 - 新习惯"></a>4 月 13 日 - 新习惯</h4><p>给自己定个近期希望养成的新习惯：中午不看手机，晚上不看电脑（除了处理工作事务之外）。</p><h4 id="4-月-14-日-警惕自以为完整和失去好奇心"><a href="#4-月-14-日-警惕自以为完整和失去好奇心" class="headerlink" title="4 月 14 日 - 警惕自以为完整和失去好奇心"></a>4 月 14 日 - 警惕自以为完整和失去好奇心</h4><p>和自诩正确同样值得警惕的是：自以为世界观已经完整了，于是不再对未知和新事物感到好奇，或者觉得没有了解的必要。</p><h4 id="4-月-15-日-以变好为目标"><a href="#4-月-15-日-以变好为目标" class="headerlink" title="4 月 15 日 - 以变好为目标"></a>4 月 15 日 - 以变好为目标</h4><p>不能诚实面对自己，会对一个人造成多大的伤害？我觉得我目前遭遇的所有苦恼主要来源于我无法面对真实的自己，接受不了真实的自己。于是，才会感到痛苦，以及使用各种各样的手段去逃避面对自己的问题。解决办法其实也很简单，去面对它们就好了。首先承认现状，我无法接受此刻的自己，而且想要逃避问题，逃避痛苦。接下来，问问自己，我为什么不敢面对自己？因为理想中的自己和真实的自己存在很大的差距，因此我不想要面对真实的自己。既然如此，我需要做的是调整自己的期望，把理想中的自己看作是自己的幻觉，这样，当看到真实的自己之后，痛苦感也许就能减轻一点。然后，我需要做的是，除了看到自己的缺点之外，也看到自身的优点，然后制定合理的计划，去提升自己，让自己一点点靠近理想中的自己。没有人生目标的确是件非常让人苦恼的事，但是我们至少可以让自己不断变得更好，这也可以作为一个人生活下去的动力。人生说短也长，我们除了承担起自己应尽的责任和义务之外，也要意识到自己就是在经历一趟旅行和一场实验，我们通过做各种各样的选择来试验自己过去积累的认知的正确性，然后通过各种新的体验以及细微的改变来认识自己。</p><h4 id="4-月-16-日-掌控你的时间和注意力"><a href="#4-月-16-日-掌控你的时间和注意力" class="headerlink" title="4 月 16 日 - 掌控你的时间和注意力"></a>4 月 16 日 - 掌控你的时间和注意力</h4><p>人最稀缺的资源是时间和注意力，但是有多少人敢说自己是完全按照个人意志来决定如何分配和使用自己的时间和注意力的呢？有太多人已经陷入了「工作是为了赚钱，下班后的休闲娱乐是对自己的奖赏」的模式。我并不是想批判这种想法，因为我曾经也是使用这种思维模式的人，况且我也没有权力批判任何人，只不过感到很可惜。因为人一切行动的根本动力来自于他的信念，如果一个人接受的是「工作的意义仅限于获得收入」这样的观念，那么他对自己的工作就不可能投入 100% 自主力，他不会主动思考如何把自己的工作做到最好，他完成工作的动力主要来自于外界的反馈，而不是获得内心的满足。当然，外界激励是很重要的一个尺度，但是仅有这一点是不够的。人与其它动物的区别是，我们是能够思考并且内心世界丰富的物种，如果无法拥有足够的意义感，我们的生活就会像一堆即将熄灭的灰烬，而拥有意义感和使命感可以让我们的生命变成熊熊燃烧的烈火。</p><p>如何获得它们？我觉得可以从「发现工作对自己和他人的意义」出发，找到工作中那些让自己感到满足和投入到忘我的时刻。其次是问问自己，除了你自己和公司内部人员之外，哪些人会因为你的工作而获益？是否能够帮助到一些第三方的人？当你问自己越多这样的问题，你对自己的角色乃至你所在公司的角色都会有更深一层的认识。每一份工作，每一家公司，都有其意义，哪怕是街边卖小吃的人也满足了一部分人的需要，没有哪种工作是完全没有意义的。写到这里，突然觉得，能够思考这样问题的人就已经是非常幸运的人了，其实还有很多人没有我这样的条件去思考这些问题。不过，反过来想，这也是我们应该努力工作的原因，我们能做的最好的事就是参与到市场中，只有每个人都最大程度地发挥出自己的能力和优势，我们才能创造出更多的财富和价值，并且最终将它们回馈到市场中去，整个社会的生产力、所有人的生活水平也会因此慢慢获得提高。</p><h4 id="4-月-17-日-出身和理想"><a href="#4-月-17-日-出身和理想" class="headerlink" title="4 月 17 日 - 出身和理想"></a>4 月 17 日 - 出身和理想</h4><p>昨晚看了一集<a href="https://www.youtube.com/watch?v=yBbhoOdLQjg">圆桌派</a>，感慨挺多的，主要是听了主持人和几位嘉宾的谈话让我联想到自己的出身，我以前只想过家庭对自己的影响，从来没想过还有出身这回事儿。想来这也是由于我所在的环境吧，我来自一个农村家庭，小时候基本上大家的家庭情况都差不多，之后升初中、高中也没有多大的变化，有的人来自县里、市里，只不过家庭条件比我好一些而已。哪怕到了大学，我也没有想过出身对不同人的影响，虽然有不少来自其他省市的同学，但是我也没觉得我们有什么不一样的。这可能和一直以来我的圈子比较小、比较普通有关系吧。当你进入一个更高层级的圈子，里面各种背景的人都有的时候，你可能就会开始思考出身的问题了。比如某个人是干部子弟，某个人是富商后代，所以我们说话、做事的方式都不太一样，等等。不过，我的确一直都觉得自己性格内向的原因中有很大一部分是由于家庭环境对我的影响，比如我不敢在陌生人面前发言，我不喜欢抛头露面，我害怕成为别人话语中的焦点，但是有的人却可以非常自如地在各种场合下说话和做事，并且始终保持怡然自得的神态，这可能是因为他们从小经历就比较丰富，见多识广的缘故吧。这期圆桌派里的嘉宾们，他们的家庭在那个年代经历了社会阶层的大洗牌，所以可以看到各种原本应该彼此碰不上面的人不但产生了交集，甚至组建了家庭，我想这也是那个年代的特殊性吧。当社会稳定下来之后，圈层、阶级就会逐渐形成并慢慢沉淀下来，像过去那样大规模的洗牌应该是不会再出现了，而能够突破阶层的人也会越来越少。向上通道也许会持续打开一道小口子，但是大幅改变社会整体面貌的现象不太可能再次发生了。</p><p>除了这些之外，这集圆桌派还谈到了理想的话题，我也开始思考自己应该追求什么样的理想，以及应该如何度过自己的一生。这个话题太过宽广，不过，我首先想到的是个人的幸福和家庭的完满。这也是人之常情吧。我们每个人都想要让自己和家人过得更好，然后才会想到更大的理想以及如何影响他人和这个世界。对我来说，作为一个普通得再普通不过的农村家庭长大的孩子，能够来到城市并立足就已经非常不容易了，如果还有余力，那一定是想着如何才能帮助自己的家人，让他们也能过得更好，因为我本来就是一直受着父母的资助才能走到今天。其实我对凤凰男/女这个词被用作贬义词还是挺不解的，我觉得一个人从不那么好的状态变得更好了，不是应该值得开心和庆祝的事吗？的确，这样的人身上会带着很多来自他从小成长环境和家庭教育留下的影子，但是，我们每个人不都是这样吗？为什么一定要让所有人都和自己一样呢？如果你觉得自己无法认同对方的观念，也适应不了对方的生活习惯等，那选择远离不就行了。对我本人而言，我还是挺为自己的农村背景感到自豪的，因为我觉得自己和其他人一个很大的不同是，我的容忍度很高。我可以接受比较艰苦恶劣的条件，也能够忍受其他人和自己有完全不同的生活习惯。另一方面，又因为我有自我更新的习惯以及还算丰富的获取信息的渠道，我现在知道了这个世界上有很多种生活方式，而且也认同每个人都有权利选择适合自己的生活方式。尽管有些部分是我不能认同的，但是我也会尽量压制内心的不同意见，尝试不去批判对方。我觉得这是增进彼此了解和打破隔阂的唯一手段。</p><p>扯远了，说回理想的话题。目前来看，的确个人和家庭的幸福比较重要一些。除此之外，就是尽可能多地认识这个世界，可以是通过工作，通过阅读，通过旅行，通过和不同的人交谈，也包括看各种各样的电影、视频等等。我觉得生命其实非常短暂，就像我昨天碎碎念中说的，时间和注意力才是这个世界上最终极的资源，如果你浪费了今天这一天，那么你的生命就少了一天。为了让自己每一刻的生命都是过得有意义的，我们必须不断守护自己的意识，按照自己内心的想法去生活，而不是外在的那些东西。一个人只有内心的平静和满足是无法被他人剥夺的。</p><h4 id="4-月-18-日-做个主动的人"><a href="#4-月-18-日-做个主动的人" class="headerlink" title="4 月 18 日 - 做个主动的人"></a>4 月 18 日 - 做个主动的人</h4><p>昨晚突然意识到一个问题，在人际交往中，我为什么不愿意主动？尤其是在和女生的互动中，我似乎总是喜欢等待对方主动，而不是自己主动示好，以及表达出内心的真实想法。甚至是在 watch porn 的时候，我也更倾向于选择一些女方主动的类型的片子。就像昨天碎碎念中提到的一样，我觉得一个很重要的原因是家庭教育。过去我也在碎碎念中提到过，爸妈的相处模式是，老爸在关系中是强势的一方，而老妈总是处于被动的一方。加上农村本身就重男轻女，从小在这种家庭环境下长大，我在无形中就被植入了女性不如男性的观念，而且是以非常隐秘的方式。我从小性格就非常害羞，尤其是在和女生相处的时候，和陌生的漂亮女生说话经常会脸红、感到不好意思。现在想想，其实这是我内心的一种防御机制，我内心会为自己想要接近对方、甚至是喜欢对方的想法感到羞愧，于是表现出害羞的行为，从而抑制自己做出任何主动的行为。过去我一直以为是自己性格的问题，但是随着年纪增长，尤其是接触了阿德勒心理学之后，我越来越觉得这一切其实是我个人信念的问题。既然我在生活中的其它方面可以做到主动，那么在人际交往方面，我也应该可以做到积极主动，只要我改变个人信念就可以了。但是，我觉得也没必要带着过去的镣铐来跳舞。已经发生的事无法被改变，我们虽然可以在事后对它们进行分析，但是也可以选择如何诠释它们。如果可以从中看到积极的一面，帮助自己在未来不再犯下相同的错误，我觉得这就是在成长，也是自我反思的意义所在。</p><h4 id="4-月-19-日-个人幸福＞表面婚姻"><a href="#4-月-19-日-个人幸福＞表面婚姻" class="headerlink" title="4 月 19 日 - 个人幸福＞表面婚姻"></a>4 月 19 日 - 个人幸福＞表面婚姻</h4><p>最近关注到单身妈妈的话题，看到有人选择自己一个人生育，还是挺有感触的。我觉得未来应该会有越来越多的人选择这样的生活方式：遵从自己的内心，选择自己喜欢的方式去生活，而不是被迫进入婚姻。我仿佛看到了自己的未来，像我这样的人也一定是会首先选择自己。虽然这样的生活方式有可能要承担一点来自外界的压力，但是相比毫无生活质量、一地鸡毛的生活，我宁愿选择一个人。也许在有的人眼里，这样的说法很难被接受，婚姻不就是彼此适应吗？但是，如果找不到一个彼此相爱、精神契合、相处融洽的人，而且你一个人也可以过得还算开心，那为什么还要进入一个不那么匹配的婚姻呢？我相信合作的价值，但是也觉得慎重一点是应该的。如果没有合适的对象的话，那就自己一个人过吧。这样做的唯一坏处是父母在情绪上很难接受，但是我觉得生活就是这样，你无法照顾好所有人的情绪。我觉得除了给父母足够的关心，让他们明白即使一个人也可以过得很快乐，并且不要让他们有后顾之忧，能做到这些就已经很棒了，至于其他的，只能听天由命了。不管他们能不能接受，我们只要做好自己该做的部分就够了。无论如何，始终都要把自己的健康和幸福放在第一位。</p><h4 id="4-月-20-日-心态平和与内心安宁的生活"><a href="#4-月-20-日-心态平和与内心安宁的生活" class="headerlink" title="4 月 20 日 - 心态平和与内心安宁的生活"></a>4 月 20 日 - 心态平和与内心安宁的生活</h4><p>最近工作和生活中的事件频率有点低，所以空闲下来的时候难免会感到有些迷茫。好在生活还算规律，所以每天早早上床睡觉，避免了把太多时间用于胡思乱想。我觉得自己还算是一个情绪比较稳定的人，但我知道这是因为我的生活足够简单，除了工作之外，生活中绝大部分时间都是在独处中度过。没有社交，自然比较容易维持内心的平静。但是，如果生活中出现一些波动，我内心的平衡也就很容易地被打乱了。我知道这也是需要刻意练习的事，只可惜自己的确比较缺乏这样的练习机会。看到过一句话，大意是，这世上没有幸福，我们所做的一切都是为了免于痛苦，以及保持内心的安宁。对于我这样一个还比较年轻的人来说，多少会有点怀疑这样的言论，但是，我的确希望过上一种尽可能简单以及内心安宁的生活，因为只有在平静之中，我才能感受到幸福。</p><h4 id="4-月-21-日-文字的力量"><a href="#4-月-21-日-文字的力量" class="headerlink" title="4 月 21 日 - 文字的力量"></a>4 月 21 日 - 文字的力量</h4><p>我相信文字的力量，即使是在这个媒体上充斥着各种短、长视频的时代，我依然觉得真正能够抚慰人心的还是文字，最有力量的也是文字，而且也只有文字才能将一个人的思想长久地流传下去，这也是为什么我开始锻炼自己的写作能力。也许无法成为一个作家，但是通过写作，我学会了如何有条理地、清晰地表达出自己的想法。我能更好地欣赏他人的文字，我知道要写出优美、易于阅读的文字有多么不容易。文字的一大用途是传递信息，其次是记录和倾诉。普通人如果能够提高自己的写作水平，也是受益良多的事。比如学会更有效地和他人沟通，学会如何表达自己，学会通过文字倾诉内心，以及学会阅读。是的，学会写作也能让你成为一个更好的读者。因为你在一开始学习写作的时候，会不由自主地去模仿自己喜欢的作者，从他最基本的行文造句，到模仿他的表达方式、思考方式。慢慢的，你会开始觉得这样是不够的，于是开始阅读其他人的文字，并且模仿他们。最终，你会逐渐形成自己的风格。即使无法形成自己的写作风格也没有关系，我觉得哪怕只是提高了个人的写作水平，那也足够了。</p><h4 id="4-月-22-日-做一个自由表达自我的人"><a href="#4-月-22-日-做一个自由表达自我的人" class="headerlink" title="4 月 22 日 - 做一个自由表达自我的人"></a>4 月 22 日 - 做一个自由表达自我的人</h4><p>昨天经历了第一次封闭隔离，虽然只是不准出大楼，而且时间也不长，只有短短 3 个多小时，但是，在这段时间里，还是有不少新的感触。比如，我发现我有时候真的非常不会闲聊。虽然也知道这没什么，因为作为一名员工，最重要的事是高效完成自己的工作，然后才是和同事融洽相处。即使做不到关系非常融洽亲密，哪怕只是保持互相尊重和友善的态度，那也足够了。毕竟，我从来不觉得能在工作中交到朋友，也许运气好的情况下可以。说起来，我真的是个比较悲观的人。我一直觉得能够理解自己的人很少，无论是在现实中还是在网络上，所以，大多数时候我都选择在一个相对安全的区域内表达自己的想法，而不是去公开的平台上表达。这一方面说明我对他人的不信任，另一方面也说明我对自己的不信任。我害怕受到他人的攻击，也害怕自己的表达对他人没有价值，只是白白占用了他人的时间。即使如此，我还是觉得自己应该开始改变。就像过去碎碎念中所说的，我的目标是做一个随时随地都能自由表达内心想法的人。也许一开始很难，但是我相信只要开始尝试，总会看到变化的。</p><h4 id="4-月-23-日-避免痛苦"><a href="#4-月-23-日-避免痛苦" class="headerlink" title="4 月 23 日 - 避免痛苦"></a>4 月 23 日 - 避免痛苦</h4><p>亚里士多德说：理性的人寻求的不是快乐，而只是没有痛苦。即使有人不同意前半句，但至少后半句是真实的。绝大部分人所做的一切都是为了远离痛苦，没有人会没有目的地去主动追求痛苦。那么，按照芒格说的「总是反过来想」的思维，人生中最大的痛苦有哪些呢？我首先想到的是失去健康的痛苦，其次是失去至亲的痛苦。除此之外，剩下的所有痛苦都来自于我们无法满足自己内心无止尽的欲望，比如对财富、地位、声誉的追求。</p><p>现在大家都喜欢说「99% 的烦恼都可以用钱解决」，其实反映出的是一种焦虑，我们害怕风险，害怕不好的事情会发生在自己的身上，所以觉得只有努力赚钱才能让自己感到安全，才能有底气去面对风险。所以，甚至有人愿意暂时牺牲自己的健康去换取财富。我觉得这是非常不划算的。虽然金钱很有诱惑力，但是长期来看，真正值得我们追求的还是身心的健康以及内心的安宁。对我来说，每天能够产出一些价值，也能让自己有所积累，这就够了。</p><h4 id="4-月-24-日-知足"><a href="#4-月-24-日-知足" class="headerlink" title="4 月 24 日 - 知足"></a>4 月 24 日 - 知足</h4><p>不再追求更多就是躺平吗？我觉得不是。我觉得这是知足的表现，而学会知足也是人生中重要的一课。一个人只有在学会知足之后，才能开始停下来思考自己真正想要什么？更多的财富也许能满足一个人更多的欲望，但是如果学不会知足，他可能会一直到死亡来临之前才能意识到自己行为的愚蠢。我们所做的一切都是为了了解自身和认识世界，一旦偏离了这一点，陷入执着于某个事物或某种状态，这就不是充满意识地活着了。</p><h4 id="4-月-25-日-勇于尝试，改变自己"><a href="#4-月-25-日-勇于尝试，改变自己" class="headerlink" title="4 月 25 日 - 勇于尝试，改变自己"></a>4 月 25 日 - 勇于尝试，改变自己</h4><p>我觉得自己非常矛盾的一点是，明明知道自己的行为会对他人造成影响，但我还是会选择闭嘴或者不作为。很难解释自己的心理。也许只是形成习惯了吧，由于长时间陷入同一种行为模式，所以打破这种模式就需要付出额外的努力。那么，如何打破它呢？我觉得首要一点是，<strong>意识到我们终有一天是要死去的</strong>。死亡是每个人最终的归宿，既然如此，此刻的恐惧以及担心就是没有道理的。可能人只有到了一定的年龄，才能想明白这个道理，但是在还年轻的时候，总是觉得未来还很长，所以会特别担心自己在他人眼中的形象。只要想清楚我们都是要死的，而且自己在他人眼中根本就没有什么形象需要维护，因为绝大部分人都只在乎他们自己，所以，一个人如何改变自己才是真正重要的事。因为当你改变自己，让自己变得更好、更主动，这对其他人来说，这只是他们观察到的一个现象，而对你自己来说，这是改变了自己人生的轨迹。也许你会变得更外向，或者变得更勇敢大胆了，又或者丰富了自己的世界观。一切都是未知的，为什么不去尝试一下呢？</p><h4 id="4-月-26-日-做好最坏的准备"><a href="#4-月-26-日-做好最坏的准备" class="headerlink" title="4 月 26 日 - 做好最坏的准备"></a>4 月 26 日 - 做好最坏的准备</h4><p>最近看了不少负面的消息，难免会受到一点影响，于是情绪变得有些紧张起来。想到自己未来生活中可能面临的种种风险，想到父母的晚年生活，想到自己有可能需要一个人面对这一切，顿时觉得压力重重。不过，说起来自己还算年轻，能够在比较早的时候就意识到这些问题，也算是一种幸运吧。但是，不要以为一切都还来得及，因为时间过得非常快，当你觉得自己还有机会可以补救的时候，往往就意味着你要开始错过它们了。最好在一开始就把事情做对、做出正确的选择。比如听从自己内心的声音，做自己喜欢的事，而不是去随大流。把自己和家人的健康和幸福放在第一位。控制消费，配置好保险，提前储备风险账户，再用剩下的钱定投。先把这些最基础的事情都处理好，然后才能有精力去思考其它事情，才能更好地生活。我们努力的目的不只是为了享受，而是为了承担起自己的责任，去保护好我们爱的人。至于爱情，我相信每个人都有追求爱的权力，但是并不是每个人都能如愿拥有爱情。况且与其苦苦追求爱，我更愿意把时间花在自己身上，和自己独处。先了解自己，再了解他人。如果没有合适的人，我也接受独自去探索这个世界。如果能够在这一过程中遇到一个愿意和我分享她的世界的人，我们一起去探索这个世界，那当然更好。怀抱希望，但是做好最坏的准备，我觉得拥有这样的心态就没什么好害怕的了。</p><h4 id="4-月-27-日-Take-Charge"><a href="#4-月-27-日-Take-Charge" class="headerlink" title="4 月 27 日 - Take Charge"></a>4 月 27 日 - Take Charge</h4><p>昨天看了 David Perell <a href="https://ckarchive.com/b/8kuqhoh0e5lv6">一篇文章</a>，讲的是专业人员「Take Charge」的重要性。公司庆祝活动之后，他雇佣了一个摄影师给公司全体员工拍合照。作为一个群像摄影师，照理说应该有很强的控场能力，会根据客户的需求确定合适的拍照方式，并且指导所有人一起配合完成摄影，而不只是会按快门就可以的。不仅仅是这位摄影师，其实现在很多人都有一种不想做主、不愿负责的倾向，包括我自己也是，觉得枪打出头鸟，所以凡事都要低调一些，哪怕是遇到那些要求自己体现出专业性的地方。对于群像摄影师来说，能否掌控好局面就是体现他专业性的一个方面。相对应的另一个例子是一个飞行员起飞前和调度中心的对话，飞行员要求的起飞方向和调度中心允许的起飞方向有偏差。此时，飞行员的选择是告诉调度中心，等到能够满足他要求的起飞方向时，他才起飞。对于飞行员来说，不管他驾驶的是什么型号的飞机，他的首要任务是从 A 点起飞，驾驶飞机到 B 点安全降落，他需要对飞机上的所有乘客负责。而调度中心的任务是协助飞行员完成这一任务。飞行员必须记住他的首要任务，而不是盲目听从调度中心的指挥。因为一旦进入盲从状态，发生事故后，责任还是在飞行员。调度中心不知道飞行员在现场面对的是什么样的情况，有些问题只有依靠飞行员自身的专业性才能发现并避免。所以，当这种情况出现的时候，飞行员必须敢于 take charge。哪怕是自己的判断出错了，最后的结果顶多是个人受到处罚，总好过判断正确但是由于没有坚持判断而酿成悲剧性的事故。所以，就像 David 说的，尽管我们的文化正在变得越来越软，但是人性并不会改变。一群人如果没有领导者，最终什么事也完不成，只是白白浪费了生产力。当他人需要我们发挥出自己专业性的时候，不要害怕成为那个领导者。每个人都有自己的专业领域，所以，每个人都应该有承担责任、成为领导者的意识。</p><h4 id="4-月-28-日-选择越多越好吗"><a href="#4-月-28-日-选择越多越好吗" class="headerlink" title="4 月 28 日 - 选择越多越好吗"></a>4 月 28 日 - 选择越多越好吗</h4><p>最近常常思考的一个问题是：选择越多越好吗？大多数情况下答案都是 Yes。但是选择多也带来了另一个问题，那就是如何在众多选择中做出最适合自己的选择？很多人就是因为不知道如何做选择才陷入了烦恼。和谁谈恋爱？选择什么样的工作？交什么样的朋友？这些都是在问答网站上非常常见的问题。就拿恋爱来说，过去很多人一辈子只生活在一个地方，很少离开自己的出生地，结婚也大多是父母之命，即使是自由恋爱，选择的对象往往也是在自己的亲友、社交圈内的人。但是，我们这一代的年轻人，择偶面似乎无限多，除了广大的同学、同事、朋友圈，连另一个城市的陌生人也可以成为潜在的择偶对象。但是，这种拓宽的选择权似乎只是一个幻觉，更多的人反而不敢也不愿意去谈恋爱了（比如我）。不知道是因为选择变多之后，看到了更多的可能性，于是不愿意将就，还是觉得自己不够好，不配去追求自己喜欢的人。反正在各种原因之下，越来越多的人选择了单身，而且在绝大部分情况下，这种「选择」都是被迫的。所以，选择真的是越多越好吗？</p><h4 id="4-月-29-日-轮滑心得：压外刃和T刹"><a href="#4-月-29-日-轮滑心得：压外刃和T刹" class="headerlink" title="4 月 29 日 - 轮滑心得：压外刃和T刹"></a>4 月 29 日 - 轮滑心得：压外刃和T刹</h4><p>记录一下自己最近练习轮滑的心得吧。首先是压刃，一个很好的练习方法是原地交叉步。在重心还掌握得不是很稳的时候，其实就可以开始练习原地交叉步了。先从自己的惯用脚开始，然后是反脚。等到熟悉向前交叉之后，再开始练习向后交叉。向后交叉其实练习的就是压外刃的技巧。另外，原地转圈也是一个非常好的练习压刃的方法，只不过每次只能压一只脚。比如，如果是顺时针方向，那就只能压右脚的外刃，如果是逆时针，则压的是左脚的外刃。另外一个压刃技巧是画 C：双手向前，一只脚作为承重脚，同时压外刃，另一只脚探出去在地面划出大弧形，同时压内刃。这样练习之后，你的双脚都会逐渐习惯压外刃的感觉。其次是 T 刹，也有不少窍门。光看他人视频的话，似乎所有人都在教你要一只脚压外刃作为承重脚，后脚位于前脚跟后，与前脚垂直并且压内刃摩擦地面，直到刹停。但是我发现，对我来说，这样的动作在原地都很难保持平衡，因为我还没熟练做到单脚掌握重心。所以，一个窍门是先练习侧面 T 刹。也就是一只脚承担大部分身体重量作为承重脚并且压外刃，另一只脚在承重脚的边上而不是后方，并且与前进方向垂直，然后用内刃小角度摩擦地面减速。这招能让你很快适应压一只脚的外刃同时摩擦另一只脚的内刃的感觉，虽然减速过程中会让你转向（因为这种姿势会让你很难控制方向），但是却会让你更快地学会 T 刹。因为等到你熟悉之后，只要把脚移到后方，其实就是 T 刹了。还有就是，刚学会 T 刹的时候，速度较快的时候不要压太多的外刃，因为很容易失去平衡。最佳的做法是保持尽量轮子垂直，然后学会逐渐增加后脚压内刃的力度。</p><h4 id="4-月-30-日-相亲和婚姻"><a href="#4-月-30-日-相亲和婚姻" class="headerlink" title="4 月 30 日 - 相亲和婚姻"></a>4 月 30 日 - 相亲和婚姻</h4><p>聊聊相亲的话题吧。老实说，我们这个时代的相亲相比过去已经有很大的进步了，毕竟，过去都是「父母之命，媒妁之言」，不少都是在婚礼当天晚上才第一次见到自己的未来对象长啥样。女方就更惨了，基本就没有什么选择权，也没有什么地位，只能「嫁鸡随鸡，嫁狗随狗」。现在听到的我们这个时代的抱怨，其实一部分是来自外界环境的凝视的压力，还有就是物质条件的比较。虽然这种比较是有一部分意义的，毕竟只有彼此条件更匹配的两个人，生活幸福的概率才更高。抛开这些不谈，我个人内心还是非常抵触相亲，一是觉得这样就不浪漫了，二是我认知中相亲是走投无路的人的最后选项，而我自认为自己似乎还不至于走到这一步（真的是这样吗？）。也许真实的生活就是两个人彼此迁就着过日子，即使日子真的过不下去了也要想办法忍让忍让再忍让。但是，你说我理想主义也好，反正我不愿意过这样的生活，我宁可选择单身。而且我在想，有多少人是为了生小孩而结的婚？比例应该不低吧。毕竟在这个时代背景之下，婚姻制度除了给人一种身份感、归属感，以及在社交场合不让人尴尬，最大的好处就是一起养育后代了吧。抛开非婚生孩子受到的歧视不说，孩子最需要的其实是父母双方的爱，这点是单身爸妈无论如何也弥补不了的。不过，想到有很多家庭的孩子是在父母中的一方缺席的情况下长大的，孩子也能成长的不错，就觉得其实也不一定非要结婚。</p><p>对我来说，此刻是我选择机会最多的时候，不知道几年之后是否还是这样，但是就目前来看，我觉得一个人的生活更适合自己。我喜欢独处，不喜欢社交，对异性包括对朋友的需求都不是太大，有自己的兴趣爱好，对这个世界还保持着好奇心，也喜欢向内探索自我。不过，我觉得既然自己已经想明白了这些事情，而且也有热情去过好一个人的生活，其实这个时候反而是最适合谈恋爱的，因为生活中的恋爱也是认识自己的关键一环。所以，最好的做法还是活在当下。如果遇到了还不错的女生，对方也愿意和我一起玩的话，那我们就一起聊天、吃饭、逛街、睡觉、发呆，去做我们彼此都愿意做的事，如果彼此都觉得合适的话再考虑是否要进入婚姻。婚姻是两个人决定一起生活，并且组成一个联盟，共同面对未来，如果我们无法接纳对方最自然的状态，那怎么能有彼此合拍的生活呢？</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅和质朴</title>
      <link href="/2022-3/"/>
      <url>/2022-3/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/NPZQm2AE5vU" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>这个月过得非常缓慢，可能是生活节奏慢下来的原因吧。另一方面，我也刻意地让自己把更多的注意力放在当下，感受工作和生活中的每个细节，用心去体会那些过去不曾注意到的事情。比如仔细看着镜子前刷牙的自己，体会脚踩在落叶上发出的声音，经过路口时看到的行人脸上的表情，夜跑完走在人群中感到孤独的时刻。我觉得当你认真开始体会生活的时候，你会发现其实琐碎的生活也非常有意思。我们不需要像电视剧或者小说中那样刺激、有意思的情节来让自己的生活变得丰富，我们需要的只是一颗足够敏感的心。过去，我以为优雅的前提是体面的生活，但是，现在我才意识到，优雅和质朴是可以共存的，而这，全都取决于一个人具有什么样的信念。</p></blockquote><span id="more"></span><h4 id="3-月-1-日-何时放弃-rat-racing"><a href="#3-月-1-日-何时放弃-rat-racing" class="headerlink" title="3 月 1 日 - 何时放弃 rat racing"></a>3 月 1 日 - 何时放弃 rat racing</h4><p>每个人都想要通过获得成功来证明自己，于是我们不停地把自己的时间和精力放在这种追逐上，但是这一切对我们来说真的这么重要吗？我不是说我们应该放弃拼搏，选择躺平，而是提醒所有人停下来思考其意义。每个人当然都应该承担起自己的责任，我们需要照顾好自己和家人，但是，这是不是意味着我们就得牺牲认识自己、探索世界的时间和机会呢？我觉得这两者之间并不矛盾。其实每个人都活在自己的 rat racing 之中，但是，当你能够满足自己和家人的基本所需的时候，就可以告诉自己，我是有得选的。你可以选择如何分配自己的时间和精力，不要被外界声音影响，去做自己真正热爱的事情，可以是阅读，可以是发展其它的业余爱好，也可以是简简单单的陪伴家人。总之，不要陷入习惯性思维，不要认为自己必须如何如何，很多时候我们只不过是自己给自己画地为牢，被自己的想法束缚住了而已。</p><h4 id="3-月-2-日-只关注自己影响圈内的事"><a href="#3-月-2-日-只关注自己影响圈内的事" class="headerlink" title="3 月 2 日 - 只关注自己影响圈内的事"></a>3 月 2 日 - 只关注自己影响圈内的事</h4><p>如何做到不被外界信息影响呢？明明知道那些信息只会增加自己的焦虑，而且并不能给自己带来任何的好处，但是还是会忍不住去关注它们，只有在事后才会意识到自己又浪费了一个晚上的时间。其实可以套用一个原则：不关注任何在自己影响圈之外的事物。如果自己的行为不能给这件事带来任何有益的结果，那你就应该立刻停止关注它。如果凡事都能做到这一点，每个人的生活都会变得简单许多，也会快乐许多。</p><h4 id="3-月-3-日-观察自己以及停止自我批判"><a href="#3-月-3-日-观察自己以及停止自我批判" class="headerlink" title="3 月 3 日 - 观察自己以及停止自我批判"></a>3 月 3 日 - 观察自己以及停止自我批判</h4><p>我觉得自己无法进入当下的原因是太过自我，而自我的一大来源是炫耀以及寻求他人认可的欲望。比如写碎碎念这件事，我的初心的确只是记录自己的想法、锻炼文字表达能力，但有时候当我一坐下来的时候却会觉得不知道该写什么，而这通常都是因为我觉得自己必须写出来一些「好的」或者「有用的」文字。这其实就是自我的束缚。我想要通过文字表达来展示自己，一想到文字会被公开，有可能被其他人看到之后，又会觉得必须写得讨巧一点，这样才能获得他人的认同和不被批评。而一旦有这样的想法出现，我表达的内容就做不到完全反映自己内心真实的想法了。真实是这个世界上最重要的品质。观察下自己的行为，我发现大多数时候自己内心的不和谐都是因为我表达的东西不够真实。我觉得仅仅是说出自己内心真实的想法，其实就可以解决绝大部分的心理问题了。观察自己，不要批判自己，接纳自己，当做到这些的时候，我们其实就已经在改变自己了。</p><h4 id="3-月-4-日-不去批判他人"><a href="#3-月-4-日-不去批判他人" class="headerlink" title="3 月 4 日 - 不去批判他人"></a>3 月 4 日 - 不去批判他人</h4><p>我觉得自己无法做到自由表达自己的一个原因是，我害怕受到他人的批判，而这种害怕来自于我自己也经常会在内心批判他人。比如看到一个体型较胖的人，会在心里想「那人好胖」，然后为自己身材还不错感到得意。我有时候会不自觉地为在街上遇到的人打分，比如颜值、穿衣搭配、给人的感觉等等，然后还会拿自己和对方进行比较以此来获得优越感。如果觉得对方比我「好」，我就会自认为低人一等，甚至会刻意避开和对方的视线接触。我觉得正是因为这样的心理活动导致我无法真正和他人进行平等地沟通，因为当你不停地拿自己和他人比较的时候，你就很难再把注意力完全集中在当下正在发生的事情上。我们所做的所有事都是在强化自我认同，有没有什么方法可以弱化这种虚假的自我感？如果能做到不去批判他人，也许就是一个大进步了。</p><h4 id="3-月-5-日-接纳生命中的一切"><a href="#3-月-5-日-接纳生命中的一切" class="headerlink" title="3 月 5 日 - 接纳生命中的一切"></a>3 月 5 日 - 接纳生命中的一切</h4><p>每次回家和父母相处总会让我在心里产生一种愧疚感，觉得他们的生活真不容易。每当出现这样的想法，我就立马意识到我又在为自己制造「麻烦」了。因为只要你觉得自己应该如何如何，而现实中却无法实现这样的目标的时候，你就会对自己感到失望。正确的做法是接受现实，从自己能够改变的事情上开始做起，比如夸奖老妈的厨艺，主动洗碗、打扫卫生，陪老爸老妈看电视、聊天，等等。很多时候，我们只是从自己的角度出发去看待身边发生的事，但是同一件事从不同的角度看到的会是完全不同的结果。我觉得容易感到感伤其实也是过于「自我」的一种表现。当外界世界和我们所感知到的不同的时候，积极的做法应该是去接受它，想办法去改变它，或者改变自己去适应它，而不是产生一种消极的情绪来抵抗它。</p><p>我们每个人所看到的世界都只是我们内心世界的投影，过去一直理解不了这句话，但是现在我才慢慢开始感到认同。的确，我们现在所处的世界对某些人来说，生存依旧艰难，但即使是在最为艰苦的条件下，我们依旧可以选择以何种态度对待它。想想经历了纳粹集中营生活的 Viktor，在那种环境下，放弃生命走向死亡是容易的，但是他却因此找到了生命的意义。普通人一生当中也会不止一次地面对生死考验，亲人的离去，甚至是自己身体上的病痛，每当这样的时刻来临，我们也会开始思考健康以及生命对我们的意义。每个人都是一个人来到这个世界，当身边还有家人朋友陪伴的时候，就应该好好珍惜，和他们分享我们的经历以及对这个世界的看法，因为终有一天，我们会孤独地离开这个世界。并不会有遗憾，或者悔恨，或者任何其它情绪，因为我们是带着记忆离开的，而且我相信在最终时刻，我们回忆中的绝大部分内容都是充满着爱与慈悲的。</p><h4 id="3-月-6-日-认识到亲密关系的价值"><a href="#3-月-6-日-认识到亲密关系的价值" class="headerlink" title="3 月 6 日 - 认识到亲密关系的价值"></a>3 月 6 日 - 认识到亲密关系的价值</h4><p>晚上洗澡的时候在想，我为什么会变成现在的自己？我这个年纪应该是最为热血、充满激情的年纪，为什么没有去谈恋爱、追逐异性？是我自己太冷淡了吗？明明对异性是感兴趣的，但为什么没有任何行动呢？是我的标准太高了？或者是觉得自己不够好？我觉得最主要还是因为我不愿意去尝试，不敢去冒险。而导致我不敢冒险的原因是：我觉得一段亲密关系不值得我付出太多，或者即使付出努力也得不到我预期中的奖励，所以干脆选择了放弃。这个结论是我在安静环境下理性分析后的结果，但大多数时候这一切其实都是我在潜意识下做出的决定。正因如此，过去的我才会感到困惑，明明自己想要去认识女生、去谈恋爱，但是为什么行动上却无法坚持下去。如果我无法改变自己的心态或者想法，那么我永远也得不到想要的结果。你要相信亲密关系的价值，而且也要相信这是一个漫长且需要反复尝试的过程。如果你现在不开始改变自己，未来的你会需要花更多的时间去学习和改变。让改变发生得越早越好。</p><h4 id="3-月-7-日-转换视角看待问题"><a href="#3-月-7-日-转换视角看待问题" class="headerlink" title="3 月 7 日 - 转换视角看待问题"></a>3 月 7 日 - 转换视角看待问题</h4><p>发现自己很多时候会陷入细节无法自拔，但其实转换下思维，看到更大的画面之后，你就会发现其实那些细节处的决定或者选择，根本就没有那么重要。既然如此，那此刻为什么还要感到纠结或者痛苦呢？这应该就是能够随时转换视角的好处了。想想生活中其它的场景也是一样。当下觉得这是一个很难解决的问题，或者觉得自己被困住了，但其实如果你转换一下视角，你会发现其实这事本来就应该是这样。你面对的是一个很大的机会，而不仅仅是挑战，大家常说的危中有机就是这样的道理。所以，关键还是要培养自己面对各种情况时的思维转换能力，多去经历一些，只有这样才能让自己的心态慢慢变得更加平和。发生任何事都是有可能的，但是，我选择接受它们的发生，去面对它们，而不是逃避它们。接下来，是认识其本质。这个问题是如何产生的，可能的解决方案有哪些，每个步骤下有可能会遇到哪些新问题，等等。如果是眼下自己无法解决的问题，我们可以去寻找合适的人的帮助，如果问题不太紧急，还可以先暂时搁置不管，交给未来的自己去解决。总之，要相信自己，也要相信时间的力量。</p><h4 id="3-月-8-日-更有效的思维方式"><a href="#3-月-8-日-更有效的思维方式" class="headerlink" title="3 月 8 日 - 更有效的思维方式"></a>3 月 8 日 - 更有效的思维方式</h4><p>很多时候，我们都是被自己的信念所限制，而不是外界环境。我不够高、我不够帅、我不够富有、我配不上，等等。因为我们自己保持着这样的信念，所以投射到我们身上的世界也就变成了我们「期望」看到的那样。如何改变自己的信念？意识到这些只不过是一个人的想法而已。既然只是大脑中的想法，那么我们就可以改变其形式，采用一种有利于我们的方式，让它们更有利于我们的工作和生活。思维是思考的方式，而思考是将我们过去的记忆、经验、知识，结合当下的情景，做出合适的判断的过程。任何一种思维都可以不断被优化，我们要做的是获得足够多的信息，采用合适的模型，做出更高效的决策。而这一过程，需要我们不断地阅读、去积累经验、去从他人身上学习，以及在生活中不断思考和反思才能做到。</p><h4 id="3-月-9-日-探索心灵就像是在探索宇宙"><a href="#3-月-9-日-探索心灵就像是在探索宇宙" class="headerlink" title="3 月 9 日 - 探索心灵就像是在探索宇宙"></a>3 月 9 日 - 探索心灵就像是在探索宇宙</h4><p>我们所做的一切都是为了认识自己，无论是生活还是工作，通过每一项任务、每一个当下的瞬间来认识自己，与他人交往是为了认识自己，一个人阅读写作也是为了认识自己。我此刻的情绪和想法是什么？我想要逃避什么？是什么让我感到恐惧？只有真正认识自己之后，我们才能明白自己和他人之间的关系，以及我们与这个世界的关系。我们所在的宇宙其实是我们心灵的一个投影。从科学的角度看，我们认识到的宇宙，无论是恒星、星系、暗物质还是各种能量场，都在以符合物理定律的方式精确运行着，但是，我们也要意识到，我们的心灵其实也是一样，复杂精巧而又无远弗届，可以看做是整个宇宙的缩影，甚至装得下整个宇宙。因此，对于每个人来说，探索我们心灵的运行方式以及去理解它，就像是去宇宙深处了解宇宙运行的奥秘一样，无比艰难但又非常吸引人，但这绝对是每个人都应该做而且是最值得做的一件事。当所有人都能全然洞悉自己的内心世界，了解自己心灵中的每一个星光及其闪耀的原因，我们就能和身边人相处地更加亲密无间，对自己、对他人、对这个世界也会真正充满爱与慈悲。</p><h4 id="3-月-10-日-写作的作用以及写出让人愿意读的文字"><a href="#3-月-10-日-写作的作用以及写出让人愿意读的文字" class="headerlink" title="3 月 10 日 - 写作的作用以及写出让人愿意读的文字"></a>3 月 10 日 - 写作的作用以及写出让人愿意读的文字</h4><p>写作是非常有效的整理自己思维的工具，每当内心有疑惑或者看不清方向的时候，最好的做法是，坐下来把自己内心的想法全都写下来，在写的过程中，你会对当下面对的问题有更多的认识。能把问题准确描述出来通常都意味着问题已经解决了一半。和他人的沟通也是一样，如果你觉得你和另一个人的关系陷入了僵局，无法通过语言沟通来解决，那么你可以尝试坐下来给他写信。当内心的想法变成文字之后，你会发现同样的表达用文字会显得更加温和。也许这只是我自己身上的差异，但是写作的确可以让我们表达出我们原本不愿意直接说出口的话。有时候看自己的文字，读起来越是流畅的文字就越像是写给一个人的信件。所以，如果你想让自己的文字易读且读起来有亲切感，最好的做法是想象自己对面坐着一个人，你的所有文字都是写给他一个人看的。写作的目的就是沟通，如果你的文字无法让人愿意读下去，你所做的所有努力都将逊色一半。</p><h4 id="3-月-11-日-探寻意义，感受平静"><a href="#3-月-11-日-探寻意义，感受平静" class="headerlink" title="3 月 11 日 - 探寻意义，感受平静"></a>3 月 11 日 - 探寻意义，感受平静</h4><p>我们需要经常提醒自己的一点是：我当下所做的事对我来说有什么样的意义？如果你能清楚地回答出这个问题，那么你就能积极主动地去做这件事，而且也能完全投入其中。相反，如果你无法准确描述出一件事对自己的意义，那么你就应该思考自己为什么要继续做这件事了。得出这样的感悟是因为，我发现很多时候我们都是无意识地去做事，哪怕是娱乐也是一样，我要看那部电影/追那部剧/看那本书，最初的动力并不是因为它们吸引了我，而只是为了打发时间。虽然打发时间也是一种选择，但是最终的结果是——你会感到更加空虚。我觉得我最终的目标是，不但做任何一件事都能发现其对自身的意义，而且在即使不做任何事的情况下，也能感到平静和满足。冥想当然是一种达到这种状态的办法，更重要的是要意识到我们自己并没有那么重要，没有任何东西需要被改变，它们只是我们的欲望的投射。假如欲望消失，那么所有消极、痛苦、不满足、愤怒、自怜、悲伤、狂妄、自我都会随之一起消失，只有这个时候，我们才能看清自己的本质。我只是暂时借用这具躯壳而存在，有一天我会老去、死去，外界环境也会继续不停变化下去。所以，放弃想要获得掌控的执念，回到自己的内心，才能真正感受到平静。</p><h4 id="3-月-12-日-寻找意义以及如何面对生活"><a href="#3-月-12-日-寻找意义以及如何面对生活" class="headerlink" title="3 月 12 日 -寻找意义以及如何面对生活"></a>3 月 12 日 -寻找意义以及如何面对生活</h4><p>有时候在想，尽管这世上有那么多我想看的电影、音乐、书籍，有那么多我想去的地方，有那么多我想体验的事，但为什么还是会在一个周六早晨体验到不想起床、什么都不想干的情绪呢？也许是因为太孤独了吧。但是我觉得也不全是因为孤独。其实我本身就是一个情绪挺消极的人。虽然一个人也能活得非常自在，但是我总是忍不住去思考周遭事物的意义。从根本上来说，一切都没有意义，无尽的时间和空间，人作为如此渺小且短命的存在，能有什么样的意义呢。但是人活在天地间，必须寻找到自身的意义，否则，我们就都成了虚无主义者了。尽可能多地体验这个世界，创造价值，和家人和朋友分享自己的生活，和更多的人建立连接，找到平静，体验到幸福感，体面地老去、面对死亡，这差不多就是所有我们能做的了。欲望多寡并不重要，只要你能权衡好自己的得失就没关系。你想要什么，你愿意付出什么，你能接受最差的结果是什么，你能在多大程度上拥抱不确定。想清楚这些，然后再去做决定，去勇敢地面对生活。也许得不到想要的，也许会被当下的情绪淹没，都没关系。事情还能更糟糕吗？你难道没有预见到这样的结果吗？痛苦和消极情绪能帮你摆脱当下的情景吗？如果不可以，那就接受它们吧。</p><h4 id="3-月-13-日-轮滑学习心得"><a href="#3-月-13-日-轮滑学习心得" class="headerlink" title="3 月 13 日 - 轮滑学习心得"></a>3 月 13 日 - 轮滑学习心得</h4><p>昨天下午开始出门练习轮滑，在江边找了个有树荫的小公园，差不多学会了基础的滑行和转弯，并没有像想象中的摔很多跤，不过始终带好头盔和护具还是必要的。记录一下自己的学习轮滑的心得吧，首先是心态要保持放松，如果不够放松，你的身体肌肉就会很紧张，然后就会容易摔跤。人的身体其实非常灵活，我们都会凭本能避免让自己受伤，但是，当自我意识过于强烈的时候，身体就会受到思维的干扰，于是做出一些不自然的动作，从而导致自己失去平衡而摔跤。其次，掌握基础动作。轮滑的精髓在于利用身体重力获得向前进的动力，所以你必须学会利用惯性，而这需要你学会几个动作就可以了。比如想要前进，就必须学会<strong>踩外「八」</strong>。首先迈开左脚，把身体重心移上去，然后再迈出右脚，再把重心移到右脚上，循环往复下去你就可以不断获得向前进的势能。转弯的时候，外侧脚转大圈，内侧脚转小圈，所以关键在于学会<strong>滑出 C 形</strong>。至于刹车，我现在主要依赖刹车轮减速，不过我发现降低身体重心并且扩大外八的站姿有利于减速，而这依赖于练好<strong>画「8」字</strong>的动作。接下来我的目标是学会 S 形转弯和后脚刹车（T 刹）。</p><h4 id="3-月-14-日-轮滑学习心得2"><a href="#3-月-14-日-轮滑学习心得2" class="headerlink" title="3 月 14 日 - 轮滑学习心得2"></a>3 月 14 日 - 轮滑学习心得2</h4><p>继续记录轮滑学习心得。我发现学好滑行特别重要，就像学习滑板一样，你必须做到能在板上非常自如地滑行，才能进一步学习其它的动作。而轮滑和滑板不同的地方在于，学会滑行很容易，但是想要滑得好很难。如果你想快速滑行，那就必须掌握<strong>单脚滑行</strong>的技巧，因为这样才不会因为速度过快而失去平衡；其次，一定要养成<strong>重心向前</strong>的习惯，否则很容易摔跤，而且有可能会摔得很惨。我自己总结出了几个我认为比较重要的练习技巧：</p><ul><li>绕圈转，可以选择花坛或者原地绕圈，这个动作可以帮你快速学会如何只将重心放在一只脚上。</li><li>滑行中抬腿练习，练这个动作之前得先保证自己能单脚滑行一小段距离，该动作主要用于学会如何使用双脚协调好身体的重心。</li><li>小幅度平移，这个动作是学习交叉步的基础，而且也可以帮你学会避开路上的障碍物。</li></ul><p>除此之外，练好葫芦步、双鱼也是新手学习轮滑的关键。</p><h4 id="3-月-15-日-价值和目标"><a href="#3-月-15-日-价值和目标" class="headerlink" title="3 月 15 日 - 价值和目标"></a>3 月 15 日 - 价值和目标</h4><p>最近越来越觉得一个人的生命意义来自于他人，来自于他和这个世界创造出何种连接。赚钱多少并不重要，但是想清楚赚钱的目的很重要。如果只是为了敛财，或者满足自己的消费欲望，那么你一定会经常感到不满足，因为绝大部分的人都能力有限，而诱惑和欲望又那么多，所以，这不是一种好的思维方式。但如果你能想清楚钱只是实现自己目标的工具，如果你追求的是实现自己的个人价值，你会活得更加快乐。也许没什么钱，但这又有什么关系呢？幸福才是终极货币。现实中，绝大部分人都会选择钱多的那个选项，我觉得最根本的原因是，他们（包括我自己）不知道自己的人生方向和目标，选择钱多的只是我们自以为的最佳选项。所以，我们要思考的是，什么才能真正让自己感到长久的快乐和满足，我应该选择什么样的标准来指导自己的工作和生活。</p><h4 id="3-月-16-日-工作与知足常乐"><a href="#3-月-16-日-工作与知足常乐" class="headerlink" title="3 月 16 日 - 工作与知足常乐"></a>3 月 16 日 - 工作与知足常乐</h4><p>有时候觉得，不知道自己想要什么其实也没什么关系。虽然这种想法有些消极，但是自己毕竟非常普通，做不到像那些厉害的人一样，有目标，有自己坚持的东西，并且追求不断做得更好。而我呢？现在觉得知足常乐也挺好。虽然不至于躺平，但是稍微努力一下，让自己过上平均线左右的生活，还是可以期待一下的，再往上我就觉得没有必要了。每个人都能改变世界，而最好的方式就是去努力工作，你的工作成果就是你为市场经济所做出的贡献，而市场经济有效的基础就是每个人都尽力提高自己的效率，为他人创造价值，从而降低各种产品的稀缺性。既然市场需要我去做这件事，并且让我得以维持还不错的生活，那么这就说明我的确能在这方面提供价值。也许我可以选择自立门户，去直接面对客户创造出他们想要的产品或者提供服务，但是，最好的做法还是与其他人合作，走他人已经探索好的道路，更安全也更平稳。每个人都要在获得个人利益以及安抚好自己的内心之间做好平衡。</p><h4 id="3-月-17-日-为自己负责"><a href="#3-月-17-日-为自己负责" class="headerlink" title="3 月 17 日 - 为自己负责"></a>3 月 17 日 - 为自己负责</h4><p>不知道想要但是不去争取和争取了但却得不到这两者哪个更难受，但是，第一种已经成了我长期以来的默认选项。有时候在想，我什么时候可以勇敢一点，成为总是做出第二个选项的人。虽然我觉得自己依旧很年轻，但是身边的人却不这么觉得，当你到了一定年纪，有些「应该」做的事你却没有做，在某些人眼里，它就成了你的弱点，他们会反复告诉你要重视起来，要去完成这件事。无论是出于好意或者恶意（我相信是出于好意），你知道自己无法被他人的言论改变，你知道自己身上最根本的问题是什么，你也知道自己的人生掌握在自己手上。你可以选择不去改变，然后这样继续生活下去，但是，当你真正开始想要改变自己的时候，你会发现自己内心深处有一丝恐慌。你发现他们过去说的话似乎有一点点道理——假如我早一点听了他们的话，或许现在就会有点不同的结果？于是你开始自我怀疑，而这就是一切焦虑情绪的来源。</p><p>所以，结论是什么？应该早一点听别人的建议去行动？不是，因为这样最终依旧有可能遇到不如意的时候，然后我又会开始反思如果当初没有听他们的建议该多好。真正的结论其实之前早就说过了，那就是承认每个人的生命都有自己的四季，只有我们自己才能知道自己当下处于哪个阶段。我们要按照自己的节奏去生活、去改变自己。每个人都只能为自己负责，更不能把权力随便交给别人，因为那样就等于把幸福的权力也交给了别人。</p><h4 id="3-月-18-日-塑造好精神"><a href="#3-月-18-日-塑造好精神" class="headerlink" title="3 月 18 日 - 塑造好精神"></a>3 月 18 日 - 塑造好精神</h4><p>最近的状态真的很差，感觉生活有点失控，想要尽力让生活回到正轨，所以昨晚又恢复夜跑了。跑步应该是我在过去一年里养成的最好的习惯了吧，它已经成了我释放负面情绪、获得能量的方法。但是，睡眠、跑步只是让身体恢复过来，心理能量的恢复却要难得多，需要花更多的时间在阅读和冥想上，然后去直面自己的问题，并且着手去解决它们。然而现实是，有时候还是会想要逃避，幻想问题会自己消失，只有事后才会意识到这种想法有多可笑。人的本性就是这样吧。我们用什么样的信念喂养自己，决定了自己会拥有什么样的心灵力量。务实、勇敢、坦率、真诚，这些是我想要看到的结果，那么我就该时刻以这些标准来要求自己，你必须先在思维上同步，然后才能在行动中表现出来。先塑造好自己的精神，这是最重要的。</p><h4 id="3-月-19-日-识别生活中的谎言"><a href="#3-月-19-日-识别生活中的谎言" class="headerlink" title="3 月 19 日 - 识别生活中的谎言"></a>3 月 19 日 - 识别生活中的谎言</h4><p>看完<a href="https://www.netflix.com/title/80220426">黑蟹行动</a>之后，心中浮现的第一个问题是：促使主人公完成任务的基础是一个谎言，那么，我的生活中有没有这样的谎言呢？我们每个人多少都听过别人告诉我们的「只要你如何如何，最终就能如何如何」的话，这些话中很大一部分其实都是错误的或是虚假的，而且就连我们自己也常常用这样的谎言安抚自己的情绪。那么，有没有什么办法可以让自己做到彻底放弃相信谎言呢？这需要你对自身状态保持非常高的敏感度吧。他必须非常清楚地了解自己的优点和缺点，也有具体的目标，能够活在当下的每一刻中，平衡好自己的工作和生活，照顾好自己的身体、心灵和情绪，具有坚定的意志力。所以，我离成为这样的人还有多远？</p><h4 id="3-月-20-日-停止给自己寻找借口、正确的休息、生命宝贵"><a href="#3-月-20-日-停止给自己寻找借口、正确的休息、生命宝贵" class="headerlink" title="3 月 20 日 - 停止给自己寻找借口、正确的休息、生命宝贵"></a>3 月 20 日 - 停止给自己寻找借口、正确的休息、生命宝贵</h4><p>人总是喜欢给自己寻找借口，给自己找台阶下，为的是让自己能心安理得地过上一种懒惰、不作为、不去冒险的生活。为了合理化这些借口，我们什么事都做得出来，包括自我攻击和自我贬低。有时候意识到真实的自己居然是这个样子的，真的让人很难过。越是意志消沉的时候就越想躺平。没有目标，没有欲望，没有动力。这是我最讨厌的状态。如何摆脱这样的状态？明明这个世界如此丰富，有那么多值得花时间去研究的东西，有那么多机会去创造，有那么新事物值得去体验，但是我们却选择把自己禁锢在当下的一点点物理和思维空间内，这是对智力的浪费。当然，有时候我们可能只是需要真正的休息，大脑、身体和情绪都需要时间才能慢慢恢复过来，所以放下手机和电脑，离开网络世界，去运动、去聊天、去独处、去大笑、去睡个昏天黑地，给自己一点恢复的时间，只有这样我们才能重新充满活力地面对新的一天。</p><p>昨晚看了一个帖子，<a href="https://www.v2ex.com/t/839342#reply44">无论看多少纪录片，都不如去一次急诊室来得真实</a>，又一次提醒了自己，生命宝贵，切勿浪费。过好自己的每一天，照顾好自己和家人的健康，这是最重要的。</p><h4 id="3-月-21-日-面对消极情绪"><a href="#3-月-21-日-面对消极情绪" class="headerlink" title="3 月 21 日 - 面对消极情绪"></a>3 月 21 日 - 面对消极情绪</h4><p>如何处理消极情绪？想象自己正在向一名心理医生倾诉，吐露自己内心最深处的想法，而且要做到毫无保留。然后转换角色，把自己当做那名心理医生，我会如何倾听？我会说些什么？我会给自己什么样的建议？基本上如果你能做到把自己大脑中的想法说出来，并且不带任何批判地去倾听自己内心的想法，那些消极情绪差不多就能被处理掉一大半。另外一个有效的办法是出去散步，选择你最喜欢的自然环境，比如有树林和湖泊的地方，即使做不到这一点，哪怕去楼下绕着大楼走一圈，也会有帮助。我觉得我们都要学会适应负面情绪，现代人有太多让自己分心、逃避负面情绪的手段，但其实认认真真去感受负面情绪也是日常生活中重要的一部分。只有更加积极地感受它们，我们才能学会如何处理好它们，继而变得更加强大。这其实也是在扩展自己的舒适圈。</p><h4 id="3-月-22-日-爱是什么"><a href="#3-月-22-日-爱是什么" class="headerlink" title="3 月 22 日 - 爱是什么"></a>3 月 22 日 - 爱是什么</h4><p>突然意识到一个问题，那就是我好像不知道怎么去爱人。目前为止，我所做的一切都只是为了我自己，我从来没有发自内心地想要为另一个人做一件事，更不要说因为对对方有爱意而去为对方做一些事。虽然上学的时候有过和同学的暧昧关系，但是那些都是他人眼中的我，而且我也只是因为处于那样的环境，觉得暧昧是一件好玩的事，所以才允许它的发生。但是，我的内心其实从来都没有真正喜欢过一个人，甚至爱上一个人。所以，我不知道爱是什么。也许，没人知道。想为对方做一些事情让对方开心，这就是爱了吗？默默关注对方而不做任何事，这就不算是爱了吗？我并不觉得。爱到底是什么，其实很难说清楚。每个人都只能自己去理解、体会爱，而无法准确表达爱到底是什么。这需要我们在自己的日常生活中足够敏感，能够捕捉到那些非常细腻的感受。爱就藏在那些细节之中。</p><h4 id="3-月-23-日-假如出生在十万年前"><a href="#3-月-23-日-假如出生在十万年前" class="headerlink" title="3 月 23 日 - 假如出生在十万年前"></a>3 月 23 日 - 假如出生在十万年前</h4><p>昨晚获得了学会感恩的另一个视角：假设自己出生在十万年前，我现在的境况将会是什么样的？十万年前，智人刚刚学会用语言沟通，身体构造上和现代人也已经没有什么区别，我猜测他们的社会结构和现在大部分的农村差不多，可能也是以家庭为单位，只不过大家都生活在部落中，不过，我每天的生活基本上是围绕着获取食物以及处理冲突这两个主题进行的。时间往后拖动，假如我出生在一万年前，我的生活又会是什么样的？这个时候许多部落已经习惯了定居的生活，开始有了农业，定居点足够大，我不再需要去打猎，但是部落间关于领地的冲突变得越来越频繁，我可能经常会担心过段时间我所在的部落是不是又会被隔壁的部落骚扰，或者我的家人在单独外出的时候不小心遭到敌对部落的攻击，所以，绝大多数时候我都过着提心吊胆的生活。时间再往后延伸，如果是一千年前，我每天的生活又会是什么样？假如我还是生活在这片土地上，而且刚好遇到了一个政治比较稳定且没有战争的年代，那么，我可能过着普通农民的生活，每天日出而作、日落而息，同时心里祈祷着这一年风调雨顺，这样我才能喂饱自己和家人。这样一对比，我现在简直就是过着人间天堂般的生活：基本不需要担心暴力事件的发生，有充足的食物和安全的住所，有足够的个人时间去做自己想做的事，能买到数不尽的商品和服务。所以，我还有什么理由去抱怨生活呢？</p><h4 id="3-月-24-日-应该谈恋爱的原因"><a href="#3-月-24-日-应该谈恋爱的原因" class="headerlink" title="3 月 24 日 - 应该谈恋爱的原因"></a>3 月 24 日 - 应该谈恋爱的原因</h4><p>过去我常常用来搪塞他人不谈恋爱的理由之一是，我害怕两个人在一起的生活比不上我单身时候的生活。仔细思考下，其实这算不上是一个足够充分的理由，因为我可以在一段关系开始之前就告诉对方，我不会为对方的幸福「负全责」。两个人在一起最重要的前提是彼此独立，我们没必要找一个需要自己照顾的人。即使是自己心甘情愿想要照顾对方，也要考虑对方是否愿意接受，而不是强行「对 Ta 好」。只要有人愿意接受这样的前提，那么我们就可以开始一段关系，慢慢熟悉彼此。如果在这一过程中，有一人觉得这段关系没有继续下去的必要了，那么，我们应该能够通过理性沟通，表达出自己真实的想法，然后和平结束这段关系。说白了，其实就是设置好有效的退出机制，任何一方都能无任何担忧地轻松退出，回到自己的单身生活，这样，对两个人来说都不会造成任何方面的负担。所以，其实每个人都有能力恋爱，也应该恋爱。因为恋爱成功的结果是让两个人都受益，而失败的结果是回到原有的状态。既然如此，为什么不恋爱呢？</p><h4 id="3-月-25-日-快乐的秘密：选择开心和愉悦"><a href="#3-月-25-日-快乐的秘密：选择开心和愉悦" class="headerlink" title="3 月 25 日 - 快乐的秘密：选择开心和愉悦"></a>3 月 25 日 - 快乐的秘密：选择开心和愉悦</h4><p>晚上洗完澡在镜子前吹头发的时候产生一个反思：我已经具备了获得幸福的条件，但却没有表现出怡然自得，这是为什么？仔细想了想，其实这完全是我自己的心态问题，我应该默认选择开心和愉悦才对。突然有种茅塞顿开的感觉。林肯说大多数人都可以决定自己要有多快乐，现在才体会到他的正确性。快乐的秘密只有一个，那就是你选择去当一个快乐的人。没有人可以夺走你的好心情，没有什么事是真正值得自己生气的。感受当下正在发生的事，不要去担忧未来，也不要把太多的时间放在回忆过去，更不要去后悔。认真、负责地做好当下的事。如果今天没法过得很开心，那么明天也一定要让自己变得快乐起来。生命宝贵，不要浪费一分一毫。</p><h4 id="3-月-26-日-接纳现状，改变自己"><a href="#3-月-26-日-接纳现状，改变自己" class="headerlink" title="3 月 26 日 - 接纳现状，改变自己"></a>3 月 26 日 - 接纳现状，改变自己</h4><p>周末抽空回顾了一下自己最近的生活状态，虽然并没有发生任何实质性的变化，除了工作、运动、花时间和自己相处之外，没有其它特殊的事情发生，但是我觉得我已经开始慢慢能够接受自己了。也许依旧没有什么大的目标，但是我变得更有耐心了。生活不就是一个人选择如何度过自己的每一天吗？既然我们能做的都非常有限，那为什么不把注意力放在自己能够改变的东西上呢？充足的睡眠，健康饮食，保持运动和阅读的习惯，冥想，断食，照顾好自己和家人，把自己的工作做好，用积极的态度去生活，我觉得能做到这样就很好了，不需要再去追求更多或者有更多的欲望。能做到这些的人就已经非常了不起了，如果还有更多的余力，再去思考如何进一步改善自己和家人的生活，甚至是去帮助陌生人。接纳自己很普通，所以选择去把这些看似「简单」的事情做好，想办法让自己生活得更加幸福，因为你所能做的，只有改变自己。</p><h4 id="3-月-27-日-实力是保持独立的基础"><a href="#3-月-27-日-实力是保持独立的基础" class="headerlink" title="3 月 27 日 - 实力是保持独立的基础"></a>3 月 27 日 - 实力是保持独立的基础</h4><p>最近花了太多时间看政治新闻，当然，也不能全怪我，一打开社交网站、视频网站就全是这些东西。最关键的是，看了这些资讯之后，对我的生活造成的正面影响很小很小。知道某个国家的历史以及它和它的领国在历史上的恩怨情仇，对我的日常生活来说并没有太大的意义。也许可以丰富我的世界观，但是好像除此之外，并没有其它的价值。不过，我好像一直以来就对历史、政治类的话题比较感兴趣，可能是过去受到了老爸的影响吧。但是有时候又觉得关心这些东西有点浪费时间和精力，因为它们都是虚无缥缈的。国家、民族的概念真的有那么重要吗？我们为什么要因为不同的观点而打压、甚至是伤害另一群人呢？可能是因为我们生活的世界依旧是一个强权决定一切的世界吧。你有实力别人才会尊重你，才会想要和你合作，否则你就会被他人利用，甚至是被欺侮。其实对于每个个体也是一样，你必须想办法让自己有足够的利用价值，或者变得足够强大，才能保持个人的独立，不去依附他人也能生存，才能有说「不」的权力，才能去维护心中的善良。</p><h4 id="3-月-28-日-抚慰他人，反思自己"><a href="#3-月-28-日-抚慰他人，反思自己" class="headerlink" title="3 月 28 日 - 抚慰他人，反思自己"></a>3 月 28 日 - 抚慰他人，反思自己</h4><p>这两天又开始在 Tell 心语上回信了。每次看来信者问题的时候，我都会在心中默默对比我自己，假如我遇到了那样的问题，我会怎么办，也许只有束手无策吧？所以，有时候会觉得自己好幸运，因为至少我从来没有陷入到那种境况中。突然意识到，这大概就是八卦的意义了吧。我们通过窥视别人的生活，对比自己，获得一些思考，于是，重新开始珍惜生命，感激能够拥有这样平凡但无重大意外的生活。茫茫苍生，人生百态，能一辈子过得平凡普通就已经是很大的福气了。我开始理解为什么有的人会随着年纪的增长，变得越来越无动于衷，可能是因为他们见过了太多这种「世事无常」的时刻。也许未来有一天我也会变成像他们那样的中年人吧。无论如何，一定要让自己变得更加强大一点，无论是在心理上还是在财务方面，也要做好风险控制。这样，即使意外发生到自己的头上，也不至于太过绝望。</p><h4 id="3-月-29-日-不断尝试、探索世界、认识自己"><a href="#3-月-29-日-不断尝试、探索世界、认识自己" class="headerlink" title="3 月 29 日 - 不断尝试、探索世界、认识自己"></a>3 月 29 日 - 不断尝试、探索世界、认识自己</h4><p>最近又忍不住开始思考我到底适合从事什么样的工作，虽然我觉得现在的工作还过得去，但是心里还是有尝试其他可能性的想法。我一直觉得自己是个 generalist，虽然并没有特别擅长什么，但是一旦看到自己喜欢的东西，总是忍不住想要去尝试一下。有时候也觉得这样不好，因为会分散自己的精力。如果能够集中自己的注意力在某一块领域，也许对我未来的发展会更好。但是，从生命的质量和丰富度来看，一定是尝试得越多越好。很多厉害的人除了深耕某一块领域之外，业余时间也是有非常广泛的兴趣爱好的。不过，多尝试没问题，最终一定要保证自己至少有一个专精的领域，这样才能保持竞争力。等你有一块足够专精的领域之后，你才能明白到达专业之路需要付出什么样的努力和艰辛，并且才能由此拓展开来，去体会其他领域中同样能给人带来巨大乐趣的那些细节。其实人的成长就是一个磨练心智的过程，我们在不断探索、尝试、扩展自己能力圈的过程中，突然有一天，发出了「原来事情还可以是这样」的感受，甚至因此发现了一个自己从来没有注意到的世界。无论是成为某个领域内的专家，又或者是成为生活中某一方面的专家，只要你去用心感受和体会，你会发现其实我们都是在探索这个世界，不停地借由外部环境来拼起的心理地图中缺失的某一片，慢慢让自己变得更加完整。</p><h4 id="3-月-30-日-对未知和意外的态度"><a href="#3-月-30-日-对未知和意外的态度" class="headerlink" title="3 月 30 日 - 对未知和意外的态度"></a>3 月 30 日 - 对未知和意外的态度</h4><p>我一直害怕自己的现状被改变，思来想去，最根本的原因还是因为我对自己的能力没有足够的信心，我害怕意外的发生，害怕自己处理不好它们。但是，生活本身就是会充满各种各样的意外，如果始终按部就班，那可能不算是真的在生活。所以，我想要表达什么？不要害怕未知的变化，甚至要主动去制造它们。一开始感到恐惧是难免的，但是只要有过几次成功处理好一系列临时发生的变化的经验之后，你就会对自己拥有越来越多的自信心。随着经验和信心的增加，你会相信自己能处理好任何的意外。虽然这是一个漫长的过程，但是你总要尽快开始第一步。其实这也是在增强自己抵御风险的能力，因为抵御风险不仅仅意味着规避风险的发生，也包括提高自己处理意外的能力，从而让风险对我们的影响降到最低。</p><h4 id="3-月-31-日-个人信念"><a href="#3-月-31-日-个人信念" class="headerlink" title="3 月 31 日 - 个人信念"></a>3 月 31 日 - 个人信念</h4><p>最近在看讲亲密关系的书，意识到两个人相处，沟通真的太重要了。不过，沟通是两个人的事，想让沟通有效的前提是两个人都得遵循一套相同的规则，而这又要求两个人有相同的价值观，价值观的背后则是共同的信念。所以，当选择和一个人在一起的时候，最重要的是看他和你有没有相同的个人信念，其次是价值观，最后才是处事规则。那么，我最重要的个人信念是什么？我相信每个人都应该是一个独立的个体，我们应该有能力照顾好自己，不需要依赖他人，自己做决定，自己承担后果，在这个基础之上，再去探索世界、了解自己。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>家人的影响</title>
      <link href="/2022-2/"/>
      <url>/2022-2/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/qGWTUMNuXOo" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>二月很短，但是感觉上却很长，可能是因为有个春节假期吧，硬生生把我从自我封闭的牢笼中给拽出来，摔到了现实世界的地板上。家人对我们的影响是巨大的，我们看待这个世界的方式，我们与其他人相处的方式，都在无形中受到了家人的影响。我觉得一个人成长的过程，其实可以看做是他试图摆脱家人影响的过程，尤其是在他还年轻的时候。不是说家人的影响不好，而是因为我们最终都要过上一种自己做主的人生的，既然如此，越早摆脱他们的影响对自己就越有利。话虽如此，我还是感到非常庆幸能够拥有我的家人的，没有他们的爱和支持，我不会成为现在的自己。</p></blockquote><span id="more"></span><h4 id="2-月-1-日-第-28-个春节"><a href="#2-月-1-日-第-28-个春节" class="headerlink" title="2 月 1 日 - 第 28 个春节"></a>2 月 1 日 - 第 28 个春节</h4><p>新春快乐，虎年大吉！</p><p>这是我度过的第 28 个春节，按照农村里的算法，出生就算一岁，那么，我现在已经 29 岁了，再过个年就 30 了。每次听爸妈说起这个，我就觉得他们话里有话，似乎在暗示我什么，不过我通常都选择当没听到，哈哈。对我来说，年龄并不重要，最重要的是保持年轻的心态：对一切保持好奇，敢于尝试新鲜事物，随时准备更新旧认知。这样的话，即使到了 100 岁，依旧能和年轻人有共同话题。我们每个人都只活一次，为什么要被外界的声音扰乱自己的内心呢？保持自己的节奏，做自己想做的事，不随波逐流，始终把个人的幸福放在第一位，只有这样，才能做出不让自己后悔的选择。我过去已经浪费了太多的时间，所以，不想再把时间浪费在让自己看起来合群或者符合世俗常规的事情上了。每个人都应该为自己的人生负责，想清楚自己想要什么，然后认真努力地去追求并实现它就好了。他人的意见，哪怕是父母的意见，顶多也只能作为参考，最终做决定的人还是你自己。每个人越早养成『为自己思考并且自己做决定、自己承担后果的习惯』越好，因为这样你就不会再有理由去逃避属于你自己的责任。而越早承担起自己的责任，你就能越早获得人生的自主权。</p><h4 id="2-月-2-日-换位思考"><a href="#2-月-2-日-换位思考" class="headerlink" title="2 月 2 日 - 换位思考"></a>2 月 2 日 - 换位思考</h4><p>学会换位思考：如果我是他，我会如何看待「自己」？</p><h4 id="2-月-3-日-过年就是过钱"><a href="#2-月-3-日-过年就是过钱" class="headerlink" title="2 月 3 日 - 过年就是过钱"></a>2 月 3 日 - 过年就是过钱</h4><p>从别的地方看到的一句话：过年就是过钱。如此真实。</p><h4 id="2-月-4-日-人的韧性"><a href="#2-月-4-日-人的韧性" class="headerlink" title="2 月 4 日 - 人的韧性"></a>2 月 4 日 - 人的韧性</h4><p>只有在逆境下才能体现一个人的修养，一个人的韧性决定了他能成长到什么样的高度。那么，我们要如何提高自己的韧性？如何培养自己的韧性？</p><h4 id="2-月-5-日-照顾好自己和家人"><a href="#2-月-5-日-照顾好自己和家人" class="headerlink" title="2 月 5 日 - 照顾好自己和家人"></a>2 月 5 日 - 照顾好自己和家人</h4><p>假期接近尾声，再一次感受到在家时间过得是多么的快，尤其是没有任何计划的情况下。原本想看完生命之书，但是目前只看了不到 20 页。唯一坚持下来的是每天早上的一组腹肌撕裂者。不过，一年能有这么一段时间陪在爸妈身边，我已经很满足了，而且我也意识到，他们其实并不在乎我能花多少时间陪伴他们，因为他们其实已经习惯了两个人的生活。我在家的这段时间里，其实我们也并没有多少话题可聊，尤其是和老爸，很多时候我们只是坐在一起看电视、玩游戏、刷手机而已。相反，他们真正关心的是那些世俗的事情，比如钱，比如讨老婆，因为在他们眼里，长期来看，只有这些才是对他们未来生活影响重大的事。如果要算优先级，目前陪伴的位置可能排在第 5 或者第 6 吧。这也提醒了自己，不要老是以自己的视角去分析他人的需求，你要站在他人的角度才能知道一个人真正需要什么。</p><p>另外，在家的生活也让我感受到，我和父母生活质量的差异原来这么大。他们的每一分钱真的是靠省出来的。我以为我的生活已经算是比较节约的了，但是和他们一比，真的是毛都算不上。现在的我才能大概体会到，当他们听说我花好几万去做牙齿矫正的时候，内心是什么样的感受。并不是想渲染出一种悲伤的氛围，但是现实就是这样。我知道我的情况其实已经算是不错的了，所以，也常常提醒自己应该感到感恩。由于过去一直不肯承认现实，所以走了不少岔路，我想接下来我应该会更加脚踏实地一点吧。先把自己和家人照顾好，把自己的生活过得像样一点，然后再去思考如何活得更有意义。当然，最好是两件事一起做。不过，人不能太贪心，能达到第一个目标我就已经很满足了。</p><h4 id="2-月-6-日-专注于自己的成长"><a href="#2-月-6-日-专注于自己的成长" class="headerlink" title="2 月 6 日 - 专注于自己的成长"></a>2 月 6 日 - 专注于自己的成长</h4><p>假期最后一天，下午终于回到了杭州，趁着时间还早，去江边跑完步，回来洗了个澡，感觉差不多满血复活了。这个年过得并不轻松，当然，对我来说，主要是心理上的。长辈的唠叨，家人的催恋催婚，加上各种经济账，让人的焦虑值达到顶峰。我有时候觉得，父母一方面真的挺不容易的，活了大半辈子了，到头来还得为子女各种操心；另一方面，我觉得在某种程度上，他们其实也是在为自己感到焦虑。面对自己逐渐老去的年龄，面对自己能力有限的事实，可能还有对死亡的恐惧。其实其他长辈也一样，他们虽然在经济上相比年轻人有很大的优势，但是却不得不承认自己已经不再年轻的事实，而且娱乐生活以及精神上也不一定有多丰富和富足。</p><p>所以，我觉得我要做的是，理解他们的焦虑，安抚他们的情绪，以及最重要的一点，不要轻易接受将他们的焦虑转嫁到自己身上。每个人都需要独自面对自己的人生。我不想按照其他任何人给我设定的人生轨迹去走，我只想按自己的想法，活出自己的人生。况且每个人都有自己的成长节奏，为什么要被外界的声音影响呢？我知道自己有很多缺陷，但是我相信自己会从这些缺点中慢慢成长起来。我也不需要和任何人比，我只能和自己比。至于长辈们的唠叨，安静聆听、理解就好了，大可不必全盘接受，也不要因此影响自己内心的平静。努力成长是你唯一要做的事。</p><h4 id="2-月-7-日-不要浪费自己的人生"><a href="#2-月-7-日-不要浪费自己的人生" class="headerlink" title="2 月 7 日 - 不要浪费自己的人生"></a>2 月 7 日 - 不要浪费自己的人生</h4><p>不要浪费自己的人生，尤其是不要浪费在那些不重要的事情上。</p><h4 id="2-月-8-日-不停地尝试下去"><a href="#2-月-8-日-不停地尝试下去" class="headerlink" title="2 月 8 日 - 不停地尝试下去"></a>2 月 8 日 - 不停地尝试下去</h4><p>不知道自己想要什么，是这个世界上最有杀伤力的事情，而一旦你有了清晰的目标和方向，那么，只要去做就可以了。一切都可以放弃掉，所有的情绪和能量都被集中在当下自己正在做的事情上。孤独、悲伤、压力、痛苦，虽然需要勇气去克服，但是，它们并不能真正伤害到我们。如何才能达到这种状态？告诉自己，既然在这个世界上有其他人可以做到，那么，我也一定可以。不要太早放弃，要不停地尝试下去。</p><h4 id="2-月-9-日-做好眼前的事"><a href="#2-月-9-日-做好眼前的事" class="headerlink" title="2 月 9 日 - 做好眼前的事"></a>2 月 9 日 - 做好眼前的事</h4><p>人生很长，暂时找不到方向也没关系，那就耐心地把眼前的事情先做好吧。认真、专注、一丝不苟，同时保持乐观。</p><h4 id="2-月-10-日-改善你和周围人的关系"><a href="#2-月-10-日-改善你和周围人的关系" class="headerlink" title="2 月 10 日 - 改善你和周围人的关系"></a>2 月 10 日 - 改善你和周围人的关系</h4><p>改善你和周围人的关系。如果觉得太难，或者不知道从哪开始，那就从见面主动打招呼、给对方一个微笑、闲聊几句话开始吧。</p><h4 id="2-月-11-日-抛开工作，如何定义自己的身份？"><a href="#2-月-11-日-抛开工作，如何定义自己的身份？" class="headerlink" title="2 月 11 日 - 抛开工作，如何定义自己的身份？"></a>2 月 11 日 - 抛开工作，如何定义自己的身份？</h4><p>假如没有了你现在的工作，你应该如何定义自己的身份？最近常常在想这个问题，离开工作，我似乎没有什么别的身份认同方式了。我喜欢跑步和看剧，但是不可能自称运动员或者影评作家吧，所以，难道我就只能以我的工作定义我自己了吗？我还有其它爱好吗？我能将爱好发展成自己的第二职业吗？我能否用它创造出更大的价值？</p><h4 id="2-月-12-日-焦虑无用，做好自己该做的"><a href="#2-月-12-日-焦虑无用，做好自己该做的" class="headerlink" title="2 月 12 日 - 焦虑无用，做好自己该做的"></a>2 月 12 日 - 焦虑无用，做好自己该做的</h4><p>最近早晨醒来，常常会陷入不知所措的状态中，有种觉得自己人生失去了方向，不知道接下来一天要如何度过的感觉。的确，我有很多想做的事，但是，我害怕自己只能一个人去做这些事。可能还是内心不够强大吧，还是会被外界的声音左右，害怕落单，害怕他人对自己的评论，害怕被嘲笑和讥讽。我觉得解除这种状态的关键在于，你要对自己的人生负责，即使是一个人，也要把自己和家人照顾好。虽然其他人对你会有更多的期待，但是，在你承担起自己的责任之后，其它所有的一切都是你自己的选择。一个人生活，没有朋友和亲密关系，虽然可能不符合世俗常规，但是只要自己觉得这样的生活是适合自己的，那就没什么问题。只要你有一颗足够强大的内心。尽管科学和统计数据告诉我们，每个人都需要社交和亲密关系才能感到快乐和有意义，但是，人终究还是以自我为中心的，我们活着也是为了体验这个多彩的世界，如果你一个人也能体验到丰富和感到内心充盈，那也没什么关系。当然，也有可能是因为当下自己还忙于生存，没有更多精力去寻找和自己有相同目标的伙伴吧。无论怎样，没必要为没有朋友或者社交而苦恼，做好自己该做的就可以了。</p><h4 id="2-月-13-日-Move-the-body-and-the-mind-will-follow"><a href="#2-月-13-日-Move-the-body-and-the-mind-will-follow" class="headerlink" title="2 月 13 日 - Move the body and the mind will follow"></a>2 月 13 日 - Move the body and the mind will follow</h4><p>每次运动完之后，哪怕是喝一杯水都会感到好幸福，而且是那种从身体深处迸发出的满足感。所以，幸福真的在于人的心境吧。Don’t take everything for granted，以感恩的态度看待你身边的每一件事物。这也是为什么我觉得习惯会如此重要，同样是两个小时，躺在椅子里刷手机和去运动这两件事，对一个人的身体、心态上的影响完全不同，前者可能会让你变得更加焦虑，而后者会让你对自己、对生活重新燃起希望。虽然偶尔放松也是必要的，但是大部分人的问题是太过放纵自己了，所以我们身边才会有那么多不健康的生活方式。这个世界上只有人类以及人类的宠物才会因为进食太多影响到自己的健康。关键是，这些最终也会影响到所有人，我们原本可以将更多的精力投入到真正重要的事情上，提升自己的能力、提高工作效率，变得精力充沛，产出更多的价值，而且这样也能体验到真正的满足感。不过，这都是每个人自己的选择。没有人可以强迫他人改变。我们只能把自己该做的那一部分做好，然后再去思考如何影响他人。先让自己过得幸福，然后再考虑如何提升他人的幸福。这是我始终且唯一的人生信条。</p><h4 id="2-月-14-日-先享受一个人的生活"><a href="#2-月-14-日-先享受一个人的生活" class="headerlink" title="2 月 14 日 - 先享受一个人的生活"></a>2 月 14 日 - 先享受一个人的生活</h4><p>今天是情人节，不过对我来说没什么特别的，依旧是一个人上下班，一个人点外卖吃。晚上下班回来后跑完步、洗完澡，躺在椅子里刷了会儿手机，待会儿准备早点上床睡觉。其实一个人没什么期待的话，也就不会感到失落了。如果不是一个人，我会怎么度过这一天呢？可能就只是身边多个人说说话、聊聊天吧，其他好像也没什么不同。但是，两个人一起生活的意义不就是陪伴彼此吗？出去跑步的时候身边多个人和你一起跑，有个人陪你一起吃饭、聊天、说笑，虽然不是时刻都能陪伴在彼此身边，但是至少对方不在自己身边的时候，会让你的心里有个可以牵挂的人。不过，想要找到一个这样彼此能聊得来、聊得通的人，真的非常看缘分和运气。在遇到这样的人之前，先好好享受一个人的生活吧。</p><h4 id="2-月-15-日-通过尝试新体验来获得平静"><a href="#2-月-15-日-通过尝试新体验来获得平静" class="headerlink" title="2 月 15 日 - 通过尝试新体验来获得平静"></a>2 月 15 日 - 通过尝试新体验来获得平静</h4><p>我们所做的一切都是为了增加自己的体验，但是，如果你在自己的日常生活中都不愿意去多多尝试、接触不一样的事物和选择，那你不是和自己所持有的信念矛盾了吗？所以，不要抗拒各种新奇体验，多去尝试。哪怕明知道会让自己感到不舒服也一样。想要做到始终保持平静、从容面对一切，光靠勇气还不够，还得不断练习，并且在这一过程中，学会掌控自己的情绪，学会苦中作乐，选择以积极视角诠释自己身边的事物。</p><h4 id="2-月-16-日-令人唏嘘的创业者、承担责任以及对存在的思考"><a href="#2-月-16-日-令人唏嘘的创业者、承担责任以及对存在的思考" class="headerlink" title="2 月 16 日 - 令人唏嘘的创业者、承担责任以及对存在的思考"></a>2 月 16 日 - 令人唏嘘的创业者、承担责任以及对存在的思考</h4><p>今天看了 v2ex 上的一篇<a href="https://www.v2ex.com/t/833951?p=3">帖子</a>，看得我心里直发堵，帖子下面大家的评论基本也都是和我差不多的感受。我在想如果我是当事人，我能不能及时清醒过来，去面对现实，承认自己犯了一个大错，然后去挽回自己的家庭和人生。其实我也不敢保证，因为我不是他，我不清楚他的经历、当时的心理状态以及做出这样的决定之后又经历了哪些事，我只是庆幸自己目前还没有陷入到像他这样被动的局面之中。「祸兮福之所倚，福兮祸之所伏」这句古语不停地在我们周围一遍又一遍地应验。你以为自己出生在一个条件优渥的家庭，就可以无忧无虑地长大了吗？一场意外就能夺走你的一切。你从小家庭不幸、无父无母、无依无靠，那么，你就只能在这样不幸的阴影中度过一生吗？幸运的是，你恰好遇上了一个非常爱你又无条件支持你的另一半。那么，你从此就会过上幸福快乐的生活了吗？并不，因为你的自私、冲动和贪婪可能会在转瞬之间就毁掉这一切。所以，真的不要太早给自己的人生下结论，因为生活永远都充满了未知数。</p><p>不过，普通人的一生虽然充满了风险和意外，但是，只要我们能做到一点，基本就不会再感到害怕了，那就是<strong>承担起自己的责任</strong>。我是在看了《少有人走的路》之后，才第一次意识到这个简单又显而易见的观念对人的影响有多大。只要你愿意承担起自己的责任，你就为自己的生命多赋予了一层意义。首先，你要为自己负责，你要爱护自己的身体，不要滥用它，照顾好自己身体和心灵的健康。然后，你要为自己的家人负责，为他们的健康快乐负责。即便你是孤儿，在你的成长过程中，也一定得到过他人对你付出的爱，也许他人不需要你的任何回馈，但是，你要把这份爱传递下去。</p><p>对了，爱才是我们所生活的这个世界的最重要的东西，虽然没人说得清「爱」到底是什么。爱有很多种，舐犊之爱，男女之爱，热爱。每个人对爱也都有自己的理解，但是，只要你愿意付出、投入爱，那么，你就能感到自己和这个世界是存在着某种联系的。然后，你会渐渐发现另外一种东西，那就是美。美也是一个很难定义清楚的东西。我们每个人都体验过美的感觉，傍晚散步时看到的天空景象，一首乐声婉转动人的歌曲，草地上一群追逐嬉笑的小孩子，甚至是一张你从未见过的风景照。很难解释「美」到底在何种程度上影响我们的生活，但是，它的确是我们这个世界不断向前发展、欣欣向荣的动力之一。为了体验到美的感觉，以及制造出更多美的事物，这是很多人活着的首要目标。不要让存在没有意义，我觉得每个人都应该思考「如何更好地活下去」这个问题。道阻且坚，但是这段旅程值得我们不停地探索下去。</p><h4 id="2-月-17-日-我正在犯的错误"><a href="#2-月-17-日-我正在犯的错误" class="headerlink" title="2 月 17 日 - 我正在犯的错误"></a>2 月 17 日 - 我正在犯的错误</h4><p>我现在正在犯的最大的错误是什么？对我来说，目前为止最大的错误应该是没有建立起自己的社交圈，太过孤立自己了。我要如何改变这种状况？首先改变自己的态度，然后是积极行动起来。利用好自己的弱连接，恢复已经休眠的社交关系，学会在公共场合表达自己（线上和线下），每天都要花足够的时间在社交上。如果能够做到以上这几点，社交状态一定会得到巨大的提升。唯一的问题是执行力，如何迈出第一步？首先要有足够的勇气，不要害怕丢脸，也不要担心他人会如何评价自己，真正重要的是你能否从这一经历中获得成长。其次，保持真实。这点需要我们做到足够接纳自我，因为只有这样我们才能放松做自己，而不是去掩盖真实的自我。我的目标是成为一个脸皮足够厚（自信、情绪感知、正向思维），不怕拒绝，也不怕被他人嘲笑的人。</p><h4 id="2-月-18-日-专注于呼吸，观察你的情绪"><a href="#2-月-18-日-专注于呼吸，观察你的情绪" class="headerlink" title="2 月 18 日 - 专注于呼吸，观察你的情绪"></a>2 月 18 日 - 专注于呼吸，观察你的情绪</h4><p>影响我们感受到幸福的只有当下的每时每刻，这也是为什么感受当下如此重要的原因。我现在在做什么？我现在的感受是什么？一个人的情绪和思维决定了他/她的状态。很多时候，我们的思维活动过于频繁，而情绪没有得到很好的观察和处理，所以，我们才会觉得和当下的自己陷入了矛盾，但却又说不出矛盾的根源。只有当外界的刺激超过了我们能够接受的程度，于是我们才会像一座小火山一样爆发了。冥想的意义就是让我们能够停下来，感受当下身体的状态。思维只是我们意识中的一个维度，情绪是意识的另一种体现。人作为一个经历漫长时间进化而来的物种，我们习惯了使用大脑控制身体，但其实通过控制呼吸，我们就能非常方便快速地和自己的大脑建立起最基础的连接，并且由此学会感受自己的意识。也许最终我们能够学会控制意识，但是，第一步永远是先去感受它。</p><h4 id="2-月-19-日-塑造你的能量场"><a href="#2-月-19-日-塑造你的能量场" class="headerlink" title="2 月 19 日 - 塑造你的能量场"></a>2 月 19 日 - 塑造你的能量场</h4><p>每个人都会散发出自己的能量场，我觉得我身上散发着一种「生人勿近」的能量场，而这反过来也强化了我喜欢和他人保持距离的习惯。改变这一点的关键在于改变自己的态度。首先，他人和自己之间的差别并没有你想象的那么大。也许我们来自不同的家庭，不同的成长环境，但是，既然我们能和彼此相遇，和彼此产生交集，那就说明我们在这一时空下是有缘分的，只不过我们来时的路不一样。所以，平等地对待你身边的每一个人。保持互相尊重，但是不要对他人有太多的期待。其次，你要学会观察自己。此刻我的感受是什么？我为什么会产生这样的想法？我感受到的痛苦的根源来自哪里？是什么阻止我感受到更为积极的一面？当你开始倾听自己内心的声音的时候，你会发现绝大多数痛苦都是因为你忽略了自己内心的需求，选择了去接受外界强加给我们的观念和想法。我们很少去反思那些欲望和焦虑的源头是什么。当我们真正想清楚自己想要什么的时候，这些情绪就会得到释放，我们才能真正开始足够投入地去做自己当下正在做的事。最后，我们要学会思考他人的需求。当你开始关注他人的需求的时候，你才会真正理解一个人。他为什么会那样思考？他为什么会做出那样的举动？你会变得有同理心，同时也更能与对方产生共鸣。</p><h4 id="2-月-20-日-低自尊与自我接纳"><a href="#2-月-20-日-低自尊与自我接纳" class="headerlink" title="2 月 20 日 - 低自尊与自我接纳"></a>2 月 20 日 - 低自尊与自我接纳</h4><p>在自我接纳之路上，我最大的障碍是经常觉得自己不太「正常」，总是会在心底告诉自己要在他人面前表现得「正常」一些。但实际上每个人都有自己特殊的地方。我不擅长处理冲突，所以总是想要避免和他人起冲突，而这种想法有时候过于强烈，以至于我会提前规避需要和他人接触的场景。一个例子，当室友在厨房做饭的时候，我会尽量不出房间，因为我害怕会打扰到对方。正是因为想要让自己表现得正常一点，所以我有时候才会显得过于礼貌，哪怕是和自己关系比较亲近的人。的确，我不擅长处理人际关系，我总是容易想得太多，比如觉得自己说的话很蠢，或者没有及时回答对方的问题，或者觉得对方会被我激怒。所以，大多数时候我喜欢自己一个人待着，去独自消化情绪。这其实也没什么不好的。但是，另一个问题就比较严重了，那就是低自尊，我总是害怕被别人看不起，或者被他人认为我不值得交往。所以，我才会在他人面前显得过于急切地想要表现自己，去展现自己的价值，哪怕是在其他人根本就没有注意到自己的情况下。我应该如何改变？首先，承认每个人都有自己特殊的地方，承认自己缺乏安全感，承认自己有各种各样的缺陷，但是也要意识到，即便如此，我也依旧撑到了现在，说明我还是有一定的韧性的，只不过我需要更多的练习，去克服独属于我的困难，去战胜自己的怯懦，去成为更好的自己。</p><h4 id="2-月-21-日-停止喂养痛苦之身"><a href="#2-月-21-日-停止喂养痛苦之身" class="headerlink" title="2 月 21 日 - 停止喂养痛苦之身"></a>2 月 21 日 - 停止喂养痛苦之身</h4><p>当下即是一切，停止为自己和他人制造痛苦。痛苦之身以痛苦为食，无论我们体验到的是什么样的痛苦情绪，如果我们只是被动地接受痛苦，那么痛苦之身就会被我们喂养地越来越活跃且贪婪。而当我们停下来，感受痛苦，感受它们的来源，观察它们，但是却又不做出任何反应，痛苦之身就会无所适从，当它们得不到赖以为生的食物的时候，就会从我们身上慢慢消散掉。</p><h4 id="2-月-22-日-观察自己"><a href="#2-月-22-日-观察自己" class="headerlink" title="2 月 22 日 - 观察自己"></a>2 月 22 日 - 观察自己</h4><p>每当觉得自己失去目标或者动力的时候，我都会停下来，告诉自己这只是一种暂时的状态。不需要给自己压力，或者寻找鸡汤来让自己重新获得努力向前的动力，通常只要停下来，安静地观察自己：此刻的心理状态，内心深处的情绪，包括不满、焦虑、抑郁、孤独等等，还有经常出现在自己脑海中的事物。等到自己感到疲惫的时候，我会立马上床睡觉。醒来之后，也许那些情绪还在，但是它们不会再继续暗中捣乱，我也能对自己的目标看得更加清晰。虽然躺平也是一种选择，但是利用同样的方法体会一下什么都不做的感觉，如果你觉得这样很好，那也没什么问题，但是大多数人都会想要做点什么，让自己和这个世界产生一点联系。哪怕只是向山谷中喊叫，也会产生回音，而我们的所有行为最终都会反应到自己的周围世界中。人生是一个不断成长的过程，每天我们都能比昨天的自己得到更多的信息、经验，也许还有智慧。我非常赞同活在当下的说法，但是同时也会忍不住期待 80 岁的自己，那时的自己会是什么样子，以什么样的心态面对自己和这个世界，和此刻的自己又有哪些不同。我希望自己不仅仅只是活着，而是能够摆脱大脑的控制、真正有意识地活着。</p><h4 id="2-月-23-日-独处与活在当下"><a href="#2-月-23-日-独处与活在当下" class="headerlink" title="2 月 23 日 - 独处与活在当下"></a>2 月 23 日 - 独处与活在当下</h4><p>虽然大多数的空闲时间都是自己一个人度过的，但是我发现其实自己根本就不知道应该如何独处。除去生活杂事之外，当真正可以什么都不干的时候，当需要独自面对自己的时候，我往往会选择电影、游戏，或者刷视频和社交网站等来麻痹自己。我其实是一个害怕孤独的人。意识到这一点之后，所有问题都可以解释得通了。如何解决这一问题？唯一的办法是不再逃避，拥抱当下。去感受自己此刻的情绪和身体的状态，而不要去思考。不要去回忆刚刚发生的事，也不要去期待即将发生的事，只是感受当下的这一刻。我们每个人能够掌握的只有当下。你只有不停地感受并且超越自己的意识，才能从被思维控制的牢笼中解脱出来。而且也只有这样，你才能真正开始生活。我现在在做什么？我此刻的想法是什么？你会注意到过去一直被自己忽略的东西，那些生活中随处可见的美丽的事物。你已经拥有了一切，而一切都在当下。</p><h4 id="2-月-24-日-进入当下，感受当下"><a href="#2-月-24-日-进入当下，感受当下" class="headerlink" title="2 月 24 日 - 进入当下，感受当下"></a>2 月 24 日 - 进入当下，感受当下</h4><p>获得幸福的一大必要条件是进入当下。最近在看《当下的力量》，得到非常多的启发。回想过去，我总是会不自觉地用思维填满自己的大脑，比如刷牙或者洗澡的时候，我会进入 auto pilot mode，各种各样的想法层出不穷，要么是回顾过去发生的事，要么是计划未来要做的事。问题是如果我一直允许自己以这种方式生活下去，我永远也不能真正地活在当下，而只能任由无意识控制自己，总是活在未来或者过去。只有进入当下，始终集中自己的全部注意力，保持高度敏感，不仅仅能注意到外在世界的变化，也能注意到自己内在身体和心灵所发生的变化，你才能真正活在当下。感受水的温度，感受风吹过脸颊的感觉，感受从很远的地方传来的火车驶过的声音，感受你的腹腔随着每一次呼吸的变化。只有这样，我们才能逃离小我的控制，我们才能超越思维，和本体合而为一。我们需要先学会控制自己的身体和意识，才能逐渐重新获得自由。最终的目的是，感受到整个世界以及生活在这个世界中的每一个人和我都是一体的，你个人的不幸福以及无意识会影响到整个世界。所以，我们应该尽全力让所有人都过得更有意识，更觉知，更开悟。</p><h4 id="2-月-25-日-如何确保不再发生战争？"><a href="#2-月-25-日-如何确保不再发生战争？" class="headerlink" title="2 月 25 日 - 如何确保不再发生战争？"></a>2 月 25 日 - 如何确保不再发生战争？</h4><p>昨天看到了俄罗斯入侵乌克兰的消息，说实话还是有点震惊的，虽然几个礼拜之前就听说可能会有战争发生，但是没想到最终真的会发生。其实不想在碎碎念里提及战争，因为这个话题过于沉重。战争意味着人为制造的动荡不安、死亡、恐惧、悲伤和痛苦，受苦的不仅仅是士兵及其家人，更多的还是普通的民众，而下达命令的人却选择了牺牲这些人的利益来实现他们的目标。边境线、民族问题、历史遗留问题，不得不承认这就是我们生活的世界所需要面对的问题。面对矛盾和纷争，当各方利益相互角逐却得不到有效解决的时候，人们就会想要使用暴力来解决。然而，我能做的，只有为那些在战争中受苦的人祈祷，并且希望永远都不再有人被迫卷入战争。没想到二战结束快要 80 年了，人类和平共处的愿望还是没能完全实现。不过，至少可以相信，这个世界上绝大部分人都是讨厌战争、追求和平的。经过这次之后，也加深了我这样的印象。唯一需要讨论的是，如何确保掌握权力的人不随意发动战争？</p><h4 id="2-月-26-日-接纳一切的方法"><a href="#2-月-26-日-接纳一切的方法" class="headerlink" title="2 月 26 日 - 接纳一切的方法"></a>2 月 26 日 - 接纳一切的方法</h4><p>如何才能做到接纳一切，包括你大脑中消极的想法和情绪？第一步是承认它们的存在，而不是忽略它们，安静地感受它们，但是，不要对它们做出任何反应，不要去分析、思考其来源，只是去感受。然后再将注意力转回到自己的身体上，调整自己的呼吸，感受身体各个部位的状态。学会接受事物本来的样子，只有这样做了，你眼中的一切才会呈现出其真实的样子，你也才能慢慢接受真实的自己。最后，学会用积极的视角去看待事物，我们无法改变外在的事物，但是却可以改变它们投射在我们心灵上的方式。所有事物都是我们通过自己的眼光过滤之后的结果。我们可以选择诠释事物的方式，这样，即使是不利于我们自身的现实，我们也可以通过改造它使其有利于我们的生存，这才是真正的乐天派。</p><h4 id="2-月-27-日-通过与人互动来认识自己"><a href="#2-月-27-日-通过与人互动来认识自己" class="headerlink" title="2 月 27 日 - 通过与人互动来认识自己"></a>2 月 27 日 - 通过与人互动来认识自己</h4><p>我觉得自己应该算得上是一个自给自足的人，但是还是会时常怀疑自己，我这样做对吗？我是不是太以自我为中心了？我需要改变自己吗？经常自我反省是好事，但是如果事事都这样，那也活得太累了。也许就是因为这样，我才会觉得自己不够自信吧。这也是为什么我总是喜欢一个人，因为这样就可以避免去面对更多的问题了。一个人的时候，无论做什么都可以，不用担心其他人的想法。但是，人不可能一直保持这样的状态下去，我们总归还是需要和其他人接触或者产生互动的。所以，最好的办法还是直面问题，你不可能一直逃避下去。况且和其他人接触、相处的过程，也是自我发现的过程。发现自己的需求，观察自己的情绪和反应，然后慢慢调整自己。这也是生活的本质，通过每一天的生活，发现自己，理解自己，从而更好地服务他人。</p><p>我觉得生命的意义在于你和这个世界产生什么样的互动，我们不一定使用相同的标准，但是最终一定是围绕这一核心展开的。既然作为人类群体中的一员，那么我就必须参与其中。当然，我并不反对那些真正过着自给自足的生活的人，我只是希望我们每个人都可以尽自己所能，让自己的生活变得更有意义，并且能够获得平静和幸福。我知道既然选择生活在人群中，那么就必须发挥自己的作用，服务其他人。这其实也是在服务自己，因为每个人都是这么做的。只要你参与市场经济，无论你做的是什么工作，你都是在服务其他人，同时也是在帮助自己，让自己和自己的家人生活得更加便利、安逸和幸福。</p><h4 id="2-月-28-日-容易受他人影响的人"><a href="#2-月-28-日-容易受他人影响的人" class="headerlink" title="2 月 28 日 - 容易受他人影响的人"></a>2 月 28 日 - 容易受他人影响的人</h4><p>老实说，自己还是很容易受到他人的影响，不知道这是我性格的问题，还是我看问题的角度的问题。我想尽力用积极的视角去解读他人说的话、做的事，但是有时候还是容易陷入负面情绪之中。可能还是因为做不到完全进入当下吧，感受自己此时的情绪，感受自己身体的状态，尝试用正面的眼光看待脑海中出现的想法。绝大部分心理活动的练习都比身体上的技巧更难掌握，所以也需要花更多的时间去适应和练习。有时候觉得自己就像一张白纸一样，任何人都可以在上面涂涂画画。所以，对能够接近自己的人保留一定的门槛还是有必要的吧，毕竟你的伙伴对你的影响最大。不过我觉得像我这样的人，还是更适合独自一个人生活。也许未来我的想法会改变吧。但是不管怎样，眼下来看，我最主要的任务还是学习和成长，人际交往也是其中的一个方面。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>键盘特殊符号中英文名称对照表</title>
      <link href="/keyboard-special-symbols/"/>
      <url>/keyboard-special-symbols/</url>
      
        <content type="html"><![CDATA[<p>该表主要是通过<a href="http://wason21cn.blogspot.com/2008/01/english-name-for-character-in-keyboard.html">这篇</a>博客整理而来的，某些符号有多种英文读法，所以我在 “Also:” 后添加了该符号的其它读法。中文名称部分我只写出了常见的读法。</p><span id="more"></span><table><thead><tr><th>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 符号 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</th><th>英文名称</th><th>中文名称</th></tr></thead><tbody><tr><td>~</td><td>tilde (sounds like til-da);</td><td>波浪号</td></tr><tr><td>!</td><td>exclamation mark; commonly read as bang in case of #!/bin/sh</td><td>感叹号</td></tr><tr><td>@</td><td>at</td><td>at 或小老鼠（台湾）</td></tr><tr><td>#</td><td>pound; but commonly read as shee in case of #!/bin/sh, not sure why. <em>Also: hash tag or sharp (from <a href="https://en.wikipedia.org/wiki/Sharp_(music)">music</a>)</em></td><td>井号</td></tr><tr><td>$</td><td>dollar</td><td>美元符</td></tr><tr><td>%</td><td>percent</td><td>百分号</td></tr><tr><td>^</td><td>caret</td><td>插字符</td></tr><tr><td>&amp;</td><td>ampersand</td><td>and</td></tr><tr><td>*</td><td>star; some read asterisk</td><td>星号</td></tr><tr><td>(</td><td>opening parenthesis (some may shorten it saying paren)</td><td>左圆括号</td></tr><tr><td>)</td><td>closing parenthesis</td><td>右圆括号</td></tr><tr><td>_</td><td>underscore; underbar</td><td>下划线</td></tr><tr><td>+</td><td>plus</td><td>加号</td></tr><tr><td>-</td><td>minus; dash; <em>Also: hyphen.</em></td><td>减号</td></tr><tr><td>=</td><td>equals</td><td>等号</td></tr><tr><td>`</td><td>backtick or backquote</td><td>反引号</td></tr><tr><td>{</td><td>opening brace</td><td>左花括号</td></tr><tr><td>}</td><td>closing brace</td><td>右花括号</td></tr><tr><td>[</td><td>opening bracket</td><td>左方括号</td></tr><tr><td>]</td><td>closing bracket</td><td>右方括号</td></tr><tr><td>|</td><td>pipe or vertical bar</td><td>竖杠</td></tr><tr><td>\</td><td>backslash</td><td>反斜杠</td></tr><tr><td>:</td><td>colon</td><td>冒号</td></tr><tr><td>;</td><td>semicolon</td><td>分号</td></tr><tr><td>“</td><td>double quote</td><td>双引号</td></tr><tr><td>‘</td><td>single quote. <em>Also apostrophe</em></td><td>单引号</td></tr><tr><td>&lt;</td><td>less than; some may read left angle bracket</td><td>小于号</td></tr><tr><td>&gt;</td><td>greater than</td><td>大于号</td></tr><tr><td>,</td><td>comma</td><td>逗号</td></tr><tr><td>.</td><td>dot; period if in English text</td><td>点号</td></tr><tr><td>?</td><td>question mark</td><td>问号</td></tr><tr><td>/</td><td>slash or forward slash</td><td>斜杠</td></tr><tr><td>(), [] and {}</td><td>may also be called brackets in general. In that case, they specifically call [] square brackets and {} curly brackets.</td><td>中文里没有这方面的问题，圆括号/中括号/花括号，它们各自表示的含义非常明确</td></tr></tbody></table><p>除此之外，中文键盘上还有以下这些特殊符号：</p><table><thead><tr><th>符号 &nbsp; &nbsp; &nbsp;</th><th>英文名称</th><th>中文名称   &nbsp; &nbsp; &nbsp;</th><th>备注</th></tr></thead><tbody><tr><td>·</td><td>interpunct</td><td>间隔号</td><td>主要用于人名，用于分割名字、中间名、姓等</td></tr><tr><td>￥</td><td>yen or yuan sign</td><td>人民币符</td><td>区分全角和半角，Mac 上使用快捷键 <kbd>option</kbd> + <kbd>Y</kbd> 可以打出半角的 <code>¥</code> 字符</td></tr><tr><td>‘ ’</td><td>single curly quotation marks</td><td>弯单引号</td><td>Mac 上使用快捷键 <kbd>option</kbd> + <kbd>]</kbd> 和 <kbd>option</kbd> + <kbd>shift</kbd> + <kbd>]</kbd> 可以打出左右弯单引号</td></tr><tr><td>“ ”</td><td>double curly quotation marks</td><td>弯双引号</td><td>Mac 上使用快捷键 <kbd>option</kbd> + <kbd>[</kbd> 和 <kbd>option</kbd> + <kbd>shift</kbd> + <kbd>[</kbd> 可以打出左右弯双引号</td></tr><tr><td>、</td><td>slight-pause mark</td><td>顿号</td><td>英文中似乎没有顿号的概念</td></tr><tr><td>「」</td><td>?</td><td>单直角引号</td><td>Mac 上某些中文输入法支持将引号替换为直角引号</td></tr><tr><td>『』</td><td>?</td><td>双直角引号</td><td></td></tr><tr><td>《》</td><td><a href="https://en.wikipedia.org/wiki/Guillemet">guillemet</a></td><td>书名号</td><td></td></tr></tbody></table><p>最后，再列一下 Mac 上其它按键的英文名称：</p><table><thead><tr><th>符号</th><th>名称</th></tr></thead><tbody><tr><td>esc</td><td>Escape，有时候用 ⎋ 表示</td></tr><tr><td>⇥</td><td>Tab</td></tr><tr><td>⏎</td><td>Enter</td></tr><tr><td>⇧</td><td>Shift</td></tr><tr><td>⌃</td><td>Control</td></tr><tr><td>⌥</td><td>Option</td></tr><tr><td>⌘</td><td>Command</td></tr><tr><td>fn</td><td>Function</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
            <tag> Cheatsheet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>温和与柔软</title>
      <link href="/2022-1/"/>
      <url>/2022-1/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/gvIkcN5YMH4" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>只有过了农历新年才会觉得新的一年真的开始了，而过年也成了我对这个月所有记忆的全部闪光点。只有在整理碎碎念的时候，才能通过文字去渐渐回忆起这个月其它时候自己的状态，揣摩自己当时的心态，以及为何会生出这样的想法并且写下这样的文字。我觉得这就是记录的意义吧，穿越时间看到过去的自己。不知道 10 年之后的自己再次看到这些文字的时候，会是什么样的心情，觉得自己当时太幼稚、太无知而感到羞愧难当？或许吧。生活会教会自己更多。但是，趁着自己还有时间并且也有这样的意愿，那就多记录一些吧。</p></blockquote><span id="more"></span><h4 id="1-月-1-日-2022-年第一天的愿望"><a href="#1-月-1-日-2022-年第一天的愿望" class="headerlink" title="1 月 1 日 - 2022 年第一天的愿望"></a>1 月 1 日 - 2022 年第一天的愿望</h4><p>新年第一天，没有太多的计划，只希望能够充实地度过这一天。其实希望每天都是如此，只不过，生命有太多不可控的因素，我觉得我能坐在这里继续写碎碎念就是一件值得感恩的事。年纪越大，经历越多，就越是觉得值得自己感恩的人和事太多了。虽然自己的生活也就那样，没有大富大贵，也没有经历过太多波澜，但是对于绝大多数人来说，如果能够保持这样平凡普通的生活一直到老，就已经是非常难得的事了。</p><p>说起来自己也还算年轻，不知道未来还有哪些考验在等待着自己。虽然觉得平淡也很好，但是没有任何风险和意外的生活，其实也挺无趣的。无论怎样，只要能够不断学习，不断充实自己的生活和体验，随着经历的增加，你对风险和意外的承受能力也会变得越来越强。我希望自己成为这样的人：等到自己 100 岁的时候，回首往事，回忆自己过去经历的种种，即使是在最困难、最煎熬的时刻，我也没有选择放弃或者逃避，而且能够平静坦然地面对自己经历过的所有痛苦和喜悦。无论生命精彩与否，最终都能获得心灵上的安宁。</p><h4 id="1-月-2-日-未来几十年的关注重点"><a href="#1-月-2-日-未来几十年的关注重点" class="headerlink" title="1 月 2 日 - 未来几十年的关注重点"></a>1 月 2 日 - 未来几十年的关注重点</h4><p>我们这个时代最缺乏的是什么呢？对于大多数人来说，在物质上早就已经摆脱匮乏状态了，即使你做着最最普通的工作，也不用担心自己吃不饱或者没地方住。但是，依然有很多人生活得不够快乐。我觉得问题的关键在于我们的思考方式，以及是否养成了好习惯。所以，我觉得接下来的几十年里，大多数人都会逐渐把注意力放在<em><strong>如何生活得更加幸福</strong></em> 这个终极问题上。作为一名互联网领域的工作者，总是会忍不住关注很多科技方面的新闻，比如最新的技术进展、大公司的动态、各种「趋势」等等，但其实这些只是我们所处的这个世界上正在发生的事情中的很小一小部分而已，即使是目前来看是全球性的问题，也只是因为它们<strong>被选择</strong>摆到台面上了而已，还有很多问题并没有引起大家的注意，至少没有引起社会主流的注意。对于普通人来说，关注个人的健康和幸福是居于首位的，而且目前市场上教大家如何生活得更加健康和幸福的产品也比较少，所以，我觉得这块应该挺有发展空间的。</p><p>那么，我作为一个普通的开发者，能够做什么呢？第一步，先努力让自己生活得更加健康，养成更多的好习惯，然后，利用业余时间开发出一些产品，可以是去宣传自己觉得好的生活方式，也可以是帮助大家养成好习惯的工具。虽然之前有尝试过一些产品，但是并没有能让自己长时间使用的工具。也许已经存在了，只是还没有发现最适合自己的吧。即使真的没有足够好的产品存在，那么我还可以利用自己已有的技能去开发一款这样的产品。</p><h4 id="1-月-3-日-命运与怀抱梦想"><a href="#1-月-3-日-命运与怀抱梦想" class="headerlink" title="1 月 3 日 - 命运与怀抱梦想"></a>1 月 3 日 - 命运与怀抱梦想</h4><p>最近常常在思考一个人仅凭自己的努力能在多大程度上改变自己的命运？其实我们的生活有很大一部分是由外界条件决定的。你出生的时间、地点、家庭，这三点几乎决定了你人生的 80%，剩下的 20% 则取决于你选择在哪里生活，从事什么工作，以及和谁结婚，而这几点又和前三点密切相关。有人说教育很重要，的确如此，但你的成长环境是你接受的第一种教育——家庭教育，你的老师和同学们则提供了学校教育，而你的父母以及其它社会关系则提供了同样关键的社会教育，最后，这三者结合起来，形成了对一个人来说最重要的教育——自我教育。自我教育的质量决定了成年后的我们会过上一种什么样的生活：我们会认识哪些人，做什么样的工作，具有什么样的价值观，选择如何度过自己的一生，等等。所以，教育质量的高低其实很大一部分也是取决于前面提到的那三点。因此，对一个普通人而言，想要改变自己的命运真的很难。这么说好像太过地理决定论和基因决定论了。不过，虽然事实如此，但现实世界中还是有很多人能够成为统计数据中的异常值，以不可思议的水平发展出一段不同寻常的人生。我这里所指的对象不仅仅是那些得到大众认可的功成名就的人，还有那些为了自己的理想而过上了一种即使不出众但能够获得极大自我满足的生活的人。我觉得这些人都应该成为我们的榜样，成为我们前进的灯塔。</p><p>我知道我是一个非常普通的人，但是即使如此，我也相信每个普通人都可以在日常生活之外，在心中抱有一点梦想，无论那梦想是什么。我们都可以成为更好的自己，只要我们愿意花时间去探索自己,无论是把自己的一个爱好发展成更有趣的事情，还是去默默做着某些看似不起眼的小事，只要你愿意付出努力，总能在日复一日的坚持之后找到人生的意义。</p><h4 id="1-月-4-日-寻找-mentor"><a href="#1-月-4-日-寻找-mentor" class="headerlink" title="1 月 4 日 - 寻找 mentor"></a>1 月 4 日 - 寻找 mentor</h4><p>最近突发奇想，觉得自己应该找个 mentor，但是找谁呢？谁愿意指导我呢？上网一查，说找 mentor 之前要先确定自己的目标是什么。想想也是，我连自己要完成什么样的目标都不太确定，又怎么能确定什么样的人适合 mentor 自己呢？其实我有很多目标，第一个是养成更多好习惯，那么，我希望有一位像 Atomic Habit 的作者 James Clear 那样的 mentor，其次是找到一位好的健身教练。对于个人职业发展，我现在也不太确定自己的目标是什么，想要学习一点商业知识，学习如何赚钱，看了一些书但是依旧没有找到适合自己做的事，所以这块可能还是得靠自己慢慢摸索了，等摸到一点门道了，才能知道应该找什么样的人作为自己的老师。另外一个重要的方面是提高自己的社交能力，我需要有一位 Rubin 那样的 mentor，我希望能够在放松做自己的同时也能拥有丰富且让自己感到满足的社交关系。目前看来，这个目标应该是我最需要付出努力的地方。不过，万事开头难，给自己多一点耐心并且坚持下去，总会慢慢看到改变的。</p><h4 id="1-月-5-日-网络世界-vs-现实世界"><a href="#1-月-5-日-网络世界-vs-现实世界" class="headerlink" title="1 月 5 日 - 网络世界 vs 现实世界"></a>1 月 5 日 - 网络世界 vs 现实世界</h4><p>大多数时候我都挺享受一个人的状态的，但是有时候还是会觉得自己和这个世界隔绝开了，比如下班回家的时候。那种感觉非常糟糕，但是又无法避免地会体验到到这种感觉。解决办法也不是没有，那就是寻找一个可以随时随地沟通倾诉自己内心想法的人，但是，要找到这样的朋友又谈何容易。我觉得自己性格上最大的缺陷是，我能够毫无障碍地在网上分享自己的真实想法，但是在现实中却很难做到这一点。但在网络上仅仅通过文字，想要做到真正毫无保留地、真诚地和另一个人交流又很困难，因为你很难分辨出对方表达的内容中有多少是假装出来的，而且由于我们现实世界中没有太多的交集，这种沟通很难长时间持续下去。另外，网络只是现实世界的延伸而已，如果把网络世界当成全部，最后一定会生出许多问题。所以，我觉得最根本的问题是：我们要如何在现实世界中对待其他人？因为这最终会反映在网络世界中。如果我们抱着真诚、热枕、真心关心他人的态度，那么无论是在现实中还是在网络世界中，我们都能得到他人的正面反馈。</p><h4 id="1-月-6-日-多多尝试"><a href="#1-月-6-日-多多尝试" class="headerlink" title="1 月 6 日 - 多多尝试"></a>1 月 6 日 - 多多尝试</h4><p>我自认为是一个能够自我学习的人，而且相信一个人只要具备足够的信念，就可以克服任何困难去做任何他想做的事（除了那些违背自然法则或伦理道德的事）。那么，是什么阻碍了自己去过上一种更满足且容易感到幸福快乐的生活？虽然我认为自己现在的生活很好，但是我知道我内心并不是真的热爱它。这体现在几个方面，首先是我和我身边的人的关系。身边大部分人和我的关系都很浅，我并不十分在乎他们，他们也不在乎我。我想要改变这点，但是却又不知道如何入手。其次，我虽然能够做好自己的工作，但是我并不享受这份工作。我喜欢被需要的感觉，但是当我真正开始做一件事的时候，我觉得我的目标是尽快到达终点，而不是享受完成这件事的过程。虽然当事情做完之后也能体会到成就感，但是我希望我能够完全自主控制自己想做的事以及完成到什么样的程度。目前来看，我离达到这两个目标的距离还很远。不过，我知道自己还有很多东西需要学习，或许我应该多多尝试，看看自己能否通过提高自己其他方面的能力来突破自我的限制。编程只是一种能力，我还需要提高自己的思维能力、谈判能力、营销能力、社交活跃度等等。</p><h4 id="1-月-7-日-不为「私利」的付出"><a href="#1-月-7-日-不为「私利」的付出" class="headerlink" title="1 月 7 日 - 不为「私利」的付出"></a>1 月 7 日 - 不为「私利」的付出</h4><p>通常情况下，我们做任何一件事都是为了得到某种反馈，那么，是否存在一种不为任何个人私利就去做某事的情况？我们经常说父母对子女的爱是无私的，但其实不是，因为绝大部分时候，子女是父母的血脉，照顾他们是一种本能和天性，是写在基因里的，因为只有这样才能让他们的基因一代代传递下去。参与慈善是不为任何个人私利吗？不是，虽然的确有人不为获得任何名誉或者头衔而去做慈善，但是慈善可以让人自我感觉良好，让人觉得「我是个好人」，也即满足一个人的自我价值感。虽然我们无法揣测他人的心理，但是做好事不留名的确会让人觉得自己更加高尚了。所以，任何时候，任何人，不为私利而行动的情况并不存在。但是，我们还是应该多去做那些不为谋取个人利益，仅仅为了帮助他人而做的事，比如帮助别人解决你擅长解决的问题，虽然不能得到任何物质上的回报，但是能够让你在心灵上得到满足。吝啬的人体会不到这一点，因为他们觉得既然自己擅长做某些事，那么他付出的所有「劳动」都应该收费。实际上，只有慷慨的人才会因为自己的行为获得更多的机会，并且也能得到他人「无私」的帮助。一切都是双向的，无论是无私奉献者还是吝啬者都一样。这也提醒了自己，没有白白付出的爱，你的付出最终会反映在这个世界的另一个角落，无论是某个人因为你而变得更温暖了，或者某个人受到了你的启发，这些影响都是实际存在但是你却不一定能看得到的。</p><h4 id="1-月-8-日-独立以及不要浪费自己的人生"><a href="#1-月-8-日-独立以及不要浪费自己的人生" class="headerlink" title="1 月 8 日 - 独立以及不要浪费自己的人生"></a>1 月 8 日 - 独立以及不要浪费自己的人生</h4><p>虽然不愿意承认这点，但是我觉得自己最大的优势是独立。虽然从来没有真正远离家人，但是我已经习惯了独自一个人的生活，不依赖任何亲人和朋友，一个人的生活。虽然没有朋友且单身的生活，看起来有点孤单，但是我不在乎。我选择接受这一切，因为我知道任何一种生活都有其两面性，看似孤单的生活，但你其实享有一个人的自由。我对自己现在拥有的一切都感到非常感激，家人、工作、生活。虽然跌跌撞撞走到现在，离当初自己的目标还有点远，但一个人的得到和付出大概率是成正比的，我没有付出太多的努力，所以也只能接受现状。不期望自己在接下来的 3、5 年内有多大的改变，但是，经过这几年的成长，我唯一学到的是：要做一个有耐心的人。我相信改变都是需要时间慢慢累积的，10 年、20 年之后再来看自己能有多大的成长吧。每天进步一点点，这是我对自己的唯一要求。尝试、犯错、反思、进步，跌倒、爬起、再次跌倒、再次爬起，承担自己的责任，感受痛苦和压力，有勇气面对失败，能接受普通，也能拥抱成功，我觉得这样的人生才不算是白过。</p><h4 id="1-月-9-日-做自己之前要先接纳自己"><a href="#1-月-9-日-做自己之前要先接纳自己" class="headerlink" title="1 月 9 日 - 做自己之前要先接纳自己"></a>1 月 9 日 - 做自己之前要先接纳自己</h4><p>我们为什么不能完全做自己？因为做自己太难了，这意味着要向他人揭露出完全真实的自我，而揭露真实的自我则考验我们接纳自我的能力。如果一个人无法做到全然接纳自我，那么，他的语言和行为就很难表达出真实的自己。我对这点深有体会。过去，我总是想要掩盖自己身上的缺陷，希望把最好的一面展现在他人面前，于是，无论对自己还是对他人来说，都有一种说不出的不和谐的感觉。而当我放弃这种需要<em>尽可能地保持完美</em> 的信念的时候，我反而可以更加放松地做自己。现在的我更能接受自己真实的样子，我知道我有很多缺点，有些是我能改变的，我会继续花时间让自己变得更好；也有些是我无法改变的，我已经学会了接受它们，接受现状。当负面的情绪和想法占据大脑的时候，我会尽可能让自己关注生活中美好的一面，包括自己身上的优点以及去感恩自己已经拥有的一切。没有什么是永久的，而且一个人始终都有权力选择以什么样的生活态度，去面对未来和未知。</p><h4 id="1-月-10-日-接受一切"><a href="#1-月-10-日-接受一切" class="headerlink" title="1 月 10 日 - 接受一切"></a>1 月 10 日 - 接受一切</h4><p>感觉生活失去方向、找不到生命的意义的时候应该怎么办？最关键的是不要让自己意志消沉下去，要想尽一切办法让自己重新燃起对生活的斗志。首先，保持正常的生活节奏，早起、工作，集中注意力做好一件事然后再做下一件。运动、冥想、阅读。尽量不要让自己陷入无所事事的状态。其次，多想想自己生活中美好的事物，做你喜欢做的事，那些真正让自己感到快乐的事，听歌、去树林里散步、对着天空发呆，从你喜欢的事物中获取力量。另外，不要批判自己，学会关爱自己。回顾自己过去达成的目标以及取得的成就，学会感恩自己已经拥有的一切。除此之外，多和他人谈论自己的感受，听听别人的想法。如果你找不到人交谈，可以像我一样，通过写日记来梳理自己的情绪和想法。最后，放弃「我需要完全掌控自己人生」的想法。有时候，我们要学会顺其自然，能够坦然接受一切，包括失控的人生，只有这样才能彻底摆脱焦虑状态。没有谁真正掌握了生命的奥义，我们都是第一次来到这个世界，学会接纳未知以及生活中出现的那些不可控的变化。</p><h4 id="1-月-11-日-Just-Do-It"><a href="#1-月-11-日-Just-Do-It" class="headerlink" title="1 月 11 日 - Just Do It"></a>1 月 11 日 - Just Do It</h4><p>改变总是十分痛苦的，尤其是当一个人在自己熟悉的环境待了很长时间之后，保持现状会成为他的本能。然而理智告诉自己，不改变会给未来的自己造成更大的痛苦，因此，长痛不如短痛，反正迟早都是要走上改变之路的。我们为什么会有那么多的恐惧？甚至明知道绝大部分恐惧都是自己想象出来的，但还是会被它们吓倒。事实上，只要战胜了内心的恐惧，这世上就没有什么东西可以阻挡我们。战胜恐惧需要怎么做？很简单，不要思考太多，当心里犹豫的时候，直接行动起来就好了。勇敢的人其实并不是内心不再感到害怕，而是能够忽略自己当下的情绪，把全部的注意力放在自己想要做的事情上，因此暂时「忘记了」害怕，而从最后的结果来看，我们只看到了他们当时的勇敢。有时候，我们的行为也会引导我们的想法，因此，当你开始行动的时候，你的想法和情绪也有可能被改变。「Just Do It」不仅仅是一句广告词，也是容易思考太多的人最应该采纳的行动准则。</p><h4 id="1-月-12-日-习惯养成心得"><a href="#1-月-12-日-习惯养成心得" class="headerlink" title="1 月 12 日 - 习惯养成心得"></a>1 月 12 日 - 习惯养成心得</h4><p>选择习惯就是选择身份，我为什么要养成那个习惯？因为我想要成为有那样习惯的人。而当我们觉得自己不是那种类型的人的时候，我们自然也就没有动力去做那种人会做的事，此时我们脑海中的想法是：我不适合做那种事/那根本不像我/这太夸张了，等等。所以，想要建立一个新习惯，一定是从改变自己的身份认同上开始的。其次是营造合适的环境。环境太重要了，直接决定了我们是去做我们期望中的行为还是延续我们过去的老习惯。提示，让它显而易见；渴望，让它有吸引力；反应，让它简便易行；奖励，让它令人愉悦。看看我们周围的环境，如果你想要改变自己的习惯，那就要先从改造环境开始，让执行新习惯变得近在眼前、值得做、更省力且做完之后会感到开心。执行是最后一步，也是最重要的一步。不过，如果前面两步都做到位了，行动反而会变得不那么困难了。难的是坚持下去，一天两天还好，十天、半个月也还能坚持，但如果是一年、两年呢？因为一件事坚持做下去，直到它开始改变我们的思维方式，往往就是需要花那么长的时间。我们可以通过做公开的承诺，寻找互相监督的伙伴，设立奖励和惩罚机制，来让自己坚持下去。另外，一个防止自己中断新习惯的方法是：允许自己有一天甚至两天没有达到自己的目标，但是每次错过之后都要给自己设定恢复此习惯的时间，并且保证到自己到时候一定不再错过，而且绝对不要让自己连续两次错过。</p><h4 id="1-月-13-日-家人对性格的影响"><a href="#1-月-13-日-家人对性格的影响" class="headerlink" title="1 月 13 日 - 家人对性格的影响"></a>1 月 13 日 - 家人对性格的影响</h4><p>我的性格中有很大一部分受到了老妈的影响，我从小就是性格内向的孩子，但因为我妈也是内向性格，而且小孩子都以自己的妈妈作为模板，所以在成长过程中，我也没有觉得自己有什么需要改变的地方。而因为我和老妈更像，所以从小到大也和老妈更亲。另一方面，也因为小时候爸妈关系不好，经常闹矛盾，会吵架甚至打架摔东西。老妈总是处于弱势地位，于是每次他俩吵架我和老姐都站在老妈一边。慢慢的，老妈变得越来越勇敢和坚强，而老爸最终也逐渐变得收敛起来了。我不知道是不是因为我们的影响，但是他们的关系的确在慢慢变得缓和，反正结果是，他们几乎不再吵架了，只是还是会经常斗嘴。长大之后，我变得越来越不喜欢交朋友，也不热衷维护和他人之间的关系，身边的朋友因此越来越少，但是我却越来越习惯一个人的生活。我知道这除了是我自身的性格之外，也有一部分是因为受到家人的影响。我害怕处理冲突，也很难对陌生人产生信任。我害怕他人知道我的软肋之后，会利用它们来伤害自己。尽管我知道这些担心都是不理性的，但是却很难彻底摆脱它们。也许我需要更多的时间吧，毕竟现在的自己还年轻，而改变又需要耐心。慢慢地去试着相信他人，让他人接近自己，学会袒露自己内心的想法，在表现出真实的自己的同时，也不要害怕受到伤害，即使得不到应有的回应，也不要因此感到沮丧，和其他人继续尝试就可以了。这是一场自我修炼之路，也是一个人成长的必经之路。</p><h4 id="1-月-14-日-抛弃羞耻感"><a href="#1-月-14-日-抛弃羞耻感" class="headerlink" title="1 月 14 日 - 抛弃羞耻感"></a>1 月 14 日 - 抛弃羞耻感</h4><p>学校教育有很多弊端，我觉得其中最大的一个弊端是教给学生太强的羞耻感。如果做不到或者做了某件事，会给自己或者自己的家人带来很大的影响，比如会遭到别人的嘲笑等，或者证明自己不如他人，被这样对待的人应该感到羞耻。学校教育通过在我们很小的时候将这种羞耻感注入到我们的脑海中，从而让小孩子们「听话」，更方便管理。其实，这种羞耻感是完全没有必要的。我们为什么要在乎别人对自己的看法？为什么要和他人比较？可是，往往要等到成年之后，我们才会听到「要勇敢做自己」的声音。因为这个时候，我们已经有能力管理好自己了，所以是时候让每个人都发挥出自己的天性，去做自己擅长的事而不必在乎他人的想法。因此，我们成年后要做的第一件事是：学会如何抛弃掉这种羞耻感。真正会因为我们的行为而蒙羞的人只有我们自己，我们只能代表我们自己。如果你的一言一行都是为了符合大众期待才去做，那你就是还没有抛弃掉羞耻感。你不必满足他人的期待，勇敢做自己吧。</p><h4 id="1-月-15-日-滑雪心得"><a href="#1-月-15-日-滑雪心得" class="headerlink" title="1 月 15 日 - 滑雪心得"></a>1 月 15 日 - 滑雪心得</h4><p>今天跟团去玩滑雪，这是我第一次一个人跟团，所以还挺兴奋的，早上 4 点不到就醒了。昨晚还有点担心这次出游会因为疫情而被取消掉，不过幸好没有。学会单板滑雪是我在去年立下的的<a href="https://ajiew.github.io/2020/">新年愿望</a>清单中的一个，结果当然是没能完全实现，所以，希望能在今年或者接下来的几年里，慢慢实现它吧。这次去的是桐庐生仙里，说来惭愧，明明是自己家乡的景点，但是直到现在才第一次去。可能那时候还没有滑雪的兴趣吧。说起来，我是在看了一个 blogger 的新年总结，其中刚好提到了刻滑，然后才在我的心里种下了一颗学习滑雪的种子。还是挺有趣的，有时候铺天盖地的广告也抵不过别人无心提起的一句话。而一旦一个想法植入到你的脑海中了，想要把它剔除掉，几乎是一件不可能的事。这是我第二次滑雪，但是经过这一天的练习，我觉得自己已经基本掌握了滑雪的基础：推坡。接下来就是继续练习落叶飘和海浪落叶飘，然后是换刃，再然后是 J 形刹车。学会这些基本就算是达到了单板入门的程度了，希望以后有机会可以去更多的地方体验滑雪的乐趣吧。</p><h4 id="1-月-16-日-看清过去，创造未来"><a href="#1-月-16-日-看清过去，创造未来" class="headerlink" title="1 月 16 日 - 看清过去，创造未来"></a>1 月 16 日 - 看清过去，创造未来</h4><p>每个人都生而孤独，因为没有人和我们有相同的经历，因此我们看待事物的角度不同，感知这个世界的方式也不同，我们在生理上也有自己独特的地方。但是，尽管如此，我们还是应该尽全力去理解他人，而理解他人的第一步是理解自己。我为什么会成为今天的我？我是如何一步步变成现在的自己的？有哪些是我主动选择和努力的结果？而又有哪些只是机缘巧合或者某种我无法控制的外力造成的？当你看清自己来时的路，再去寻找自己前进方向的时候，也许就更能有意识地做出真正适合自己的选择，并且把注意力放在自己能够改变的事情上。</p><p>对我来说，我觉得我人生的前半段都在随波逐流，我从来都没有认真规划过自己的人生，也没有思考过自己真正想要什么。即使有时候看上去好像有目标，但是那目标只是外界灌输给我的观念。<em>我要完成学业。我要寻找一份好工作稳定下来。我要去做别人都在做的事。要过体面的生活。要做一个正常人。</em>但是，直到最近几年，我才真正开始思考自己到底想要的什么，究竟做什么事才能够让自己感到快乐。可能人只有在解决生存之后才能学会思考吧。我快乐吗？理论上而言，应该感到快乐，因为曾经想要的现在都有了。唯一的不足之处是没有社交生活、没有朋友，但是这么多年下来，其实我早就习惯了一个人。所以，最关键的问题还是，没有找到真正让自己感到有成就感的事。虽然有时候能体验到心流的状态，但是并不持久。曾经在碎碎念中说过这是因为我还没有养成好习惯，没有持续提升自己。当你能够创造出更多的价值之后，自然就能体会到成就感以及能够沉浸其中了。这是非常理性且合理的陈述，只不过对于绝大部分人而言，这样的答案总归让人有点难以接受。热爱、理想、天性，这些才是人们想要听到的话语。还是放弃这种思维吧，去做你想做的事，去创造价值，没有人是生来就该做什么的。</p><h4 id="1-月-17-日-自由主义者的经济学观点"><a href="#1-月-17-日-自由主义者的经济学观点" class="headerlink" title="1 月 17 日 - 自由主义者的经济学观点"></a>1 月 17 日 - 自由主义者的经济学观点</h4><p>昨天 binge watch 了一天的油管视频，主要是 Matt 以及其它 pro-china youtuber 的视频，先是关于国内外疫情的对比，以及国外主流媒体的倾向性报道，还有国内外城市生活的对比等等，第一次真正意识到国内城市生活的便利性和安全性，尤其是在看了费城最脏乱差的<a href="https://www.youtube.com/watch?v=Bi1Kf-1qd6Y">街头景象</a>之后，这种感觉更加强烈了。</p><p>晚上看了采访 Ken Harmond 教授的<a href="https://www.youtube.com/watch?v=uV1zjwwhY1c">视频</a>以及 Richard Wolff 的 <a href="https://www.youtube.com/watch?v=ynbgMKclWWc">google talk</a>，又让我产生了重返校园学习一门新学科的愿望，比如经济学或者历史学。作为一个自由主义者，我当然不会完全赞同 Richard 的观点，所以昨晚躺在床上一直在思考他观点中存在的问题。我觉得其中最大的问题在于，他是从一个 nationalist 的角度出发去批判美国社会现状中存在的问题的，但是，对于真正的自由主义者而言，其实这个世界上就不应该有国家和政府，每个人都应该是一个具有自由交易能力的个体。所以，当企业将工作机会从一个国家转移到另一个国家时，这是由于前一个国家的工人的竞争能力不足导致的。真正有问题的不是资本主义，而是政府干预。</p><p>至于财富不平衡问题，这其实也不应该是一个问题，因为巨富的财富并不是躺在金库里，而是成为了流通在市场上的资本和商品。况且这是社会回报给他们的权力，他们通过承担巨大的风险而得到巨大的回报，因此，他们最终才得以利用手中的财富来决定生产何种商品、如何生产，以及如何转移和使用这些商品。普通消费者也因此而收益，我们获得了市场上更加丰富且廉价的商品。只要人类社会依旧存在，贫富差距就会继续扩大，这种差距主要是由科技进步导致的，而不是自由市场分配机制的不公平。最重要的一点是，穷人的生活也会随着科技进步而不断改善。现在最贫穷的穷人，放在中世纪的欧洲或者唐宋时期的中国，也已经是过着像贵族般的生活了。未来的科技进步会加大这种趋势，技术是具有普惠性的。</p><h4 id="1-月-18-日-财务自由之后想要尝试的工作"><a href="#1-月-18-日-财务自由之后想要尝试的工作" class="headerlink" title="1 月 18 日 - 财务自由之后想要尝试的工作"></a>1 月 18 日 - 财务自由之后想要尝试的工作</h4><p>如果获得了财务自由，我想要尝试的工作有：</p><ul><li>公交车司机（每天重复一条线路来熟悉一座城市）</li><li>大排挡厨师（做不了大饭店的厨师，至少可以考虑大排档，学习成本和要求都更低）</li><li>健身教练（哪怕当不了教练，把身材练好也不亏）</li><li>培训班老师（教小孩子学习元编程，从基础的打字开始教起）</li><li>景点导游（了解景点所有的相关信息，然后再把自己学到的东西介绍给其他人）</li><li>水族馆训养师（了解一种动物的所有习性）</li><li>农场工人（学习挤牛奶、操作农用器械等）</li><li>待补充…</li></ul><h4 id="1-月-19-日-自我怀疑和选择目标"><a href="#1-月-19-日-自我怀疑和选择目标" class="headerlink" title="1 月 19 日 - 自我怀疑和选择目标"></a>1 月 19 日 - 自我怀疑和选择目标</h4><p>最近又陷入了消极的情绪之中，常常一件事做着做着就会开始怀疑其意义，不知道自己接下来应该干什么。解决办法也不是没有，那就是制定好每日计划，除了工作之外，也要提前确定好每天下班之后的计划。不过，就算这样，还是会找不到动力。一方面是因为焦虑，另一方面是因为无聊。越是需要给自己所做的事寻找意义，就越是容易感到无聊。说服自己是最难的事。其次，我觉得我最大的问题是没有强烈的动力源。对成功没有太大的渴望，也不知道自己真正适合做什么。想要尽早实现财务自由，知道靠工资很难实现，但是又想不出有什么副业是自己可以尝试的，所以才会陷入焦虑的情绪之中。有时候甚至都开始对自己的工作产生了怀疑，这份工作可以维持多久？我能保证自己将来不会被淘汰吗？我有什么办法将主动权掌握在自己的手里？其实也知道答案是什么，但是还是会常常怀疑自己。每次看到那些比自己优秀的人，都会感到羡慕，羡慕他们有清晰的计划，而且执行得也非常好。只能希望自己也能尽早成为像他们那样的人。</p><p>每天进步一点点，这句话当然没错，但是当你觉得失去方向的时候，也许就该停下来，思考下自己的选择。首先，把眼前所有的选择都罗列出来（光这一步可能就要花掉你很多的时间，但是也有可能因此发现新机会），然后再用自己的价值观与想要实现的目标一一对照，寻找出最适合自己的选择。这一过程中，你可能需要不断调整自己目标的优先级，而且不同的选择之间可能也各有利弊，需要你做出权衡。当不同的选择之间差别不大时，选择与自己的核心价值观和目标最接近的那个，如果都很接近，那就通过掷骰子来解决。</p><p>其实所有的问题都可以用这种思考方式来解决，但我发现真正难的地方在于找出所有可能的选择以及明确自己的核心诉求。</p><h4 id="1-月-20-日-无法投入亲密关系的原因"><a href="#1-月-20-日-无法投入亲密关系的原因" class="headerlink" title="1 月 20 日 - 无法投入亲密关系的原因"></a>1 月 20 日 - 无法投入亲密关系的原因</h4><p>我为什么不敢投入到一段亲密关系之中？昨晚听了一段故事 FM 的播客，听其他人描述自己无法投入到亲密关系中的原因。看得出来，这三个故事是经过精心挑选的，因为从这三个故事中，可以归类出三种让大多数人无法投入亲密关系的原因：家人对我们的观念的影响、不知道如何表达爱、害怕承担由爱带来的责任与压力。这三条对我来说全中，家人灌输给我的观念是：找个差不多的人一起过日子就行了，什么爱不爱的都不重要。但是，我期待的亲密关系是温暖、健康、有爱的，我们关心彼此，希望和对方一起成长，一起去体验和经历生活中的一切。但是，如何表达爱、如何爱别人又是一件需要不断学习成长的事。从我父母的相处模式中，我有时候能感受到他们对彼此的爱，虽然大多数时候这种爱不是通过语言来表达的。我同样也知道学习如何去爱和表达爱需要时间，所以要对自己多一点耐心。最后一点，承担压力和责任是每个人都需要面对的问题。相比过去，我觉得自己已经进步很多了。当你知道这压力背后是所爱之人的幸福的时候，一切就又都是有意义的了。所以关键还是，我想要什么？我愿意为此付出什么？想清楚这两点之后，压力就变成动力了。</p><h4 id="1-月-21-日-幸福与保持专注"><a href="#1-月-21-日-幸福与保持专注" class="headerlink" title="1 月 21 日 - 幸福与保持专注"></a>1 月 21 日 - 幸福与保持专注</h4><p>昨天一整天时间都在看 <a href="https://www.navalmanack.com/almanack-of-naval-ravikant/happiness-is-learned">navalmanack happiness</a> 部分，关于幸福，Naval 最大的论点是现代人不快乐的原因在于无法做到 be present，我们总是容易被外界环境干扰，总是容易沉浸在各种资讯、形形色色的诱惑、他人灌输给我们的想法之中，而不知道该如何让自己安静下来，去听一听内心的声音。我真正想要什么？我应该做什么？什么才是让自己真正感到满足的事？如何获得内心的平静？冥想是一个好办法，让人慢慢变得能够静下心来，去感受自己此刻的心境、情绪和身体各个部分的感觉。我们首先要和自己的内心世界建立起连接，然后才能协调大脑和身体的其他部分，让它们彼此合作，才能做好一件事情。如果大脑不停地在思考待会儿我要做什么，或者在想刚刚或者过去发生的事，你是不可能把眼下的事情做好的。<strong>专注并且让自己保持住这种状态，只有这样才能完成一件又一件 的事。</strong>另外，每当你觉得自己无法专注的时候，先问问自己，我接下来要做什么，然后告诉自己：<strong>我先做两分钟，之后无论发生什么都没关系。</strong>我觉得只要能做到这两点，那就没有什么事是完不成的了。</p><h4 id="1-月-22-日-Pura-Vida"><a href="#1-月-22-日-Pura-Vida" class="headerlink" title="1 月 22 日 - Pura Vida"></a>1 月 22 日 - Pura Vida</h4><p>自我意识太强不是好事，如何才能降低自我意识？一个好办法是变得绝对专注，专注于当下正在发生的事，专注于自己正在做的事，专注于自己内心的活动。这样，你就没有多余的心理空间和精力去消耗在无用的自我意识上了。其次，尽量从积极的角度对事物进行解读。当你意识到自己正在被攻击的时候，或者内心出现某种对自己的负面评价的时候，停下来问一问自己：这种「攻击」真的是针对我的吗？亦或是我自己想象出来的？这种负面评价有依据吗？我为什么要进行自我攻击？如果你开始向自己提问，你会发现，绝大多数的自我怀疑和恐惧都来自于我们内心的不安全感，还有对自己的不自信，以及过去积累起来的一些根深蒂固的信念和偏见所导致的。有没有办法抛弃掉这些偏见和信念？当然有，只要我们愿意放下。放下我们给自己贴的标签，放下我们相信自己身上具有的身份，以完全开放的心态，开始拥抱一切。「这是一项我从来没有接触过的新体验，我感到紧张和兴奋」、「和她聊天很开心，我希望以后还有机会再和她聊天」、「这个任务有点难，我需要想办法拆分并一点点解决它」。这样做之后，你不会再受困于过去，也不再寻求解释。发生的已经发生了，没什么好解释的。而未发生的事和你过去的经历毫无关联，没必要用过去的经历来限制住自己。这才是真正的活在当下。</p><h4 id="1-月-23-日-留守儿童和选择善良和爱"><a href="#1-月-23-日-留守儿童和选择善良和爱" class="headerlink" title="1 月 23 日 - 留守儿童和选择善良和爱"></a>1 月 23 日 - 留守儿童和选择善良和爱</h4><p>昨天看了竹内亮拍的贵州留守儿童环境下长大的<a href="https://www.youtube.com/watch?v=U3aMaDScJ3c">高中生生活</a>，很是感慨，又倒回去看了一席演讲《<a href="https://www.youtube.com/watch?v=j7vsG4Metvc">我拍了杀马特</a>》。两种视角呈现出两种画面，我不知道留守儿童里有多少人是走向杨薇和韦行这条路的，又有多少人是走向杀马特这条路的。如果是我处在那种环境下，我当然希望自己是第一种情况，但是我知道一定有第二种情况，甚至还会有第三种更加令人唏嘘的情况，只不过没被镜头记录下来而已。</p><p>昨天看完视频之后的第一个想法是，我比他们幸福多了。第二个想法是，我能帮他们做点什么？现在看来，除了捐助，可能没有其它更好的方式了。但是，以我目前的力量，通过捐助只能帮助到一两个人，想到还有千千万万个这样的人，总觉得有些无力。所以，最好的做法还是去传播善良和自我教育的理念。这些人中，如果其中有人想要改变自己的命运，光靠别人的救助是没有用的，唯有靠自己的努力，毕竟有人宁愿去当三和大神也不愿意让别人来帮自己改变。</p><p>观念的改变是最难的，也是最重要的。首先，作为社会的一份子，我们要先改变自己的观念，先去认识和了解他们，然后再去帮助他们。其实我们身边有很多这样的人，在城市里做着最基础工作的快递员、外卖员、门卫、保安，也有一些是来自这样的家庭。我常常提醒自己，每当觉得自己正在承担巨大压力和痛苦的时候，想想工地上的那些建筑工人，想想他们的工作环境和生活环境，还有他们远在家乡的亲人，你还有什么好抱怨的呢？</p><p>在一个正义的社会中，每个人都应该关心、尊重每一个努力工作的人，同情理解那些比自己更为不幸的人，帮助那些意志消沉的人，让他们的生活重新走上正规。作为一个自由主义者，并不想要看到更多的福利制度，但是我相信，正义和善良是人的天性，即使没有福利制度，也会有人自愿站出来去帮助他们身边的伙伴。理论上来说，一个社会中只要有一个这样的人，这种助人之风就不会熄灭，因为人是社交动物，影响力会不断通过我们的人际关系一层层地传递出去。哪怕你传递出的是最微弱的善良的信号，最终也会影响到无数人的生活。所以，无论如何，都要选择善良和爱。</p><h4 id="1-月-24-日-Ego-vs-Spirit"><a href="#1-月-24-日-Ego-vs-Spirit" class="headerlink" title="1 月 24 日 - Ego vs Spirit"></a>1 月 24 日 - Ego vs Spirit</h4><p>每个人的内心都有一场战争，一场自我 (Ego) 和心灵 (Spirit) 的战争。Ego 告诉我们，为了获得外界的认可，我们需要不断努力拼搏，在职场上，在商业环境中，在我们所在的任何领域中，为了获得世俗意义上的成功，为了让自己著作等身，为了让自己合群，为了让自己过上一种让他人羡慕的生活。但是，我们的 Spirit 并不在乎这些，它只想获得平静和安宁，而这显然是和 Ego 的目标相矛盾的，于是它们需要不断与彼此争夺对大脑的控制权。</p><p>Ego 和 Spirit 在这场战争中不停地厮杀，但是却很难分出胜负。有时候 Ego 暂时占领上风，我们在职场、商业市场或学术市场中获得了不错的成就，于是，我们的自我得到了很大的满足。但是，Spirit 却开始质问：这一切都是为了什么？你现在真的感到快乐和满足吗？这时，我们才意识到自己过去太过关注 Ego 而忽略了 Spirit，所以开始渐渐放弃自己已有的「成就」，并去追求和满足 Spirit 的愿望。</p><p>很多人的一生都可以总结为上面这种模式。有没有可以让自己的 Ego 和 Spirit 和平相处的办法呢？当然有，那就是不断地让 Spirit 做计划，同时塑造我们的 Ego，重新定义什么是成功。这样，我们就可以在做自己想做的事的同时，也能满足自己的 Ego。听上去很难，但是却绝对值得一试。我能想到的大多数真正成功（并非只是世俗意义上的成功）的科学家、企业家、教育家都是这样做的。虽然并不知道他们内心真实的想法和经历，但是我相信他们的表述是真诚的。因此，既然他们可以做到，我也一定可以。Fake it, till you become it.</p><h4 id="1-月-25-日-不要羞于开口表达自己的真实需求"><a href="#1-月-25-日-不要羞于开口表达自己的真实需求" class="headerlink" title="1 月 25 日 - 不要羞于开口表达自己的真实需求"></a>1 月 25 日 - 不要羞于开口表达自己的真实需求</h4><p>过于关注自己真的是非常消耗内心能量的事，很羡慕那些无论何时何地都能放松做自己的人，说自己想说的话、做自己想做的事，而不必在意他人的看法。虽然有些无心说出的话可能会伤害到别人，但是只要不是恶意的，他人也不太会放在心上。说到底，我羡慕的其实是那种能<strong>随时随地表达出自己真实需求的人</strong>，因为这样的人更容易得到他们想要的东西。如果你不说出自己的需求，得到回应的可能性为零，而表达出来之后，至少能让他人听到你的需求，即使无法立即得到满足，至少能让他人记住你，知道你是一个敢于表达的人。当然，大多数时候，我们应该靠行动去争取到自己想要的东西，我想说的是，不要做一个羞于开口的人。你配得上任何你想要的东西，只要你愿意付出足够的努力。另外，也不要被自我束缚。你不需要和他人保持一致。做自己想做的事，追求你自己的目标，<strong>不要为了满足外界期待而牺牲自己的真实需求</strong>，不要为了融入或者合群而去做别人都在做的事。每个人都是独一无二的，你要走属于自己的人生道路。他人的不理解、埋怨，甚至嘲笑和讥讽，都是正常的反应，你不需要去一一回应。<strong>孤独是永恒的</strong>。永远不要期望有人能够一直站在自己的身边。偶尔遇到有人愿意理解你，陪你走上一小段旅程，那更要加倍珍惜。能做到平静接纳一切的人才是世界上最强大的人。</p><h4 id="1-月-26-日-小我和本我"><a href="#1-月-26-日-小我和本我" class="headerlink" title="1 月 26 日 - 小我和本我"></a>1 月 26 日 - 小我和本我</h4><p>接纳自己为什么这么难？我们无法改变自己的身体构造，但是为什么连改变自己的态度也这么难？我觉得首先需要承认的一点是，改变是一个漫长的过程。昨晚开始阅读当下的力量，我也逐渐开始相信，我们身体里其实住着另外一个自己，我们是由一个<strong>小我</strong>和一个<strong>本我</strong>构成的，一旦开悟，本我就将可以控制小我。也许开悟之后我们还是会因为外界的刺激而感受到痛苦，但是本我能够注意到每一个当下的自我意识，并且识别到这种痛苦的根源。痛苦说到底只是因为欲望得不到满足。所以，想要获得平静和快乐，唯一的做法是放弃欲望。这并不是说我们应该立刻躺平，或者终日冥想，而是意识到我们追求的应该是更高层次的满足。当一个人的生理欲望得到满足之后，我们可以选择 rat racing，不停地去更新升级自己的生活方式，也可以选择活在当下，建立和本我的连接，做真正让自己感到满足的事。不回忆过去，也不去思考未来，调整期待，专注于当下，这是获得幸福与平静的唯一办法。</p><h4 id="1-月-27-日-承担起自己的责任"><a href="#1-月-27-日-承担起自己的责任" class="headerlink" title="1 月 27 日 - 承担起自己的责任"></a>1 月 27 日 - 承担起自己的责任</h4><p>每次回家都能感受到自己心态上的变化，内心在不停地和自己作斗争，一边自我攻击一边自我安慰，一边感到失望一边又感到感恩。我不知道我这样矛盾的性格是什么时候形成的。虽然不想承认，但终究还是因为家庭成长环境对自己的影响。这种感觉真的很讨厌：明明知道自己需要改变，但是却又不知道该从哪开始。觉得父母太保护自己了？那你就更应该承担起自己的责任啊。觉得自己性格太被动？那就变得主动一些呗。这有多难？而且觉得难就对了，这世上哪有什么真正容易的事情？你应该对自己拥有的一切感到感恩。虽然我知道你在努力适应，但是不要忘了，很多人并不是像你一样幸运。每个人都有获得快乐和幸福的条件，虽然困难重重，而且未来会有越来越多的问题出现，但是你要对自己有信心。照顾好自己和家人是你的责任。</p><h4 id="1-月-28-日-公开表达自己"><a href="#1-月-28-日-公开表达自己" class="headerlink" title="1 月 28 日 - 公开表达自己"></a>1 月 28 日 - 公开表达自己</h4><p>过去特别不喜欢在网络上公开发言，一是觉得自己表达的东西没有足够的价值，二是害怕招来别人的批评。但是，当我渐渐发现身边和自己想法一致的人越来越少的时候，才开始明白过来，我必须要开始学会公开表达，哪怕是有反对自己的声音，因为像我这样的人，最终一定只能通过网络，才能结交到和自己想法一致的朋友。尤其是在看了这个 <a href="https://www.youtube.com/watch?v=MB5IX-np5fE">TED</a> 视频之后，更是加深了我这样的信念。虽然每个人都要独自应对孤独和焦虑，但是，人毕竟是社交动物，我们只有在拥有充足且令人满足的人际关系之后，才能获得价值感和意义感。所以，一定要学会表达自己，学会变得更加开放，让他人了解自己，主动分享自己的想法。</p><h4 id="1-月-29-日-孤独与理想的人际关系"><a href="#1-月-29-日-孤独与理想的人际关系" class="headerlink" title="1 月 29 日 - 孤独与理想的人际关系"></a>1 月 29 日 - 孤独与理想的人际关系</h4><p>有时候觉得，我为什么会变成像现在这样，如此不愿意与人交流。过去自己似乎还有几个可以聊天的同学朋友，但是最近一个都没有了。除了家人之外，我不知道我还能和谁去说自己的心里话。当然，写日记是一个很好的发泄渠道。但就像昨天说的，人是社交动物，有时候我们需要和其他人沟通互动才能获得心理上的安慰。孤独可能是现代社会的副产品之一吧。但是，其实每个人都知道解决办法是什么，那就是打破自己的心理障碍，学会主动和他人建立起连接。我们太过习惯伪装自己了，每个人都装作自己过得很好，并且不想让别人知道自己真实的心理状态。告诉别人「我感到很孤独」是一件很难说出口的事，因为这似乎说明自己没人缘、不受欢迎、没人喜欢自己等等。我相信不只有我一个人有这样的想法，虽然其他人可能不会像我这般，如此「独立」和疏离人群，而且我们感到孤独的程度和频率也不一定相同，但是孤独这种感受一定是共通的：觉得自己没有可以倾诉的对象，没有人可以理解自己，全世界只有自己一个人，等等。</p><p>我觉得解决这个问题最终还是得向内探索，沟通和倾听并不一定适合所有人。要让自己有事做，无论是发展一个新的爱好，还是把时间投入到工作里，行动起来之后我们会感到更加充实，而且达成目标也会让自己感到喜悦。另外，不要去追求获得他人的认可，我们应该学会自我表达，但不是为了向任何人证明自己，只是纯粹为了分享而已。用这样的心态，他人和自己都会感到更加轻松。朋友和恋人不是求来的，而是因为我们彼此有共同点、互相吸引，并且我们有能力也愿意在对方身上花费时间、金钱和精力，对方的快乐就是我的快乐。如果时机合适的话，我们也愿意组成长期合作伙伴关系，享受彼此的陪伴，共同面对未来的风险，等等。我觉得这才是我追求的理想的人际关系，我希望我能和身边每个人都组成这样的关系。</p><h4 id="1-月-30-日-对父母的观察和反思"><a href="#1-月-30-日-对父母的观察和反思" class="headerlink" title="1 月 30 日 - 对父母的观察和反思"></a>1 月 30 日 - 对父母的观察和反思</h4><p>假期在家和父母相处的时间比较长，所以又能注意到我们身上众多的不同之处，从生活习惯到思维习惯等，但作为子女，我只能尽量去适应他们。另外，由于已经很久没有和他们长时间生活在一起，我觉得自己也是在作为一个旁观者，观察他们两个人的相处。虽然他们的生活中有很多不和谐的地方，但是我觉得可能这就是他们的相处方式吧。有很多的 power struggle，也有沟通出现问题的时候，但是，他们已经像这样相处几十年了，改变的可能性非常低，而且他们早就已经习惯了。在我眼里可能不是理想的沟通模式，但是在他们眼里可能觉得根本没什么，日子照样过。</p><p>我有时候会突然感到很惶恐，想到他们为自己付出那么多，想到未来我有可能没办法很好地照顾好他们，就觉得自己现在应该更加努力一点。但是，我知道每次回到杭州之后，我就会将这些想法都逐渐抛到脑后。我知道他们希望我过得幸福，而现在最大的担心是害怕我找不到对象。我不想告诉他们这其实是因为我不知道如何与他人相处，而且也根本没有谈恋爱的欲望。想太多没用，还是放下这些心理负担吧，改变你能改变的，先把自己的生活过好、过幸福。</p><p>现在每次回来和爸妈聊天，几乎都能聊到钱的话题，老爸已经不止一次提醒我不要害怕因为没钱结婚而不谈恋爱。我也是第一次感受到现实中的农村是什么样的，原来和一个人结婚要花这么多钱。我买房的首付一大部分是他们给的，以后结婚的话，还要准备彩礼钱、办婚礼等等各种支出。想到这些，心里长叹一口气，怪不得他们工作那么辛苦，收入在农村也不算低了，但还是过得那么节俭，其实都是为了我。</p><p>不过，我还是觉得我不会为了他们而妥协。每个人都有自己的困难需要面对，他们的困难比我多一些，除了要面对工作的辛苦还得面对他人给的压力（你儿子找不到对象巴拉巴拉），而我的困难在于，找到自己的人生目标，获得成长，以及改变自己的性格。但是，我不想要草率进入婚姻，因为婚姻改变不了任何东西。每个人都应该对自己的人生负责。不过，我的确应该多谈谈恋爱了，先表达兴趣和尝试接触，如果合适的话彼此相处看看，至于结果怎样，无所谓。我觉得自己现在的年纪才是正适合谈恋爱的年纪，心智更成熟，有一定的经济基础，也有明确的目标，缺的只是决心和勇气。</p><h4 id="1-月-31-日-变得温和、柔软一些"><a href="#1-月-31-日-变得温和、柔软一些" class="headerlink" title="1 月 31 日 - 变得温和、柔软一些"></a>1 月 31 日 - 变得温和、柔软一些</h4><p>今天是除夕，想再聊聊父母。虽然不想搬出原生家庭那一套，而且也知道往原生家庭的 Procrustean bed 上一躺，并不能解释自己身上所有的问题，但是不可否认，父母真的对我们造成了很大的影响。首先，我得承认我还算是比较幸运的，虽然出生在农村，但是我的家庭并不穷困。也许不富裕，但是至少从小到大从来都不愁吃穿。相比那些真正在贫困中挣扎过的家庭，我已经算是过得非常「体面」的了。但是，这并不能代表我的童年就是幸福的。</p><p>我觉得我的家庭关系中最大的问题是爸妈之间的沟通方式。他们习惯了使用刻薄的语言和对方沟通，有时候是挖苦、讽刺对方，虽然不是家暴，但应该算得上是语言暴力，而且这种暴力一定会对孩子的心理造成影响。我不想夸大这种沟通方式的杀伤力，不过我真的觉得自己一直到现在都还有心理上的阴影。我开始变得不爱说话，害怕表达出自己的意见，习惯于掩盖自己的真实想法。还有即使是非常想要一件东西也要装出无所谓的样子，因为我知道如果直接说出想要，不但会遭到拒绝，甚至还会换来嘲讽和挖苦。随着成长，这些「特质」在我的性格中变得越来越根深蒂固，我不停地在加强自己这样的习惯。过去青春期的时候，我还会偶尔爆发一两次，一般是语言上的反击，但是通常这并不能改变任何东西。直到最终，我已经习惯了这样的自己，甚至觉得自己的性格就是这样。但是，从最近几年开始，每当回到家中的时候，每当再次长时间和他们在一起相处的时候，我才突然开始在心底反问自己：他们为什么要这样沟通？我又为什么会变成像现在这样？家不是应该是让每个人都可以放松做自己的地方吗？我为什么要战战兢兢，不敢说自己想说的话，时刻担惊受怕，害怕受到他们的指责？</p><p>更恐怖的是，我发现我其实也经常表现得像老爸一样，充满负面情绪，说话带刺，喜欢苛责他人，但只有在事后回忆起来才会意识到：笨蛋，刚刚为什么要像那样说话？所以，有的时候我也会害怕自己未来会变成他的翻版。这也是我不愿意认识新朋友的原因，因为我害怕自己会伤害到他人，尤其是进入一段亲密关系，我不想这个世界上出现另外一个老妈。我觉得理想的相处模式应该是彼此尊重，互相爱护、理解对方，心意互通，即使有分歧也不会用带刺的话伤害对方。尤其是当你知道对方的一切弱点的时候，更不应该肆无忌惮地去攻击对方的软肋。然而现实是，这就是我所成长起来的家庭环境，虽然比不上真正的暴力，但是说实话，真的不太好受。</p><p>Anyway，说了这么一大堆，虽然并不能改变什么，但是，能够写出来也算是一种情绪上的释放，而且还可以用来提醒自己：要变得温和、柔软一些。你一定可以改变自己的，只要你有足够的耐心。加油吧。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Starting a new journey</title>
      <link href="/2021/"/>
      <url>/2021/</url>
      
        <content type="html"><![CDATA[<p>在一个阴雨绵绵的周末下午，我终于还是下定决心坐下来把这篇年终总结给写完。因为拖延是个无底洞，只要你愿意，你可以一直拖下去，最终我很有可能会拖到过年，我不想回家之后还抱着个电脑写 2021 年的年终总结。</p><p>过去这一年对我来说发生了不少事，换工作，搬家，适应新环境、新的同事和室友，工作内容上的变化，家人朋友的变化，还有我自己身上发生的变化。有些变化可能只有在事后回想起来，才能意识到它们对自己造成了什么样的影响，而且这种影响有可能是非常长远的，只不过当下的自己还意识不到。我想这也是写总结的意义之一吧。</p><p>我在 <a href="https://ajiew.github.io/2018/">2018</a> 年使用过一个年终总结的<a href="https://stevepavlina.com/blog/2005/01/the-year-in-review/">模板</a>，今年想再次套用一下，所以就挑几个方面来总结自己的 2021 年以及展望新的一年。</p><span id="more"></span><h3 id="身体健康"><a href="#身体健康" class="headerlink" title="身体健康"></a>身体健康</h3><p>我觉得自己过去一年最大的成就应该是养成了跑步的习惯，尤其是从下半年开始，每天下班第一件事是换衣服然后出门跑步。所以，当年底发现自己这一年跑步的总距离达到了 <a href="https://running.ajiew.me/">1500 公里</a>，远超<a href="https://ajiew.github.io/2020/">年初计划</a>的 500 公里的时候，还是挺惊讶的。新的一年里，唯一的目标是将这个习惯继续保持下去，每天都跑就可以了，跑多少都无所谓。</p><p>另外，从去年的 5 月份开始还养成了每天早上做一组 Ab Ripper X 的习惯，同样的，希望自己能在新的一年里将这个习惯继续保持下去。</p><p>去年下半年对健康的一大投入是去做了牙齿矫正，从此开始了我的牙套生活。虽然吃东西非常不方便，但是我也终于<del>被迫</del>养成了餐后使用牙线的习惯。而且我觉得未来一定会有越来越多的人接受牙齿矫正，所以想等有空单独写一下自己牙齿矫正的经历，可以给其他人作为一个参考。</p><h3 id="心理健康"><a href="#心理健康" class="headerlink" title="心理健康"></a>心理健康</h3><p>保持写日记的习惯。2021 年<a href="https://ajiew.github.io/tags/Journal/">碎碎念</a>写了接近 18 万字，这些文字可能对其他人没有多大的意义，但是它们对我自己来说，是一笔非常非常宝贵的财富。虽然不一定多有智慧，但是每次阅读这些文字，我都能从中汲取到力量，让我重新鼓起勇气，独自面对这个复杂又绚丽多彩的世界。</p><h3 id="工作-职业发展"><a href="#工作-职业发展" class="headerlink" title="工作/职业发展"></a>工作/职业发展</h3><p>去年真正开始使用 Flutter 开发项目，虽然不是常规的项目，但是在不到两个月的时间内，从开发到正式上线，也算积累了不少 Flutter 开发的经验。接下来的一年里，除了继续进阶 Flutter 之外，还想接触一些其它方面的技术，比如 iOS 开发和前端开发。另外，安卓方面也要继续进阶，比如 Kotlin Coroutines 以及 Compose UI，希望自己不要半途而废。</p><p>另外，接下来的一年还想学习一下视频编辑，因为想要制作一些教学向的视频，帮助其它新手入门开发，这也是为了锻炼自己的语言表达能力以及克服镜头恐惧。</p><h3 id="财务"><a href="#财务" class="headerlink" title="财务"></a>财务</h3><p>保持记账的习惯，继续极简主义的生活方式（使用愿望清单、「如非必要，勿增实体」），想办法获取第二收入。</p><h3 id="个人情感"><a href="#个人情感" class="headerlink" title="个人情感"></a>个人情感</h3><p>我发现自己目前最大的问题不是单身，而是根本就没有社交生活。先解决孤单的问题，再考虑如何去认识自己喜欢的人吧。当然，最终结果也有可能是，发现自己根本就不需要社交。无所谓，自己开心就好。</p><h3 id="家人"><a href="#家人" class="headerlink" title="家人"></a>家人</h3><p>过去一年家人中发生变化最大的应该是老姐了，终于和包哥结束了不算太长的爱情长跑正式进入了婚姻，恭喜他们。不过也正因如此，今年过年家里将只有我和爸妈三人了。不过我觉得没什么，毕竟我们迟早都是要将重心转移到自己的小家庭里的，而且在这个随时随地都能视频见到彼此的时代，反正我是觉得在哪过年都是一样的。</p><p>家人是我们最大的财富，但问题是：你每年有多少时间真正花在了关心、陪伴自己的家人身上？你有问过他们真正想要什么、是否开心快乐吗？</p><h3 id="情绪方面"><a href="#情绪方面" class="headerlink" title="情绪方面"></a>情绪方面</h3><p>保持平静，活在当下。首先，你自己要做一个安静且快乐的人，只有这样，你才能认识其他安静又快乐的人。</p><h3 id="社交方面"><a href="#社交方面" class="headerlink" title="社交方面"></a>社交方面</h3><p>到了这个年纪才发现，一个内向不爱说话的人认识新朋友有多难。如果你在学校里没有结交太多知心朋友的话，那么，等你毕业之后，你很有可能会发现自己身边连一个可以说话聊天的人都没有。而想要改变这点也很简单，<strong>改变自己的性格</strong>。多说话，无论身边有没有人愿意听或者别人喜不喜欢听。只有不停地说，你才能获得认识新朋友的机会。不要想着等别人来认识你，因为没有人愿意主动接近一个没有任何特点的人。而且每个人都在等着他人来接近自己，你只有成为那个「他人」，才能掌握主动权。</p><h3 id="个人成长"><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h3><p>个人成长是一辈子的事，而且这是个循序渐进的过程，你不可能一下子就跳上几个台阶。它也不一定遵循某种固定的节奏，比如有时候，在某些偶然的事件出现在你的生命中之后，你可能会在一个很短的时期内，达到过去几年也达不到的成长高度。但是，大多数时候，个人成长是一件考验耐心的事：你得不停地和痛苦做斗争，一遍又一遍地重复那些「苦工」，长时间地阅读，每天都去做那些在旁人眼中看起来有点枯燥乏味甚至是无聊的事。不过没办法，c’est la vie，这就是人生。</p><blockquote><p>人生长久，而快乐短暂，行动宜速，享受宜缓。</p></blockquote><p>另外，关于个人成长，2021 年最大的感悟是：</p><ul><li>接纳自己</li><li>承担责任</li><li>敢于承诺</li><li>学会感恩</li></ul><p>这几个话题也常常出现在我过去一年的碎碎念中，希望等到今年年底的时候能有更多新感悟吧。当然，最好是没有感悟，因为那就说明我已经做得很好，完全把它们融入到自己的生活中，它们已经成为我认知和行为处事的原则，所以感知不到它们了。无论怎样，这都是一件好事。</p><hr><p>跑完步回来重新再读一遍，觉得以上这些大部分都是废话。虽然相比去年，这次的总结和计划已经简短很多了，但我还是觉得自己罗列了太多的东西。其实最核心的部分应该是列出自己最想要养成的习惯，对我来说是<strong>阅读</strong>和<strong>冥想</strong>，其它东西都是次要的，都是结果而已，只有行动才能带来结果。</p><p>两个习惯：每天早上冥想 30 分钟，每天晚上阅读 30 分钟。就这么简单。看年底会不会打自己脸。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
            <tag> Reviews </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向未来思考</title>
      <link href="/2021-12/"/>
      <url>/2021-12/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/XofZMIczTDo" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>我发现每到年底的最后一个月，人总是会变得忙碌起来，可能是内心的焦虑在起作用吧：一看还有那么多未完成的目标，心底的不安会让人想要补救式地勤奋一阵子。再加上周围舆论环境渲染出的氛围，大家都在谈论自己这一年的得失，如果你的内心不够坚定，可能还会忍不住拿自己和他人比较。不过，在坐下来整理自己的碎碎念的时候，内心会慢慢变得平静下来。过去的就让它过去吧，我们能把握的只有未来。写碎碎念的目的不也是为了记录以及给未来的自己做参考吗？要学会面向未来思考，不要浪费时间在抱怨和后悔上。</p></blockquote><span id="more"></span><h4 id="12-月-1-日-理解他人：相信每个人都在尽力而为"><a href="#12-月-1-日-理解他人：相信每个人都在尽力而为" class="headerlink" title="12 月 1 日 - 理解他人：相信每个人都在尽力而为"></a>12 月 1 日 - 理解他人：相信每个人都在尽力而为</h4><p>我觉得我们都需要学会理解他人，而理解他人的一个好的出发点是，相信虽然每个人都有自己的困难需要面对，但是大家都在尽自己所能，努力做到最好。以这样的心态，我们会变得更加宽容，碰到别人犯错的时候，我们也会容易变得有同理心。想想我们自己，其实也经常犯错，既然我们可以原谅自己，那么是不是也要在别人出错时多考虑下别人的处境。每个人都想要做到最好，但是总会有意外发生。当意外正好发生在我们身上的时候，不要用负面的思维方式，因为这只会让自己的处境变得更加糟糕，而是要用理解和宽容去化解眼前的不如意，况且我们只有在冷静的时候才能想出更多的解决办法。</p><p>尽管如此，还是想说：不要当一个老好人。我有时候觉得自己就有这种倾向，觉得最好谁都不得罪，非常害怕和别人起冲突。但其实这样有时候也会害了别人。在别人犯错的时候，最好的做法是善意地提醒对方，而不是一味地回避。让对方知道自己犯了错，并且能够得到教训，这样下次他就不会再犯同样的错误。这也是在帮助对方成长。如果每次犯错都能得到原谅，那么也许他永远也学不会改正自己的错误。过犹不及，凡事都是如此。除此之外，最最重要的一点是，要保证自己一定要做到凡事尽力而为。不求完美，但是力求做到最好。这样，即使是因为自己而没有达成目标或者中途犯了错，至少也能做到问心无愧。另外，我们也要学会对自己宽容。犯错不可怕，只要能在事后反省总结自己的错误，并且得到教训，下次不再犯类似的错误，这就获得了一次成长。</p><h4 id="12-月-2-日-掌控虚荣心"><a href="#12-月-2-日-掌控虚荣心" class="headerlink" title="12 月 2 日 - 掌控虚荣心"></a>12 月 2 日 - 掌控虚荣心</h4><p>每个人都有虚荣心，我们应该思考的是，如何让虚荣心有利于我们的发展，而不是阻碍我们的发展。比如我发现自己喜欢保持神秘感，因为这种神秘感可以让自己感到舒适。神秘感让人有无限遐想，什么都不用付出就可以得到他人的注意，尽管代价是和他人相处时的陌生感以及距离感。也许在一开始时保持神秘感是种好的做法，可以引起别人对你的兴趣，但是如果你想长时间维持这种神秘感，别人就会离你而去，因为你看起来不容易接近，而每个人都更喜欢一个容易相处的人，而不是一个你无法深入了解的人。另一个例子是，我有时候会因为虚荣心而接受别人的赞美，即使我知道这种赞美不是我应得的，是他人的误解，但是，我却不想去解释，因为这种「误解」让我感觉良好。这种做法虽然不属于主动撒谎，但其实本质上也是不诚实。因为虚荣而撒谎会让人走上歧途。所以，最好的做法是始终保持正直，即使是在无法解释的场景下，也要在心里告诉自己：这种评价不是自己应得的，不要被它迷惑。这样做之后，与接受虚假现实的你相比，你还是你，只不过会变得更加脚踏实地。最终，我们都要学会掌控自己的虚荣心。如果我们想要成为更好的人，想要获得他人的欣赏和赞美，就只能不断地付出努力，靠自己的能力和作品说话，而不是依赖某些外界的物品来让自己获得虚假的优越感。</p><h4 id="12-月-3-日-制造更具体的目标和生活的新鲜感"><a href="#12-月-3-日-制造更具体的目标和生活的新鲜感" class="headerlink" title="12 月 3 日 - 制造更具体的目标和生活的新鲜感"></a>12 月 3 日 - 制造更具体的目标和生活的新鲜感</h4><p>没有目标的人生不值得过。这两天经常思考：我能做什么？我近期和未来的目标是什么？似乎没有明确的答案。回顾自己最近的状态，工作没有什么起色，感情生活也处于空白状态，同时自己也没有太大的欲望和野心，想要学习新东西，但是也提不起什么劲，这样浑浑噩噩的日子不免让自己感到心慌。所以，我觉得我需要给自己制定出更加具体一些的目标，比如花三个月时间把某个项目完成到什么程度，或者一年后的月收入达到多少，等等。还有就是给自己的生活制造出一些新鲜感，比如尝试学习新的乐器，去做一些自己没做过的事。一个人的生活非常自由，但是也容易陷入颓废和养成一些不好的习惯，我应该把这些时间好好利用起来。年轻的时光非常宝贵，有些事情真的是只有在年轻的时候才适合去做，等自己的年纪再大一些，可能就体会不到它的乐趣了，比如玩滑板和谈恋爱。可能我这个人真的比较晚熟吧，别人大学里喜欢做的事，我却要到工作 4、5 年之后才开始感兴趣。不过，好在我长了一张比较显年轻的脸，所以还不至于太过奇怪。<strong>什么都可以尝试，一切皆有可能</strong>，我想在这样的幻觉破灭之前、中年危机来临之后，好好体验一下这种感觉。</p><h4 id="12-月-4-日-外星移民"><a href="#12-月-4-日-外星移民" class="headerlink" title="12 月 4 日 - 外星移民"></a>12 月 4 日 - 外星移民</h4><p>最近在看 Lost in Space 这部剧，讲的是地球生态环境恶化，在人类被迫移民其它星球的过程中，一个由科学家和工程师组成的家庭在新世界的险恶环境下共同努力求生的故事。每次看这种类型的剧都会忍不住幻想：如果未来有这样的机会，我会不会放弃地球上的一切去新的世界开始新的生活？虽然这样的假设在我有生之年实现的可能性很低，但是，的确光想想就觉得兴奋。虽然我对目前的这个世界都算不上有多了解，毕竟从电视、纪录片里看到的世界和真实的世界，差距还是非常大的。但是，我还是忍不住想要去亲眼看下外星生物长什么样。其实，如果能在有生之年得知外星生物的存在以及他们的生命形态，就觉得已经算是非常不错的了。从小就坚信我们不是宇宙中的唯一生命，如果能在自己离世之前验证自己当初的信念，那也算是没有遗憾了。毕竟，来过这个世界，而且还见过其它星球上的生命，这简直太酷了。</p><h4 id="12-月-5-日-宋飞和他的朋友们"><a href="#12-月-5-日-宋飞和他的朋友们" class="headerlink" title="12 月 5 日 - 宋飞和他的朋友们"></a>12 月 5 日 - 宋飞和他的朋友们</h4><p>最近重新开始看 Seinfeld，每天吃午饭的时候看一集，非常下饭。其实我一开始看 Seinfeld 的时候会觉得有点奇怪，为什么 Jerry 会和 George 和 Kramer 这样的人成为朋友？因为老实说，他作为一个受欢迎的 standup comedian，收入不低、风趣幽默、长相也不赖，似乎不应该和 George 这样偏执、敏感又小心眼的人成为朋友，而且普通人见了 Kramer 这样的邻居可能会想要立马搬家吧，Elaine 又是怎么从前女友变成一个异性好朋友的？后来多看了几集才算明白了，虽然他的朋友们有各种各样的「毛病」，但是本质上都是好人，而且他们能够一起相处地非常融洽，我觉得这才是作为朋友最重要的衡量标准。对于朋友，我们不需要在乎他们的身份或者其它外界因素，只要你们能够一起悠闲地聊天，享受和彼此的相处时间，就够了。另外，Jerry 作为一个 standup comedian，肯定需要从生活中取材，而他的这些看上去古怪的朋友恰好可以为他提供很多新笑话的灵感。况且现实世界中，又有多少人能做到 George、Elaine、Kramer 那种程度呢？为了朋友几乎能做任何事情，一般人能遇到一个这样的朋友就已经非常难得了吧。尤其是 Elaine 这样的人，风趣幽默、不做作，有多少人能和自己的前女友继续做朋友？老友记里六个人的朋友关系太过完美，我觉得普通人可能更应该追求 Jerry 和他的朋友们之间的那种关系。我们彼此坦诚相待，而且喜欢和对方待在一块儿打发时间。</p><h4 id="12-月-6-日-对钱的态度的转变"><a href="#12-月-6-日-对钱的态度的转变" class="headerlink" title="12 月 6 日 - 对钱的态度的转变"></a>12 月 6 日 - 对钱的态度的转变</h4><p>对于很多像我一样从农村来到城市的人来说，想要真正在城市立足，买房是第一道坎。刚好最近正在经历这个事儿，所以来聊聊买房的话题吧。首先，我觉得如果你决定在一个地方长期发展下去，那么在当地拥有一套房产肯定会变成一个自然而然的需求，因为你肯定不愿意一直靠租房生活。租的房子再怎么好，也不会有真正的家的感觉。而且在大多数一二线城市，你一个人也不太可能租到太好的房子，除非你不差钱。另外，租房还有一个室友的问题，如果你是和自己不认识的人合租，你的租房体验还要承担额外的风险，因为你不知道自己的室友是个什么样的人，比如是否爱干净等。既然拥有自己的房子是一个实实在在的需求，加上大城市房价上涨的趋势没有停歇的意思，所以当然是越早拥有自己的房子越好。</p><p>虽然有的人会说，买了房就会有种被束缚的感觉，房贷的压力会限制你未来的发展。不过我的想法刚好相反，我觉得买了房之后你反而会获得更大的动力去努力工作和想办法赚钱。在没有买房之前，你可能还有退缩的余地，但是一旦背负上债务的压力，你会不得不去面对那些自己不愿面对的事情，比如钱。我过去对钱采取的一直都是不太在意的态度，觉得自己一个人反正饿不死就行，但是现在的想法完全不同。我过去当然也知道钱是个好东西，只不过没有像现在那么重视它。此刻的我的想法是，钱就是一个人价值和能力的外显，是他身边的人以及市场对他做出的贡献的反馈。当然，这里面有运气的成分，但是我相信，绝大多数人都可以不靠运气，仅凭自己的努力，也能让自己的价值得到充分的发挥。所以，不要抗拒这个事实，要爱钱。大多数想要变得更加富有的人要做的第一件事就是正确认识钱，要对钱产生渴望，但是又不至于变成钱的奴隶。Learn how to monetize, and learn how to say no.</p><h4 id="12-月-7-日-父母的爱"><a href="#12-月-7-日-父母的爱" class="headerlink" title="12 月 7 日 - 父母的爱"></a>12 月 7 日 - 父母的爱</h4><p>今天去售楼处签认购合同，还好有老姐陪我去，不然一个人真的会有点不知所措。领资料、签一堆材料、按手印，基本上都是对方让我干什么我就干什么，就算上面写的是卖身契，估计我也是不看就直接签了(ಡωಡ)。买房付首付应该是我目前为止做的最大的一笔支出了，心里难免有点紧张和兴奋。当然，这一切离不开家人的支持，尤其是爸妈，如果没有他们掏老本把攒的养老钱都给了我，我是无论如何也付不起首付的。没啥好说的，只能以后慢慢还债。不过这么说可能有点太现实了，他们也是因为爱我才愿意付出自己的所有。只有父母对子女的爱才可以这样付出并且不求回报吧。但是，我之前也说过，有时候这种爱会让人觉得窒息。因为你会不自觉地给自己一种压力，那就是我要回报他们，而当你意识到自己当前的能力还不足以回报他们的爱的时候，你会对自己感到失望。更常见的情况是，你会屈服于父母对你的爱和付出，于是选择听从他们对你的人生的指导和规划。这其实也是一种糟糕的选择，我们会因此而失去为自己的人生做主的能力。还好此刻的自己还不至于走到这种地步。我现在能做的，只有先把自己的人生过好，然后尽自己所能，回馈他们的爱。承认他们的付出，关心他们，体谅他们，尽可能多地花时间陪伴彼此。</p><h4 id="12-月-8-日-知足和学会感恩"><a href="#12-月-8-日-知足和学会感恩" class="headerlink" title="12 月 8 日 - 知足和学会感恩"></a>12 月 8 日 - 知足和学会感恩</h4><p>今天早上醒来突然有个顿悟，那就是我是幸运的：做着自己喜欢的工作，有无条件支持自己的家人，有信任我的同事和伙伴，还有什么可以奢求更多的呢？我已经感到非常满足了。关于爱情，遇到一个你喜欢而且对方也喜欢你的人，我觉得这已经超出自己的控制范围了，我现在要做的是让自己配得上目前所拥有的一切。而让自己配得上的唯一方法是，更加努力地工作，更加努力地提升自己的能力，问问自己能为他人做什么，不要抱怨任何事物，学会表达感恩。</p><h4 id="12-月-9-日-那些应该尽早犯的错"><a href="#12-月-9-日-那些应该尽早犯的错" class="headerlink" title="12 月 9 日 - 那些应该尽早犯的错"></a>12 月 9 日 - 那些应该尽早犯的错</h4><p>我觉得人在年轻的时候，最需要明白的一点是，<strong>犯错并没有那么可怕</strong>。因为我们的人生还很长，有足够的时间去纠正自己的错误。事实上很少有什么错误是真正无法挽回的。只要我们愿意改变自己，大部分错误其实都是让自己成长的机会。当你具备了这样的心态的时候，你对自己过去犯的错误会更加坦然。而且已经发生的事情无法被改变，你只能改变还未发生的事。做好准备，应对接下来可能出现的一切挑战就可以了。我过去犯过很多大大小小的错误，幸运的是，最终并没有给自己或者他人造成非常大的伤害，但是要说自己学到了哪些教训，好像并没有太多。唯一可以确定的是，我未来还会继续犯错，有些错误可能还会一再地犯，但是，我知道最终自己一定是可以纠正自己的。我对犯错的态度是，既然它一定会发生，那不如让它来得更早一些，这样我就可以避免在未来再犯这些错误，从而造成更严重的后果。这样的错误可以是：和他人交往中会犯的错误，财务管理过程中犯的错误，还有积累技能时犯的错。那么，有哪些错误是应该永远避免的呢？目前能想到的是：受骗上当、结交烂人、沾染坏习惯。</p><h4 id="12-月-10-日-理想的朋友和合作伙伴"><a href="#12-月-10-日-理想的朋友和合作伙伴" class="headerlink" title="12 月 10 日 - 理想的朋友和合作伙伴"></a>12 月 10 日 - 理想的朋友和合作伙伴</h4><p>马克思说过人的本质是一切社会关系的总和，那么我最重要的社会关系是哪些呢？父母、亲属，然后是朋友和同事，最后是一些熟人。在所有的社会关系中，和我最接近的人往往对我的影响也最大，所以我们的父母和关系亲近的亲属对我们的影响是最大、最广泛的，而且这种影响基本上会持续终生。我们能够控制的只有自己的朋友和合作伙伴。朋友是一个人赖以生存的基础，理论上来说不存在没有朋友的人，因为朋友不一定是现实中的某个人，也可以是素不相识的某个人，甚至有可能他已经不在这个世界上了，比如某个逝去的作家。当然，大多数人会选择自己生活空间内的某个人作为自己的朋友，分享彼此的生活，相处陪伴彼此等等。我觉得最好的朋友除了可以做以上这些事情之外，还应该帮助彼此成长，互相鼓励，给对方提供建议，希望对方能够过得更好，实现自己的理想和目标。如果身边能够拥有一两个这样的朋友，那真的是一生的财富。至于合作伙伴和同事，我觉得理想情况下，也应该是建立在朋友的基础上，只不过我们拥有相同的目标，一起做事，为了共同的利益而努力。同样的，要找到这样的工作也很难。你要让自己先成为自己理想中的朋友和合作伙伴，才能慢慢找到和你相同的人。</p><h4 id="12-月-11-日-自我剖析：学会如何认识新朋友"><a href="#12-月-11-日-自我剖析：学会如何认识新朋友" class="headerlink" title="12 月 11 日 - 自我剖析：学会如何认识新朋友"></a>12 月 11 日 - 自我剖析：学会如何认识新朋友</h4><p>尽管我知道应该交什么样的朋友，但是自己似乎从来都不擅长主动去交新朋友。之前有分析过这有可能是因为自己过于挑剔，习惯先看到他人身上的缺点而不是优点。道理其实都懂，世界上没有完美的人，我自己身上也有一堆毛病，但是现实中却做不到这一点。心里总是喜欢盯着彼此不同的地方，觉得因为对方身上和自己的差异，或者因为对方的某个观点和自己不一样，我们肯定没法好好相处。于是，对方也会开始用同样的态度对待你，在你身上挑刺，最终大家只能够维持着一种距离感，以陌生但又不触犯彼此的方式相处。回想自己过去身边所有的人际关系，似乎都可以总结为这种模式。所以，我从来没有遇到过一个可以无话不谈的好朋友。即使遇上了，可能也会因为我的这种态度而不欢而散。我这里描述的只是一种现象，并不是为了批判自己。虽然我的描述和现实可能有些差别，但是总体是符合实际情况的。那么，我要如何改变这种状况呢？我在碎碎念里无数次提到要改变自己的态度，但是文字叙述和在现实中做到，这两者之间可能隔了一个地月距离吧。有没有更实际一点的做法呢？我觉得一个人的处事方式不是一天两天形成的，想要在短时间内改变是非常困难的，我们能做的只有<strong>循序渐进地改变自己</strong>。那就从主动和人打招呼<strong>开始做起吧，然后学会正确</strong>表达自己的想法和需求。先做好这两点就足够了。</p><h4 id="12-月-12-日-被问题击中后解除僵直的做法"><a href="#12-月-12-日-被问题击中后解除僵直的做法" class="headerlink" title="12 月 12 日 - 被问题击中后解除僵直的做法"></a>12 月 12 日 - 被问题击中后解除僵直的做法</h4><p>我们总是会在某一刻突然发现，原来自己有这么多问题需要面对，然后会陷入不知所措的状态。但是，问题不会自己消失，除了冷静下来思考解决的办法，没有别的路可选。连岳说过，你不解决麻烦，麻烦就要解决你。所以，我学到的第一点是：不要逃避问题。其次，要有一个良好的心态。有些问题虽然棘手，但是不是非常紧急，我们可以以时间换空间，先想想有什么临时的解决办法，把最棘手的问题留到以后慢慢解决。当然，最好的做法是一步到位，但是现实总是做不到完美，你要学会接受这一点。其次，要相信没有什么问题是解决不了的，即使有，我们还可以借助外力去解决它。我们毕竟都只是普通人，普通人的首要任务是把自己的生活过好，而生活是有很大的容错性的，不存在什么致命的问题需要我们必须立马去解决它。当然，前提是你不要犯什么大错，比如 all in 一个你根本不懂的领域，俗称「被骗了」。最后，在问题解决之后，我们还要学会反思自己，如何避免以后再犯相似的错误，如何避免被意外击中。唯一的做法是平时就注意积累这样的经验，多多提升自己的认知，不停地学习，提高自己解决问题的能力，提高自己风险承受能力（俗称「多赚钱」）。</p><h4 id="12-月-13-日-关爱你身边的所有人"><a href="#12-月-13-日-关爱你身边的所有人" class="headerlink" title="12 月 13 日 - 关爱你身边的所有人"></a>12 月 13 日 - 关爱你身边的所有人</h4><p>人与人相处最重要的是什么？除了平等与尊重，最重要的是关爱他人。无论你是顶级运动员又或者是普通上班族，如果想要受到他人的欢迎，那么就必须做到这一点。这样看来，那些受到大众关注的人更容易得到批评也就不奇怪了，因为即使他们愿意、想要去关爱更多的人，但永远也不可能同时满足所有人的愿望。不过，如果能够得到单独相处的机会，一个人是否关爱他人很容易就能从他的行为表现中体现出来。对我来说，这方面我一直做得很差。一方面和我的性格有关，我是偏疏离型人格，自然而然地就会与他人保持距离感，而且常常觉得他人不值得信任。所以，我也不太会去主动关心他人。但是，我觉得这点是可以被改变的。首先，我有良好的意图，我愿意帮助他人。其次，我相信我们本质上都是同一种人，我们身上的相同点远远多于彼此的不同之处。最后，我愿意改变自己，我希望通过这样的改变可以让自己的生活变得更加充实和令人满意。那么，我要如何做呢？从关爱身边最亲近的人做起，然后是身边的同事，还有不常见的家人、朋友，最后是身边所有的陌生人，任何人都可以是我们的朋友。</p><h4 id="12-月-14-日-提高自己的心力"><a href="#12-月-14-日-提高自己的心力" class="headerlink" title="12 月 14 日 - 提高自己的心力"></a>12 月 14 日 - 提高自己的心力</h4><p>如何提高自己的心力？辉哥说要从三方面入手，首先是对环境的合理假设，即世界不完美以及人性积极。世界不完美指的是你不能期望自己拥有完美的环境。环境一直在改变，你不可能等到条件成熟才去做事，必须学会接受不完美，并且努力去适应环境。人性积极指的是你要相信他人都希望能把自己的事情做好，除非是在小说里，没有人愿意看到世界朝着混乱无序的方向发展。其次，我们要花时间打造自己的核心能力。每个人都有自己最核心的能力，我们要把资源投入到如何把核心能力提升到卓越层级，这样我们才能形成个人的口碑和声望，他人在遇到该领域内的难题时，第一时间会想到的就会是我们。另外，除了投入资源在核心能力上之外，我们还要学会识别制约自己发展的短板，找到并识别它们，如果我们能将这两者结合起来，我们就可以无边无际地成长下去。最后一点是「君子求诸己」，也就是遇到问题时向内找原因。反思自己哪些地方没做好，并且在下一次相似的情景中做出改变，只有这样我们才能获得成长。无论什么不利的情况发生，首先要承认事情没做好这个事实，然后是反思自己做得不足的地方，并且坦诚地和自己的伙伴沟通。这样做的好处是，他人也会慢慢变得开放和坦诚，这样所有人都能从错误中获得改变和提升的机会，整个组织也能不断地朝着越来越好的方向发展。</p><h4 id="12-月-15-日-阅读的精髓是一遍遍地重复"><a href="#12-月-15-日-阅读的精髓是一遍遍地重复" class="headerlink" title="12 月 15 日 - 阅读的精髓是一遍遍地重复"></a>12 月 15 日 - 阅读的精髓是一遍遍地重复</h4><p>有人说一旦停止阅读三天以上，就会开始觉得镜中的自己变得面目可憎。我已经连续好几个礼拜没有阅读了（如果公众号文章不算的话），所以，有时候连每天早上的碎碎念也不知道该怎么写了。我也渐渐体会到，对于文字工作者来说，阅读真的非常重要，一方面阅读可以让你保持对文字的敏感，另一方面还可以让你源源不断地获得灵感与话题。我们每天接收那么多的信息，但是对自己生活真正起到促进作用的，真的很少。虽然我常常会一刷推就刷个把小时，但是大多数文字看过之后就被忘得一干二净了。文字信息只有在一遍遍重复之后才能刻进你的脑子里。因此，长时间聚焦在一个话题上的阅读、反复琢磨才是吸收知识的正确方式。重新开始阅读吧。</p><h4 id="12-月-16-日-保持大脑极度开放"><a href="#12-月-16-日-保持大脑极度开放" class="headerlink" title="12 月 16 日 - 保持大脑极度开放"></a>12 月 16 日 - 保持大脑极度开放</h4><p>如何做到保持大脑极度开放？首先，要承认自己有犯错的可能。尤其是对自己熟悉的领域，我们常常会觉得自己已经做了足够的调研，或者觉得自己有足够的权威，但是这并不代表自己就一定是正确的。始终记得自己有可能会犯错会让我们保持谦卑，也会对自己的工作做得更加细致。其次，客观看待他人的批评。我们大多数的批评来自我们的上级或者平级的同事，得到批评很有可能说明我们的工作没做好，而大多数人的第一反应是为自己辩解。但其实这种做法完全没有任何意义。你要看到隐藏在批评背后的改进自己的机会，比如自己做得不足的地方，下次如何改进；对方提出的哪些反馈对自己来说是宝贵的建议，你能从这些批评中看到自己的哪些弱点等等。珍惜每一次他人对你的批评，因为这些都是帮助你提升自己的机会。你能得到批评的渠道越多，你成长的空间和速度也越快。尤其是当你的能力达到一定高度的时候，这个时候得到的真诚的批评可能会越来越少，所以只有在自己能力还不足的时候就培养起这种愿意接受他人批评的特质，你才能逐渐得到更多来自同事和朋友对自己的真诚的反馈。</p><h4 id="12-月-17-日-你选择如何生活？"><a href="#12-月-17-日-你选择如何生活？" class="headerlink" title="12 月 17 日 - 你选择如何生活？"></a>12 月 17 日 - 你选择如何生活？</h4><p>马上就要年底了，回顾了下年初订下的计划，完成情况惨不忍睹，不过好在我早就料到了这种情况，所以也没有太失望的感觉。新的一年马上开始了，那就再接再励呗。随着年龄的增加，越来越觉得，其实一切都没什么关系。人生很长，虽然过去浪费了很多时间，但是人只要一旦开始醒悟，并且开始弥补自己犯下的错误，进步会非常迅速，最终一切都会变得好起来。虽然不同的人醒悟的时间早晚不同，但是总体来看，这个时间点什么时候到来都不算晚。人是被使命感驱动的生物，一旦你获得了使命感，你会感到自己充满活力，生活仿佛重新燃起了斗志。哪怕再过几个月就要死去，你的使命感也会促使你在这几个月内把自己能做的部分都做好。我过去觉得人在生死面前只能听天由命，但是现在觉得，生死其实只是生活的一部分，没有生就没有死，而没有死亡，人生的意义感就不存在了。既然我们最终都是要走向死亡的，那么，就要在自己还活着的时候，好好珍惜自己的生命，珍惜自己和家人和朋友的相处时间，珍惜自己所拥有的一切，珍惜这个世界上一切美好的东西。死亡无法避免，但是我们可以在活着的时候选择如何生活。</p><h4 id="12-月-18-日-缺乏挫折和失败的劣势"><a href="#12-月-18-日-缺乏挫折和失败的劣势" class="headerlink" title="12 月 18 日 - 缺乏挫折和失败的劣势"></a>12 月 18 日 - 缺乏挫折和失败的劣势</h4><p>最近打算开始写年终总结，回顾自己这一年经历的时候想到一个问题，那就是自己过去似乎从来没有经历过特别重大的挫折。这当然是一件好事，没有人希望被意外和痛苦击中。但是，换个角度这也是个缺陷，因为人在经历痛苦和挫折之后，往往能成长得更快，也更加能明白努力的意义。回顾自己这二十多年的经历，我能想到的最大的挫折可能也就是高考只考了个三本，大四的时候差点因为挂科太多而延期毕业。工作之后的经历也非常平淡无波澜，进入一家外企工作一年多，然后进入一家中小型创业公司工作三年，然后来到现在的公司。除此之外，我也没有做过特别冒险的事情，所以也没有经历过特别大的失败。我觉得这也能解释我现在的状态吧，不擅长且恐惧与人交流，这是因为我没有特别多这方面的经历；面对比较大的困难的时候，心里总是会感到抗拒，而不是感到兴奋；常常容易感到失去耐心；对于他人的犯错总是耿耿于怀，容易小心眼；等等。</p><p>我害怕自己一直保持这种状态，所以想要改变自己。比如，如果以后我想要创业，那么我将面对的困难将会比现在遇到过的难上许多倍，而我能力上欠缺的地方太多了。不过，还好我比较擅长反思自己，经历的挫折比较少有可能是因为自己成功避过了那些风险比较大的坑。虽然以后依然有可能会遇上，不过，我觉得只要你能锻炼出比较强大的情绪和心理调节能力，做好足够的准备，给自己留出足够的安全空间，那就没什么好害怕的了。也许当真正的挫折来临的时候，我还是会无法承受甚至直接崩溃，但是我相信自己最终一定是能挺过去的。勇敢地去面对一切未知吧。</p><h4 id="12-月-19-日-承担责任：你不需要他人的监督"><a href="#12-月-19-日-承担责任：你不需要他人的监督" class="headerlink" title="12 月 19 日 - 承担责任：你不需要他人的监督"></a>12 月 19 日 - 承担责任：你不需要他人的监督</h4><p>周末的时候总是控制不好娱乐和学习的时间，总是会忍不住长时间刷社交网站或者看视频，所以有时候会忍不住想，如果我不是一个人的话，比如身边有个人监督自己的话，是不是就不会这样了。但是转念一想，如果一个人的时候都做不到自律，和他人在一起的时候就能做到吗？你怎么知道结果不是两个不够自律的人一起堕落呢？祈求有一个监督自己的人就是一个偷懒的做法，这意味着把决定权交给别人，背后暗含着「我不想为自己负责，你要为我负责」的想法。如果你自己都做不到对自己严格要求，又怎么能祈求别人能做到？即使他人能够做到对你严格，你又怎么知道这种严格是否真正有利于自己未来的发展？因为他人并不非常了解你真正想要达到的目标。所以，我觉得最佳的做法还是保持我们作为独立个体的尊严，每个人都承担起自己的责任，包括为自己做选择以及承担选择后的后果。即使是和自己最亲爱的人在一起，也不要放弃这种「我的人生完全由自己负责」的态度，这是我们生而为人的根本所在。也许那些小的方面可以交给他人做决定，比如新的发型、服装风格、值得尝试的美食等等，但是像「如何成为我们自己」这样的核心是绝对不可以交给他人来决定的。而为自己做决定的关键在于如何做到更了解自己：我想要实现什么样的目标？我想要如何度过自己的人生？我最看重什么，我最核心的价值观是什么？如何才能长期服务于提高自己和他人的幸福和健康水平、创造更多价值？如果你能够回答出这些问题，你就能制定出清晰的计划，并且不需要他人监督也能够朝着目标不断地努力下去。</p><h4 id="12-月-20-日-耐心、坚持-热情"><a href="#12-月-20-日-耐心、坚持-热情" class="headerlink" title="12 月 20 日 - 耐心、坚持+热情"></a>12 月 20 日 - 耐心、坚持+热情</h4><p>我们所做的所有事都是为了获得更大的自由。财富并不能给我们带来更多的快乐，但是可以给我们选择权，选择不去做某些事的自由。但是，如果你能找到自己真正愿意花时间、投入精力去做的事，即使无法获得足够的金钱上的激励，也不能获得他人的肯定，或者得到世俗意义上的成功，但你依旧能够获得自由。所以，真正关键的是如何让自己投入到一件自己能够收获快乐和成就感的事情中去，无论它是什么。如果你还没有找到这样的事业，那也没关系，就先去建立和拓展自己的技能集合，获得稀缺而又有价值的技能。如果你连这点都做不到或者想不清楚，那还是没关系，你还可以先把自己目前能做到的事情做好。对一个二十几岁的人而言，时间是你最好的朋友。耐心、坚持加热情，仅凭这三点基本就可以帮助你克服你能遇到的所有的困难和挑战。</p><h4 id="12-月-21-日-自我改变之路"><a href="#12-月-21-日-自我改变之路" class="headerlink" title="12 月 21 日 - 自我改变之路"></a>12 月 21 日 - 自我改变之路</h4><p>人的性格是天生的吗？一部分取决于我们的基因，另一部分则是由于我们的成长环境。而这两点都是我们无法主动选择的。比如我的性格，不爱交际，喜欢独处，凡事都觉得应该靠自己解决，这些特质很明显是来自我妈，因为她也是这样的人。另外，我喜欢新事物，对音乐非常热衷，做事特立独行，这些则来自我爸。你的父母和家庭环境决定了你的性格和爱好，因此也决定了你未来会成为什么样的人。这么说似乎有些消极，难道我们就无法自己决定自己的人生了吗？成年之后的我们也许还有机会改变自己，但是这样的阶段往往持续时间很短，比如在我们离开家第一次独立生活的时候。对大部分人来说是高中、大学阶段，以及毕业之后 5 到 10 年内。在这之后，绝大部分人的生活节奏都会逐渐变得稳定下来，所以改变的窗口也逐渐关闭。如果你错过了这个时间窗口，之后再想要改变自己，难度会大上很多。幸运的是，自己目前就处于这个窗口期的最后阶段，我觉得自己还是有机会去改变自己，重新塑造自己的性格、观念、习惯等等，我希望自己能够变得更擅长与人沟通，能够自由地表达自己的想法，变得更加开放和坦诚，通过分享自己的一切，去帮助、连接更多的人。这是一条伟大的自我改变之路，我希望自己能一直走下去。</p><h4 id="12-月-22-日-如何保持投入"><a href="#12-月-22-日-如何保持投入" class="headerlink" title="12 月 22 日 - 如何保持投入"></a>12 月 22 日 - 如何保持投入</h4><p>有时候总是觉得自己无法长期投入做一件事，其实不是因为自己缺乏集中注意力的能力，而是没有在心理层面说服自己眼下这件事是值得做的。如果你不相信一件事的意义，那么你自然不能全身心投入进去。所以，最近我常常问自己的一个问题是：这件事对我有什么样的意义，对他人又有什么样的意义？明白了一件事的意义之后，我们才可以开始行动起来，思考如何用最佳的方式去完成它。即使是一个一下子难以解决的问题，因为知晓其意义，我们也不会在内心觉得有抵触，首先把可能的解决方案都列出来，然后逐个尝试，如果暂时没有思路，可以先让自己休息一会儿，尝试从其它角度理解这个问题，然后解决方案可能就会慢慢浮现出来了。另外，对于自己不想做的事，可以先尝试做个 5 分钟，告诉自己如果 5 分钟之后自己还是不想做这件事就可以去做其他事。通常情况下，通过这 5 分钟的集中注意力，获得一点进度之后，我们会得到继续工作下去的动力。总结一下，要让自己长时间投入做一件事，进入心流状态，我们需要明白这件事对自己的意义，并且学会制造意义；对于依旧不想做的事，可以尝试 5 分钟法则，允许自己只做 5 分钟，如果还是不想做，那就停下来先去做别的事。</p><h4 id="12-月-23-日-工作只是生活的一部分"><a href="#12-月-23-日-工作只是生活的一部分" class="headerlink" title="12 月 23 日 - 工作只是生活的一部分"></a>12 月 23 日 - 工作只是生活的一部分</h4><p>工作和生活应该区分开吗？理想情况下，工作应该就是我们生活的一部分，我们的工作定义了我们自己，每个人自身价值感的一大部分就是通过工作来体现的，大多数人的理想也都是通过工作来实现的。但是，对于绝大多数人来说，工作只是一个谋生的手段，虽然可以获得其它附带价值，但这并不是因为他们真的热爱自己的工作，如果有得选，大多数人可能会选择别的工作，或者干脆不工作。既然如此，我们要如何看待工作？我觉得工作只是生活的一部分，我们通过工作为他人创造价值，同时也能获得报酬，维持自身的生存和发展。但工作终究不能代表我们的全部。这个世界太大了，值得体验的事物太多了，我们最终会组建家庭，去认识新朋友，以及花时间在各种各样的兴趣爱好上。这些东西全都组合在一起，才构成了我们的生活，成就了今天的我们，让我们成为一个完整的人。虽然在工作中我们能体验到很多，也能得到许多挑战和成长，但生活其它方面的经历同样能给我们制造出许多新体验和挑战，我们不应该忽视任何一个方面。</p><h4 id="12-月-24-日-我更喜欢真实世界中的月亮"><a href="#12-月-24-日-我更喜欢真实世界中的月亮" class="headerlink" title="12 月 24 日 - 我更喜欢真实世界中的月亮"></a>12 月 24 日 - 我更喜欢真实世界中的月亮</h4><p>最近 The Matrix Awakens 发布了一支<a href="https://www.youtube.com/watch?v=WU0gvPcc3jQ">预览视频</a>，使用虚幻 5 引擎打造，看完让人对次世代游戏又多了一份期待。但是看完视频和大家对它的讨论之后，我不禁开始思考：游戏打造出的世界越来越接近现实是件好事还是坏事？对游戏玩家而言，当然是越接近现实越好，因为这样我们对游戏世界就更有代入感。而且游戏一旦具备了这种能力，这意味着游戏开发者可以打造出任何游戏设计师能够设计出的世界，这绝对是一件让人兴奋的事情。昨晚下班回家的路上，抬头看到天空中挂着一轮明亮的月亮，似乎已经很久没有看到过这样的月亮了。于是突然意识到一个问题：如果游戏中每天都能看到这样的月亮，而且更大、更亮，你会选择去看游戏里的月亮还是在现实中的月亮？我觉得我还是会选择现实中的月亮。正是因为少见所以我才会感到印象深刻，如果随时都能见到，而且体验比真实世界更好，我就不见得会有这样的感受了。游戏中我们体验到的东西都是过渡渲染的，现实世界中很难真正体验到，正是因为有了这样的对比，才让游戏有吸引力；但是，现实世界中的人和物体受限于物理法则，无法拥有像游戏中一样的能力。所以，我很好奇，在新奇体验和真实之间，大多数人会如何作选择？</p><h4 id="12-月-25-日-独立的原因和雄狮少年"><a href="#12-月-25-日-独立的原因和雄狮少年" class="headerlink" title="12 月 25 日 - 独立的原因和雄狮少年"></a>12 月 25 日 - 独立的原因和雄狮少年</h4><p>又到了圣诞节的这一天，忘了去年过圣诞是什么样的场景，翻了翻那天的日记和碎碎念，似乎那时候根本就没觉得这天有什么特殊。本来也是，一个人的话就不会想到要有太多的仪式感，毕竟自己开心就好。突然想到，其实我这样性格的人也有一个好处，那就是凡事只能求自己，因为身边没有朋友可以帮忙。你只能自己化解情绪，搞定那些看似搞不定的难题，一个人去面对所有可能的困难。很难说是因为我的性格造就了我身边缺少朋友这个现实，又或者是因为没有朋友所以造就了我喜欢独立解决问题的习惯。可能两者互为因果吧。</p><p>昨晚去看了雄狮少年，挺好看的一部片子，让我对国产动画电影有了新的看法，原来国产动画也是可以讲出一个真实、精彩而又不做作的故事的。看这部电影的时候，有几个瞬间觉得自己就是阿娟。可能每个农村长大的孩子，离开成长的村镇，来到城市之后，接触到不同的人和事，多少都会有种自己不如别人的感觉。我虽然并没有觉得自己曾经因为自己的身份受到过欺侮或者歧视，但内心还是常常会觉得，自己和那些城市中产家庭长大的孩子有很大的不同。也许我们所受的学校教育差不多，但是我们所受的家庭教育可能相差很大；我们可能喜欢相同的歌手和乐队，但我不一定有过和他们一样的去现场看演唱会的经历；我们都在工作后经济独立，但是我们对待财富的观念不一定相同。我觉得这些是自己和那些城市中产间最大的区别。所以，可能只有很少很少的人才能和自己观念一致吧。不过，现在来说这些都不重要了，重要的是要让自己养成更多好习惯，生活地更加自由。即使是一个人，也要过得充实。即使无法拥有幸福，至少还可以拥有平静。</p><h4 id="12-月-26-日-家人是你最大的宝藏"><a href="#12-月-26-日-家人是你最大的宝藏" class="headerlink" title="12 月 26 日 - 家人是你最大的宝藏"></a>12 月 26 日 - 家人是你最大的宝藏</h4><p>每次回家都会有种从理想掉进现实的感觉，和家人相处一会儿立马就能意识到很多自己一个人生活时容易忽视的东西，比如钱。不过，回过头想想，一个人的时候当然比较自在，可以不用考虑那么多，但是当你有了需要你照顾的家人的时候，你还能像现在这样思考吗？大多数情况下，我觉得只要能够做到问心无愧就可以了。如果以后我有了自己的家庭，我希望自己也能拥有这样的心态。说回家人的话题，我觉得我们虽然无法改变自己的家人，但是我们可以影响他们。我以前也想过要改变自己的家人，但是发现连改变自己都很难，又怎么可能去改变别人？所以也慢慢接受了家人们原本的样子。我们都不完美，但是我们愿意花时间陪伴、照顾、理解彼此。能够得到回应的爱是这个世界上最美妙的东西。</p><p>我一直以「喜欢努力的人」自我标榜，但是似乎从来都没有意识到我的爸妈就是我身边的榜样，虽然他们做的工作很普通，但他们一直都在努力地生活，努力照顾好自己和家人。二十多年来我一直见证着这一切，但是我从来没有想过要感谢他们。不知道为什么突然变得有点煽情，可能是因为节日气氛吧。我一直是个比较迟钝的人，感情上如此，对待家人的态度上也是如此。但是，什么时候醒悟都不算晚。人是观念的产物，一旦意识到自己的责任，他/她的行动也会变得积极主动而又迅速起来。虽然我也知道有时候我们的表达掺杂了很多情绪成分，但是，我希望自己可以记住此刻的情绪，我相信情绪是更加真实的自我。当理性思考烙进大脑深处的时候，它就变成了情绪，成就感、爱意、善意、赞赏之情，皆是如此。我好像从来没有像现在这样感到感恩过。拥有一个爱你的家人真的是全世界最美好的事，因为你知道，即使没有人愿意爱你、接纳你，无论如何，你至少还是可以回到你的父母身边。嗯，没有什么好害怕的了。</p><h4 id="12-月-27-日-找到适合自己做的事以及养成好习惯"><a href="#12-月-27-日-找到适合自己做的事以及养成好习惯" class="headerlink" title="12 月 27 日 - 找到适合自己做的事以及养成好习惯"></a>12 月 27 日 - 找到适合自己做的事以及养成好习惯</h4><p>如果想获得更多的自主力，要做的第一件事是想清楚自己的优劣势，然后养成更多的好习惯。我擅长什么？我能够做什么？我做哪些事能够比其他人做得更好？人们愿意为我提供的产品和付出的劳动付费吗？雇主看中的是我的什么能力？哪些事是我可以尝试的？哪些事不值得花费自己的注意力？如果你能想清楚这些问题的答案，那么你就不用害怕找不到方向了。不停地去尝试，总会有天能发现真正适合自己做的事。发现适合自己做的事，这是每个人的人生中最重要的事情之一，其次就是养成好习惯。好习惯定义了我们，决定我们会成为什么样的人。即使你知道自己要做什么，但是如果没有好习惯，你不可能做得太好。因为任何一件事，要达到卓越的程度，都意味着我们要付出巨大的努力和付出。如果你不能照顾好自己的身体和精神，你可能甚至都达不到优秀的程度。而好习惯的维持同样需要我们付出许多努力，这是一件长期的工程。如果你知道自己应该做什么，也能养成支撑自己生活地更加健康、工作更加高效的习惯，那么你就是无敌的。即使没有获得世俗意义上的成功，我觉得你也可以做到生活得幸福快乐。这就是我的人生目标。</p><h4 id="12-月-28-日-学会适应和改变自己的生活"><a href="#12-月-28-日-学会适应和改变自己的生活" class="headerlink" title="12 月 28 日 - 学会适应和改变自己的生活"></a>12 月 28 日 - 学会适应和改变自己的生活</h4><p>昨晚第一次尝试了电热毯，钻进被窝的那一刻被感动到了，没有什么比在冬天拥有一个暖和的被窝更让人感到幸福的了。于是开始反思自己为什么没有早点尝试电热毯，顺便开始思考自己的生活中还有哪些像电热毯这样的能极大提升幸福感的东西是缺失的。我发现很多时候阻碍我们生活得更加幸福的不是我们的经济条件，而是我们太过于习惯去过一种和过去相同的生活。生活其实一直是在发展变化的，我们要做的是不断适应新变化，及时调整和改变自己的生活习惯。比如，我以前从来没有意识到固定的起居习惯会给自己的生活带来多大的改变，但是自从养成这样的习惯之后才发现过去没有这样的习惯的自己有多么愚蠢。我觉得每个人都应该养成固定的作息，良好的生活和工作习惯，并且不断地对其优化、做出调整和改变，只有这样之后我们才能有足够的时间去反思自己，以及产出更大的价值。</p><h4 id="12-月-29-日-关爱自己"><a href="#12-月-29-日-关爱自己" class="headerlink" title="12 月 29 日 - 关爱自己"></a>12 月 29 日 - 关爱自己</h4><p>人在年轻的时候往往是话语权最弱的时候，在学校需要听老师、家长的话，毕业了又得听公司领导的安排，除了同辈，没有人想要听我们说话。如果你恰好还是一个性格内向不爱说话的人，那么大多数时候你只能不停地和自己对话。不过，我觉得和自己对话是个人成长中非常重要的部分。因为人只能通过不断的自我对话才能发现自己的优劣势，并且学会关爱自己。爱自己非常重要，在这方面我们永远都有提高改进的空间。爱自己不但意味着要养成好的习惯，照顾自己的身体和精神，做对自己长期有价值的事，还意味着要学会为自己思考，去发现潜在的机会和需要改变的地方，反思、反省自己，让自己变得越来越好。当我们变成一个越来越勇敢、越来越自信，对自己的人生有越来越大掌控的人的时候，我们的一切成就都离不开当初那个把关爱自己放在第一位的决定。</p><h4 id="12-月-30-日-内向性格的优势"><a href="#12-月-30-日-内向性格的优势" class="headerlink" title="12 月 30 日 - 内向性格的优势"></a>12 月 30 日 - 内向性格的优势</h4><p>有时候常常懊恼于自己过于敏感内向的性格，甚至开始思考为什么这种基因能够流传下来。仔细想了想，我觉得可能的原因是，内向性格的人通常不会主动去伤害他人，也较少作恶，因此更容易被信任，所以也能得到一定的资源并生存下来，因此这种基因得以保留下来。对于现代人来说，虽然我们还是更喜欢外向的人（即使像我这样内向的人也一样），但是，内向的人最大的优势是，我们很少会去打扰别人，也很难让人产生讨厌的感觉，再加上现如今信任的成本如此之高，内向的人因此具备了一些优势。当然，也有可能是因为我自己本身是内向性格的人，所以对同样是内向性格的人有种天然的信任感。无论如何，接受自己内向性格这个事实，然后尽可能努力去认识新朋友，扩展自己的人脉圈，发挥出自己的优势，为他人提供价值。这样的话，无论你是什么样性格的人，都能过得幸福快乐，而且这是每个人都能做到的事。</p><h4 id="12-月-31-日-不发朋友圈的原因"><a href="#12-月-31-日-不发朋友圈的原因" class="headerlink" title="12 月 31 日 - 不发朋友圈的原因"></a>12 月 31 日 - 不发朋友圈的原因</h4><p>今天是 2021 年的最后一天，由于这个日子的特殊，让原本应该是挺普通的周五与剩下的其它几十个周五立马区分了开来。对我来说，今天和往常没什么不同，下班、换衣服、去跑步、洗澡、洗衣服、上网闲逛。不过，今天还是不能免俗地发了条朋友圈，简单总结了下自己的这一年。现在朋友圈打开的频率越来越低，也几乎不再更新，最近半年只发了一条动态，还是因为不小心点了微信小助手的群发功能而做的解释。为什么不再发朋友圈？一方面是因为开始写碎碎念之后，越来越觉得自己在朋友圈的表达不够真实；另一方面，觉得生活是自己的，没必要分享给别人看；还有就是，觉得有些想法可能分享之后也无法得到自己想要的回应，所以干脆就不发了。现在，我的想法也开始有点动摇，一是每个人都渴望得到他人的理解和回应，无论何种程度，二是虽然都是通过文字记录，但是如果你的想法能够影响或者启发一小部分人，那不也挺好的吗？即使他人不认同你也没关系，我们还可以通过理性讨论来消除彼此的误解，这样对双方都有好处，我们都能因此而获得成长和进步。不过，要建立起一个彼此信任、能够畅所欲言的环境还是很难的。我对在现实生活中找到一两个这样的同类都不抱太大的希望，更不要说建立起这样圈子了。或许应该尝试在公共领域多发言，这样说不定能认识更多的同类。</p><p>Anyway, Happy New Year! I wish everyone have a wonderful life in 2022!</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在高德地图上展示 Shapefile 中的数据</title>
      <link href="/shapefile-to-wms/"/>
      <url>/shapefile-to-wms/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2021-12-21/ganymede_globes.png" alt="ganymede_globes"></p><blockquote><p>这篇介绍一下如何将 <a href="https://desktop.arcgis.com/zh-cn/arcmap/10.3/manage-data/shapefiles/what-is-a-shapefile.htm">Shapefile</a> 转换为 WMS 图层并在高德地图上展示出来。</p></blockquote><p>如果你是一名 GIS 开发者，那么你对 Shapefile 一定不陌生，它是一种用于存储地理要素的几何位置和属性信息的文件格式。具体来说，它主要通过几何图形（点、折线、多边形）存储道路、桥梁、河流等空间对象的几何位置。另外，它还可以通过不同的文字、颜色等标识出这些空间对象的属性。</p><p>很多地图制作工具都支持导出 shp 格式的数据（比如 <a href="https://www.esri.com/zh-cn/arcgis/products/arcgis-desktop/resources">ArcGIS</a>），但是，如果想要通过第三方地图 SDK 加载这些数据，往往需要先做一步转换操作，比如转换为 <a href="https://lbs.amap.com/api/javascript-api/guide/layers/wms">WMS 图层</a> 或者 <a href="https://developers.google.com/maps/documentation/javascript/kmllayer">KML 图层</a>。这里，我就以高德地图为例，介绍如何通过 <a href="http://geoserver.org/">GeoServer</a> 将 Shapefile 转换为 WMS 图层并加载到 Android 地图 SDK 中。</p><span id="more"></span><h3 id="将-Shapefile-转换为-WMS"><a href="#将-Shapefile-转换为-WMS" class="headerlink" title="将 Shapefile 转换为 WMS"></a>将 Shapefile 转换为 WMS</h3><h4 id="GeoServer-安装"><a href="#GeoServer-安装" class="headerlink" title="GeoServer 安装"></a>GeoServer 安装</h4><p>GeoServer 是一个提供地图创建和数据分享服务的<a href="https://github.com/geoserver/geoserver">开源</a>软件。我们可以通过<a href="http://geoserver.org/download">官网</a>下载 GeoServer 最新版本并启动本地服务 (<code>sh ./bin/start.sh</code>)，然后根据<a href="https://docs.geoserver.org/latest/en/user/gettingstarted/web-admin-quickstart/index.html">教程</a>登录进入 <a href="http://localhost:8080/geoserver/web">Web 管理后台</a>。</p><h4 id="发布-Shapefile"><a href="#发布-Shapefile" class="headerlink" title="发布 Shapefile"></a>发布 Shapefile</h4><p>参考<a href="https://docs.geoserver.org/latest/en/user/gettingstarted/shapefile-quickstart/index.html">官方例子</a>发布 Shapefile，操作流程：</p><ol><li>Add new workspace</li><li>Add new store (data source)</li><li>Add all the new layers from the store</li></ol><p>除此之外，我们还可以在 Layer Groups 中将多个 Layer 添加到同一个分组中。</p><h4 id="访问-WMS"><a href="#访问-WMS" class="headerlink" title="访问 WMS"></a>访问 WMS</h4><p>当我们将 Shapefile 中的数据全都转换为 WMS 图层之后，就可以通过 GeoServer 的 Layer Preivew 查看图层了。假设你将多个图层添加到了 Layer Group 中，那么访问路径就是：<a href="http://localhost:8080/geoserver/wms">http://localhost:8080/geoserver/wms</a></p><h4 id="需要注意的坑"><a href="#需要注意的坑" class="headerlink" title="需要注意的坑"></a>需要注意的坑</h4><p>在发布 Layer 时需要注意一下 SRS 的问题，比如我就遇到了无法读取 Native SRS 的问题。不过，由于绝大部分空间坐标系一般都是使用 <code>EPSG:4326</code>，如果你也遇到了这个问题，可以将 Declared SRS 设置为 <code>EPSG:4326</code> 来解决这个问题，参考：<a href="https://geoserver-pdf.readthedocs.io/en/latest/data/webadmin/layers.html#coordinate-reference-systems">GeoServer: Coordinate Reference Systems</a></p><h3 id="在高德地图上加载-WMS-图层"><a href="#在高德地图上加载-WMS-图层" class="headerlink" title="在高德地图上加载 WMS 图层"></a>在高德地图上加载 WMS 图层</h3><p>对于高德地图 Android SDK，可以通过自定义 <code>UrlTileProvider</code> 来加载 WMS 图层，具体的实现方式我参考了这篇文章：<a href="https://blog.csdn.net/GISuuser/article/details/79700571">在高德地图 Android SDK 上添加 GeoServer 发布的 WMS 图层</a>。</p><p>大致的实现过程是，首先根据切片的像素点坐标、切片大小和缩放层级计算出距离，再将距离转换为经纬度，最后再将经纬度坐标进行一次转换，从高德地图使用的 GCJ02 坐标转换为 WGS84 坐标（使用 <a href="https://github.com/taoweiji/JZLocationConverter-for-Android">JZLocationConverter-for-Android</a>），最后才能得到正确的 BBOX 范围。</p><p>示例代码见：<a href="https://github.com/ajiew/amapdemo/blob/main/app/src/main/java/me/ajiew/amapdemo/map/WmsTileProvider.kt">AmapDemo</a></p><img src='../assets/2021-12-21/shapefile-to-wms-demo-min.gif' width=50%/>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> GIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>依赖注入框架 Hilt 的使用</title>
      <link href="/hilt-notes/"/>
      <url>/hilt-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="https://miro.medium.com/max/1200/1*WH1qbEWjpri3p5HkBzboiQ.png"></p><blockquote><p>这篇记录下 Hilt 最基本的使用方法。</p></blockquote><p>Hilt 是基于 Dagger 开发的依赖注入框架。我们知道 Dagger 是 Java 开发中无可否认的功能最为强大的依赖注入框架，但是它的缺点是使用起来比较复杂，尤其是对于初学者而言，学习曲线异常陡峭。而依赖注入框架在 Android 开发中又是一个非常重要的工具，因此，在 Kotlin 成为了 Android 开发者的首选语言之后，开源社区中诞生了许多基于 Kotlin 依赖注入框架，比如 <a href="https://github.com/InsertKoinIO/koin">Koin</a> 和 <a href="https://github.com/Kodein-Framework/Kodein-DI">Kodein</a>。谷歌当然也注意到了这一点，所以也基于 Dagger 推出了更简单易上手的 Hilt，它的主要优势是：</p><ul><li>基于 Android 简化了 Dagger 相关的基础架构；</li><li>提供了一组标准的 Component 和 Scope 以简化使用、提升可读性以及便于代码共享；</li><li>简化针对不同的构建类型（比如测试、调试或发布类型）配置不同的绑定。</li></ul><p>之所以能做到以上这几点，是因为 Hilt 自动帮我们做了很多工作，比如自动生成用于和 Android Framwork 绑定的 Component/Scoped annotations/Bindings/Qualifier 等，而如果使用 Dagger 的话，这些都是需要我们自己手动编写代码来管理的。</p><span id="more"></span><h3 id="Hilt-的基本使用"><a href="#Hilt-的基本使用" class="headerlink" title="Hilt 的基本使用"></a>Hilt 的基本使用</h3><p>使用方式上，Hilt 和 Dagger 相比最明显的区别是，不再需要定义 Component，对于每一个 Android 基础类，Hilt 会自动为它生成对应的 Component，并且会根据安卓组件的生命周期来创建和销毁。如下：</p><table><thead><tr><th align="left">Hilt 组件</th><th align="left">注入器面向的对象</th></tr></thead><tbody><tr><td align="left"><code>ApplicationComponent</code></td><td align="left"><code>Application</code></td></tr><tr><td align="left"><code>ActivityRetainedComponent</code></td><td align="left"><code>ViewModel</code></td></tr><tr><td align="left"><code>ActivityComponent</code></td><td align="left"><code>Activity</code></td></tr><tr><td align="left"><code>FragmentComponent</code></td><td align="left"><code>Fragment</code></td></tr><tr><td align="left"><code>ViewComponent</code></td><td align="left"><code>View</code></td></tr><tr><td align="left"><code>ViewWithFragmentComponent</code></td><td align="left">带有 <code>@WithFragmentBindings</code> 注释的 <code>View</code></td></tr><tr><td align="left"><code>ServiceComponent</code></td><td align="left"><code>Service</code></td></tr></tbody></table><p>因此，对于一个最简单的 MVVM 项目而言，使用 Hilt 做依赖注入一般需要按照以下的步骤：</p><ul><li>添加 Hilt 插件和依赖，对于每个 module 都要单独添加</li><li>使用 <code>@HiltAndroidApp</code> 标注你自定义的 <code>Application</code></li><li>使用 <code>@AndroidEntryPoint</code> 标注你的 <code>Fragment</code> 或者 <code>Activity</code></li><li>使用 <code>@HiltViewModel</code> 标注你的 ViewModel 类，以及用 <code>@Inject</code> 标注构造器</li><li>使用 <code>@Inject</code> 标注需要注入的依赖，比如 Repository 等</li><li>定义 Hilt 模块，用于<strong>提供无法直接注入的依赖</strong>，比如接口类和外部的依赖类等<ul><li>使用 <code>@InstallIn</code> 标注该模块的作用范围</li><li>使用 <code>@Provides</code> 标注提供每个依赖的方法</li><li>使用 <code>@Binds </code> 标注需要注入依赖的接口和具体实现（通过抽象类和抽象方法）</li></ul></li></ul><p>具体例子可以参考我的开源小项目：<a href="https://github.com/aJIEw/Jithub">Jithub</a></p><h3 id="模块和组件"><a href="#模块和组件" class="headerlink" title="模块和组件"></a>模块和组件</h3><p>虽然 Hilt 大大简化了依赖注入的使用，但是使用方式上和 Dagger 并没有太大区别，最基础的组成部分依旧是模块和组件。对于某个 Hilt 模块，如果我们想要注入多个相同类型的依赖，同样需要通过定义限定符来实现。</p><p>使用注解定义限定符（例子来自<a href="https://developer.android.com/training/dependency-injection/hilt-android">官方文档</a>）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Qualifier</span><br><span class="hljs-meta">@Retention(AnnotationRetention.BINARY)</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthInterceptorOkHttpClient</span></span><br><br><span class="hljs-meta">@Qualifier</span><br><span class="hljs-meta">@Retention(AnnotationRetention.BINARY)</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherInterceptorOkHttpClient</span></span><br></code></pre></td></tr></table></figure><p>除此之外，我们还可以使用 Hilt 自带的限定符，比如 <code>@ActivityContext</code> 和 <code>@ApplicationContext</code> 等。</p><h4 id="组件的使用细节"><a href="#组件的使用细节" class="headerlink" title="组件的使用细节"></a>组件的使用细节</h4><p>之前提到过对于不同的 Android 类，Hilt 会为之生成对应的组件，我们在模块中通过 <code>@InstalledIn</code> 引用组件，然后 Hilt 会将模块安装到对应的组件中，最后再把依赖注入到组件中。</p><p>除此之外，每个组件都有自己的<a href="https://developer.android.com/training/dependency-injection/hilt-android#component-lifetimes">生命周期</a>，而且我们还可以为组件限定作用域。不同的组件作用域内可使用的依赖也不同，比如 <code>@FragmentScoped</code> 作用域内的依赖可以在 <code>@ActivityScoped</code> 的组件中使用，但是无法在 <code>@ViewScoped</code> 的组件中使用。</p><table><thead><tr><th align="left">Android 类</th><th align="left">生成的组件</th><th align="left">作用域</th></tr></thead><tbody><tr><td align="left"><code>Application</code></td><td align="left"><code>ApplicationComponent</code></td><td align="left"><code>@Singleton</code></td></tr><tr><td align="left"><code>View Model</code></td><td align="left"><code>ActivityRetainedComponent</code></td><td align="left"><code>@ActivityRetainedScope</code></td></tr><tr><td align="left"><code>Activity</code></td><td align="left"><code>ActivityComponent</code></td><td align="left"><code>@ActivityScoped</code></td></tr><tr><td align="left"><code>Fragment</code></td><td align="left"><code>FragmentComponent</code></td><td align="left"><code>@FragmentScoped</code></td></tr><tr><td align="left"><code>View</code></td><td align="left"><code>ViewComponent</code></td><td align="left"><code>@ViewScoped</code></td></tr><tr><td align="left">带有 <code>@WithFragmentBindings</code> 注释的 <code>View</code></td><td align="left"><code>ViewWithFragmentComponent</code></td><td align="left"><code>@ViewScoped</code></td></tr><tr><td align="left"><code>Service</code></td><td align="left"><code>ServiceComponent</code></td><td align="left"><code>@ServiceScoped</code></td></tr></tbody></table><h3 id="其它细节"><a href="#其它细节" class="headerlink" title="其它细节"></a>其它细节</h3><p>如果需要在 Hilt 不支持的类中注入依赖，比如 <code>ContentProvider</code>，我们可以通过创建 <code>EntryPoint</code> 来访问这些依赖。</p><p>通过 <code>@EntryPoint</code> 创建依赖入口（通常是一个接口），然后在其中定义方法提供所需要的依赖，再通过 <code>@InstalledIn</code> 来定义安装到哪个组件。另外，访问 <code>EntryPoint</code> 依赖也和普通的依赖不同，我们需要通过之前定义好的 <code>EntryPoint</code> 接口来访问依赖项。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> entryPointInterface = EntryPointAccessors.fromXxx(Application/Activity/Fragment/Context, EntryPointInterface::<span class="hljs-keyword">class</span>.java)<br></code></pre></td></tr></table></figure><p><code>EntryPointAccessors</code> 中包含不同的创建方法，对应于创建不同的组件，比如 <code>EntryPointAccessors.fromApplication()</code> 对应于 <code>SingletonComponent</code>，<code>fromActivity() </code> 对应于 <code>ActivityComponent</code> 等。创建 <code>EntryPoint</code> 接口对象之后，我们就可以通过它来访问依赖了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>可以看到，Hilt 大大简化了传统依赖注入框架的使用方式，但是核心功能基本和 Dagger 保持一致，因此，开发人员可以将更多的注意力放在开发上，从而提升开发效率。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提出好问题</title>
      <link href="/2021-11/"/>
      <url>/2021-11/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/CfMVqYfpfdo" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>这个月最大的感受是，不是所有问题都只有一种解决方法，有的时候我们只不过需要换一种思考方式。另外，很多眼下完成不了的事情或者解决不了的问题，暂时放一放其实也没关系，因为当未来的某一天我们回过头来再看的时候，很有可能它们已经不重要了或者能够很轻松地被解决。这类事情其实是暂时性问题。所以，重要的是找到那些持续性的问题，更进一步，累加式的问题。那些如果现在不解决，未来依旧会持续存在，并且很有可能会变成更大的问题的问题。如何区分这两种问题也是一个难题。提出问题但是不给解决方案似乎是无意义的做法，但是，我觉得有时候提出一个好问题其实比解决一个普通的问题更有意义。</p></blockquote><span id="more"></span><h4 id="11-月-1-日-不安全感和勇敢"><a href="#11-月-1-日-不安全感和勇敢" class="headerlink" title="11 月 1 日 - 不安全感和勇敢"></a>11 月 1 日 - 不安全感和勇敢</h4><p>在剖析了那么多遍自己身上的不安全感之后，我发现我还是无法解决这个问题。也许一开始的态度就错了，不应该把它看做是一个需要解决的「问题」，而是把它看做是自己的一个特质。就像搏击俱乐部里的杰克一样，泰勒只不过是他拥有的另一个人格，而我只不过需要学会控制我的泰勒，以及学会和他和平相处。不安全感说到底是一种不自信，它也是一种保护自己的办法。通过对自己的质疑限制自己的行动，从而避免做出一些冒险的举动，通过减少冒险，减少被拒绝和失败的风险，从而让自己少受到的伤害和维护自己的面子，保持感觉良好的状态。当然，这种思维方式也会禁锢更多的可能性。本来我可以尝试那个新的工作机会，那件没有体验过的事，或者某段从来没有尝试过的对话，认识一个陌生人的机会，等等。我当然可以劝说自己放弃挑战自己的不安全感，做一个「老实本分」的人，但是我知道这样的人生不是我想过的。我要尝试战胜自己的天性，而不是做成长环境给我带来的习惯的奴隶。如何战胜不安全感？如何变得更加自信？如何积极主动地迎接挑战？说到底只有一句话：变得更加勇敢。虽然我的名字里就有一个『勇』字，但是勇敢这个词已经被我忽略了太久了。这是一种极其可贵的品质。它可以让人尝试新事物，养成新习惯，做自己从来没做过的事，挑战自己，敢于承诺，学会忠诚。勇敢和有勇气不是意味着不再害怕，而是能去做自己想做的事，战胜对失败的恐惧等等。</p><h4 id="11-月-2-日-保持平静和放松"><a href="#11-月-2-日-保持平静和放松" class="headerlink" title="11 月 2 日 - 保持平静和放松"></a>11 月 2 日 - 保持平静和放松</h4><p>在任何时候都能保持平静和放松是一种巨大的优势。这种特质有的人与生俱来，但是我不是。我也希望自己能够拥有这种特质，不过这需要漫长时间的练习，以及不断地自我反思。人只有在保持平静和放松的状态下才能表现出自己的本性，才能发挥出创造性。比如此刻正在写碎碎念的我，只有手在不停地敲击键盘，而我的身体和大脑处在完全放松的状态下。我能听到窗外的鸟叫声，楼下散步行人的细语声，远处汽车驶过的引擎声等等各种各样的杂音，同时我又可以任凭思绪自由地放飞自我。真的挺庆幸自己每天早上能够拥有这几十分钟的自由时间，通过和自己的对话让我感到身心放松。即使昨天晚上的睡眠质量不佳，我也可以通过自由写作缓解大脑的疲惫，理清思绪，释放压力。我在担心什么？我有哪些恐惧？我渴望哪些东西？我需要做哪些事让自己的心恢复平静？我今天最大的目标是什么？如何高效地度过这一天？如何提高自己的生产力？我今天要尝试哪些没做过的事？凡事只要想清楚之后，目标和结果都显得不再那么重要了，我们只要让自己安静地去做就可以了。我觉得这就是<strong>心定</strong>的力量吧。</p><h4 id="11-月-3-日-成熟-vs-像孩子一样"><a href="#11-月-3-日-成熟-vs-像孩子一样" class="headerlink" title="11 月 3 日 - 成熟 vs 像孩子一样"></a>11 月 3 日 - 成熟 vs 像孩子一样</h4><p>成熟的标准是是什么？能够主动承担责任？得体的待人接物？有足够的经济能力，能够帮助他人？能够换位思考、体谅他人的难处？如果照这些标准，我觉得成熟只是一种状态而已，和年龄无关。有的人因为父母的关系，从小就耳濡目染，加上成长环境的影响，很早就表现地异常成熟。而有些人从小是被宠坏的小孩，可能到了三、四十岁也依旧是毫无责任感，甚至还需要父母家人的照顾才能勉强过活，如果父母不放手，他可能一辈子也无法变得成熟。对我来说，我有时候常常觉得自己不够成熟，主要表现在待人接物上，总是觉得自己有些笨拙，而有时候又觉得自己在心理上已经挺成熟的了。可能这只是一个过渡期吧，在不成熟迈向成熟的过程中，总有这样的一个中间状态。我当然希望自己可以变得更加成熟，但是同时我也希望自己不要丢失掉孩子的天真和浪漫、青年的热血和无畏。我不想变成那种成熟但无趣的人。我觉得成年人最大的优势是，既可以享受成年人的自主力以及获得他人的尊重，同时又可以表现地像孩子一样，尤其是在自己爱的人面前。在该成熟的时候成熟，同时又能像孩子一样撒娇耍赖，这样的人才是幸福的，而且也显得更加可爱。</p><h4 id="11-月-4-日-记住痛苦时刻以及学会推销你自己"><a href="#11-月-4-日-记住痛苦时刻以及学会推销你自己" class="headerlink" title="11 月 4 日 - 记住痛苦时刻以及学会推销你自己"></a>11 月 4 日 - 记住痛苦时刻以及学会推销你自己</h4><p>人的记忆喜欢粉饰自己的过去，尤其喜欢夸大自己的成就，掩盖那些令自己感到难堪的事。这也是记录的意义之一，只有诚实记录下自己此刻真实的想法，才能让未来的自己明白，有些痛苦是真实发生过的。而记住这些痛苦的时刻，可以让自己长记性，得到教训，学会反思自己。很后悔没有早点开始记录自己，但是至少应该庆幸这后悔发生在我的二十几岁，而不是即将老去的时候。关于我自己，我犯过的最大的错误是什么？不会推销自己。我过去的想法是酒香不怕巷子深，只要你自己足够优秀，自然就会吸引到人来和你合作。事实是很少有人能达到这样的程度，尤其是当你还默默无闻的时候。一开始的时候必须要学会展示自己，至少要懂得如何吸引他人的眼球。如果别人都注意不到你的存在，你怎么推销你的产品和想法呢？有的人由于出生和成长环境比较优渥，天生自带光环，所以不需要担心缺少关注，也能享受他人的关注。但是很不幸，这样的人注定只是少数，大部分人还是要依靠自己所掌握的某种技艺和持续不断地自我营销，才能逐渐吸引来一些人的关注，然后利用这关注慢慢建立起自己的品牌和口碑。获得关注只是为了推销你的产品和想法吗？或者只是为了换来个人的成功？当然不是，<strong>获得关注既意味着影响他人的能力</strong>。你可以传播你的价值观，引导他人改变他们的生活，以及和适合的人做一些有意思的事情，等等。总之，这是一件值得做且有意义的事。</p><h4 id="11-月-5-日-写碎碎念的意义"><a href="#11-月-5-日-写碎碎念的意义" class="headerlink" title="11 月 5 日 - 写碎碎念的意义"></a>11 月 5 日 - 写碎碎念的意义</h4><p>目前，写碎碎念对我来说最大的意义是记录自己，还有就是帮助自己找到人生目标。虽然我现在依旧不知道自己的目标是什么，但是每次阅读自己过去写下的文字，我都觉得它在一点点变清晰。另外，这也是一种表达自己的方式。文字虽然不如语言直接，但是只要我们愿意诚实表达自己，记录自己内心深处的想法，通过这种记录还是可以帮我们厘清自己的思绪，找到自己最重要的价值观，从而加深对自己的了解。而且我也逐渐开始认为，只有你能表达出来的东西才是你真正学会的东西。我们如何思考才是决定我们人生的关键。我们的价值观不会自动变好，我们的习惯也不会。只有不断打磨自己的想法，不断地重复那些对自己来说最重要的价值观，我们才能把它们变成自己的一部分，并且始终选择符合自己价值观的、正确的方式去行动。</p><h4 id="11-月-6-日-家乡的婚礼、表达自我、生活态度"><a href="#11-月-6-日-家乡的婚礼、表达自我、生活态度" class="headerlink" title="11 月 6 日 - 家乡的婚礼、表达自我、生活态度"></a>11 月 6 日 - 家乡的婚礼、表达自我、生活态度</h4><p>今天好朋友结婚，人生第一次当伴郎，想聊聊结婚的习俗。对于长在这片土地上的人来说，关于婚丧嫁娶的一些事情，真的不是你一个人能控制的。哪怕你不喜欢，也得遵从安排，按照当地的风俗来办。这点我能理解。而且一些习俗也在随着时间变化，随着大家生活水平的提高，一些不好的现象也在慢慢消失，我觉得这点还是挺好的。对于结婚办酒席这件事来说，主要的目的还是图个热闹。农村里更是如此。因为是熟人社会，大家平时都彼此相识，偶尔互相走动，也需要通过这样的场合让彼此保持联络，维持关系。虽然我们心里会觉得很麻烦，因为觉得这些人中，除了一些关系要好的亲戚之外，大部分人都和自己没什么关系，而且以后也不一定会再联系彼此。办酒席最大的目的还是为了我们的父母，因为这些基本上就是他们所有关系的总和——亲戚、朋友和熟人。而且生活在这个环境中的他们，未来很有可能会在这里终老，农村里的关系人脉网络起到了一个大型的社区互助组织的作用。</p><p>在近距离体验了两次家乡的婚礼之后，我心里多少也开始有点焦虑。首先是单身这件事，外界环境灌输给我的是信息是，单身很丢脸，你应该尽早结婚生子。我虽然嘴上接受这一观点，但是内心的真实想法是，这完全就是你自己的事啊，为什么要被外界的压力绑架呢？当然，我知道有个彼此相知相爱的人是非常难得的事，我也非常期待能够遇到那个对的人，但是建立一段亲密关系需要克服很多困难。你需要为此付出很大的努力，不断地提高自我，为这段关系付出自己的时间和精力，然后还需要一点点运气，要有缘分，两个人才能最终走到一起。我最大的问题是什么呢？不擅长公开表达自己，太喜欢掩盖自己的真实想法，以至于错失了很多机会。如果我能克服这个弱点，并且学会主动和更多的人沟通交流，甚至做到能随时随地表达自己的想法，那么我就能获得更多成长的机会。不仅仅是获得更多人际关系上的机会，甚至还有可能影响到我人生的发展方向。我们都是独一无二的个体，如果每个人都能发出自己的光芒，我们就能照亮更多身边人的生活，影响到更多的人，让更多人和自己建立连接，并且通过这种连接，分享、整合彼此的优势和资源。</p><p>人是观念和习惯的产物。观念并不能直接改变我们的生活，但是却能指导我们如何生活。光是知道并没有用，关键还是要有所行动，我们都要学会不断发展、完善自己的价值体系和思维方式。我觉得我是幸运的，能够早早走上这条自我发现之路。虽然起点不高，但是我对自己过去的经历感到感恩，也对现在所拥有的一切知足（家人、工作和自我成长），同样也对未来充满信心。我知道我只要沿着这条自我发现之路上不断走下去，未来一定会过得更加幸福。无论年龄多大，我们都可以选择以何种方式对待自己的人生。幸福之路有两条，一是向内探索自己，二是向外探索世界，内心充盈的人哪怕一辈子只生活在同一个地方，也同样可以过得快乐和幸福。阅读、运动、工作、帮助他人，做让自己真正感到满足的事，用心感受当下生活里的每一个瞬间，我觉得这才是每个人都应该拥有的生活态度。</p><p>虽然有些东西即使用文字也无法完全表达出自己的意思，而且即使表达出来也不一定足够准确，但是我觉得这些东西还是值得写下来用来提醒自己的。每当觉得迷茫找不到方向的时候，就可以翻看自己过去写下的文字，回想当时的心境。虽然看似都是一些大道理，但其实道理和一个人在认真审视自己的生活之后得出的感悟还是不同的，你的思考会更加贴近现实。这也是写碎碎念的意义之一吧。</p><h4 id="11-月-7-日-和陌生人交流的心得"><a href="#11-月-7-日-和陌生人交流的心得" class="headerlink" title="11 月 7 日 - 和陌生人交流的心得"></a>11 月 7 日 - 和陌生人交流的心得</h4><p>和陌生人交流时，除了需要克服自己的心理障碍之外，关键是要把对方当做是<strong>自己的朋友</strong>一样去相处，并且足够放松，这样你才能关注当下正在发生的事，而不需要去寻找话题。但是有的时候也会发现，和有的人就是不知道该说什么。我在想我和自己的朋友在一起的时候，会发生这种情况吗？我会纠结自己应该说什么不应该说什么吗？好像并不会。所以，每当谈话陷入僵局或者不知道自己是否应该开口的时候，就说明我们还不能完全放松做自己。<a href="https://www.youtube.com/channel/UCsMcTtQH_YWD-qBgy3vY9JQ">Rubin</a> 说过，在和陌生人交流的过程中，他人的行为表现就像是我们的一面镜子。我们往往是预期了对方的想法和行为之后，然后再通过自己的行动去「验证」自己的想法。换种态度，一切可能截然不同。而且不带任何心理预设地去和他人沟通也会轻松很多，我们不用担心对方会不会接自己的话，或者担心自己问了不该问的问题。被拒绝也不是一件太可怕的事，因为我们只是在诚实表达自己的想法，说出自己想说的话。对方如何反应都是有可能的，我们不知道对方正在经历什么，情绪状态如何，或者是以何种角度进行思考。坦诚面对自己的真实想法，保持诚实，表达自我的同时也对他人保持好奇，通过沟通交换一段经历、分享彼此的观念和想法，我觉得这是和陌生人交流的最大意义。</p><h4 id="11-月-8-日-敏感而又自卑的人"><a href="#11-月-8-日-敏感而又自卑的人" class="headerlink" title="11 月 8 日 - 敏感而又自卑的人"></a>11 月 8 日 - 敏感而又自卑的人</h4><p>脑海里一团乱麻的时候会想要找个空旷安静的地方彻底放空自己。有时候觉得「他人即地狱」，转念想到还有那么多给自己带来过快乐的陌生人，又觉得「他人也是天使」。也许天使和地域只隔了一个情绪起伏周期吧。有时候在想，我这样的人是不是人群中的极少数啊。但是，想到自己这么普通，也许我只是个太过封闭自己、活在自己世界中太久了的普通人吧。虽然想要尝试和周围的世界建立更多的连接，关心他人，但是最后还是会回到原点。此刻脑海里闪过了一大堆鼓励自己的话，但是却被我刻意忽略掉了。也许我需要体验挫败感吧，这种感觉让我觉得自己是在真实地活着。敏感而又自卑的人需要缩回自己的安全屋内才能慢慢恢复过来。还是要对自己好一点呐。</p><h4 id="11-月-9-日-微尘的意义在于爱与被爱"><a href="#11-月-9-日-微尘的意义在于爱与被爱" class="headerlink" title="11 月 9 日 - 微尘的意义在于爱与被爱"></a>11 月 9 日 - 微尘的意义在于爱与被爱</h4><p>现代人的宗教是科学，而科学鼓励人们探索未知，寻找真理。在这一过程中，人类必然会逐渐意识到，相比于整个物理世界，也就是我们生活的宇宙而言，人类的存在简直不值一提，无论是在时间还是空间尺度上。我们只是天空中忽闪而过的一颗流星，最终可能无法留下任何痕迹。对于人类整体而言都是如此，更不用说每个个体了。在我们短暂的几十年、百来年的生命中，绝大部分人都对人类的发展没有任何贡献，只是这个世界的匆匆过客，一粒微尘而已。不但如此，我们还要像其它生物一样，挣扎着生存，在激烈的竞争中寻求传递自己基因的机会。虽然相比几百、几千、几万年前，此刻在这个星球上活着的大部分人的生活都有了明显的改善，我们不用去冒险狩猎动物，日日去田里劳作，忍受战乱和饥荒，但是我们还是无法过得幸福和快乐，还是会被欲望支配着生活，找不到生活的目标与意义。不过，我们虽然只是微尘，但是只要有爱人也被爱，存在就是有意义的。</p><h4 id="11-月-10-日-享受一个人的状态"><a href="#11-月-10-日-享受一个人的状态" class="headerlink" title="11 月 10 日 - 享受一个人的状态"></a>11 月 10 日 - 享受一个人的状态</h4><p>最近在思考一个问题，我喜欢我现在的状态吗？工作，运动，阅读，无论做什么事都是一个人，似乎没有其他人可以分享自己的想法和情绪。有时候想到自己未来可能永远也交不到一个知心的朋友，心里就会产生非常强烈的恐惧感。但其实很少人能够拥有真正理解彼此的「灵魂伴侣」吧。相比他们，我只是少了很多普通朋友，比如一起吃饭聊天的朋友，一起出去玩乐的朋友，一起分享彼此生活的朋友，等等。但是，我并不渴望和其他人去做这些事。我非常享受一个人的状态。绝大多数时候，我都希望能够自己一个人待着，做我自己喜欢做的事。无论是玩游戏，跑步，玩滑板，看书，看电影，哪怕只是对着墙壁发呆，也是种让我恢复能量、和生活建立起连接的方法。最近喜欢在傍晚的时候离开工位下楼去散散步，秋天的傍晚真的好美，夕阳照在建筑物的外墙上，所有物体的影子都被拖的很长，树叶的颜色也十分丰富。还有天空中的云，各种形状，煞是好看。有时候连成一片，气势磅礴；有时候是鱼鳞云，像连绵起伏的群山。哪怕没有云的时候，仅仅是看着蓝天也会让我心情变得好起来。我觉得无论何时，个人的幸福和快乐永远是排在第一位的。幸福就是对当下的一切感到满意，享受当下的一切，而不去寻求任何的改变。如果能够始终保持这样的状态，一个人有什么不好的呢？</p><h4 id="11-月-11-日-克服社交弱点"><a href="#11-月-11-日-克服社交弱点" class="headerlink" title="11 月 11 日 - 克服社交弱点"></a>11 月 11 日 - 克服社交弱点</h4><p>看了昨天的碎碎念，老实说，其实我对当下的人际关系还是不满意的。一直都在积极寻求改变，但是改变发生得很慢，所以有点气馁。承认自己需要朋友以及为无法交到更多朋友而感到沮丧这个事实，其实没什么大不了的。毕竟每个人都有自己的弱点。我的弱点是很难和别人坦诚沟通，所以很难交到朋友。每次和陌生人相见的时候，我看到的都是对方的缺点，而如果对方很完美，那么我想到的就都是自己的缺点。这让我很难平等地和对方进行沟通。我也在思考自己为什么会这样？可能是从小成长在不受关注的环境下，觉得自己需要足够好才值得引起他人的注意吧。还有就是自卑心理在作祟，总是感到不自信，外貌、财富、魅力、个人能力等等，每当你感到犹豫的时候，机会就已经错过了。如果我不能克服自己的这些弱点，我觉得我可能一辈子都会以当前的方式生活下去。这也太凄凉了。我不想要这样，这不是我想要的生活。所以，我才要改变自己。首先，改变自己的思维方式。要相信自己是一个值得爱的人，同时关注他人身上和自己的共同点。不要去和他人比较。做一个快乐的人，总是看到事物积极的一面。乐观一点，不要抱怨。认真负责地做好手上的每一件事。我觉得做到这些是提高自尊以及慢慢变得自信的必经之路。</p><h4 id="11-月-12-日-我最不能忍受什么？"><a href="#11-月-12-日-我最不能忍受什么？" class="headerlink" title="11 月 12 日 - 我最不能忍受什么？"></a>11 月 12 日 - 我最不能忍受什么？</h4><p>如果我们不知道自己想要什么，那么还可以反过来问自己「我最不能忍受的是什么？」。这些不能忍受的东西就是我们的底线，我们不但应该避免它们，还要使自己向着它们相反的方向努力。比如，假如我无法忍受贫穷，那么，我就要努力工作，获得更多的收入，同时管理好自己的支出，慢慢积累起存款；还得学会理财，不要让手里的钱贬值得太快，想办法通过投资获得收入；等到积累了足够的财富之后，还得学会获得优质的资产来让财富保值。<strong>每件事都有它的因果链条，只要我们愿意探索、看清事物的本质，我们就能避免其中的陷阱，让自己生活得更加幸福。</strong>再比如，我现在对自己的社交生活不满意，我想要拥有更多的朋友，开始和他人建立起亲密关系。那么，我就要改变自己的态度，不要再用无所谓的态度对待身边所有有可能发展成友谊或者亲密关系的人际关系。努力让自己变得更值得交往，为他人提供价值，无论是情绪价值还是实际价值。帮助他人，做一个快乐的人。其次，改变自己的性格。要变得更主动一些，不要因为害羞或者胆怯而退缩。最后，要足够坦诚，做一个真诚的人，并且养成自我表达的习惯。不要隐藏自己的真实想法，说出自己心底的想法，向他人展示真实的自己。没有人是完美的，至少你不用扮演、假装成另外一个人去生活，而且没有人会喜欢一个虚伪的人。</p><h4 id="11-月-13-日-养成定期反思、回顾的习惯"><a href="#11-月-13-日-养成定期反思、回顾的习惯" class="headerlink" title="11 月 13 日 - 养成定期反思、回顾的习惯"></a>11 月 13 日 - 养成定期反思、回顾的习惯</h4><p>人需要不断地反思自己，这就是为什么我们需要在工作中阶段性地对自己的表现进行评估。其实不仅仅是工作，我觉得我们也要多对自己近期的生活进行总结回顾，养成每周、每月、每年回顾总结的习惯。我这周最大的问题是什么？我这个月过得最不顺利的地方是什么？今年以来我最大的危机是什么？通过不断回顾自己做得好和不好的地方，我们才能及时发现问题，对自己的行为表现做出调整，避免它们在未来演变成更大的问题和危机。</p><p>虽然我有年末总结和制订新年计划的习惯，过去还会在年中进行总结，但是我发现这还不够。我需要每周、每月都对自己的表现进行总结和回顾。虽然听上去很麻烦，但是我觉得这件事是值得做的。每周只需要抽出两个小时来做这件事，一个小时做总结，一个小时做下周计划，然后每个月末再对自己的计划完成情况进行核对，并且在下个月做出调整。不需要非常详细的计划，只要大致列出自己要完成哪些事。我觉得只有这样，我才能完成自己定下的目标。比如去年的新年计划中，我希望找到自己的兴趣所在，但是今年已经过去了 85%，我究竟尝试了多少新事物呢？还有之前一些未完成的计划和项目，比如学习 Bash 和建立数字花园，都是只是开了个头之后就再也没有进展了。如果我能每周都抽出时间把它们安排进自己的每周计划当中，并且追踪它们的完成进度，现在很有可能早就完成了吧。</p><p>有些时候我们不去做一些重要且对自己未来有益的事，其实不是因为我们太懒惰了，而是因为我们没有养成好的工作习惯以及建立有效的反馈机制。当我们不但能够设立出清晰的目标，同时还能够量化自己的完成情况的时候，实现目标的过程会变得简单许多。过去的自己犯过很多错，比如不知道如何设立目标，同时也不知道如何追踪关键结果，所以行动的时候往往效率很低。但是，我很擅长总结自己犯下的错，所以每当我回过头去看的时候，我才会发现：「哦，原来我当时的目标是这个」，「哦，原来先完成这个再完成这个很重要」，「哦，原来我浪费了那么多时间在那件事上」。人只有通过犯错才能获得成长。我很幸运地能够不断获得犯错的机会，也能修正自己过去犯下的错，更希望自己未来能不再犯相同的错。痛苦+反思=成长，如果我们能够把反思变成自己的习惯，是不是不需要经历痛苦，也能收获成长？</p><h4 id="11-月-14-日-完全独立生存下来的能力"><a href="#11-月-14-日-完全独立生存下来的能力" class="headerlink" title="11 月 14 日 - 完全独立生存下来的能力"></a>11 月 14 日 - 完全独立生存下来的能力</h4><p>每当觉得很难或者坚持不下去的时候，就问问自己：假如你真的是孤身一人，你能够在这个世界上生存下来吗？如果你在这个城市一个人都不认识，只靠你自己，你能存活下去吗？如果你有信心完全靠自己也能生存，那么眼前这点困难就不算什么，都是可以克服的，大不了就从头开始呗。更进一步，如果把你放到这个世界上的任何一个角落，你能保证自己能够生存下来吗？其实这个世界上大部分城市的运转都是相似的，都是陌生人社会，我们需要和其他人合作才能维持自身的生存和发展。因此，在不依赖他人的情况下，只要你能在其中一个城市生存下来，那么你就可以在世界上任何一个城市生活，只不过难易程度有区别而已。首先，你要融入当地人的生活。这需要你了解当地的法律法规和风俗习惯，要会说当地的语言，即使做不到流利也要能够进行基本的对话。其次，你要让自己能够产出价值，无论是通过你的劳动还是提供服务。最后，你需要有朋友，这样当你遇到问题时就有人可以沟通交流，哪怕无法解决实际问题，至少可以获得一些安慰，帮助你撑过难关。你只有具备了不依赖他人也能在任何城市生存下来的能力，才能代表你是一个完全独立的人。而且你也不用担心自己会被困难击倒。最重要的是，这个世界对你来说，就像是一个娱乐场，等着你去探索。如果你对自己当下的生活不满意，你还可以去寻找适合你的城市，然后开始新生活。希望每个人都能有勇气去探索和改变自己的生活。</p><h4 id="11-月-15-日-以真实的自我和他人相处"><a href="#11-月-15-日-以真实的自我和他人相处" class="headerlink" title="11 月 15 日 - 以真实的自我和他人相处"></a>11 月 15 日 - 以真实的自我和他人相处</h4><p>之前表达过自己在不同的角色间切换的能力很差，我在想，如果我们不必扮演多个角色呢？始终以同一个角色将自己展现在任意一个人面前会怎样？无论是面对公司中的同事和上司，还是生活中遇到的陌生人，如果我始终都能以真实的自己，以最自然、最舒服的姿态去和他们相处，这样的我会活得更加轻松吧，而且也不再需要切换角色了。那么，是什么阻止了我用这样的方式去和他人相处呢？还是自己的心态问题吧。我总觉得我需要在不同的人面前表现地不一样，在不同的场合做不同的自己。但其实根本不必如此。没有人会因为你表现出真实的自我而批判你。也许有人会因此而不喜欢你，但是没关系，我们不用让每个人都喜欢自己。现实中一定有很多人不喜欢你，你不必关注那些不喜欢你的人，只要选择那些喜欢你的、爱你的人，和他们相处，就够了。做真实的自己需要有一点勇气。首先，你要学会接纳自己真实的样子。虽然不完美，但是没关系。只要你足够关心自己和他人，没有任何东西会阻挡在你和他人之间。我们都是普通人，有自己的优势和缺陷，如果每个人都能发挥出自己的特长，向他人展示出自己最美好的一面，这个世界会变成什么样？我想要生活在那样的世界中。所以，就从自己开始做起吧。慢慢改变自己，影响你周围的人，直到改变你的环境。</p><h4 id="11-月-16-日-未来的虚拟现实"><a href="#11-月-16-日-未来的虚拟现实" class="headerlink" title="11 月 16 日 - 未来的虚拟现实"></a>11 月 16 日 - 未来的虚拟现实</h4><p>昨晚看了一集黑镜，讲的是近未来一对好友在虚拟现实中扮演另一个身份的自己并且沉迷在和对方的性爱中的故事。如果真的实现了这样的技术，我想结婚率还会进一步下降吧。到那时，我们为什么还要结婚？可能最大的目的真的就变成了——为了生孩子。但是，如果是不那么喜欢孩子的人，估计一辈子也不会结婚，两个人彼此喜欢且相处愉快，在一起生活就够了，为什么要在法律上限制自己，排除认识其他异性的机会？另外，这对性爱以及爱情也是一种挑战。到那时，真实的性爱可能已经比不上虚拟中的性爱了，而性又是爱情中至关重要的一部分。如果虚拟可以替代现实中爱情的一部分，我们对爱情的需求就真的只剩下感情的部分了，也就是说柏拉图式的爱会占据社会主流。除此之外就是现实利益的计算，两个人一起生活可以降低生活成本，但是这需要时间磨合，需要迁就对方，学会妥协。如果你不愿意花时间和精力去经历这一过程，你大可选择独自生活，然后使用虚拟和现实结合的手段，同样可以过得幸福和快乐。我忍不住幻想那时候的社会形态会发生怎样的变化。虽然这只是想象出来的剧情，但是我觉得这种技术未来很有可能会实现，而如果这种技术真的成熟之后，人们会用它来干什么？肯定不仅仅会用在游戏中，教育、社交、工作等等方面都有可能发生天翻地覆的变化。期待未来。</p><h4 id="11-月-17-日-人类是一体的以及确定自己的目标"><a href="#11-月-17-日-人类是一体的以及确定自己的目标" class="headerlink" title="11 月 17 日 - 人类是一体的以及确定自己的目标"></a>11 月 17 日 - 人类是一体的以及确定自己的目标</h4><p>每当晚上听到 Molly Nilsson 的 <a href="https://open.spotify.com/track/4xt3c9RqK1uD9L5au4mgyN?si=0bba94d9b96e493c">H.O.P.E.</a> 的时候，都会忍不住抬头看天，在想星空深处是不是有另外一个生命也在和我做着同样的动作。宇宙对于我们来说实在是太广阔了，而人的生命又那么短暂，所以有时候会觉得一切都非常没意义。生命对每个人的意义真的只能靠他自己去赋予。时间倏忽而过，要是不好好把握，等明白过来的时候发现自己已经老了，那就真的只有后悔的份了。当然，我是不赞成那种只顾享受的「活在当下」的做法的。如果你出生在一个富豪家族，这么做也许没什么问题，但是绝大部分人都是普通家庭长大，还是需要承担起自己的责任的。我觉得理想的人生应该是能够为他人做出贡献的人生，无论是为了你的家族、你爱的人，还是人类整体。年纪越长就越是觉得人类是一体的，尽管我们有不同的种族、肤色、性别、外貌、学识等等，但只要能想办法把大家团结在一起，我们就能创造出各种各样的奇迹。当然，坏人还是会有，不过我觉得他们不值得花费我们的注意力，就像病毒一样，遇到就隔离开就好了。</p><p>关于我自己，我也想通了一些事，比如：不要问自己「我想要什么」，而是问自己「我要追求什么样的目标」，给自己定好目标后我们才能找到生活的方向。无论是要赚多少钱，要在哪里买房，要追到某个喜欢的人，又或者是要成为一个什么样的人，从事某种工作，解决某个难题。目标驱动我们的人生。我当下的目标是什么？成为一名优秀的 Flutter 开发者。为什么？首先，出于现实的考量，目前 Flutter 开发就业市场比较广阔，而安卓开发的市场在不断萎缩。其次，Flutter 开发可以解决很多问题，比如节约开发成本。最后，这也比较适合我，因为我觉得我擅长实现 UI，但对研究系统底层的动力不足，不过我喜欢学习新技术和新平台，以后可以做到既懂安卓开发，也了解一些 iOS 开发，如果以后可以不断深入研究，那么成为一名 Flutter 开发专家也是挺不错的选择。最关键的一点是，这是一条新赛道，我可以重新开始。既然确定了目标，接下来需要做的就是开始制订计划并且认真执行了。</p><h4 id="11-月-18-日-慈悲冥想"><a href="#11-月-18-日-慈悲冥想" class="headerlink" title="11 月 18 日 - 慈悲冥想"></a>11 月 18 日 - 慈悲冥想</h4><p>最近接触到一种新的冥想方式 <em>Compassion Meditation</em>，慈悲冥想。简单来说，就是在冥想的时候在心中默念一句祝福他人的话，比如 <em>May all beings be free of pain and sorrow. May all be well and happy.</em> 然后将这句话应用到不同的对象上，可以从你爱的人、你熟悉的人开始，然后是你不认识的人，甚至是你讨厌的人，最后到一切生命。我觉得可以将慈悲冥想理解为为自己和他人祈祷。慈悲冥想的目的是将我们的注意力从批判的角度转换为关爱他人，从孤立到连接彼此，从冷漠或憎恨到关心和理解彼此。这种冥想会让我们的情绪变得更加积极向上，我们身边的所有人都可以是慈悲冥想的对象，哪怕是那些你现在还不喜欢的人，使用慈悲冥想之后，你会发现其实我们只是不了解对方而已。即使不喜欢某个人，在为对方祈祷之后，你自己身上的负面情绪也会消散掉。你会觉得世间万物都有他们的位置，你会对自己所拥有的一切感到满足，对现状感到满意。衷心希望他人过得幸福快乐也会让你自己变得更加快乐，我觉得这就是慈悲冥想的神奇之处。</p><h4 id="11-月-19-日-用游戏视角看待生活"><a href="#11-月-19-日-用游戏视角看待生活" class="headerlink" title="11 月 19 日 - 用游戏视角看待生活"></a>11 月 19 日 - 用游戏视角看待生活</h4><p>当遇到我们不喜欢做的事的时候，可以把它看做是一场游戏，这样我们就更加有动力去完成它。而且所有事情都可以用游戏的心态来玩。比如如果用游戏的视角看待谈恋爱，一开始，你需要学会如何认识陌生女孩子，一旦你能掌握这方面所有的技巧，你就通过了这场游戏的入门关卡，接下来是学会如何让女生喜欢上你，也就是如何讨女孩子的欢心。这又涉及到更多的技巧，需要你提升自己其他方面的能力，比如获取资源的能力、学习的能力、情绪调节和自我控制的能力、剖析他人心理的能力，还有同理心、同情心、幽默感等等。这场游戏的目的是认识一位彼此相处最自在、能力互相匹配而且彼此相爱的人进入婚姻。当然，进入婚姻后我们又开始了一种叫做「婚姻生活」的新游戏，而想要玩好这个游戏，难度更大。</p><p>当遇到困难重重或者找不到前进的动力的时候，不妨试一下这种游戏的心态，这样，我们可以把困难转变成一件不那么难熬，甚至是值得享受的事。我不快乐是因为我没有达成自己游戏中的目标。为什么没有达成自己的目标？因为我还缺乏 X 和 Y 技能。如何获得 X 技能？我需要先提升自己的等级和经验值，同时不断练习 A 和 B 这两个技能，还要去完成 n 个 Z 任务。用玩游戏的心态去对待那些目前还未解决的问题，哪怕是再大的困难，也会变得有趣起来。</p><h4 id="11-月-20-日-做事哲学以及找到适合你做的事"><a href="#11-月-20-日-做事哲学以及找到适合你做的事" class="headerlink" title="11 月 20 日 - 做事哲学以及找到适合你做的事"></a>11 月 20 日 - 做事哲学以及找到适合你做的事</h4><p>这个世界上最难的事是什么？找到自己喜欢且有价值做的事应该是其中之一吧。其次是专注做好一件事，即使一开始没那么喜欢它。人真的是很奇怪的一个物种，相比其它生物，明明已经不需要担心安全和食物了，但却还是要为每天应该做什么而发愁。当人还是动物的时候，维持生存很难；当人成为能够运用工具和能够思考的人之后，寻找到有意义的生活，同样很难。前两天说目标感很重要，但是才过几天，想法就又变了。目标感只是意义感的伪装，找到事情的意义才是问题的关键。找到做事的意义，其实就是一个人的生活哲学。他如何思考，为什么这样思考？什么东西对他来说最重要？应该如何做好一件事，要把这件事做到什么程度才算是「好」？如果不把这些问题想清楚，总有一天，他会被这些问题纠缠到无法入睡。</p><p>那么，我的意义感来自哪里？目前来看，我已经度过了价值和观念的构建阶段。我知道自己需要和他人生活在一起，而且也无意过那种自给自足、独立于世界之外的隐居生活，所以对我来说，意义感离不开人类社会。我想要为他人创造价值，我想要让自己和他人生活得更加幸福，我希望他人因为我而变得更快乐，生活变得更加容易、更值得享受。而达成这一目标的方式太多了，可以做的事也太多了。其实都不用具体选择哪一个行业或者工作类型，每天以这种心态去工作、生活就可以了。但是，人总是希望能够以更高效的方式去达成自己的目标。而从事商业活动就是现代社会达成这一目标的最简单的途径。什么样的事最适合我去做而且我能够做得比别人更好？这个社会最需要什么样的人才？当下大家最需要解决的问题有哪些？我是否具备解决这个问题或者提供某种服务的能力和资格？找到这些问题的答案，也许你就能解决人生意义的问题。</p><h4 id="11-月-21-日-人类增强技术以及未来生活的想象"><a href="#11-月-21-日-人类增强技术以及未来生活的想象" class="headerlink" title="11 月 21 日 - 人类增强技术以及未来生活的想象"></a>11 月 21 日 - 人类增强技术以及未来生活的想象</h4><p>昨晚看了 The Titan 这部科幻片，讲的是地球末日危机背景下的一个故事，一位激进的科学家尝试改造人类身体从而适应在土星的卫星泰坦上继续生存下去。看完片子联想到，未来如果科技和道德允许，人类一旦开始改造自身，这个进程可能会像整容一样，使人类走上无穷无尽的追求完美的自我升级之路。不过，用整容做比喻好像不太恰当，因为目前绝大部分人都没有尝试过整容，可能更像是接种疫苗吧。在疫苗发明之前，瘟疫和各种流行病常常肆虐各个大陆上的人口，但是现在几乎不存在这种情况了 (Covid is laughing in the corner..)。人类强化也是一样，一开始可能只是为了试验新技术或者治疗某种疾病，等到技术成熟之后就会开始向大众普及。想象一下，军队最开始试验这种人类增强技术用来改造士兵，通过改造得到了耐力、力量、速度都远超常人的超级战士。接下来，这种技术就会向民用的方向普及，一开始是为先天有缺陷的人提供治疗，比如肌肉萎缩症等，而后是普通人也开始尝试这种「新技术」。既然都是通过技术手段改造人体，而且不需要刻苦的训练就能得到强化后的身体器官，再加上技术上没有明显的缺陷，为什么不让普通人也变得更强呢？一旦足够多的人对自己使用了人体增强技术之后，这场竞赛肯定不会就这么停下来，会有越来越多的细分领域的新技术被发明出来，而且接下来还有基因编辑和生化人等许多方向可供选择。简单来说，人类开始主导自身的进化，并且开始朝着越来越多样化的方向发展。种族问题不再是问题，因为未来我们彼此间的差异会比种族和肤色大得多。富人会变得像神一样无所不能。穷人虽然无法承担得起像富人一样的改造技术，但是他们同样能得到某种程度上的改造，因此他们的能力也还是会远远超过这个时代下的我们。然而这一切都是我的想象，也许未来人类根本不会向这个方向发展，也许人类发明出了无与伦比的虚拟现实技术，大家到时候都生活在虚拟世界中也说不定。</p><h4 id="11-月-22-日-抛弃竞争思维，选择帮助他人"><a href="#11-月-22-日-抛弃竞争思维，选择帮助他人" class="headerlink" title="11 月 22 日 - 抛弃竞争思维，选择帮助他人"></a>11 月 22 日 - 抛弃竞争思维，选择帮助他人</h4><p>昨天周末，几乎一天没出门，在家看剧刷油管，偶然刷到一条 vlog 视频，让我同时心生羡慕和焦虑。其实也没什么特别的，就是一个美国亚裔女生的日常生活。让我感到羡慕的不是他们的生活方式，而是他们身上散发出的那种无忧无虑、天真自然的状态。反观自己，似乎成年之后就再也没有呈现过这样的状态了。我觉得说到底，还是环境的因素大一些吧。国内的生存环境竞争更加激烈，每个人都想要把别人比下去，似乎只有这样才能证明自己的价值，才能让自己从人群中脱颖而出。我现在觉得这种思维方式是错误的，但是不知道应该如何从这种竞争中跳出来。我知道自己过去其实也一直都是以这种方式思考的，但是它并不能让我变得更加优秀，只是让我变得更加焦虑，而且也容易活得不快乐。虽然快乐在于心境，但是你肯定希望你所处的环境是轻松自在的，是互相鼓励、帮助彼此成长的，而不是为了争夺资源而互相比拼、展示各自的能力。那样，即使人的能力提升了，但是却失去了好的心态，得到更多的焦虑。我知道，自己目前能力有限，无法改变自己的环境，所以只能从改变自己做起。首先，真正专注于自我成长，专注于个人目标，抛弃竞争思维，把他人当做自己学习的榜样。其次，改变自己的心态，做一个善于分享和接纳他人建议的人。最后，竭尽所能帮助他人，尤其是那些工作不久的新人，帮助、指导他人也是一种学习的过程，如果你能帮助越多的人，你的能力提升得也越快。</p><h4 id="11-月-23-日-如何独处：正念冥想、感恩和为他人祈祷"><a href="#11-月-23-日-如何独处：正念冥想、感恩和为他人祈祷" class="headerlink" title="11 月 23 日 - 如何独处：正念冥想、感恩和为他人祈祷"></a>11 月 23 日 - 如何独处：正念冥想、感恩和为他人祈祷</h4><p>我虽然喜欢独处，但是却不擅长独处。昨晚没有出门跑步，睡前比平时多出了一个小时的时间，所以有了这样的感慨。一个人的时候总是想要用各种事务将时间填满，比如跑步、电影、游戏、上网闲逛等，但是如果让我什么都不做，反而会觉得恐慌。简单来说，还是不够活在当下吧。所以才需要更多地练习<strong>正念冥想</strong>，认真感受此刻的一切，包括你周围的环境、脑海中不停闪现出的想法、身体器官的状态，把自己想象成一个观察者感受当下的一切。随着周围环境的变化，或者脑海中想法的影响，感受自己各种情绪的起落。不要去思考情绪的来源，只是去感受它。无论感受到的是孤独、痛苦、焦虑、冷漠，还是喜悦、满足、平和，都要完全接纳它们。情绪和感受是我们心灵的保护罩，通过这些情绪我们可以了解到自己的哪些需求没有被满足。另外一个值得练习的技巧是，<strong>多感恩以及为他人祈祷</strong>。感恩自己所拥有的一切，祈祷身边人甚至是陌生人都能活得健康、幸福、长寿，这是增进个人幸福感的心理秘诀。</p><h4 id="11-月-24-日-工作的意义以及学会赋予意义"><a href="#11-月-24-日-工作的意义以及学会赋予意义" class="headerlink" title="11 月 24 日 - 工作的意义以及学会赋予意义"></a>11 月 24 日 - 工作的意义以及学会赋予意义</h4><p>我现在的工作对我最大的意义是什么？其一是得到报酬，维持自身的生存；然后是自身能够获得成长；有成就感。缺失的地方是，不能和同事相处地非常亲密和愉快，拥有更有意义的人际关系。但是这主要是因为我不愿意打开自己的心扉，去分享自己的生活和思考，也不愿意让别人接近我，所以主要是我的问题。理想的工作应该是除了能够提供以上这些东西之外，还能够长期对他人的生活造成有益的影响。我觉得我现在的工作最大的问题就在这点。虽然我现在正在做的每个项目对每个客户而言都是有意义的，但是长期来看，10 年、20 年、30 年之后，这些项目的意义还能继续存在下去吗？这不禁让我开始思考，什么样的工作才能在二、三十年之后还能继续提供价值。编程只是工具，是实现目标的一种方式，未来还会不停地出现新的工具，我能确保自己能跟上新的潮流、掌握新的技术吗？如果你能信心满满地说 Yes，那么无论你现在正在从事的是什么工作，都不用感到担心，因为这说明你具备不断学习和自我更新的能力。</p><p>老实说，我此刻对自己最大的焦虑是计算机科学的基础不是太好，所以，可能还是要先把基础掌握好。至于其它的意义感之类的问题，你要相信你所做的每一件事都有其意义。街边的小摊贩为什么能够忍受大冬天还出来卖水果，因为她有家要养。如果你还在抱怨做事找不到意义，去问问他们是什么感受。要学会为自己所做的事赋予意义。不过，我不是鼓励大家去做需要大量重复、低技能的工作，我的意思是每份工作都有其困难的地方，<strong>学会先把简单的事情做好</strong>。要知道能把简单的事做到极致也是不容易的，而且也能得到成长。之后再去试着发现机会，做更难一点的事，这样会好一点。最后一点是：要有耐心。改变都是慢慢发生的，坚持足够长的时间之后再来看结果。</p><h4 id="11-月-25-日-解除焦虑和迷茫：珍惜时间"><a href="#11-月-25-日-解除焦虑和迷茫：珍惜时间" class="headerlink" title="11 月 25 日 - 解除焦虑和迷茫：珍惜时间"></a>11 月 25 日 - 解除焦虑和迷茫：珍惜时间</h4><p>昨晚睡前又陷入了焦虑的情绪之中，觉得自己毕业 4 年多，能力、经验并没有达到自己的预期，再加上对未来的发展也看得不是太清，如果继续从事移动端开发，Android + Flutter，虽然近几年不用担心工作机会，但是 5 年之后呢？那时我将超过 30 岁，如果想要继续从事一线开发的工作，无论对于初创公司还是大厂来说，都必须具备过硬的条件才可以。如果是初创公司，我必须能够带来足够的价值，无论是技术上还是其它资源上；如果是大厂，技术必须过硬，其次是履历要足够好看。以我目前的履历和技术，很有可能将会无处可去，最终被迫接受一些为了维持生存的工作机会。我当然不想要这样的结果，所以，陷入了焦虑之中。这还只是未来 5 年的情况，如果是 10 年呢？20 年呢？技术发展日新月异，虽然我对自己的学习能力有信心，但也难免还是会感到担心。现在我只是一个人，未来组建了家庭之后，还能有多少时间用于学习呢？转念一想，别说那个时候，就算是现在，我每天工作之余用于学习的时间有多少呢？就算有很多时间，如果不好好珍惜，还是会被自己浪费掉的。没时间只是借口。而且现在没有人打扰自己，时间充裕，更应该把时间利用好，巩固基础，学习新技能，并且把它变成自己的习惯。未来的事交给未来再说吧，没人能说得准未来会发生什么。现在自己毕竟还年轻，依旧处在积累的阶段，偶尔迷茫是正常的。只要拥有一个健康的身体，保持思考和反思的习惯，这个世界上真的没有什么好怕的，做好随机应变的准备就好了。</p><h4 id="11-月-26-日-不要为了逃避痛苦而选择沉迷"><a href="#11-月-26-日-不要为了逃避痛苦而选择沉迷" class="headerlink" title="11 月 26 日 - 不要为了逃避痛苦而选择沉迷"></a>11 月 26 日 - 不要为了逃避痛苦而选择沉迷</h4><p>最近有一个顿悟，我们所有的沉迷都是为了逃避痛苦。初高中时候的我曾经沉迷过游戏一段时间，现在回想起来，其实不是那款游戏多么好玩多么吸引我，而是我想要逃避学习的痛苦。而且在游戏中能体验到那种自己和他人是相连着的感觉，也是支持我持续玩下去的原因。这是因为我害怕孤独，不知道如何与自己相处，通过游戏可以逃避独处的压力。一个例证是，现在我能接触到的游戏种类更丰富，游戏内容制作更加精良，游戏设备也更强大，但是我却没有玩的动力了，这就说明我并不是真的热爱玩游戏。然而我还是会常常沉迷刷手机，刷社交网站、看视频等，不过这只是因为过去没有像现在这么多的娱乐方式而已。所以，我现在才开始意识到，找到自己沉迷的原因很重要。如果是为了逃避痛苦才做这件事，那么就要告诉自己应该马上停止，因为逃避并不是解决问题的办法。这也是为什么我们需要养成好习惯，把日常的工作和生活流程化之后，很多逃避痛苦的行为都会自动消失。<strong>什么时候起床，什么时候工作，什么时候运动，什么时候学习，这些问题不应该交给意志力来决定，而是应该成为我们的习惯。</strong></p><h4 id="11-月-27-日-做真实的自己"><a href="#11-月-27-日-做真实的自己" class="headerlink" title="11 月 27 日 - 做真实的自己"></a>11 月 27 日 - 做真实的自己</h4><p>随着年纪渐长，越来越羡慕小孩子的天真和无畏，他们对一切事物都保持好奇心，想要什么就会说出口，从来不会掩盖自己的真实想法。成年人为什么做不到这一点呢？因为我们有太多东西需要考虑了。我们在说一句话或者做一件事之前，会先考虑对方的想法，会担心事情后续的发展，以及周围人会如何评价自己等等。当然，身处陌生人社会，保持警惕是应该的，但是，我觉得我们应该思考，当下的这种警惕和猜忌是否还有必要？我观察到的身边的大多数人都是比较友善的，既然如此，为什么不尝试打开自己的心扉，多多搭讪以及认识身边的其他人呢？为什么不能做真实的自己，告诉对方自己的真实想法呢？我觉得最主要的原因还是我们习惯了戴着面具生活。如果你能打破这种人与人之间的面具，和任何人都能坦率地沟通交流，告诉对方自己的真实想法，那么，你会获得无数的机会：认识新朋友，获得更多的资讯和商业机会，甚至发展出一段恋情等等。回看自己过去这几年的状态，似乎朝着越来越孤立的方向发展，究其根本，除了性格的因素之外，最大的原因还是自己太过封闭自己了。而其实想要改变也不难，认真对待现有的人际关系，关心身边的每一个人，打开自己的心扉，表达自己的真实想法。万事开头难，那么，就从每天和同事打招呼以及练习微笑开始吧。</p><h4 id="11-月-28-日-要么改变自己，要么接受现实"><a href="#11-月-28-日-要么改变自己，要么接受现实" class="headerlink" title="11 月 28 日 - 要么改变自己，要么接受现实"></a>11 月 28 日 - 要么改变自己，要么接受现实</h4><p>每件发生在你身上的事都是有原因的，尤其是那些你不喜欢但却又无力改变的事。当然，有一些是天生的，比如我们的长相和身高等等，但是大多数那些后天发生的令我们感到不舒服的事，通常都是我们自己造成的。比如缺少深度的人际关系，身边没有好朋友等。因为我们总是太过被动，而且也没有提高自己的价值，加上不懂得如何表达和关心他人，于是越来越难交上新朋友。如果你还有一个挑剔的性格，眼里容不下一点沙子，总是习惯性看到他人身上的缺点而不是优点，那么在你眼里，你身边值得交往的人也不会很多。所以，为了改变现状，你的选择只能是改变你自己。要么改变你的性格，变得更主动、积极、外向，学会关心他人，站在他人的角度思考问题，而不是首先想到自己。然后不断提升自我价值，让自己值得「被利用」，并且学会表达自己，这样才能获得更多的关注和潜在的机会。再有就是降低自己的择友标准，没有人是完美的，你在别人眼里也一样全身都是缺点，但是如果我们只关注他人身上的缺点，失望是肯定的。一切都是视角的问题，换个角度，用积极的眼光看，所有事物都有它存在的必要的一面。能够看到他人身上的缺点是个好事，但是也要能够看到他们的优点，只要是值得你学习的，而且缺点也不是太致命，那么就应该接纳它们，就像我们能够接纳自己身上的缺点一样。除此之外，如果你不愿意改变自己，当然也没问题，那么就要接受自己不能得到更充实、更令人满意的人际关系的现实，学会和这种现状和平相处，不要寻求改变，也就不会感到痛苦了。二者选其一，别无他法。</p><h4 id="11-月-29-日-思考情绪的来源"><a href="#11-月-29-日-思考情绪的来源" class="headerlink" title="11 月 29 日 - 思考情绪的来源"></a>11 月 29 日 - 思考情绪的来源</h4><p>每当觉得情绪不佳的时候，比如感到伤心、难过、愤怒、难堪、无聊的时候，可以问自己几个问题：我身体各个部位现在是什么感觉？我为什么会有这样的感觉？我的这些情绪的来源是什么？是因为某些发生在我身上的事吗？我为什么会这样思考？换个角度思考这件事的话，我还会有这样的感觉吗？我能否改变看待这件事的方式？我的感知方式是否正确？我的哪些需求没有被满足？虽然直接对某事做出反应是种自然而然的处理方式，但是如果我们能克制住这种冲动，让自己停下来思考一会儿再做出应对，会让我们处理事情变得更加游刃有余。智慧就是在这样不断地反思中慢慢增加的。不要以为自己做不到或者做不好，只要多去尝试几次，情况总能慢慢改善的。</p><h4 id="11-月-30-日-编程语言不重要，基础更重要"><a href="#11-月-30-日-编程语言不重要，基础更重要" class="headerlink" title="11 月 30 日 - 编程语言不重要，基础更重要"></a>11 月 30 日 - 编程语言不重要，基础更重要</h4><p>编程语言不重要。过去一直以为语言很重要，你必须学会 C 或者 C++ 才能了解编程的精髓，但是最近我的想法改变了，掌握计算机基础和熟悉编程范式才是真正的核心。语言只是实现我们的目标的方式，对于不同的项目完成它们的最合适的语言可能也不一样，但是只要我们真正掌握了计算机基础和编程的核心思想，学习不同的语言将是一件非常自然而然的事。所以，不要纠结于要不要学习某一门语言，而是问自己，我的基础怎么样？我的目标是什么？我现在应该关注的重点是什么？如果你要开始实现一个新项目，在一开始时，了解需求的各种细节以及如何实现才是需要考虑的事，选择什么样的语言优先级反而不是很高。而如果你想要精进自己的基础，语言同样不重要，因为学习计算机基础、算法和数据结构、操作系统、计算机网络，这些都和编程语言无关。哪怕是学习计算机课程中的编译器，即使不了解某一门语言，也不会影响你对这门课程的学习。所以，放弃那种「我一定要学会某种语言」的执念吧。语言并不重要，真正重要的是把你的时间投入到巩固基础上。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不断成长</title>
      <link href="/2021-10/"/>
      <url>/2021-10/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/7hx4gdlfamo" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>这个月似乎发生了很多事，但是当我坐下来想写点什么的时候，却不知道该从哪开始写起。最大的变化来自家人，老姐的结婚对我们全家人来说都造成了不小的冲击。从办酒席到去温州，前前后后感觉发生了好多事，第一次看到家里人来了那么多的亲戚，第一次全家人一起坐那么长时间的大巴车，第一次收到那么多红包，第一次发现原来女生穿上婚纱后的变化会这么大。我想对爸妈来说，一定也有很多这样的第一次，不知道他们心里是怎么想的，可能也是各种情绪混杂在一起，感觉很难用语言来表达自己吧。无论怎样，老姐和姐夫的人生已经开始了新的一页，而我自己也该考虑下未来的计划了。虽然还不知道自己的人生伴侣在哪里，但是我知道自己身上正在悄悄发生着一些变化，思维方式的缓慢转变，逐渐养成的新习惯，以及更加健康的生活方式等，让我越来越有种我能够掌控自己人生的感觉，很多焦虑都自动消失了，我也有了更多的时间和精力去思考和规划自己的未来。今年是我从实习工作开始的第五个年头了，回想五年前的自己，不敢说全都达成了自己当年的目标，但是至少还算是合格的。我虽然成长得很慢，但是至少从来没有放弃过成长。我觉得<strong>能够不断成长</strong>是对一个人最好的褒奖，我也希望自己永远都配得上这样的评价，直到死亡。</p></blockquote><span id="more"></span><h4 id="10-月-1-日-老姐的婚礼"><a href="#10-月-1-日-老姐的婚礼" class="headerlink" title="10 月 1 日 - 老姐的婚礼"></a>10 月 1 日 - 老姐的婚礼</h4><p>昨天请了一天假提前回家了，因为是老姐结婚办喜事的日子，从早到晚家里都坐满了人。老实说，每次见到这些亲戚，我心里其实都很惶恐，因为他们总是喜欢问你一些让你尴尬的问题。虽然可以糊弄过去，但是你一不小心就会说出一些事后回想起来会让自己感到难堪的话，而且总是会伴随着后悔的情绪。不过，我相信人的记忆具有偏好性，这些不好的记忆是会随着时间逐渐被淡忘掉的。关键是要对自己的想法和行为足够敏感，不要被一时的所作所为所误导，那个不是真实的自己。我觉得只有在安静状态下的自己，比如此刻正在写碎碎念的我，才更真实。人总是需要有更多的时间，才能逐渐变得更能感知自己周遭的一切。接下来还有几天的时间，需要延续这种不太真实的自我，之后就可以继续做真实的自己了。控制你能控制的，不要试图改变他人的想法，需要对你的人生负责的只有你自己。</p><h4 id="10-月-2-日-情绪化的自我以及敏感是件好事"><a href="#10-月-2-日-情绪化的自我以及敏感是件好事" class="headerlink" title="10 月 2 日 - 情绪化的自我以及敏感是件好事"></a>10 月 2 日 - 情绪化的自我以及敏感是件好事</h4><p>我觉得自己是个特别矛盾的人。我的内心好像有两个自我，一个想要讨好他人，一个想要做自己。所以，有时候我会说出一些违心的话，只是为了让别人接受我、喜欢我，但是事后又会觉得自己真恶心，居然也会说出那样虚情假意的话来。而有的时候，我又会觉得自己太过自我，太过直言不讳，容易忽视他人的感受。可能每个内心敏感的人都会有我这样的感受吧。不过，我们也要从两面看待自己的这种矛盾心态。厌恶讨好型人格可以让我们注意到自己的所作所为，从而更关注自己的内心，而警惕过于自我让我们对他人的感受变得更敏感，关键是如何把握好这两者之间的平衡。一直以来，我都觉得自己是个非常理性的人，但其实我也会偶尔变得情绪化，只不过我不会把这种情绪化的自己展现出来。所以，我需要改变的一点是，不要隐藏情绪化的自己，要学会通过沟通表达自己的感受。我们都只是普通人而已，能够改变的东西非常有限，唯一能够控制的，可能就只有我们自己的想法以及想法之后的情绪了。不要害怕面对它们，也不要因此而苛责自己。还有，敏感是件好事，和性别无关，不要在乎别人的想法。</p><h4 id="10-月-3-日-人脉就是你能给他人提供的价值"><a href="#10-月-3-日-人脉就是你能给他人提供的价值" class="headerlink" title="10 月 3 日 - 人脉就是你能给他人提供的价值"></a>10 月 3 日 - 人脉就是你能给他人提供的价值</h4><p>这两天老姐结婚，我作为参与者之一，着实体会到结一次婚到底有多麻烦。除了祝福之外，心里还产生了许许多多的想法，比如家庭的重要性，比如亲朋好友、人脉的重要性，比如见到人要主动打招呼，等等。处理好人际关系真的很重要，也很难。人脉其实分为两块，一块是你的血缘带来的，也就是家庭关系人脉网，另一块是我们自己主动建立的，比如你的朋友圈和组建新家庭带来的关系网。前者由卵巢决定，但是后者是可以被我们主动控制的。而对于家庭环境一般的人而言，后者显然比前者重要得多。你选择什么样的人做朋友很重要，唯一比这更重要的可能只有选择人生伴侣了。对我而言，家族关系网中能够带给我的有用的资源不多，我身边的朋友也不多。所以，我的起始值约等于零。但是，我觉得自己毕竟还年轻，而且至少身边没有人给自己拖后腿，这点我就已经挺感恩的了。其次，芒格说过得到一样东西的最好的方法是让自己配得上它，建立高价值的人脉网的关键在于让自己拥有足够的价值。就我自己目前的状态来看，虽然离目标还有点远，但是我觉得自己至少还是有一点利用价值的。懂点编程，理解能力还 OK，虽然口头表达能力差了点，但是文字能力还算过得去。而且我觉得提升能力和建立高价值的人脉关系网这两者之间并不冲突，尽早去开始认识、结交自己喜欢且崇拜的人，和他们做朋友；同时学会分享，坚持为他人提供价值，只有这样才能逐渐赢得更多人的信任并且建立更深层次的友谊。</p><h4 id="10-月-4-日-和家人们的相处以及待人接物"><a href="#10-月-4-日-和家人们的相处以及待人接物" class="headerlink" title="10 月 4 日 - 和家人们的相处以及待人接物"></a>10 月 4 日 - 和家人们的相处以及待人接物</h4><p>这两天老姐结婚，家里办完酒席之后还要去姐夫家，姐夫家在温州泰顺，所以我们一家人一起坐一辆中巴车去那边。这一路上通过和家人们的相处以及到那边之后发生的事情，让我有种重新认识了自己家人的感觉，而且改变了过去我对家人的很多看法。最大的感慨是，他们更像是一个个普通人了，我能够更近距离地观察他们喜怒哀乐的情绪变化，这让我觉得我的性格和行为表现上有很多他们的影子。另外就是，我和人接触、打交道的能力确实有待提高。我的爸妈其实也都不擅长和陌生人打交道。对我来说，最主要的原因还是经历得太少，缺少社会的毒打，这方面老姐就比我好很多。关键还是要学会站在他人的角度思考：如何说话才能让别人感到舒服，如何让他人觉得自己得到了尊重和重视。聊天的时候也一样，我并不擅长闲聊，同样页是因为经历的事情太少，知识面也不够广。所以，还是要去多体验，多和不同的人聊天可以增加自己的见识，另外阅读、旅行等也有帮助。待人接物是最考验一个人的同理心的，而且也只有在大量的实践中才能得到提高，就像学习游泳，你理论掌握得再好，都不如去水里游个几次来得进步快。一定要多和陌生人聊天，不要让自己大脑中的想法束缚自己，你身边的所有人都和你一样只是普通人而已，我们身上的共同点远多于不同点，努力寻找彼此的共同点，分享彼此的经历。放轻松一点，表达出自己真实的想法和情绪。只要能始终保持这样的信念并且持续行动下去，相信我身边的朋友会越来越多。</p><h4 id="10-月-5-日-改变与重新开始的勇气"><a href="#10-月-5-日-改变与重新开始的勇气" class="headerlink" title="10 月 5 日 - 改变与重新开始的勇气"></a>10 月 5 日 - 改变与重新开始的勇气</h4><p>改变是人生的主题，我们每个人都在不停地发生变化，一方面是因为个人经历的不断更新，在新的环境、新的事物和新的人的共同作用下，我们产生了一些新的观点，或者改变了过去的一些行为模式。另一方面，随着年龄的增长以及阅历的增加，我们身体的激素水平趋向稳定，我们不再变得容易冲动，而是更多地通过反思自己、长久以来形成的价值观和决策系统来行动。尽管如此，我们还是要拥抱变化，挑战自己旧有的认知，继续不停地改变自己。因为没有人是完美的，我们就像一条航行在大海中的小船，需要不停地校准航向才能抵达最终的幸福之地。改变有时候需要我们拥有<strong>重新开始的勇气</strong>。比如，当我们发现需要改变自己的性格或者做事的方式的时候，一开始肯定会觉得困难重重，想要延续自己已经习惯的行为模式，但是，当我们意识到这种方式只会让自己陷入更多的麻烦之中，而到时候我们将不得不去改变自己的时候，我们就会明白应该让这种改变尽早发生。不要害怕改变带来的痛苦。痛苦加反思等于成长。越是感到痛苦，就说明我们正在发生的改变越大。另外，也要记得，我们努力的最终目的是生活得更加幸福。因此，要学会有的放矢，不要让其它事物阻挡了我们真正的目标。</p><h4 id="10-月-6-日-和家人聊天"><a href="#10-月-6-日-和家人聊天" class="headerlink" title="10 月 6 日 - 和家人聊天"></a>10 月 6 日 - 和家人聊天</h4><p>有时候总觉得自己不擅长和他人相处，不会闲聊，甚至和家人在一起时也是一样。但是，说到底，我只是不知道如何寻找共同话题而已，一旦聊到我擅长的话题，我还是可以聊得挺起劲的。和家人闲聊也是种增进彼此感情以及了解彼此的过程。虽然我们过去在一起相处了很长时间，但是自从离开家之后，我们面对面聊天的机会其实并不多。所以，一旦有这样的机会还是要多多表达自己，然后也多听听他们的想法。虽然你可能对某些话题已经如数家珍了，他们一开口你就知道接下来他们要说什么。但是，即使如此，你也应该认真倾听。他们也只是普通人，有着自己的烦恼、担忧、怨气以及其它各种各样的情绪，通过聊天可以释放掉这一部分压力，也可以让我们的关系变得更加亲近。我的问题是太过习惯于隐藏自己的情绪，喜欢把自己的真实想法藏在内心深处，尤其是那些不满的情绪和无人能解的困惑。虽然说出来并不能解决实际问题，但是至少可以让他们加深对你的了解。你的困难和担忧会得到亲人的理解，他们也因此更能接纳你。还有，不要耻于谈钱，家人的一大功能就是在特殊时刻可以在经济上互相支持。不得不承认，如果发生了重大意外，家人亲属才是我们的最后一道保险。</p><h4 id="10-月-7-日-和家人的关系"><a href="#10-月-7-日-和家人的关系" class="headerlink" title="10 月 7 日 - 和家人的关系"></a>10 月 7 日 - 和家人的关系</h4><p>又度过了一个十一假期，今年假期的主题是老姐结婚。虽然知道婚礼对女人来说很重要，但是我觉得老姐的婚礼不算太复杂，就只是在家里摆摆酒席，亲戚朋友来喝几天喜酒，然后去男方家里再办一次。话虽如此，要准备的东西还是很多，在我看来还是挺麻烦的。不过，这种事毕竟一辈子就只有一次，也不能省略，只能尽可能做到最好吧。另外一个感悟是，你和家人的联系真的是无法被斩断的。尤其是在农村，一个家族内部的联系非常紧密，哪怕你想要独立于关系圈之外，也无法做到。当然，我不是说这样不好，家族内几个家庭频繁来往当然有好处，彼此有个照应，有亲情作为纽带，家族成员间可以互相帮助、互通有无、彼此分享、共同成长等等。我还是挺庆幸自己能够出生、成长在这样的环境下的。所以，为了家人，我们也要更加努力一点，希望有朝一日可以帮助到家族中的其他成员，为家族的繁荣发展做出贡献。还有一点就是，每一次回家都能感受到浓浓的世俗气息，也就是钱的压力。可能是我现在单身吧，还体会不到钱在人际关系中所起到的作用。但是，当你作为家族成员的一部分，有时候会不得不和其它亲戚产生经济上的利益纠葛，子女教育、老人养老、人情往来支出，这些都离不开钱。所以，不要耻于谈钱，而是要有意识地思考如何才能解决问题，并且让事情向好的方向发展。最后，家人很重要，但是你的个人成长更重要。</p><h4 id="10-月-8-日-停止自我审查"><a href="#10-月-8-日-停止自我审查" class="headerlink" title="10 月 8 日 - 停止自我审查"></a>10 月 8 日 - 停止自我审查</h4><p>比言论审查更严重的问题是自我审查，也就是每当我们想要表达的时候，先在脑海中审查自己，最后往往会导致我们没有说出想说的话。虽然有时候我们的确应该「三思」而后行，但是涉及到和陌生人聊天的情况下，我们最大的问题往往是想得太多。我应不应该插嘴说话？打断他们是否不太礼貌？现在可以走上前去打招呼吗？如果不知道该说什么怎么办？我应该和她们聊这个话题吗？聊这个会不会越界了？当你在大脑中不停重复这些问题时，你会发现自己越来越不敢去开口和陌生人聊天。所以，我们应该停止自我审查。不要过度思考，直接开口说出自己当下心中的想法就可以了。学会自我表达首先要从注意到自己的想法开始，当你停止审查自己的想法，当你真正接纳自己，你会发现你和陌生人没有什么不同，聊任何话题都可以拉近彼此关系、增进对对方的了解。</p><h4 id="10-月-9-日-习惯养成之建立身份认同"><a href="#10-月-9-日-习惯养成之建立身份认同" class="headerlink" title="10 月 9 日 - 习惯养成之建立身份认同"></a>10 月 9 日 - 习惯养成之建立身份认同</h4><p>养成一个好习惯或改掉一个坏习惯的关键是要建立身份认同，如果我想要成为那样的人，我应该怎么做？我们每个人都有自己的局限性，有着自己想要改变的地方，而且在那方面一定有人做得比我们更好。所以，我们应该以那些做得比我们好的人为榜样，并且相信自己终有一天会成为他们那样的人。这样一来，我们养成好习惯或者改掉坏习惯的动力就会变得更足。如果我是他，我是应该去跑步还是坐在懒人椅里玩手机？如果我是他，我是应该看书还是玩游戏？如果我是他，我是应该认真处理完工作上的事再去做其他事，还是先放松一会儿之后再处理？当我们始终以榜样作为自己的行为标准时，我们就获得了控制自己如何行动的能力，习惯养成或戒除都会变得更加容易。当然，可能有的人不吃这一套，那也没关系，关键是要找到自己在乎的东西，并且把它作为改善自己行为的力量源泉。</p><h4 id="10-月-10-日-27-岁生日以及过好自己的人生"><a href="#10-月-10-日-27-岁生日以及过好自己的人生" class="headerlink" title="10 月 10 日 - 27 岁生日以及过好自己的人生"></a>10 月 10 日 - 27 岁生日以及过好自己的人生</h4><p>今天是我的 27 岁生日，作为一个孤寡青年，今天除了获得了家人的问候之外，并没有其它特殊的事情发生。当然，最主要的原因还是自己太懒了，懒得折腾。我觉得一个人过得舒服就好了，没必要给自己或者别人制造麻烦。不过，仪式感还是要有一点的，所以，中午给自己下了一碗面条，下午还去配了一副新眼镜，希望自己以后能擦亮眼睛，尽快找到自己的另一半，哈哈。虽然很享受一个人的生活，但是还是想尝尝爱情的苦和甜呐。有时候想想，觉得生活在大城市里还被迫保持单身这件事真的好奇怪，明明身边有那么多机会，明明只要稍微改变一下自己，就能认识很多女生，但是还是无法踏出第一步。人真的是习惯的产物吧。无论如何，对于目前的生活状态，我还是非常感恩的。接下来还有更多好习惯需要养成，而且改变自己是一个缓慢而渐进的过程，我对未来感到乐观。无论外界如何评价自己，人生始终是你自己的，怎么过好它是你的责任。不要被他人用他们的标准限制了自己的发展。而且说真的，人生真的没有什么是非做不可的，你只需要按照自己的步调前进就可以了。每个想要教育你的人，真相是其实他们也不知道应该如何度过自己的人生，所以才会想要用自己的价值观去影响甚至控制他人。当然，对于一些真心的建议还是要听一听的，尤其是当这些建议来自那些爱你的人。但是，不要被「爱」绑架，要始终把自己的幸福放在第一位，然后再去考虑如何提升他人的幸福。</p><h4 id="10-月-11-日-旅行和更换生活环境"><a href="#10-月-11-日-旅行和更换生活环境" class="headerlink" title="10 月 11 日 - 旅行和更换生活环境"></a>10 月 11 日 - 旅行和更换生活环境</h4><p>最近心里有种蠢蠢欲动的感觉，想要去旅行，想要去另一个地方走走看看。但其实最近工作上没什么压力。可能就是因为工作太闲了，所以大脑里才会开始滋生各种各样的想法。当然，也有可能是因为最近家人朋友身上发生了很多变化，所以我也想要改变一下自己，而改变自己最快的方法就是换一个生活环境。有时候坐在工位上会想，我为什么要坐在这里？我到底在干什么？然后开始回忆自己去过的地方，想象自己在当地生活的样子。即使换一个地方生活，时间久了，一定还是会感到无聊的吧。只要是每天见到的、熟悉的环境，无论再怎么无与伦比、美轮美奂、独一无二，总有一天在你早上醒来的时候，会有一刻对周围环境感到厌倦。所以，其实还是心境的问题。旅行只能抚平、缓解你的心情，让你体验到新奇感，发现新环境和自己生活环境的差异。我们最终还是要调整心态接受自己平时的工作和生活环境。当然，极少数情况下，旅游的目的地会让你真正考虑在当地生活下来。而这又需要考虑更多的因素，比如工作环境、家人朋友的意见、搬家成本等等。所以我非常羡慕自由职业者，因为他们的职业对工作地点和环境的要求最低。我也想过成为一名独立开发者，但是一想到这么做要承担的风险和压力，就觉得还是算了吧。人一切的焦虑终究还是对自己能力的不自信。安逸、舒适的环境只会让人越来越堕落，而追求刺激和激情则必须让人放弃掉一部分安全感，真是两难的抉择。</p><h4 id="10-月-12-日-人能改变环境：不要抱怨，行动起来"><a href="#10-月-12-日-人能改变环境：不要抱怨，行动起来" class="headerlink" title="10 月 12 日 - 人能改变环境：不要抱怨，行动起来"></a>10 月 12 日 - 人能改变环境：不要抱怨，行动起来</h4><p>「人是环境的产物」，这句话过去听了无数遍，但是从来没有真正理解它的意思。很多时候，人只有在亲身体验过、有过对比之后，才会在某一时刻下突然明白：哦，原来这句话是这个意思。我们今天的样子是被过去的环境塑造出来的。这句话本身并没有什么意义，有意义的是当你意识到，人是能改变自己的环境的。知道环境塑造人不是要让你把现状（尤其是不好的现状）全部都归因于环境，而是要让自己积极行动起来，利用它、改造它、让它为你服务。如果你屈服于你所成长的环境，觉得无力改变自己所处的环境，那你就被环境俘虏了，你是它的囚犯。而如果你相信自己不会被当下的环境所困，你有能力改变自己从而改变自己所处的环境，让它变得越来越好，越来越有利于自己和他人未来的发展，糟糕的环境反而能够给你足够的动力，让你变得充满斗志，变得更加勇敢和坚毅。这也是为什么我们应该尽量少抱怨，也要尽量远离那些喜欢抱怨的人，他们会让你的心态逐渐发生改变，让你有种环境是无法改变的感觉。抱怨、发牢骚并不能改变任何东西，只会让身边的人变得和你一起沮丧。只有行动起来，才能改变现状。哪怕一时半会看不出任何改变，也要坚定信念，一直、一直地行动下去。</p><h4 id="10-月-13-日-避免后悔，立刻行动"><a href="#10-月-13-日-避免后悔，立刻行动" class="headerlink" title="10 月 13 日 - 避免后悔，立刻行动"></a>10 月 13 日 - 避免后悔，立刻行动</h4><p>当我们感到后悔时，通常分为两种情况，一种是觉得自己做了不该做的事，另一种是觉得该做的事没做。前一种类型的后悔往往会随着时间流逝而逐渐减弱，后一种类型则相反，随着时间的推移，当你反复想起它时，后悔情绪有可能会增强。这些不仅是我自己的观察，背后也有统计数据的支撑。所以，它给我的启发是：当你想要做一件事的时候，尽快去做，因为由于不做造成你未来后悔的风险，大于做了之后短期内感到后悔的风险。行动之后你可以告诉自己：至少我试过了。而如果你什么都没做，将来回想起来，你会忍不住想：如果我当时没有犹豫，而是立马行动了，现在我的处境会是什么样子的？如果你当时没有行动，你会越想越懊恼，甚至在内心谴责自己当时的不作为。我们喜欢想象，尤其喜欢想象美好的结局，但是这想象有时候只会徒增自己的烦恼。只有行动带来的结果是确定的。为了减少会让自己感到后悔的事情的出现，当我们感到犹豫是否应该做某件事的时候，只要问问自己，将来我是否会因为没有做这件事而感到后悔，如果是则要选择立刻行动。</p><h4 id="10-月-14-日-我的肢体语言"><a href="#10-月-14-日-我的肢体语言" class="headerlink" title="10 月 14 日 - 我的肢体语言"></a>10 月 14 日 - 我的肢体语言</h4><p>每当去人多的场合的时候，总是会觉得有人在看着自己，所以我的行为表现会显得特别拘谨，哪怕是在自己非常熟悉的环境中，我的肢体语言也会显得不是很自然，不够自在和舒展。我觉得我的这种表现最根本的原因是缺乏安全感，觉得自己不够好，和周围环境格格不入，而且觉得身边人不会喜欢我。演变出这种心理和一个人的成长环境有关。我从小生活在一个批评远多于赞美的环境，我的父母尤其是父亲小时候对待我的方式比较严苛。一直到现在，我都害怕和他沟通。语言暴力也是暴力的一种，只不过比肢体暴力稍微好一点。当然，每个家庭都不是完美的。至少我知道他们还是爱我的，只不过他们也有自己的局限性，很多时候没法做到面面俱到，我也能理解这一点。但是，此刻的我早已成年，已经具备改善自我以适应周围环境的能力。所以，我应该想办法改变我自己。首先是心理上的：没有人是完美的，每个人都有自己的缺陷和不足，没必要只关注到不好的一面，也要注意到自己的优点。学会爱自己。其次，你不用让所有人都喜欢你，你是一个独立且独特的人。当你表现出自己的真实样子，一定会有人不同意你，或者和你有着完全不同的观点和喜好。你无法让所有人都赞同你。这个世界正是因为每个人的不同之处而呈现出如此丰富多彩的样子。不过我们虽然不同，但依然可找到让彼此融洽相处的方法。当你能够接纳并坚持自己的独特与不同，同时也能学会接受他人，你也就能展现出更加真实的自我，表现得更加自然、不再拘谨。</p><h4 id="10-月-15-日-学会说『不』以及找到人生目标"><a href="#10-月-15-日-学会说『不』以及找到人生目标" class="headerlink" title="10 月 15 日 - 学会说『不』以及找到人生目标"></a>10 月 15 日 - 学会说『不』以及找到人生目标</h4><p>一个人的时间和精力是有限的，当你对一件事说了 Yes 的时候，这就等同于对所有其它的可能说了 No，所以，我们要学会分辨哪些事是真正值得做的。我们生活中真正重要的事很少，除了吃饭睡觉，维持生存的必要条件之外，我们还需要意义感以及让自己和我们关心的人生活得幸福。而一件事是否有意义，是否能提升自己和他人的幸福度，有时候不太容易判断，还和你当下的状态相关。比如，当你还在为生存挣扎的时候，如何获得下一顿饭就是一切意义的所在。但是，当你超越了为生存而战的状态之后，意义更多来自于你的价值观和思考方式。所以，我们应该认真思考的是：我具有什么样的价值观？我应该追求什么样的目标？当你的目标符合你的价值观的时候，你的行动就是在向你的目标靠近，你会享受达成目标的过程，你也能够分辨出哪些事对你来说是真正重要的，哪些事是值得做的。不过，随着人的成长，人的价值观有可能会发生改变，因此，目标也有可能发生改变。即使价值观不变，我们的目标也有可能发生改变。所以，不要害怕不断调整自己的目标。人生很长，我们有足够的时间去发现并追求适合自己的目标。</p><h4 id="10-月-16-日-缺乏承诺和投入"><a href="#10-月-16-日-缺乏承诺和投入" class="headerlink" title="10 月 16 日 - 缺乏承诺和投入"></a>10 月 16 日 - 缺乏承诺和投入</h4><p>最近看了 David Perell 的一篇文章（<a href="https://ckarchive.com/b/8kuqhohr2rpn">Commit to One Thing</a>），其中提到当下人们最大的问题是可选项太多，由此导致缺乏承诺 (Lack of commitment)。的确，观察下现在的年轻人中存在的现象：越来越常见的单身偏好，越来越频繁的跳槽，以及越来越趋同化的兴趣爱好。我觉得这些就是缺乏承诺和投入的表现。对我自己来说，我从来没有思考过认真投入到一段感情中去是什么样的感觉，我知道喜欢一个人的感觉，但是我不想要这之后的维持一段关系所需要的投入和付出。我理想的恋爱关系是不需要任何一方的刻意付出，也能让双方感到轻松、舒适和自在，但我也知道这是不现实的。对于工作也一样，理想的工作应该是能够发挥我所长，并且看起来像是在玩一样的工作。但是实际上，这样的工作只有在你积累了足够的资本之后才会显现出来，而在这之前，你需要不断地做选择，包括如何让自己获得一系列的知识和技能，最终才能慢慢接近那份理想的工作。甚至一项兴趣爱好也需要你有足够的投入才能发展地越来越好。所以，我们应该问自己：如何让自己变得敢于承诺和显示出足够的决心，以及愿意为之投入足够的热情？</p><h4 id="10-月-17-日-牙齿矫正与珍惜健康"><a href="#10-月-17-日-牙齿矫正与珍惜健康" class="headerlink" title="10 月 17 日 - 牙齿矫正与珍惜健康"></a>10 月 17 日 - 牙齿矫正与珍惜健康</h4><p>在下定决心要做牙齿矫正后，今天终于去把这事给办了，再过一个月我就要开始戴着牙套生活了。经历了拍片、检查、沟通、拍照、扫描之后，我觉得我对自己牙齿不够好看这件事已经没有那么害怕了。因为经过这么一顿折腾，加上金钱的付出，你会觉得其实牙齿好不好看已经不重要了，只要足够健康就可以了。就像一个人去了一趟急症室之后世界观都会大受震动是一样的。生命宝贵，健康无价，这些只有在你意识到自己即将失去它们的时候，你才能深刻体会到。人年轻的时候，往往对健康不太在意，因为衰老、疾病对他们来说还很遥远。所以你会看到，那些亲身经历了自己或者亲人得了一场大病的过程的人，会突然像是变了一个人一样，”改头换面，重新做人”。我在想，为什么要在经历了痛苦之后才能让自己发生改变呢？有什么方法可以让人在健康的环境下也能体会到「拥有健康的身体就是最大的幸福」这一点呢？好像没有什么好的办法。因为通常人在健康的情况下，不会常常想到这些，最多会为自己和家人配好完善的保险，然后在危机发生的时刻，祈求上天给自己一个机会能够熬过这一关。或许通过游戏的形式可以做到，但是，会有人愿意去玩这样的游戏吗？通过体验痛苦从而让自己珍惜健康？还是算了吧。</p><h4 id="10-月-18-日-关于容易感到紧张以及如何调节心态"><a href="#10-月-18-日-关于容易感到紧张以及如何调节心态" class="headerlink" title="10 月 18 日 - 关于容易感到紧张以及如何调节心态"></a>10 月 18 日 - 关于容易感到紧张以及如何调节心态</h4><p>有时候还是对自己容易感到紧张这件事不能释怀，老是在想我为什么这样？我是不是有广场恐惧症？形成这种结果的原因是什么？是因为对自己不自信？身份焦虑？社交焦虑？我觉得可能都有一点吧。比如一个人逛商场的时候，我总是在心里告诉自己，要让自己的行为举止表现地自然一些，不能让别人笑话我，但却忘了其实大部分人根本就不关心你在做什么，只有我自己老是觉得有人在关注着自己。为什么？因为我害怕那种被他人 judge 的感觉。这其实是个心态的问题吧。太关注外界会如何评价自己的人，就像是把视角移动到了他人那里，然后再用他人的视角看自己，此时的自己会很难把注意力放在眼下的环境中，所以会容易感到紧张。这点对于和陌生人聊天、发表演讲等其实也同样适用。最关键的是要感到放松，要意识到你只是非常普通的一个人，他人不会特意关注你或者寻找你身上的瑕疵。只要你保持善意，他人也不会用恶意对待你。那些不好的想法大多数是你自己想象出来的。深呼吸，微笑，凡事往好的方面想，话慢慢说，不要想当前事情之外的事，专注于当下发生的事就好了。</p><h4 id="10-月-19-日-撒谎是为了减轻自己的痛苦"><a href="#10-月-19-日-撒谎是为了减轻自己的痛苦" class="headerlink" title="10 月 19 日 - 撒谎是为了减轻自己的痛苦"></a>10 月 19 日 - 撒谎是为了减轻自己的痛苦</h4><p>我发现我有时候经常会撒一些无关紧要的「小谎」，很多时候我也不知道当时自己为什么会撒那个谎，有可能是想让自己脸上有光，或者是为了面子。但是无论原因是什么，哪怕再小的一个谎言，事后回想起来，心里总是会不舒服，总感觉哪里不对劲，有时候还会在心里责骂自己。越是回想，越是煎熬。这就是为什么我们应该<strong>始终保持诚实</strong>。哪怕只是撒一个小谎，都会在一个人的心里造成这么大的不协调，那些成天撒谎的人是怎么说服他们自己的？不过，我觉得他们实际上可能根本意识不到自己在撒谎，因为他们已经习惯了以他们喜欢的方式对事实进行解读。我会因为撒谎而感到痛苦，说明我还没有跨过那一道坎。对自己说的每一句话都保持诚实真的是很难的一件事，我还需要花更多的时间练习。首先，从与自己的对话开始。注意到大脑中的想法，注意自己此刻的情绪，不要忽略掉任何微小的变化。要相信自己。随着你对自己的观察越来越多，你会对自己越来越包容。学会理解自己是开始理解他人的第一步。有时候，我们撒谎的目的往往不是为了欺骗他人，而是想要逃避现实从而减轻自己的痛苦。认识到这种痛苦的根源是什么，然后意识到，撒谎并不能减轻我们的痛苦。保持诚实虽然会让自己短期内感到痛苦，但是长期来看对自己更为有益。</p><h4 id="10-月-20-日-改变自己的感知方式以及学会自我观察"><a href="#10-月-20-日-改变自己的感知方式以及学会自我观察" class="headerlink" title="10 月 20 日 - 改变自己的感知方式以及学会自我观察"></a>10 月 20 日 - 改变自己的感知方式以及学会自我观察</h4><p>我觉得自己需要明白的一点是，有时候你的感觉并不能反映出现实，也就是说你的感觉与真实的距离可能很远。我们每个人都在用自己的方式感知这个世界，而我们的感知方式受限于我们过去的经历、所受的教育以及个人性格等因素。由于感知方式的不同，同样一个场景下发生的一件同样的事，不同的人可能会得出截然相反的结论。这点从很多社会学家所做的实验中已经可以看出来了。那么，如何改变自己的感知方式，让它朝着更积极、鼓励自己行动的方向变化，我觉得这是我们每个人都要努力思考的事。一个好的模板是：对于那些长期来看对自己有益但是有可能会造成短期痛苦的事，由于你的恐惧而不敢去做的事，你应该立刻去做，也就是说要使用「<strong>行动引导情绪</strong>」策略。而对于行动过程中产生的负面想法或者过于乐观的想法，你不应该让自己忽略或者过于重视它们，而是可以提醒自己，它们很有可能只是你的个人解读，你需要先确认事实是否如此，也就是使用「<strong>是真的吗</strong>」策略。除此之外，我觉得记录是一个非常重要的手段，通过记录下事情的经过以及最终的结果，还有自己的感受等，你会慢慢对自己看待事情的方式有更多的理解，我为什么会那样思考？我当时的心路历程是什么？观察自己想法和情绪的变化是改善的第一步。</p><h4 id="10-月-21-日-不必始终扮演同一个角色"><a href="#10-月-21-日-不必始终扮演同一个角色" class="headerlink" title="10 月 21 日 - 不必始终扮演同一个角色"></a>10 月 21 日 - 不必始终扮演同一个角色</h4><p>有时候发现自己因为长期扮演一个角色，比如上班的时候是个不爱说话的程序员，而忘记了自己还有另外一面。比如昨晚洗澡的时候，突然意识到，我以前很爱唱歌的啊，但是现在好像只有在洗澡的时候才会跟着音乐哼上几句。忍不住思考：如何从一个已经习惯了的角色中跳出来，切换成另外一个角色的样子？我好像已经快要逐渐失去这样的能力了。小时候的我总是可以在几个角色之间切换，比如在学校里的时候，我可以在乖学生和搞怪同桌这两个角色之间切换，而在家的时候，我就会变成一个听话的好孩子的模样。但是此刻的自己，好像已经无法从「沉默寡言的程序员」这个缺省设定中跳出来了。都说职场会磨灭人的天性，把所有人打造成同一个样子。我觉得不应该是这样的，关键还是在于你的选择。工作应该让我们的人格变得更加丰富，而不是变得彼此趋同。我们所有人都是职场环境的一部分，每个人都应该有意识地去塑造我们的环境，让它变得更适合大家和谐共处。除了提升自我能力之外，工作也是丰富自我、完善人格的手段。所以，你不用始终扮演同一个角色，而是应该努力寻求改变。一开始的改变可能是微小的，但是时间会积累起这些改变，直到慢慢变成自己想要的样子。</p><h4 id="10-月-22-日-Love-what-you-do"><a href="#10-月-22-日-Love-what-you-do" class="headerlink" title="10 月 22 日 - Love what you do"></a>10 月 22 日 - Love what you do</h4><p>我们每个人都想要获得财务自由，即不需要为钱工作，这样就可以自由支配自己的全部时间，做自己想做的事。无数次我们想象自己拥有一个梦幻般的事业，我们热爱它，将自己全部的心血投入其中，就像许多艺术家日以继夜地投入到他们的作品创作中一样。但是，这样的工作/事业似乎遥遥不可及。不是每个人都有幸做他们最喜欢的同时也是最擅长的事的。所以，我觉得关键的一点是要意识到，这样的工作/事业可能并不存在，相反，我们需要改变自己的观念。不是去<em><strong>寻找</strong></em> 梦幻般的事业，而是努力<em><strong>打造</strong></em> 出自己的事业。这是两种截然不同的态度。就像谈恋爱一样，你不可能等到遇到最合适的那个人才开始谈恋爱，而是只有通过不断地尝试，和不同的人恋爱之后，才能发现什么样的人才是最适合自己的。<strong>干一行爱一行</strong>，这句话看似简单，但真要做到却很难。阅读那么多文字和书籍之后，我此刻才真正明白其中的道理。不过，还是挺庆幸自己能早早领悟，因为这样就能不必花太多时间在迷茫、焦虑和反反复复上了。不过，我想要说明的是，如果一个人清楚无误地确认自己更适合做另外一件事而且自己也具有一定的优势，或者他/她非常厌恶当下的工作，那么的确应该及时做出合理的调整。我这里想要表达的是，如果你没有更好的选择或者拥有的选择大都相似，那么你就应该改变自己的态度，先把眼下的这件事做好、做到极致，然后再考虑进一步的发展。行动会改变一个人，行动越久，随着经验的增加，我们的身份感也会逐渐被塑造出来，我们的最终目标应该是认同感、成就感和自我价值感，合而为一。</p><h4 id="10-月-23-日-改善和父母的关系、我们和他人并没有如此不同、选择善良和爱"><a href="#10-月-23-日-改善和父母的关系、我们和他人并没有如此不同、选择善良和爱" class="headerlink" title="10 月 23 日 - 改善和父母的关系、我们和他人并没有如此不同、选择善良和爱"></a>10 月 23 日 - 改善和父母的关系、我们和他人并没有如此不同、选择善良和爱</h4><p>现在每次回家都有种不一样的感觉，总感觉我和父母之间的距离越来越远了。我想要试着去理解他们，可是总觉得我们之间隔着一道墙。可能还是因为心理上存在隔阂吧。我不知道这种隔阂是在什么时候建立起来的，在我第一次意识到他们身上也有我讨厌的某些品质的时候？在我想要倾诉但是他们却没有耐心倾听的时候？我知道我自己也并没有做得很好，而且总的来看，可能我的因素更大一些。不过，意识到问题就已经是进步了，接下来就是如何改善的问题。我觉得我们和父母之间的相处模式很大程度上指导了我们会如何与其他人的相处，所以，如果我们能够和父母相处地更加融洽、和谐、有爱，我们和其他人之间的关系也能相处得更好。</p><p>首先要意识到的一点是，无论我们所处的环境、自身的状态如何变化，我们和他人本质上的差异其实并没有那么大。我们都是一样的人类，渴了要喝水，饿了要找吃的，有自己的喜怒哀乐，有厌恶的东西，有始终坚守的信念，也有不愿分享给他人的小秘密。既然如此，没必要因为那些细枝末节的「差异」就将彼此对立起来。我们都只来到这个世上一次，能够和彼此相遇就已经是莫大的缘分了。的确，观念和习惯上的差异，会让两个人看起来如此不同，但是，我相信即使是阶层完全不同、观念差异巨大的两个人，如果抛开那些先入为主的偏见，坦诚地沟通彼此的生活，一定也能发现，原来我们其实并没有那么不同，他/她和我一样，也有相似的烦恼，也思考过同样的问题，甚至有一些相同的喜好。</p><p>我始终相信，善良和爱是区分人类世界和动物世界的分界线，而且这完全取决于你如何选择。选择善良和爱，永远胜过选择仇恨和对立。好的选择，让我们生活得更加幸福快乐，与他人建立更加积极正面的人际关系。我们会觉得自己是可以被他人理解的，能够从他人那里得到支持，我们的善意能够得到某种形式的回馈。越是笃信这一点，我们的行动所产生的结果就越能证明这一点。我们的每一个选择都在塑造着自己生活的环境。</p><h4 id="10-月-24-日-家人及关于农村生活的感慨"><a href="#10-月-24-日-家人及关于农村生活的感慨" class="headerlink" title="10 月 24 日 - 家人及关于农村生活的感慨"></a>10 月 24 日 - 家人及关于农村生活的感慨</h4><p>每次回家都是对自己的一次提醒，那就是家人在我们生命中是无法抹去的一部分。无论你喜欢还是不喜欢，你的成长环境始终是你过去经历中的一部分。而且家族中的每个成员都见证了你的成长，在他们眼里，你依旧是过去那个啥都不懂的小孩子。尽管我们自己的思维方式相比过去已经发生了巨大的变化，但是他们似乎依旧没有改变过。我有时候会想，当我年老的时候，我是否会变得像现在的长辈一样，不再接受任何新思想，固守着自己那些几十年来的观念和经验，不再愿意发生任何改变？希望不会如此。不过无论怎样，他们始终是我的家人。尽管我们身上的共同点已经越来越少，能聊的也仅限于一些简单的、无关痛痒的话题，但是他们见证了你人生的每一个发展阶段，这也是一种缘分吧。有时候也会觉得麻烦，但是我觉得正是因为农村里还有这样与其他人交织在一起的人际关系网络，所以才显得比城市生活更加有人情味一点。每次回家我都感到这是一个充满活力的社区，而且每个人都部分参与了他人的生活。虽然也免不了窥探和比较，但是通过这样的比较，也可以让大家有一种大概的方向感，以及让生活变得更加丰富一些。我觉得没有人可以真正地过上一种完全独立的生活，因为只要你还活着，就免不了与他人发生接触，然后就会发现自己和他人生活的不同之处，所以，也免不了会相互比较。不过，只要意识到生活是自己的，我们是自己人生的主人，只有我们自己才能决定如何度过它，我们就能从这种比较中跳脱出来，慢慢向自己内心想要的生活靠近。</p><h4 id="10-月-25-日-失眠及改变生活态度"><a href="#10-月-25-日-失眠及改变生活态度" class="headerlink" title="10 月 25 日 - 失眠及改变生活态度"></a>10 月 25 日 - 失眠及改变生活态度</h4><p>昨晚又一次失眠了，躺在床上胡思乱想，脑海里一遍遍重复播放着各式各样的焦虑，无非就是那些被重复过无数遍的话题：我适合做什么？我有热爱的东西吗？我人生的方向在哪？如何实现财富自由？如何交更多朋友？我会不会一直单身下去、孤寡到老？再有就是对自己外貌的不自信，对自己学历的不自信，甚至对自己的成长背景和家庭环境也感到非常不自信。我觉得可能人在每个阶段都会有各种各样的焦虑吧，所以，问题不在于如何解决、平息掉这些焦虑，而在于如何调整自己的心态。人只要还活着，就一定会有无法满足的欲望，除非你选择过一种禅修式的生活。既然如此，我们就需要学会和焦虑和平相处。有时候只是我们想要的太多，而能做的又太少，于是才给了恐惧和焦虑滋长的空间。当你学会珍惜自己所拥有的一切，学会给予和帮助他人，你会发现，其实我们只是被自己欲望蒙蔽了双眼。每个人原本都可以过得幸福快乐，只不过我们主动选择了过一种「悲惨」的生活。学会接受那些自己无法改变的东西，学会从已经存在的事物中发现其美好的一面，珍惜、感恩我们遇到的所有人、事、物。保持这样生活态度，我们的人生会过得越来越好。</p><h4 id="10-月-26-日-有智慧的人以及成为一个更丰富的人"><a href="#10-月-26-日-有智慧的人以及成为一个更丰富的人" class="headerlink" title="10 月 26 日 - 有智慧的人以及成为一个更丰富的人"></a>10 月 26 日 - 有智慧的人以及成为一个更丰富的人</h4><p>早上看了辉哥的一篇文章，<a href="https://mp.weixin.qq.com/s/qUeHOIYWKWFTtnZY1fe35g">什么样的女人适合结婚</a>，提到真正的条件只有一条，那就是有智慧，即知道自己想要什么。如果以此为标准，我碰到过的适合结婚的女人很少很少。可能是我还太年轻吧，我觉得我遇到的大多数女性都只能被称为女生，还不够成熟到被称为女人，而其中有智慧的更是极少数。所以，可能真的是缘分未到吧。而我自己，从外表上看一点也不成熟，像个小孩子，但是我觉得自己至少在心理上还算是比较成熟，知道要有责任感，要有担当，也能够理性分析自己当前的处境并尽量做出最适合自己的决定。这样看来，我应该基本符合辉哥说的有责任心、上进心、同理心的<a href="https://mp.weixin.qq.com/s/aiv0lEDCddi87bQv3Y983A">适合结婚的男人</a>的条件吧。不过，作为一个情感经历完全空白的人，有时候容易「饥不择食」，再加上长辈们的催恋以及在言论上制造的焦虑气氛，让我真的有种自己将要单身一辈子的恐慌感。</p><p>为什么现在那么多人找不到老婆/老公？其中一大原因是因为我们有了更多的选择权，我们不依赖另一个人也可以生活得很好。而且在大城市中也不会像在农村里一样，有那么「爱管闲事」的邻居和亲戚，只要你能够承受独自生活的压力，哪怕你闭门不出天天宅在家里，也没有人会说你半句闲话。由于经济独立，长辈们能对我们造成的影响非常有限，顶多在言语上对我们进行「攻击」，所以，是否应该恋爱或结婚完全取决于我们自己的选择。话虽如此，我并不反对人应该多谈恋爱，以及在遇到合适的对象的时候乘早进入婚姻这一观点。虽然婚姻在这个时代的作用越来仅限于经济和社会生活方面，其它方面的意义并不大。但是，爱情对一个人的滋养，以及能够给人带来积极、正面的意义，这点是无可否认的。爱情会让我们变得更加完整，学会更好地爱他人以及与他人合作。</p><p>每个人都憧憬爱情，但并不是每个人都能拥有它。在遇到自己的爱情之前，我们要先努力让自己成为一个更加丰富的人。什么样的人才算是丰富的人？心中有坚定的信念，面对未知不慌乱；对自身价值和优劣势一清二楚，也善于发现他人的闪光点，懂得与人合作；能做好他人交代的细微之事，也能领导他人；能不断成长、自我更新，也能帮助、成就他人；心怀宽广，志向远大；温柔善良，明辨是非；真诚勇敢，勤奋务实；理性乐观，自由浪漫。我们能成为这样的人吗？我相信是可以的，只要我们愿意花时间打磨自己。人生那么长，哪怕每次只改变一点点，总会向目标靠得越来越近。最大的不利因素是我们会逐渐习惯于过一种按部就班的生活，并且慢慢以为自己是无法改变的。无论在什么年纪，你一定是可以改变你自己的，首先要相信这一点。然后就是积极地行动起来。每天只做一件和昨天不同的事，做一件让自己感到开心、自豪的事，日积月累下来，你会最终发现自己变成了另外一个人。相信自己能改变，相信积极行动的力量，我们就能成为自己想成为的人。</p><h4 id="10-月-27-日-翻通讯录和真正的幸福"><a href="#10-月-27-日-翻通讯录和真正的幸福" class="headerlink" title="10 月 27 日 - 翻通讯录和真正的幸福"></a>10 月 27 日 - 翻通讯录和真正的幸福</h4><p>每次翻通讯录的时候，我都会为自己感到悲哀，除了家人之外，我发现我竟然没有一个可以随时发起语音或者视频的好友，哪怕是可以随时闲聊的人都很少。每次意识到这点我都会在心底默默下定决心，要更加积极主动去联系老朋友、认识新朋友，但是时间一长，生活被其它琐事占据之后又会恢复原样。我本性是个疏离型人格的人，总是害怕麻烦他人，其实也是怕他人麻烦自己，所以我讨厌人情往来。但是，的确，有时候可能别人的举手之劳就能够帮自己省去很多时间和麻烦，而我总是怕欠他们人情。其实有时候这种人情往来也是一种维持彼此联系的方式。再有就是，我翻通讯录的目的其实也是想看看他人是否过得比我好，我害怕自己是被落下的那个。这也是为什么我有时候还是会陷入比较的漩涡之中。生活是自己的，和他人比较是没有意义的。很多时候只有当一个人过得不堪的时候，才会想要看看他人的生活，如果别人过得比自己更糟糕，那么他心里也能得到一点安慰。虽然这种心理有点病态，但是也是人之常情。我觉得一个活得幸福快乐的人是不会主动拿自己的生活和他人的生活去比较的。因为当你需要通过比较才能感到「幸福」的时候，这种「幸福」其实是你的攀比心和虚荣心的伪装出来的。真正的幸福一定是来自内心的满足：人际关系的和谐，对自己所做之事感到充实满意，对自己拥有的一切都感到感恩和心满意足，对当下发生的每件事都能以平和的态度对待。这是我们每个人都应该努力追求的幸福状态。</p><h4 id="10-月-28-日-如何处理孤独"><a href="#10-月-28-日-如何处理孤独" class="headerlink" title="10 月 28 日 - 如何处理孤独"></a>10 月 28 日 - 如何处理孤独</h4><p>孤独是一件坏事，但是人只有经历过长期的孤独才会明白，拥有一个彼此懂得、理解、支持、相爱的人是一件多么不容易的事。所以，我们才应该不断丰富自己，不断让自己变得更好，能够适配更多类型的人和环境，这样才有可能最终遇见那个合适的他/她，并且有勇气把自己介绍给对方。但是，我也渐渐开始疑问，假定我们有了一个完美的伴侣，也就是各方面都与自己适配的人，我们就不会再体验到孤独和不被理解了吗？我想肯定还是会有的。类似孤独这样的情绪是天生的，是写在基因里的，有的人可能的确更容易体会到它们，而和外界环境、是否存在可沟通的对象无关。那么，我们要如何排解这种情绪呢？首先要意识到，孤独是无法避免的，它是一种希望和现实对比之后所产生的落差。我们只能控制自己的心态，调整自己的期望，让它保持在一个适度的范围内，而不至于给自己的工作和生活造成困扰。由于环境的刺激，我们有时候会表现出极高的期望值，处于亢奋的状态，而当心情平复之后，这种落差就会把我们带入一个情绪低潮期。当我们识别出这种由过高的期望所带来的情绪变化的时候，我们就应该及时调整自己的心理预期，把它拉回到和现实齐平的状态。当然，理想情况下，我们应该始终保持在一个理性平和的状态，尊重客观事实，减少因为个人喜好和想法而影响了对实际情况的判断。但是，我们都不是圣人，即使是圣人也需要很长的时间才能修炼成这样的状态。所以，我们只能允许自己不断犯错，并且相信自己可以在一次又一次的犯错和纠错中逐渐获得改进。</p><h4 id="10-月-29-日-人和环境最终一定是互相匹配的"><a href="#10-月-29-日-人和环境最终一定是互相匹配的" class="headerlink" title="10 月 29 日 - 人和环境最终一定是互相匹配的"></a>10 月 29 日 - 人和环境最终一定是互相匹配的</h4><p>改变总是痛苦的，我们习惯了做过去的自己。有时候常常在心里懊恼，为什么我不能像「他们」那样，或者有「他们」那样的性格。但现实是我们每个人出生、成长在不同的环境中，这点是我们无法主动选择的。成长环境有好有坏，但后天的观念和习惯更重要。也许前者我们无法控制，但至少后者是可以通过个人努力和不断学习来改变的。对于一个农村长大的孩子来说，我觉得自己已经算是做得还不错的了。当然，只是相对而言。不过，我知道我将继续成长下去。我不需要和其他人进行比较，我只需要不断超越自己。适当地鼓励自己可以让自己更加有信心去改变自己。虽然我有时候还是会觉得自己和身边的环境格格不入，不过我知道那只是因为自己还没完全习惯而已。长期来看，一个人的品格和能力一定是和他的环境相匹配的。我们要做的只是不停地提升自身的能力以及改善自己的观念，让自己配得上已经拥有的一切，而我们生活和工作的空间则会在这一过程中慢慢变得更好。</p><h4 id="10-月-30-日-说和做"><a href="#10-月-30-日-说和做" class="headerlink" title="10 月 30 日 - 说和做"></a>10 月 30 日 - 说和做</h4><p>说和做是两件完全不同的事，每个人都可以拥有自己的理论，并且把这套理论打磨地非常逻辑自洽，但是，他可能从不去执行这套理论，也就是从不证明这套理论是否有效。不要做这样的人。我有时候看自己过去写的碎碎念的时候，常常会不由自主地发笑，因为我发现我最近遇到过的某个问题，其实问题场景和解决办法我都已经写过了，但是当实际发生的时候，我还是会按照自己过去的经验来处理，而不是按照「正确的做法」去行动。我当然不是在否定反思和写作的意义，而是想要说明<strong>如何行动</strong>才是真正关键的部分。每个人都清楚地知道自己的优缺点，但是到了一定的年纪之后，很多人都放弃了改变自己缺点的愿望，为什么？因为他们知道那真的太难了。所以，具有改变的意愿只是第一步，<strong>能否为之付出行动</strong>才是真正重要的部分，也是我们变得普通或优秀的分水岭。行动起来只是一句口号，但是真正做到却需要我们在经历漫长的痛苦和挣扎，以及无数次反思和退却之后，才能最终达到「知行合一、做我所想」的理想状态。</p><h4 id="10-月-31-日-有趣与单口喜剧"><a href="#10-月-31-日-有趣与单口喜剧" class="headerlink" title="10 月 31 日 - 有趣与单口喜剧"></a>10 月 31 日 - 有趣与单口喜剧</h4><p>我有时候在想，做一个有趣的人到底意味着什么？让他人觉得你有趣有那么重要吗？可能是因为我长时间和自己相处习惯了吧，我不需要为了另外一个人而牺牲自己的时间和精力，去想方设法逗对方开心，让他/她觉得和自己在一起的时光是快乐的。一个人的时候只需要让自己开心快乐就够了，想做什么立马就可以去做，有什么安排也不需要和其他人商量，时间完全由自己掌控。虽然如此，但是我的兴趣爱好似乎也不是很多，除了喜欢跑步和滑板，最近没有什么其它的活动可以让自己感到期待和兴奋的了。说回有趣，我觉得有趣最大的意义可能是给你身边的人带去快乐吧，其他人和你在一起的时候，会觉得是愉悦快乐的，而不是枯燥乏味。对个人而言，这也是一种成就感吧。所以说到底，有趣也是一种有用的技能。有趣的人可以把有趣作为一种职业，比如单口喜剧演员和脱口秀主持人。我最近就沉迷上看 Russell Peters 的视频，原来看一个人嘲讽台下的观众也可以这么好笑。当然，这需要极大的技巧以及观众的配合，首先观众不能太容易觉得被冒犯，而演员则要把握好边界，并且尽量在边界内发现诠释事物的新方式，以及最关键的一点：能够让人发笑。有点想去尝试一下说单口喜剧，我觉得这是世界上最难的工作之一。不光是写笑话难，还需要掌握各种复杂的沟通技巧，还考验你的临场反应能力，对不同群体的观众的心理的把握，等等。你在台上的每个动作以及说话时候语音语调的变化都是表演的一部分，它对一个人的心理、学识、韧性、思维能力、表达能力都有极高的要求，但是如果能够把观众逗笑，这又是非常容易让人感到满足、奖赏性很高的一件事。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每时每刻的练习</title>
      <link href="/2021-9/"/>
      <url>/2021-9/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/FHO6a2H-pqY" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>这个月过得还算充实，如果满分 10 分，我觉得至少应该能打个 8 分吧。虽然只看完了一本新书，但是重看了过去看过的几本书，还是收获了不少新的感悟。人只有在保持活跃的时候才能感觉到自己是在真实地活着，而要保持活跃，就必须让自己在保持思考的同时，配合体能上的刺激。身体、情绪、思维、意志（精神），这些需要我们每天有意识地不断练习，才能够维持住健康，才有可能生活得幸福。每一个时刻、每一个场景都是练习的机会，而随着练习的次数越来越多，我们会越来越靠近真实的自我。</p></blockquote><span id="more"></span><h4 id="9-月-1-日-电影《养家之人》短评"><a href="#9-月-1-日-电影《养家之人》短评" class="headerlink" title="9 月 1 日 - 电影《养家之人》短评"></a>9 月 1 日 - 电影《养家之人》短评</h4><p>「Raise your words, not your voice. It is rain that makes flowers grow, not thunder.」这是电影养家之人结尾的一段话，从主人公口中听到这段话，感觉尤为震撼。在那种弱肉强食的环境下，想要维持生存都是一件艰难的事，更别说其它了。但是，主人公一家是让人感到温暖的一家人，爸爸始终保持着幽默的生活态度和优雅的风度，温柔的妈妈在危机出现时表现地隐忍而又坚强，看似冷漠自私的姐姐其实心里体贴、关心每一个家人，并且愿意为了家人而牺牲自己的幸福，而主人公则在家庭陷入危机后主动成为了家中的『养家之人』。她剪掉自己的头发，打扮成男孩模样去为家人打水、买生活必需品，去街头讨生活，去面对各种危险的情境。她也认识了新朋友，但是对比朋友的家庭，她显然意识到自己的家庭是幸福的，只不过爸爸此刻被关进了监狱。经过一番历险之后，她救出了爸爸，妈妈和姐姐、弟弟也重新获得了团聚，但是，这样的结局还是让人心里说不出的难受。的确，我们可以把这一切归咎于战争，但是，明明这个故事里的很多让人心碎的情节都是可以避免的，不过最终它们还是发生了，原因是什么呢？我觉得最主要的原因是恶劣的环境造成的。资源越是有限，恶人的生存空间也就越大，当好人的成本也越高，这是形成所有悲剧的最根本的原因。</p><h4 id="9-月-2-日-选择积极的态度"><a href="#9-月-2-日-选择积极的态度" class="headerlink" title="9 月 2 日 - 选择积极的态度"></a>9 月 2 日 - 选择积极的态度</h4><p>对于同一件事不同的人可以有不同的解读，即使是同一个人，在不同时期，对这件事的感知方式也会发生变化。所以，形成我们对一件事的看法的决定性因素不在外界，而在于我们自己。这就是为什么「悲观者总是正确，而乐观者赢得未来」的原因。我们如何看待一件事并不会影响一件事的未来，之后的行动才是决定性因素。但是，如果我们采用更加积极的视角，我们的行动就会朝着我们所相信的方向努力，因此，事情最终也更有可能朝着我们预期的方向发展；而如果我们采取悲观的态度，此时我们通常也会采取一些比较消极的行为方式，由于缺乏人为的干扰，事态变坏也就情有可原了。因此，我们每个人都是自证预言的产物。我们相信什么，如何行动，事情最终的结果，这些其实从一开始就已经确定了。意识到这一点就是改变的开始，从一开始就选择一种有利于自己行动的态度或者解读方式，让事情朝着自己预期的方向发展的关键在于你如何看待它，永远要选择积极的角度，要相信自己能够改变它，即使改变不了，你也能影响它，让他朝着自己预期的结果更近一点。悲观和放弃行动永远是最差的选择。</p><h4 id="9-月-3-日-分配好你的注意力"><a href="#9-月-3-日-分配好你的注意力" class="headerlink" title="9 月 3 日 - 分配好你的注意力"></a>9 月 3 日 - 分配好你的注意力</h4><p>如何保持不分心？当做一件需要集中注意力的事的时候，我发现自己很容易就会分心，或者是被外界环境干扰，或者没过多久就去做别的事了，我觉得每个人都遇到过这样的问题。长时间集中注意力是很难的，尤其当你在做一件有难度的事情的时候。但是，只要挺过了开始阶段的困难，后面就会越来越容易。解决办法依旧是<strong>三分钟法则</strong>，让自己先做一小会儿（写一句话、读一页、跑 100 米），然后看看自己此时内心的感觉，如果还是觉得无法继续，那就休息一会儿，再接着做一小会儿。重复多个循环之后，你就会慢慢进入状态了。另外，我们还需要给自己创造一个良好的环境，一个干扰比较少的环境，这样我们才能更容易集中注意力，也不容易分心，比如断网、远离手机等。注意力是最稀缺的资源，分配好它们是我们最重要的任务。</p><h4 id="9-月-4-日-解决孤独和找到生活的意义的方法：立刻行动"><a href="#9-月-4-日-解决孤独和找到生活的意义的方法：立刻行动" class="headerlink" title="9 月 4 日 - 解决孤独和找到生活的意义的方法：立刻行动"></a>9 月 4 日 - 解决孤独和找到生活的意义的方法：立刻行动</h4><p>现代人最大的问题是孤独和找到生活的意义。这个当然只是我自己的感受，并不一定准确。不过，从我自己以及我观察到的身边人来看，的确如此。而且这两个问题都只能依靠我们自己才能解决。孤独是因为我们觉得自己身边找不到同类，或者无法得到自己理想中的社交。而生活的意义则来自于我们所做的事以及如何赋予它们意义。这两点都依赖于个人的主动性，也就是说外界无法帮助我们去实现它们。你只能靠自己去寻找适合自己的交流对象，认识并且接纳对方进入自己的生活，通过互相倾诉尝试理解彼此，然后在日常生活中逐渐积累起信任和关爱，最终认识到自己是能够被他人理解的，而不再是孤单一人行走在这个世界上。你只能自己去尝试做不同的事，才能逐渐认识到自己擅长和适合做什么，并且在这一过程中意识到这件事的价值所在，然后逐渐把它作为自己生活的一部分，甚至作为区分自己和他人的标志，此时你才能认识到自己生命的意义所在。虽然我们都知道如何解决这两大问题，但是有时候还是会不知所措，为什么呢？最主要的原因是，我们害怕改变自己，更害怕改变之后带来的变化。我们已经习惯了现在一切都可预期的生活，而对未知的未来充满了恐惧。唯一的解决办法是：立刻行动。行动是驱逐恐惧的良药。</p><h4 id="9-月-5-日-拥抱个人主义"><a href="#9-月-5-日-拥抱个人主义" class="headerlink" title="9 月 5 日 - 拥抱个人主义"></a>9 月 5 日 - 拥抱个人主义</h4><p>一个明显的事实是：三代人之后，没有人将会记得我们是谁。也就是说，在你死后 100 年的世界中，你就像从来都没存在过一样。这个想法非常能解放我们心中的束缚，因为它会让我们更加关注自己。既然最终没有人会记得我们，或者我们认识的任何人，那么我们就不应该在乎别人如何看待自己，最重要的是我们选择如何度过自己的一生。我们要勇敢做自己，活出真实的自己，追求自己的梦想，遵从自己内心的愿望，不要为了满足他人而牺牲自己的幸福和快乐，更不要在乎别人如何看待自己。表达出自己的想法，向世界展示你自己。这些像喊口号一样的话，想要做到却非常难。而且只要有越多人开始这样做，后来者加入时所受到的阻力也越少，尤其是在我们这个思想比较保守、受几千年儒家文化影响的社会。Individualism 是现代社会给每个人的礼物，让我们有机会做真实的自己，而不是被世俗观念束缚，去做别人期望中的自己。拥抱个人主义，尽量只为自己而活，而且要活得自由洒脱。当然，与此同时，我们也要承担起自己的责任，不要因为追求个人自由而伤害到其他人。保护好我们爱的人，让更多人感受到幸福。这样度过自己的一生才算是对自己和他人负责。</p><h4 id="9-月-6-日-为自己的工作赋予意义"><a href="#9-月-6-日-为自己的工作赋予意义" class="headerlink" title="9 月 6 日 - 为自己的工作赋予意义"></a>9 月 6 日 - 为自己的工作赋予意义</h4><p>在找到使命感之前，学会给自己所做的事赋予意义感。因为并不是每个人都拥有个人使命，但是每个人都可以给自己做的事找到意义。这是我在上个周末里获得的最大的启发。个人使命是什么？是一个人长期的目标和驱动力。比如对一位作家来说，他的个人使命可能是写出好作品，启发更多的读者；一个教师的使命是更好地完成教学任务，让学生在理解并掌握关键的知识点的同时，学会如何去思考；一个生物医学家的使命是探究人类某些基因的奥秘，找出对抗某种疾病的方法，彻底消灭某种疾病；一个视频博主的使命是通过内容创作让更多人感受到这个世界的精彩与多样。对很多人来说，个人使命似乎还比较遥远（比如我），所以，我们需要学会给自己所做的事赋予意义感。比如，我是一个安卓开发程序员，我不知道自己的个人使命是什么，但是我可以给我所做的工作赋予意义。首先，它解决了我的生存问题，也就是通过工资收入让我能够维持目前的生活；其次，它让我能够通过自己所掌握的技术去解决一些问题，虽然这个任务不是完全由我一个人完成的，但是我参与了其中某一部分的完成（客户端开发），所以如果没有我这个项目就不可能完成，或者说不那么完整；最后，我通过这个项目获得了成长，接触到了之前没有接触过的技术，学到了各种各样的新知识，包括如何更好地应对压力等等。这一切都是工作的意义，而这些意义也都能够真实地反应出至少部分现实。所以，我应该感到更有动力去做好自己的工作。这就是为自己的工作赋予意义的意义。</p><h4 id="9-月-7-日-解决棘手问题的五个步骤"><a href="#9-月-7-日-解决棘手问题的五个步骤" class="headerlink" title="9 月 7 日 - 解决棘手问题的五个步骤"></a>9 月 7 日 - 解决棘手问题的五个步骤</h4><p>当面对一个棘手的问题时，我们应该如何着手去解决它呢？从开发的角度来看，主要可以分为下面几个步骤：<strong>第一步</strong>，观察现象。问题在何种情况下出现，出现的前置步骤是哪些，是否每次都能稳定重现。<strong>第二步</strong>，根据观察到的现象，提出可能的假设。这一步需要我们根据经验来推断出现问题的原因，一开始我们可能会觉得无从下手，但是随着时间的推移，我们慢慢会积累起越来越多的分析问题的经验以及建立足够的心理表征，从而做到下次遇到类似的问题时可以根据「直觉」来解决它。<strong>第三步</strong>，通过调试手段验证假设，找出问题的根源。通过上一步中提出的假设，我们可以开始有针对性地对其进行验证，从而找到问题的根源。<strong>第四步</strong>，寻找规律或模式。确定问题之后，我们才可以开始寻找解决方案，通常是通过观察问题出现时的日志，找出其呈现出的某种规律。<strong>第五步</strong>，根据规律提出假设，尝试解决该问题。最后一步才是真正做苦活，因为我们可能需要反复尝试各种方案才能最终确定可行的解决方案。但是，因为前几步所奠定的基础，问题最终一定能得到解决。所以，这时候我们只需要有足够的耐心，不断尝试下去即可。而且随着解决的问题越来越多，你的经验也会越来越丰富，从而在遇到类似的问题时，可以快速想到解决方案。其实这五个步骤不仅仅可以用于解决开发相关的问题，也可以用于解决生活中出现的方方面面的问题。</p><h4 id="9-月-8-日-理性的思维方式"><a href="#9-月-8-日-理性的思维方式" class="headerlink" title="9 月 8 日 - 理性的思维方式"></a>9 月 8 日 - 理性的思维方式</h4><p>人都有情绪，也有自己的喜好，但是我们需要经常提醒自己的一点是，不要让情绪和喜好影响自己的判断。比如对于一篇文章，你可能不喜欢这篇文章的作者，此时如果作者在这篇文章中提出了对你来说有用的观点或者有价值的信息，但是你因为个人情绪以及偏见而选择了放弃这篇文章，这样你就失去了一次自我改进和优化的机会。再比如，我们常常在工作中需要面对一些不得不做的事，我们可以勉强接受去做这件事，但是此时心中难免会带有一丝不满的情绪，如果事情进行地不是很顺利，我们的不满就会堆积，很有可能导致最后事情没有按照计划完成。正确的做法是，调整自己的心态，看到这件事积极的一面，找到其对自己和他人的意义，要意识到情绪和偏见不会给自己带来任何好处，只会妨碍自己进步。在情绪和理智之间，永远要选择理智。尽管做起来比实际难很多，但是只要我们不断在日常生活中训练自己的这种思维方式，我们就能往理智这边越靠越近。</p><p>反过来看，我们的情绪难道就完全无意义吗？其实也不是，我觉得情绪其实是更本能的理性。当我们习惯了在某种情境下做出特定的反应，比如抱怨、推脱和不合作，其实是因为我们觉得这种反应有利于我们自己。通过把自己的不舒服表达出来，从而舒缓自己内心的压力、焦虑等，尽管这种表达反而会让事情朝着失控的方向发展。所以，为了让选择理性成为自己的习惯性选择，我们需要经过一段漫长时间的思考和练习，才能让它变成我们的「情绪」，并且完成从「我不想/不喜欢XXX」到「我能从XXX中学到什么」以及从「这件事对我来说太难了」到「如何才能解决它」的转变。</p><h4 id="9-月-9-日-Be-a-doer-not-a-thinker"><a href="#9-月-9-日-Be-a-doer-not-a-thinker" class="headerlink" title="9 月 9 日 - Be a doer, not a thinker"></a>9 月 9 日 - Be a doer, not a thinker</h4><p>成为一个行动者，而不是只想不做。有时候想想自己生活中遇到的那些问题，如果所有的事我都能用过往提到过的思维方式去行动，那么问题可能早就已经解决了。然而现实是，就算你具备了一切关于应该如何行动的理论，等到事情发生的时候，你可能还是无法按照你的预期去行动，还是会犯错和走弯路。这就是为什么知易行难。但是，我觉得从理论到行动，最大的障碍还是行动的次数，有的人可能尝试一、两次就放弃了，但有的人却可以不断尝试下去，直到自己达到了理想中的目标。我觉得我应该努力成为后者这样的人，一个积极行动但是不完美的思考者远比完美但是不积极行动的思考者有说服力。虽然思考也并不简单，也需要大量的输入才能转换成输出（也就是行动），但是尽快开始行动的确更加重要。</p><h4 id="9-月-10-日-以终为始：检验目标是否有效的方法"><a href="#9-月-10-日-以终为始：检验目标是否有效的方法" class="headerlink" title="9 月 10 日 -  以终为始：检验目标是否有效的方法"></a>9 月 10 日 -  以终为始：检验目标是否有效的方法</h4><p>真正的以终为始是：假如我现在 80 岁，某个目标对我来说依旧重要吗？如果我们能始终用这个目标作为评判目标是否合理的依据，那么就可以避免绝大多数只看到短期利益的「陷阱」。从长期来看，你的目标关注点在于某件事是否能增加自己和他人的长期的幸福；是否让所有参与者都获益，而不是只让少部分人受益却让其他人蒙受损失；是否给他人带去了便利；是否给自己和他人的生活方式带来了积极的改变；等等。当我们以这样的标准筛选自己的目标之后，你会发现符合条件的目标很少，但是一旦选定之后，它就开始为我们提供强大的动力，而且行动也会变得更加容易开始。我们不需要再去纠结应该怎么做，而只要问自己：这件事是否符合根据我的目标所立下的愿景，某个决定是否会让我偏离目标，某个人是否和我一样有相似的目标和追求。</p><h4 id="9-月-11-日-三个爱好"><a href="#9-月-11-日-三个爱好" class="headerlink" title="9 月 11 日 - 三个爱好"></a>9 月 11 日 - 三个爱好</h4><p>偶然看到一条推特，大概意思是人需要有三个爱好，一个可以让你赚钱的爱好，一个可以让你保持健康的爱好，以及一个可以让你保持创造力的爱好。我觉得这个建议挺实用的。反问自己，我大概可以说出自己第二个和第三个爱好是什么，但是想要凭借爱好赚钱还是挺难的。老实说，自己对于编程还远远谈不上热爱，甚至连喜爱都谈不上，只不过不那么讨厌而已。但是，我的确能用它养活自己，也能做一点有用的事。除此之外，我想象不出自己一生都在这个领域深耕的场景。我知道我又陷入了建立个人资本和激情假设的争论中，但是，工作 4 年多了，依旧没有建立起任何值得一说的职场资本，是否说明自己不适合这个领域？一方面自己的确是没有投入太多精力，另一方面也可以将原因归结于一直没能找到能让自己集中注意力、全情投入的方法。当然，按照现实的观点来看，方法和习惯明显比个人好恶以及激情假设来得有效，但是，人总是会在漫长的尝试中逐渐失去耐心。缺乏有效的目标和低程度的投入导致了目前的结果。所以，我的目标应该是寻找出更好的方法和追求改变。</p><h4 id="9-月-12-日-成为统计学上的异常点"><a href="#9-月-12-日-成为统计学上的异常点" class="headerlink" title="9 月 12 日 - 成为统计学上的异常点"></a>9 月 12 日 - 成为统计学上的异常点</h4><p>不可否认的一点是，我们的出身在很大程度上影响了我们的人生轨迹。从我们出生的那一刻开始，不同的家庭环境影响了我们性格的形成、接触到的世界、娱乐方式以及身边的朋友。光是能否养成阅读的习惯就能对一个人的发展造成巨大的影响，而我是到大学之后才算是逐渐养成了这个习惯。假如自己从小就养成了这个习惯，此刻我的人生轨迹会是什么样的呢？尽管出身对我们的人生影响很大，但是我并不认为出身决定了一切。我的童年非常平平无奇，没有做出什么出格的事；我也没有上过好的大学，认识一群厉害的同学。但是，这并非就说明我注定要走一条符合大众心理预期的人生发展的路，也不是说我从此无法做出杰出的贡献。当然，我的人生大概率是会按照普普通通的方式进行下去。但是，我觉得每个人都应该寻求去做统计意义上的异常点，我们应该尽自己所能去过一个不同寻常的人生。我们不应该用一条人生发展轨迹来限制自己，要相信自己可以做出一番事业，度过一个不符合他人预期的、全然不同的、精彩的人生。</p><h4 id="9-月-13-日-发现和利用好自己的比较优势"><a href="#9-月-13-日-发现和利用好自己的比较优势" class="headerlink" title="9 月 13 日 - 发现和利用好自己的比较优势"></a>9 月 13 日 - 发现和利用好自己的比较优势</h4><p>最近在看经济学的思维方式这本厚厚的经济学教科书，虽然才看了一半，但是已经改变了我过去的很多想法。凡事皆有成本，比较优势永远存在，所以，我们应该在市场允许的条件下，思考如何让自己的效益最大化，而不是一味降低成本。比如，我的职业是一名程序员，也就是软件工程师，我可以选择不断精进自己的职业技能，然后用这种技能变现，我也可以尝试别的方式，比如创造出一款不错的软件，不断地打磨它，再通过利用各种营销手段等引起更多人的注意，并且在这一过程中找到合适的商业方式从中盈利。这两种方式所需要的技能看似差不多，其实还是有差异的。后者明显看上去更有趣，但是也需要去接触一些技术之外的东西。所以，关键还是要看你的比较优势在哪，如果你擅长在技术上精进，并且最终凭借精深一门技术从而得到职业上长远发展和被重视的资本，那么，你可以获得一个不错的结果。而如果你觉得自己除了技术之外，还擅长一些别的技能，也就是你的比较优势在技术之外，比如演讲和写作，那么你就可以通过以技术为背书，借助你的比较优势为自己赢得更多的关注并且得到更多人的认可，最终创造出自己的产品。当然，你还可以选择介于这二者之间，既在技术上精进，又通过第二技能去获得影响力，并且由此获得更多的自主力。具体如何选择和行动，取决于找到你的比较优势。</p><h4 id="9-月-14-日-对待时间的两种思维模式"><a href="#9-月-14-日-对待时间的两种思维模式" class="headerlink" title="9 月 14 日 - 对待时间的两种思维模式"></a>9 月 14 日 - 对待时间的两种思维模式</h4><p>《有限与无限的游戏》里有提到过两种对待时间的方式，一种是我打算在某项活动中投入多少时间，另一种是我要用某种活动填满某段时间。对比自己，我好像大多数时候都在用后一种方式对待自己的时间。几点起床，几点上班，几点下班，几点做什么，这样会让自己觉得时间好像是用来「度过」的，而不是一种可以利用的资源。但是前一种方式则是把「活动」作为重点，你的目标是什么？你想要创造什么样的结果？为了达成这样的结果需要你投入多少时间？以这种思维方式行动，时间就是一种宝贵的资源，你需要学会如何更高效地分配好它们，你是在「利用」时间而不是「度过」时间。另外，这也是我们能否进入心流状态的关键所在。</p><h4 id="9-月-15-日-正确地工作-vs-正确的工作"><a href="#9-月-15-日-正确地工作-vs-正确的工作" class="headerlink" title="9 月 15 日 - 正确地工作 vs 正确的工作"></a>9 月 15 日 - 正确地工作 vs 正确的工作</h4><p>正确<strong>地</strong>工作远比正确<strong>的</strong>工作重要。这个结论不是我得出的，而是 <em>So Good They Can’t Ignore You</em> 一书的作者在总结了他的多个采访对象后得出的。至于为何如此，我觉得最主要的原因是前者更注重行动，而且更具实践性，而后者则更加困难且操作性不强。用通俗的话来说，「干一行爱一行」才是正确的思维方式，并且可以让人立马行动起来。每一个行业里的每一个个体都可以找到自己工作中令人不满意的地方，如果我们眼里都只盯着那些让自己不愉快的部分，那么没有一份工作可以让自己感到享受其中。相反，我们应该把焦点放在如何提高自己的技能水平和工作效率，如何让自己变得更加擅长自己的工作，把自己的工作当做一门艺术去打磨到极致。长此以往，我们将获得更多的自主力，而这自主力将逐渐演变成促使我们继续前进的动力，帮助我们找到自己人生的使命。而当你将工作和人生使命结合在一起的时候，你就进入了一个人可以获得的最佳的状态，你会在工作中发现生命的意义。</p><h4 id="9-月-16-日-维持不适感"><a href="#9-月-16-日-维持不适感" class="headerlink" title="9 月 16 日 - 维持不适感"></a>9 月 16 日 - 维持不适感</h4><p>无论是身体还是思维，都需要有意识地刺激它们、锻炼它们，才能维持住健康状态。尤其是思维，如果长期缺乏刺激和锻炼，就会逐渐退化。这点可以被一个小实验证明，当你从高强度的环境中解放出来的时候，再去做一些轻松的任务，你会感到无聊。这其实就是因为你的大脑适应了困难模式，在转向简单模式的时候，得不到足够的智力上的刺激，于是就会产生厌倦和无聊感。维持这种不适感是让自己不断进步的关键所在。如果你已经习惯了处理轻松的任务，比如阅读对自己来说已经没有任何挑战性的书，解决已经解决过的问题，那么，长此以往，你会渐渐失去进步的动力和可能性，你对稍微有一点难度的问题就会产生排斥感，而不是产生兴奋感，你的能力会逐渐退化到解决最基本的问题上，智力也是。不要让自己陷入这种环境，如果你目前处在一个轻松的环境中，要记得给自己制造不适感，并且尽早进入一个能够持续给自己制造不适感的环境。</p><h4 id="9-月-17-日-向他人展示自己的弱点"><a href="#9-月-17-日-向他人展示自己的弱点" class="headerlink" title="9 月 17 日 - 向他人展示自己的弱点"></a>9 月 17 日 - 向他人展示自己的弱点</h4><p>承认自己身上有弱点，并且敢于向他人展示它们。我觉得这点是克服害怕和陌生人交流的关键所在。每个人都希望自己在他人心中的形象是完美的，但是现实中完美的人很少或者根本不存在。我们每个人都有自己的弱点，如果你不主动去展示它们，而是等到他人来发现，这样会给人造成一种你不诚实的感觉。有弱点的人才显得真实。展示自己的弱点其实不会削弱你在他人心中的形象，而是体现出一种自信。如果你对自己的弱点都能毫无保留地向他人展示，那么对方会感到被接纳以及对你感到亲密，因此也更容易拉近彼此的关系。</p><h4 id="9-月-18-日-记住沟通的目的"><a href="#9-月-18-日-记住沟通的目的" class="headerlink" title="9 月 18 日 - 记住沟通的目的"></a>9 月 18 日 - 记住沟通的目的</h4><p>沟通的目的是什么？对我来说，最大的目的是交流想法，向彼此传达对方不知道的观点和信息。但是，很多时候，当我发现他人的想法和自己不一样的时候，我就会慢慢失去耐心，于是忘记了沟通的目的。不要试图去打破他人的信念，因为你永远都不可能通过一次简单的沟通做到这点，这只会引起他人的厌烦。相反，你应该用一种别人能够接受的方式来表达自己的想法，要尽量用简洁的语言概括出你的观点的不同之处，但是要阐述清楚其主要论点和逻辑，最好还能启发他人去思考。如果能让他们意识到「这是一个新的思考该问题的角度」，那么，你的目的就达到了。而如果你是用说教甚至是居高临下的方式来表达，估计对方很快就会失去倾听的耐心，轻则对你的观点产生抗拒感，重则对你这个人产生厌恶感。高质量的沟通不是一件容易的事，需要我们有足够的同理心而且也要掌握一定的技巧和方法。但是，只要记住自己沟通的目的以及自己并没有恶意，那么，任何沟通都是一次增进对彼此了解的机会，也是一次自我观察的机会，我们可以通过表达自己来发现自己最真实的想法。</p><h4 id="9-月-19-日-不完美、尊重不同、养成好习惯"><a href="#9-月-19-日-不完美、尊重不同、养成好习惯" class="headerlink" title="9 月 19 日 - 不完美、尊重不同、养成好习惯"></a>9 月 19 日 - 不完美、尊重不同、养成好习惯</h4><p>如何才能真正做到接纳不完美的自己？有时候当发现自己的缺点的时候，我还是会在心里贬低自己、对自己感到失望，明知道这种情绪对自己没有任何用处，但是却控制不了自己的大脑。可能还是经历得太少吧。只要人还活着，就难免会发现自己和他人的差异之处，一切都取决于你如何看待这种差异。如果你习惯性地拿自己和他人比较，那么你永远也无法获得真正的平静；而如果你学会欣赏自己和他人身上的不同，那么这种差异就成了这个世界如此丰富多彩的原因。承认自己的不足就可以了。如果你能够改变这种不足，那就想办法去改变它，并且在下次做得更好就行了。但是，不要用它来打压自己，你应该对自己好一点。另外，生活的确很难，不过这个世界上有很多比你更难的人，想想他们是怎么做的，既然他们可以克服那些困难，你也一样可以做得到。至于幸福和快乐，我觉得有时候能够保持内心的宁静也是一种幸福，而快乐更多在于看问题的角度和方式，首先改变自己的想法，然后持续行动下去、养成更多的好习惯就可以了。</p><h4 id="9-月-20-日-回家的感受"><a href="#9-月-20-日-回家的感受" class="headerlink" title="9 月 20 日 - 回家的感受"></a>9 月 20 日 - 回家的感受</h4><p>每次回家都忍不住思考自己未来的生活会是什么样的，因为在和家人相处的过程中，难免会发现我们彼此是多么地不同，而且会忍不住对比自己和他们的生活。首先，一个显然的事实是：我肯定已经无法适应家乡的生活了。最主要的原因当然是这里没有适合我的工作，即使有也意味着收入要大打折扣。另外，我已经习惯了城市里的各种生活便利，虽然即使农村里现在也开始有各种外卖和快餐店，但是像基础设施和环境的舒适性这些还是没法和杭州比。所以，我还是非常感激自己能够有机会生活在城市里的。</p><p>每次和长辈们相处都会意识到，我们这一代人相比他们那一代人真的幸运太多了，最明显的是由教育水平所带来的差异。我们所受的教育至少可以让自己能够凭借个人能力比较轻松地过上自己想要的生活，虽然也会有生活压力，但是主要还是为了追求更好而带来的压力。但是他们那一代人，很多人真的是因为在受教育上吃了亏，所以面临的选择相比我们要少很多很多。尤其是上上代人，也就是我们爷爷奶奶外公外婆那一辈人，很多都不识字，可以说是被剥夺了通过自我教育来获得进步的权力。我知道有些老人从不识字到识字全靠自学，但是那样的人终究只是少数。像我外婆那样年纪的人，要让她们在那样的年纪学会认字真的太难了，所以她们也用不了智能机，无法像我们一样享受哪怕是阅读公众号的权力，而只能依赖电视等传统的媒体。对比我和我爸我妈，虽然这种差距没有那么大，但其实也还是非常明显。我可以通过网络获取任何我想要的资讯，从地球另一边的人的生活，到某个科技公司正在研发的产品，只要我想，随时都可以关注到他们的最新动态；从 MIT 到哈佛的所有的在线课程，只要我想学任何时候都可以开始学习。但他们却缺乏必要的技能去做到这一点，所以，我现在也特别能感受到教育的重要性，尤其是学会自我教育的重要性。</p><p>人总是要学会去接受那些自己无法改变的东西。而且每个人也都有自己的局限性，就像我们这代人也要面对「如何从众多选择中选择最适合自己的」的难题，以及由此带来的行动力不足的问题。不过，至少有一点是确定的，那就是我们这一代人以及下一代人会比我们父母那一代人以及他们的父母那一代人生活得更加幸福。当然，前提是你是一个负责任且懂得延迟满足的人。暂时不知道自己想要什么或者适合做什么也没关系，只要脚踏实地，把每一天都过得充实，不断学习进步，并且乐于分享，生活得幸福快乐是必然的。</p><h4 id="9-月-21-日-信息茧房与批判性思考"><a href="#9-月-21-日-信息茧房与批判性思考" class="headerlink" title="9 月 21 日 - 信息茧房与批判性思考"></a>9 月 21 日 - 信息茧房与批判性思考</h4><p>这两天在家，不知不觉又花了很多时间刷视频，其中有多少是真正有启发性的内容？其实并不多，这些视频最大的作用是给自己在心理上提供了舒适，让我感觉到自己离这个世界还是很近的。但是，晚上看书的时候突然意识到，最终呈现在我面前的信息都是经过算法筛选的，它们会随着我花的时间越多，变得越来越单一、片面，让我越来越以为它们所反映的就是真实的世界。比如，我看的视频越来越集中在几个频道上，而且他们的很多观点都是相似的。公众号等其它信息渠道也是一样。所以，我逐渐活在了算法为了迎合我的个人偏好所创造出的世界中，也就是常说的被<strong>信息茧房</strong>给困住了。</p><p>如何打破信息茧房？我觉得关键在于不要依赖任何算法提供的内容作为自己唯一的信息获取渠道，少依赖二手信息。对于一些感受类的分享，不要全盘接受，尽量在自己去亲身体验之后再做判断。真实的世界远比网络上的丰富多彩，相应地，情况也更加复杂，不要被单一视角所限制。另外，广泛地阅读是打破信息茧房的最重要的手段。书本不会随着时间变化，其中的观点大多是历久弥新的，虽然也有过时的部分，但至少不会像在网络上那样被淘汰得那么快。不要只倾听某一方的观点，要学会批判地接受，没有一个人的观点是全然完整的，和真实的世界相比总会有一些出入，你只能自己去分析判断，然后再决定哪种观点或者其中的哪些部分离真实更近一些。</p><h4 id="9-月-22-日-人是观念和习惯的产物"><a href="#9-月-22-日-人是观念和习惯的产物" class="headerlink" title="9 月 22 日 - 人是观念和习惯的产物"></a>9 月 22 日 - 人是观念和习惯的产物</h4><p>人是观念和习惯结合之后形成的产物。我们拥有什么样的观念，决定了我们会如何行动，而不同的行动让我们的生活逐渐天差地别。习惯就是在我们的观念影响下产生的固定的行为模式。我们的生活作息、工作方式、情绪感受、思维模式，都是我们习惯的一部分。所以，如何养成更多的好习惯，就是决定我们人生质量的关键所在。目前对我来说，最重要的好习惯有哪些呢？早睡早起、冥想、阅读、运动、<strong>刻意练习</strong>、自我反思、<strong>正向思考</strong>、<strong>协作</strong>、<strong>分享</strong>、<strong>感恩</strong>，这其中一部分是已经做到的了，但是依旧存在不断改进的空间，其它部分还需要继续努力培养起来。根据《掌控习惯》中的习惯形成的四要素，提示、渴望、反应、奖励，不断优化自己的习惯，从小处做起，相信这些好习惯最终都会慢慢变成自己日常生活的一部分。</p><h4 id="9-月-23-日-学会让陌生人喜欢你"><a href="#9-月-23-日-学会让陌生人喜欢你" class="headerlink" title="9 月 23 日 - 学会让陌生人喜欢你"></a>9 月 23 日 - 学会让陌生人喜欢你</h4><p>昨晚看了 James Altucher 的 google talk 之后，启发很多，上床睡觉闭上眼睛也还是思绪翻飞。我觉得他提出的很多建议都值得专门拿出来写一写，但是今天就谈谈我对他这个人的感受吧。首先想到的是我们平时容易忽略的一种非常重要的能力，尤其是在你想要说服他人的时候，那就是<strong>让他人喜欢你进而信任你</strong>的能力。从他的谈话中我看到了一个非常坦诚、经历丰富、思维敏捷、有幽默感，同时还非常谦虚的人。为什么他能做到这一点？为什么他能给我这样的印象？我觉得首先，一开始和人接触的时候，让他人信任你是非常难的，如何让一个陌生人从完全不了解你到开始对你发生兴趣，并且逐渐发展到喜欢你并且由衷地信任你？坦诚是其中一个关键的因素，并且不仅仅是做到坦诚，而且要让他人真正感到你是坦诚的。这是一门需要花时间不断练习的技巧。另外，如何让听众喜欢上你同样也是一门需要练习的技能。表现得坦诚只是一个必要条件，让他人喜欢上你则还需要更多。涉及到听众的喜好和心理，这次谈话的目的，以及如何通过合适的方式表达出你的观点，这是一门艺术。我觉得正是因为他是一个真正的沟通大师，所以他的播客能吸引到那么多各行各业的专家去和他聊天吧。聊天真的是一种非常基本且重要的技能。</p><h4 id="9-月-24-日-打破心中的藩篱，学会主动和人聊天"><a href="#9-月-24-日-打破心中的藩篱，学会主动和人聊天" class="headerlink" title="9 月 24 日 - 打破心中的藩篱，学会主动和人聊天"></a>9 月 24 日 - 打破心中的藩篱，学会主动和人聊天</h4><p>如何打破自己心中的藩篱？说起来自己独居也有一段时间了，差不多已经习惯了一个人的生活，但是，有时候还是会觉得自己需要改变现在的生活状态。人毕竟还是需要一点社交才能让生活保持平衡。我觉得目前自己最大的障碍是不敢和陌生人聊天，其实不仅仅是陌生人，哪怕是身边以及过去认识的熟人朋友，如果能开始多接触并且找到共同话题的话，那么也可以逐渐发展出更深入的关系。说到底还是因为心中有太多的顾虑，比如害怕被拒绝，觉得太主动会没面子，不想显得太刻意等。其实这些都只是我们在自己内心给自己制造出的障碍，现实是别人真的没那么在意，只要你去尝试、行动之后，以上这些都不会成为问题。首先，被拒绝没有那么可怕，世界上有那么多人，不可能每个人都和你合得来，你只要找到合得来人去认识、去相处就可以了。面子说到底是他人对自己的看法，这是完全不可控的，所以没必要在意。尊重你的人不会因为你的一两次行为就不再尊重你，而且这个世界上你最需要获得他的尊重的只有一个人，那就是你自己。至于刻意与否，这只是个人的看法而已，我并不觉得直接就等于刻意，关键看你怎么做，如果你非常放松，那么即使直接表达出你的想法也可以显得不那么刻意，而且我们都需要时间才能逐渐习得如何表现得不那么刻意。如果不开始练习，那么你永远也学不会如何微妙地表达自己的想法。</p><h4 id="9-月-25-日-用你的快乐感染身边的人"><a href="#9-月-25-日-用你的快乐感染身边的人" class="headerlink" title="9 月 25 日 - 用你的快乐感染身边的人"></a>9 月 25 日 - 用你的快乐感染身边的人</h4><p>越来越觉得保持愉悦、开心的状态非常重要，无论是在日常工作还是生活中，如果你能始终保持愉悦，你身边的人才更愿意与你沟通，而且你积极快乐的状态也更容易影响到他人，让他人也拥有一个好心情。其实不用别人说我也知道，过去自己常常摆着一张苦瓜脸，好像整个世界都欠自己的一样。但是慢慢地我发现，如果我改变自己的这种状态，不但自己的心情会变好（Action leads mood），其他人也会被我影响。比如如果你笑着和路人点头打招呼，通常也能收到路人的微笑回应。他人是我们自己的一面镜子，你如何行动会反应到他人对待你的行为中。虽然有时候并不总是能收到积极正面的回应，甚至还有可能是负面的，但是只要你是真正快乐的人，他人的行为并不会影响你太多。你可以选择让这种负面在你这里停止，向身边人传递快乐、阳光、乐观、积极向上的情绪。这个世界只会因为那些乐观且持续行动的人变得越来越好，而不是消极负面的人。</p><h4 id="9-月-26-日-练习说话"><a href="#9-月-26-日-练习说话" class="headerlink" title="9 月 26 日 - 练习说话"></a>9 月 26 日 - 练习说话</h4><p>表达同样需要持续练习才能获得进步。昨天录了个视频，用于在老姐和包哥婚礼上放，突然意识到，原来我的语言沟通能力是这么地弱。发现自己说话的时候存在很多问题，最明显的是说话时候的声音很轻，我只有把音量调大才能听清自己在说什么，终于明白了为什么有的人和我聊天的时候会侧过耳朵来，他们是真的听不清。其次，我发现自己会习惯性地抿嘴和舔嘴唇，这个动作会给人一种非常不自信的感觉。我知道自己牙齿不是很好看，既不太整齐，而且门牙很大中间还有牙缝，但是每当自己做这个动作的时候，会让人更情不自禁把注意力集中到你的牙齿上，并且感觉到你的不自信。最后，过去自己常常以为自己的表达能力还可以，但其实只有在真正看过自己的视频之后才会发现其实并不行。有时候感觉就像大脑的运转速度跟不上嘴巴，有时候又觉得想法转瞬而逝嘴巴跟不上大脑。其实说到底还是缺乏训练，平时和人面对面的沟通交流太少。我喜欢用文字沟通，但是使用文字的时候，大脑有更多的时间将想法处理之后再表达出来，而语言沟通的情况下，大脑没有这样的缓冲时间，于是需要你提前组织好文字，因此需要你的思维运转速度变快，由于我的大脑缺乏这种锻炼，因此才会常常觉得自己表达不出来自己的想法，或者会一时语塞。所以，解决办法也很简单，多说，多表达，抓住一切机会和人聊天，并且有意识地分析自己的进步和不足之处。时间长了之后，你的表达能力一定会慢慢提高。</p><h4 id="9-月-27-日-快速进步的秘诀：寻找专家做你的老师"><a href="#9-月-27-日-快速进步的秘诀：寻找专家做你的老师" class="headerlink" title="9 月 27 日 - 快速进步的秘诀：寻找专家做你的老师"></a>9 月 27 日 - 快速进步的秘诀：寻找专家做你的老师</h4><p>我们都知道只有通过持续不断的练习才能获得进步，但快速进步其实也有秘诀，那就是找到你想学习的领域里的大师作为你的老师，也就是寻求专家的指导。为什么这么说？因为专家知道在学习过程中的大多数难点以及如何克服它们，而且他们可以帮你避开很多坑，让你少走很多弯路。他们长时间从事该领域，所以积累了非常丰富的经验和学习心得，如果能够得到他们的指导，他们一眼就能看出你的问题和做错的地方，然后给出建议。因此，你不需要花费太多时间就能发现自己的问题，并且马上做出改进。当然，有些错误只有自己摸索、尝试过纠正之后才能获得进步，但是这样的错误总归是少数，绝大多数错误、失败如果可以在一开始就避免它们，那么我们就能收到更多正面的反馈，让我们拥有更好的起点。</p><h4 id="9-月-28-日-新体验与感受每一个生活瞬间"><a href="#9-月-28-日-新体验与感受每一个生活瞬间" class="headerlink" title="9 月 28 日 - 新体验与感受每一个生活瞬间"></a>9 月 28 日 - 新体验与感受每一个生活瞬间</h4><p>看过很多高龄老人的采访，大多数人都会说如果他们能重新过一次自己的人生，会希望自己能够更追随自己的内心，哪怕是去做一些在旁人看来滑稽可笑的事，或者犯一些很傻的错，也就是要更勇敢地去面对生活，更不怕犯错，尝试更多的新体验。所以，对我的启发是，那些现在看来无用或者不值得做的事，对未来的自己来说未必如此。比如旅游，虽然现在看来，不去那个地方走走看看，或者在当地生活一段时间，对我的人生几乎没有什么影响。但是，十几年之后，当你想起自己当年的经历的时候，可能只有这些新的见闻和生活体验才是最印象深刻的。这不是说我们必须不停追求新奇的体验，我们当然可以享受生活的平淡，只是要记住，每一个瞬间都可以是增加你和这个世界接触的机会，不要放弃让自己感受到不同体验的机会。</p><h4 id="9-月-29-日-和陌生人聊天"><a href="#9-月-29-日-和陌生人聊天" class="headerlink" title="9 月 29 日 - 和陌生人聊天"></a>9 月 29 日 - 和陌生人聊天</h4><p>越来越觉得和陌生人聊天是一种必备的技能，尤其是在当下大家都习惯了在网络环境下的沟通交流，似乎都忘记了怎么和陌生人交谈。那么，和陌生人交谈有哪些好处呢？最显然的好处当然是我们可以认识更多的人，并且有可能和其中一部分人成为朋友，甚至是恋人。其次，主动和陌生人聊天是需要勇气的，尤其是在那些让我们感到胆怯的场合下，如果能做到这一点，这会增加我们再次行动的勇气，我们也会变得越来越自信。最重要的一点是，我们会变得越来越真实，越来越能注意到自己的想法，我们会习惯于表达自己的真实意图，也能帮助我们和身边人相处地更加和谐。</p><h4 id="9-月-30-日-寻找共同点"><a href="#9-月-30-日-寻找共同点" class="headerlink" title="9 月 30 日 - 寻找共同点"></a>9 月 30 日 - 寻找共同点</h4><p>昨天说到和陌生人聊天的好处，那么，是什么阻碍了我们鼓起勇气去和陌生人聊天？可能是不自信，可能是怕打扰到他人，但是对我来说，最关键的因素是，我觉得自己和他人不同。为什么会这样想，其实一方面，我们的确非常不同，比如我们的长相、外貌、衣着、说话方式、性别等等，但是作为一个陌生人，他人同样会这样看待你，如果你能够首先打破这种信念，那么你会发现，其实我们并没有看上去那么不同。首先，我们都只是普通人，无论你家境好坏、颜值高低、是否身居要职，都是要吃喝拉撒的人类一员，而且也逃脱不了生老病死等终极规律的控制，我们都经历过天真顽皮的童年时代，并且最终都将离开这个世界。所以，既然我们出现与离开的方式相似，那么，剩下的那些不同其实并不是那么重要，<strong>要相信我们身上的共同点一定多于不同点，要让自己感到我是和他人相连着的，并且一定是能够被他人理解的</strong>。我们的最终目的是尽可能多地团结我们身边的人，鼓励、帮助彼此不断成长，一起成长为更好的人。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>别太匆忙</title>
      <link href="/2021-8/"/>
      <url>/2021-8/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/BtBFZ9bBFDE" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>这个月经历了自己这段时间以来，过得最为艰难的一段日子，从自己那段时间写的碎碎念也可以看得出，自己当时的内心有多煎熬。不过再怎么艰难的处境，咬咬牙，再挺一挺，也一定都能熬过去的。人的韧性都是在经历了许多困难之后才逐渐炼成的。此刻的自己，洗完澡坐在书桌前，房间里的空调轻轻地吹出一阵阵凉风，床边放着一大袋超市买回来的零食，准备待会儿看部电影后早点上床睡觉。现在再回想起那几个无法入睡的夜晚，也只不过会抿嘴一笑而已。其实生活并没有那么复杂，难的时候咬咬牙挺过去，得闲的时候放松一下，犒劳犒劳自己，有爱人或者朋友在身边的话就找他们说说话、谈谈心，即使没有，一个人也可以做很多让自己感到开心的事。我们都只是普通人而已，没必要让自己一直活在高压之下。人生很短也很长，你能做的事是很有限，但是，也用不着过得太匆忙，时不时也该停下来，用心体会自己所拥有的一切。</p></blockquote><span id="more"></span><h4 id="8-月-1-日-程序员的优势"><a href="#8-月-1-日-程序员的优势" class="headerlink" title="8 月 1 日 - 程序员的优势"></a>8 月 1 日 - 程序员的优势</h4><p>我觉得作为程序员最大的优势是，永远都有新东西可以学习和研究。无论你是做哪方面的开发，不仅在那一方面有海量的方向可供你选择，其它方面也有相关的东西值得接触。只要你感兴趣，永远都不怕没有东西可以学习。最常见的，比如学习一门新语言或者新框架，学习其它领域的开发等等。所以，即使当下的自己没有什么长远的目标也没关系，那就尽可能多地学习，同时利用所学解决生活中的一些问题。看看自己过去写下的灵感列表，有不少是值得做成一个完整的项目的，只不过从来没有考虑过利用现有的方案去实现。说起来，其实我也是误打误撞才选择了软件开发作为自己的职业，这个时代最新也最热门的工种。所以，要利用好时代带给我们的红利，同时不要辜负了自己的好运。</p><h4 id="8-月-2-日-少批评，多赞美，保持积极乐观的态度"><a href="#8-月-2-日-少批评，多赞美，保持积极乐观的态度" class="headerlink" title="8 月 2 日 - 少批评，多赞美，保持积极乐观的态度"></a>8 月 2 日 - 少批评，多赞美，保持积极乐观的态度</h4><p>我觉得我身上一个最明显的缺点是总是喜欢用略显消极的态度看待事物。比如，如果一部电影故事不合我胃口，我就会采用批评的态度否认整部电影，而不是看到让自己享受其中的某些方面。<strong>批评总是很容易，而学会如何去欣赏却很难。</strong>这一点，我觉得是很多人身上都有的毛病。学会从不完美的事物中发现美好的一面，是我们每个人都要学会的技能。如果采用消极的态度，那么，生活中所有事物都存在一些可挑剔的小毛病，而且你自己也不会很开心，因为你很难从自己不喜欢的事物中获得愉悦和满足；而如果你总是用积极的眼光看待周围的一切，那么，你会发现所有的人、事、物都有它可爱的一面，你会变得更加快乐，所有人都更愿意和这样的人相处，因为积极、快乐的情绪是会传染的。我觉得保持乐观积极可能也是获得幸福的秘密之一吧。</p><h4 id="8-月-3-日-时常感恩"><a href="#8-月-3-日-时常感恩" class="headerlink" title="8 月 3 日 - 时常感恩"></a>8 月 3 日 - 时常感恩</h4><p>每当觉得生活不够精彩、有意思的时候，我们可以停下来，回忆自己过去的经历，看看自己周围的一切，想想自己拥有的一切。我觉得自己是个幸运的人，至少从我过去二十几年的生命中所接触到的人和事来看，我算是幸运的。我有爱我的家人，许许多多曾经帮助过我的老师和同学、素不相识的陌生人等，他们让我成为了此刻的自己。我做着自己喜欢且能够获得成就感的工作，我的同事都是正派善良的人；我有足够的空闲时间去读我想读的书以及做其它我想做的事；我能常常见到我的家人。能够拥有这一切，我已经非常满足了。幸福需要你学会向内探索，我真正想要什么？真正让自己感到满足的事是什么？而学会感恩是获得幸福的首要条件。</p><h4 id="8-月-4-日-我们自己才是自己的贵人"><a href="#8-月-4-日-我们自己才是自己的贵人" class="headerlink" title="8 月 4 日 - 我们自己才是自己的贵人"></a>8 月 4 日 - 我们自己才是自己的贵人</h4><p>每个人都期望得到贵人的指点，比如遇到一个品德或者能力特别突出的人来启发、引领自己。但是，我们大多数人都是普通人，除非你刻意地去改变自己的环境，否则我们的身边基本上通常也只能是被普通人包围着。想要快速取得进步，最好的办法是更换自己的环境，进入一个更积极、更优秀的圈层。但这又不是容易做到的，因为环境本身很难改变，更不要说向上改变了。每个人都想要变得更好，而这其实没有捷径可走，唯有不断努力学习，做好自己该做的事，持续进步下去，让自己慢慢变得更优秀。当你变得更好的时候，各种机会的大门才会慢慢向你打开，你也才能有意地去选择自己的环境。所以，归根结底，还是要从改变我们自己上入手。努力改变自己，才有可能获得更多机会，才有可能得到「贵人」的指点。另外，现在的学习资源如此丰富，书本、网络就是我们最重要的「贵人」，而它们的获取成本也很低。只要你伸出手去，你就能得到想要的帮助，利用好这点。</p><h4 id="8-月-5-日-做好自己的事"><a href="#8-月-5-日-做好自己的事" class="headerlink" title="8 月 5 日 - 做好自己的事"></a>8 月 5 日 - 做好自己的事</h4><p>昨天下午和晚上都在网易，因为现在做的项目网易是客户。他们反馈了很多问题，瞬间觉得这周剩下的时间过得不会太轻松。下午调试问题到一半，被叫去帮忙处理 iOS 打包证书的问题，最后通过借用别人的账号来打包发布了内测版本。晚上体验了网易的餐厅，好久没看到这么密密麻麻的人群，感觉密集恐惧症都要犯了。晚上继续调试，但是效率不高，几乎没有解决什么实质性的问题。昨晚回来后躺在床上睡不着，一方面是心里觉得有压力，还有几个棘手的问题需要解决，有点担心项目不能按时交付；另一方面，翻来覆去想白天发生的事，心里觉得有点委屈。其实也没发生什么，只是在配合处理问题的时候，觉得对方隐隐约约表现出一种轻蔑的态度，事后回想起来让人觉得有点不太舒服。突然意识到当时其他人看我的眼神都不太一样，因为我就是对方嘴里的那个「外包同学」。心里有一刻挺失落的，觉得被这样称呼有种不被尊重的感觉。但是，这些只是我自己的感受而已，没有人知道他们的真实想法是什么。另外，别人怎么想是他们的事，我只需要做好自己的事就可以了。而且他们说的也没错，我现在做的的确是外包业务。所以啊，人还是不能太玻璃心。认真做事就好了，想那么多没用。改变你能改变的；如果改变不了，那就接受它。</p><h4 id="8-月-6-日-信心和勇气"><a href="#8-月-6-日-信心和勇气" class="headerlink" title="8 月 6 日 - 信心和勇气"></a>8 月 6 日 - 信心和勇气</h4><p>每当觉得坚持不下去的时候，就应该停下来休息一会儿，回头看看自己已经走了多远。虽然这一路上遇到很多困难和挫折，但好在都被自己一一克服了，相比过去，我已经获得了改变。既然我还能站在这里，那就说明自己已经获得了成功。的确，目前还是有很多需要改进的地方，对现状也还是有不甚满意的地方。但是，要相信这些只是暂时的，既然过去的自己能取得进步，现在的自己就没有理由会止步不前。不过，有时候也要允许自己感到失落，每个人都有遇到挫折的时候，每个人也都会有负面、消极的想法出现。注意到它们，但是不要让自己悲观太久。因为我们迟早都得乐观起来，生活才能继续。遇到痛苦，我们的本能是想要逃避，不要批判自己，觉得自己太懦弱。要允许自己为人，Permission to be human。承认自己只是个普通人，也有脆弱的时刻，即使想要不顾一切缩回自己的保护壳之中，也是正常的现象。要相信一切都会过去的，只要你能表现出足够的意志力和面对困难的勇气，就没有什么东西能够真正击倒你，信心和勇气才是不可战胜的。</p><h4 id="8-月-7-日-控制压力和保持平衡"><a href="#8-月-7-日-控制压力和保持平衡" class="headerlink" title="8 月 7 日 - 控制压力和保持平衡"></a>8 月 7 日 - 控制压力和保持平衡</h4><p>不要给自己太大的压力。无论是工作还是生活上，我们有时候会被压力逼得喘不过气来。当面对挑战的时候，应该如何调整自己的心态？除了给自己加油打气之外，我觉得我们还得学会舒缓压力，无论是通过运动还是其它方式。我们需要让紧绷的神经有一小段放松的时间，否则压力堆积达到我们能够承受的阈值之后，会像火山一样爆发。太多的压力是有害的，但是适度的压力是有益的。所以，如何平衡好「度」的问题才是真正考验我们的地方。人只有在压力之下才能获得成长，但是在压力之下保持愉悦的能力也是非常重要的。我们每个人都是手中握着一个平衡杆在走险路。遇事不崩其实说的就是我们在面对压力的时候保持镇定的能力，这需要我们平时就不断刻意训练自己，包括处理紧急状况的能力、面对困难时的勇气和信心、意志力等等。想要积累起这些，只有靠长时间的自我修炼、不断思考以及持续的行动，只有身体、思维、意志、情绪都足够强大，我们才能从容不迫地面对未知的一切。</p><h4 id="8-月-8-日-解决属于你的问题"><a href="#8-月-8-日-解决属于你的问题" class="headerlink" title="8 月 8 日 - 解决属于你的问题"></a>8 月 8 日 - 解决属于你的问题</h4><p>我们为什么喜欢超级英雄电影？其实我们不仅是被他们的超能力所吸引，每个人都可以凭空幻想出一堆超能力，但是，比超能力更重要的是每个超级英雄背后的故事：他们的成长经历，为了获得超能力所付出的牺牲等等。很多英雄其实一开始只是一个普通人，甚至比普通人还要弱一些，大部分超级英雄的童年并不快乐，获得超能力之后也弥补不了自己过去所受的创伤。不过，每一个超级英雄最后之所以成为了「英雄」而不是「反派」，其实不是因为他们的能力，而是因为他们选择站在了正义的一边，选择了帮助那些没有超能力的普通人，或者去完成一些只有他们才能完成的任务。联想到现实，其实不管你是什么样背景的人，无论是贫穷还是富有，是来自城市中产又或者是农村家庭，每个人都有自己困难要面对，能力强大的人照样会有迷茫和痛苦的时刻。我们要做的是要始终选择善良，要为这个世界增添更多的价值，并且从中找到属于自己的人生意义。这个世界上有很多人，也有很多种生活方式，很多人和我们过着完全不同的生活。意识到这一点，而且要学会理解并尊重那些和自己不同的人，然后选择适合自己的生活方式，去解决你遇到的困难。除了让自己生活得幸福快乐，也要帮助身边的人获得它们。我们生来就是为了解决问题，并且只有在这一过程中才能慢慢找到生命的意义。</p><h4 id="8-月-9-日-如何面对挑战和失败"><a href="#8-月-9-日-如何面对挑战和失败" class="headerlink" title="8 月 9 日 - 如何面对挑战和失败"></a>8 月 9 日 - 如何面对挑战和失败</h4><p>面对挑战的时候，除了能有勇气迎难而上之外，我觉得最重要的一点是，要<strong>相信自己</strong>能跨过这道坎。无论最终结果如何，成功或者失败，其实都不重要，真正重要的是你有面对结果的勇气，并且在这一过程中没有退缩和逃避。每个人都需要学会和焦虑以及压力相处，需要学会战胜自己内心的恐惧。只要有一次这样的经历，当下次面对困难的时候，你就不会轻易想到要去逃避它们。因为逃避始终是比较消极的做法，不仅不能解决问题，而且还会打击自己的信心。但是如果你选择直面它，即使最终结果仍是失败，你会意识到，其实所谓的「失败」也不过如此，并没有想象得那么可怕；而且你也能收获一些经验，在下次面对类似情况的时候，可以改变策略，从而做得更好。智慧是从失败的经历中获得的，失败的次数越多，你获得的避免失败的经验也就越多，也就更有可能在未来获得成功。另外，人生路还很长，不要让自己陷入挫折或者失败的阴影中太久；你还很年轻，未来还有很多机会。即使偶尔摔一大跤也没事，要相信自己无论如何都能重新站起来，拍拍屁股继续往前走。</p><h4 id="8-月-10-日-如何培养起好的品格"><a href="#8-月-10-日-如何培养起好的品格" class="headerlink" title="8 月 10 日 - 如何培养起好的品格"></a>8 月 10 日 - 如何培养起好的品格</h4><p>无论做什么事，如果你相信这件事必须由你完成，你就会义无反顾地去克服一切困难，去迎接所有的质疑和敌意。所有需要你去解决的问题都变成了有意义的挑战，而你所做的一切都不仅仅是为了完成目标，也是为了磨练自己的意志，成为一个更好的人。为什么我们需要工作，尤其是有挑战性的工作，其实抛开获得报酬和激励之外，最重要的一点是因为它能磨练我们的品格，让我们变得坚韧、有耐心，学会承担责任，学会与他人合作，尊重他人，也更能体现出自己的价值。最能体现我们价值的时刻，是在那些困难、充满压力和挑战的环境下，我们所表现出的品质，这种品质是我们人生能否过得幸福的关键。你是否勇敢、自信、沉着、冷静、理智、善于分析和思考，能否关心、尊重他人，学会换位思考、高效与人合作，是否懂得影响、激励他人，创建良好的氛围，帮助并领导其他人完成共同的目标等等。这些品质只有在长时间的自我反省和实践中，才能逐渐培养起来。除了不断重复这些人人都知道的「道理」之外，耐心一点，让自己真正开始以这些观念为指导，在生活中实践它们，慢慢变成自己想要成为的人。</p><h4 id="8-月-11-日-Justice-Moderation-amp-存天理、灭人欲"><a href="#8-月-11-日-Justice-Moderation-amp-存天理、灭人欲" class="headerlink" title="8 月 11 日 - Justice/Moderation &amp; 存天理、灭人欲"></a>8 月 11 日 - Justice/Moderation &amp; 存天理、灭人欲</h4><p>人一切的痛苦都来自于无法实现自己的欲望。我们爱上某个人，在 Ta 身上倾注了自己全部的情感和精力，但是最终却没有得到自己期望中的回应，于是我们就会感到失望和痛苦；我们与某个人结婚后，发现对方渐渐表现出一些让自己不满意的行为，变得越来越自私，甚至没能提供足够的经济支持、承担起照顾家人的责任时，我们会感到无比痛苦和绝望。所以，获得幸福和快乐的关键是要学会<strong>控制自己的欲望</strong>，学会遵循自然规律，认清事物的本质。古代的很多哲学都提到过这些，比如古希腊的斯多葛学派提倡的追求正义 (Justice) 和节制 (Moderation)，以及王阳明的「存天理、灭人欲」。正是因为很多人还不懂得这个道理，所以在物质条件优渥得多的现代，依旧有非常多的人过得不快乐。要了解如何获得幸福和快乐，我觉得这些古代的哲学才更加值得参考和学习。人虽然也只是一种动物，但是人能够思考和自我控制，这点是区分我们和其它动物的关键。</p><h4 id="8-月-12-日-关注自身的发展，不要和他人比较"><a href="#8-月-12-日-关注自身的发展，不要和他人比较" class="headerlink" title="8 月 12 日 - 关注自身的发展，不要和他人比较"></a>8 月 12 日 - 关注自身的发展，不要和他人比较</h4><p>很多时候，我们的不满情绪都是在和他人比较中产生的。比如当我们得知自己的薪资和同事相比差了很多，但是我们认为彼此的付出和贡献并没有相差很多时，这时我们心中的不满情绪就会变得异常强烈。这也是为什么很多公司都会禁止员工之间讨论薪资。但是，我觉得这种拿自己和他们比较的行为，大部分情况下只会徒增烦恼。因为我们每个人都是非常独特的个体，除去教育经历、家庭背景等这些无法改变的外在条件之外，还有自身性格、认知水平、个人天赋、生活习惯的不同，再加上人脉关系、运气等因素，所有的一切结合在一起，造成了我们此刻境遇的不同。但是，我始终相信，资本市场是公平的。一个人有可能暂时会被亏待，但是长期来看，如果他/她一直保持勤奋努力、积极进取的心态，最终一定能得到应有的回报。我们应该只关注自身，不断进步，不停发现自己的问题并且自我修正，即使最终没有得到自己想要的结果，至少也能做到问心无愧。</p><h4 id="8-月-13-日-我真正想要什么？什么才是真正重要的事？"><a href="#8-月-13-日-我真正想要什么？什么才是真正重要的事？" class="headerlink" title="8 月 13 日 - 我真正想要什么？什么才是真正重要的事？"></a>8 月 13 日 - 我真正想要什么？什么才是真正重要的事？</h4><p>我真正想要的是什么？每当感到迷茫或者是现实让自己不知所措的时候，都应该问问自己这个问题。我为什么要做这件事？我能从中收获什么？什么才是真正重要的事？想清楚这些之后，你对所做的事才会有更深的理解，也才能愿意真正投入其中。人最重要的东西就是自己的时间和精力，要善用好它们。如果你觉得一件事情不值得做，那么就要思考是否能避免它们。如果无法避免，那么也要想办法寻找其意义。</p><h4 id="8-月-14-日-在遇上她之前耐心成长"><a href="#8-月-14-日-在遇上她之前耐心成长" class="headerlink" title="8 月 14 日 - 在遇上她之前耐心成长"></a>8 月 14 日 - 在遇上她之前耐心成长</h4><p>昨晚和老姐一起回家，到家挺晚的了，所以洗完澡就上床睡觉了。今天七夕，但是对于一只单身汪来说，并没有什么特殊的感觉。马上 27 岁了，但是依旧没有谈过真正的恋爱，一次都没有。这是一件丢脸的事吗？似乎有点。反正每当和家人或者同事聊起这个话题的时候，感觉气氛都会变得有些尴尬。不过，我觉得最重要的还是自己的感受。如果不想谈恋爱，也没有合适的机会，那单身也未尝不是一种好的选择，毕竟一个人的确非常轻松自在。虽然偶尔也会感到孤单，但是凡事都有两面性，不可能所有好处都被你占了。我理想中的爱情是什么样子的呢？首先，彼此相爱是第一条。其次，两个人一起分享彼此的生活，互相鼓励彼此，互相陪伴，见证彼此的成长，尽自己一切努力让对方感到幸福快乐，一起去体验这个丰富多彩的世界。遇见这样的人很难吧？肯定很难，但是还是要怀抱希望，保持开放的心态。这个世界这么大，一定会有一个比较适合你的人在某一个时刻出现在你的生命中。此刻我能做的，只有做好自己的事，以及多一点耐心，等待她的出现，等遇到的时候要让自己配得上她。</p><h4 id="8-月-15-日-谈交友"><a href="#8-月-15-日-谈交友" class="headerlink" title="8 月 15 日 - 谈交友"></a>8 月 15 日 - 谈交友</h4><p>找到一个彼此观念契合又能一起生活的人真的太难了，数数看自己身边有多少合得来的朋友，就知道这件事是多么的不容易了。我们看待事物的方式，彼此的脾气性格，甚至是彼此的家庭和经济状况，都会影响到我们的相处模式。只有在彼此的差距不是太大，同时又有很多共同点的情况下，我们才能逐渐走进彼此的生活，慢慢拉近关系，直到最后发展出感情甚至是爱情。我始终觉得，一见钟情的感情都不会太靠谱，因为荷尔蒙会让人看不清对方的真实样子。虽然我知道大多数人坠入爱河的时候都是盲目的，但是如果可以的话，我还是希望自己和对方能够更加理性一些。我们的生活习惯，对待生活和工作的态度，财富观念，甚至是育儿理念是否一致，这些才更重要。当然，身高、外貌这些也是重要的因素，但是只要没到实在看不惯对方的程度，就可以把优先级往后排一排。那么，怎样才能找到这样的人呢？除了主动拓展关系，最重要的还是要保持开放，改变自己的处事风格，尽量做一个轻松自在的人，要敢于在陌生人面前表达自己。说白了，就是脸皮要厚，胆子要大，不要怕丢脸，多尝试和陌生人搭讪聊天，不要放过任何一个拓展自己人脉的机会。</p><h4 id="8-月-16-日-找到你的动力源"><a href="#8-月-16-日-找到你的动力源" class="headerlink" title="8 月 16 日 - 找到你的动力源"></a>8 月 16 日 - 找到你的动力源</h4><p>为什么有的人总是充满活力，能够朝着自己的目标不断努力，而有的人却喜欢安稳，认为只要日子能过得去就好了？我觉得除了成长环境、所受教育、身边人的观念的影响之外，最主要的原因是后者没有形成<strong>强大的动力源</strong>。比如有的人的动力源是摆脱贫困，也许他们从小生活在一个物质条件相对匮乏的环境之下，真切地感受过贫穷的滋味，所以他们有足够的动力去摆脱贫穷，改善自己和家人的生活环境。在达到这一目标之后，因为有过这样的经历，所以还会希望帮助更多的人摆脱贫穷。有的人的动力源是爱情，为了能够和所爱之人在一起，愿意放弃一切，付出所有，去冒险、去突破自己、去做各种不可思议的事。还有的人的动力源是寻求真理，比如所有那些我叫得出或者叫不出名字的科学家们。那么，我的动力源是什么？我对金钱并没有非常大的渴望，对物质上的享受也没有太大的感觉。对爱情有渴望，但是我觉得我不是那种会为了爱情而放弃其它爱好或者获得非常大的动力的人。这样看来，我最大的动力源应该是找到自己的动力源。没有动力源的人生是不值得过的，一个有意义的人生应该是充满目标感的，我希望自己能够充满目标感地过完自己的一生，并且能够不断获得新的体验。</p><h4 id="8-月-17-日-如何走出情绪低潮期"><a href="#8-月-17-日-如何走出情绪低潮期" class="headerlink" title="8 月 17 日 - 如何走出情绪低潮期"></a>8 月 17 日 - 如何走出情绪低潮期</h4><p>每当陷入情绪低潮期的时候，我都会愈发意识到好习惯的重要性。当想要放纵自己的时候，因为过去养成的习惯的存在，从而让自己至少能够完成一些事情，而不是完全无节制地满足自己的懒惰和欲望。那么，如何摆脱情绪低潮，重新让生活进入正规？第一件事是，要找到让自己陷入情绪低潮的原因。我为什么会有这样的情绪？我是怎么一步步进入到现在的状态的？如果你仔细寻找就会发现，其实真正的原因早就在几周前甚至几个月前就埋下了种子。事情一步步发展成了现在的样子，是因为你没有尽早发现问题并且及时做出调整。那么，我要如何改变现状呢？首先要接受现实。你现在所面对的一切都是你过去所作所为的结果，我们要承担起自己的责任。不要逃避现实，也不要把原因抛给外界——这就是我自己造成的。所以，第一步是坦然面对现实，接受真实的自己。然后再开始寻求改变，无论是通过养成更多的好习惯，还是寻求提升自己的能力，以便能够更加高效地解决自己工作和生活中遇到的问题。这一过程可能非常漫长，但是，只要你开始行动并做出改变，事情就会开始向好的方向发展，你要对自己的未来保有信念。</p><h4 id="8-月-18-日-学会自我提问"><a href="#8-月-18-日-学会自我提问" class="headerlink" title="8 月 18 日 - 学会自我提问"></a>8 月 18 日 - 学会自我提问</h4><p>每个人都在强调要做自己热爱的事，但是真正这么做的人又有多少呢？很多人都是被迫做着现在的工作，而不是出于热爱。但是，当你问一个人：除开现在的工作，你最想做的事是什么？能有一个直接了当、清晰的回答的人一定是少数。大多数人都不知道自己想要什么，这是导致他们做的不是自己喜欢的工作的原因。很多人的愿望是财务自由，说白了就是钱多到花不完，但是之后呢？很多人可能并没有想过。有多少人认真思考过实现财务自由需要我们做什么？财务自由其实并不像我们想象的那么遥不可及，只要<strong>被动收入&gt;生活支出</strong>就可以了，但是有多少人想过要增加自己的被动收入？所以，我觉得大多数人最大的问题是思考得太少，我们应该多问问自己「我想要什么？」、「如何达成目标？」等此类问题。只有在学会如何思考之后，我们才能开始寻求解决问题的方法。我感到不快乐的原因是什么？是因为想要的得不到满足还是只是被当下的欲望蒙蔽了双眼，忘记了自己应该感恩目前所拥有的一切？我感恩自己拥有的一切，也会回馈他人的帮助以及适当地给予他人，但还是对现状不满足？那么，我就需要继续向自己提问，找到这种不满足的根源，然后再以此调整自己的工作和生活。当你开始向自己提问的时候，问题其实已经解决了一半。</p><h4 id="8-月-19-日-把一件事做好"><a href="#8-月-19-日-把一件事做好" class="headerlink" title="8 月 19 日 - 把一件事做好"></a>8 月 19 日 - 把一件事做好</h4><p>一个人其实不需要活出太多的样子，只要能把一件事做好，会解释其他所有的事。昨天读到的这句话，让我思考了好久。一句话或者一个观念如果能够停留在我们脑海中，通常说明我们内心深处早就认同它们了，只不过没有找到合适的语言表达出来。我们为什么不需要活出太多的样子，因为人的精力是有限的，我们通常只能花时间在一、两个领域中达到比较擅长的程度，并且因为在这一、两个领域中获得的成就而被他人记住。而能把一件事做好是一个人基本能力的体现，你只要能够做好一件事，做到精通，即使其他方面做的不是那么好，别人也会认可你。比如，我们会宽容脾气暴躁的杰出艺术家，也会允许程序员在社交场合表现得比较木讷，等等。能把一件事做好是一个人建立起自己信誉的第一步，只有完成了这一步，我们才能得到与他人合作的机会，做更多有价值、有意义的事。</p><h4 id="8-月-20-日-保持观念和信念的可塑"><a href="#8-月-20-日-保持观念和信念的可塑" class="headerlink" title="8 月 20 日 - 保持观念和信念的可塑"></a>8 月 20 日 - 保持观念和信念的可塑</h4><p>人与人之间的差距是怎么形成的？我觉得最主要的原因是观念或者说是信念的不同。但这也不是说只要接受了新观念和信念就能立马改变一个人，因为从接受到真正理解再到实际行动，往往需要花很长的时间。而且对于许多顽固的人来说，光是让他们改变自己的观念或信念，就已经是非常困难了。忘了是在哪里看到的，我们可以认为那些不愿改变自己想法的人事实上已经「精神死亡」，只不过在生理上还活着且继续「存在」下去。为了不让自己成为这样的人，我们必须时刻注意自己是否已经思维固化，是否还能通过对不同的观点进行认真思考后才得出结论，而不是一味地排斥和自己不同的事物以及想法。我们必须不断学习和成长，才能让自己接触并甄别出对自己有用的观念和信念。观念指导我们的行动，行动改变我们的环境，而环境又会进一步强化我们的观念。为了走上正确的道路，我们必须尽可能早地选择正确的观念，然后以此作为自己行动的依据，不断强化它、修正它，直到死亡。</p><h4 id="8-月-21-日-耐心做好一件事"><a href="#8-月-21-日-耐心做好一件事" class="headerlink" title="8 月 21 日 - 耐心做好一件事"></a>8 月 21 日 - 耐心做好一件事</h4><p>有时候在想，我们为什么会焦虑，根本原因是想要「快速成功」。我们幻想未来更加强大的自己，而对此刻的自己没有了耐心。但是，任何技能的习得都是需要时间的，需要我们熬过每一个感到枯燥乏味、彷徨、迷茫，甚至是自我怀疑的时刻。直到我们不再去思考「成功」，不断精进成为了我们的习惯，然后突然有一天，有人告诉我们：你已经是这个领域的佼佼者了。虽然那个时候，我们对他人的评价可能已经不那么在乎了，但是，估计也还是会感到高兴吧。无论是所谓的匠人思维也好，建立宝贵而稀缺的职场资本也好，只不过是说法不同而已。越来越觉得，这种「有足够的耐心，愿意花足够长的时间掌握并精通一件事」的态度是自己所需要的。哪怕要花上一二十年，只要认真投入其中，再难的事你也一定能学会并做到出色。怕的是你没有耐心。</p><h4 id="8-月-22-日-由永生联想到死亡的意义"><a href="#8-月-22-日-由永生联想到死亡的意义" class="headerlink" title="8 月 22 日 - 由永生联想到死亡的意义"></a>8 月 22 日 - 由永生联想到死亡的意义</h4><p>如果人类真的实现了永生，活着的意义是什么？我们现在所做的一切，学习知识、获得财富、创造价值、繁衍、探索新知、扩展人类活动范围，这一切在永生面前好像都不再那么重要了，因为只要没有小行星撞上地球或者发生大规模战争，人类已经可以依靠现有的科技一直快乐地生活下去了。所以，如果人类真的实现了永生，科技发展的速度一定会放慢。我们不再急切地想要探索其它宜居星球，因为我们只要在太阳爆炸之前找到一个可替代地球的行星就可以了。过去几百年的时间里，现代科技的出现杀死了宗教，而如果人类实现了永生，艺术和哲学一定会重新繁荣发展起来，甚至超越过去，因为我们迫切地需要重新找到生命对于我们的意义。科学已经给不了我们答案了，答案只能在艺术和哲学里寻找。另外，生命科学一定变得更加繁荣，因为我们会更加无法忍受「自杀」这件事了，我们会想尽一切办法让一个人永远无法死亡，哪怕是让他活在数字世界里。所以，如果实现了永生，未来的数字世界一定也会无比繁荣地发展下去。这反过来也会减慢人类探索其它星球的步伐，因为我们可以在数字空间里创造出任何一个可能的世界。虽然永生很有诱惑力，但是我并不想要看到这样的世界。这样看来，对于现在的我们来说，生命的意义其实是死亡赋予的。所以，虽然死亡很讨厌，但是也并非毫无意义，它是人类继续向前发展的驱动力。</p><h4 id="8-月-23-日-与他人建立连接"><a href="#8-月-23-日-与他人建立连接" class="headerlink" title="8 月 23 日 - 与他人建立连接"></a>8 月 23 日 - 与他人建立连接</h4><p>一个明显的事实是：人需要和他人建立连接。因为只有这样，我们才能在生活中感受到幸福——每个人都离不开亲情、友情和爱情。那么，如何才能与他人建立连接？最关键的一点是保持开放和包容。你要能接受和自己不同的人，即使是和自己相似的人的身上，也有与自己不同的地方。你需要认识到人是立体的，我们所看到的只能代表他/她的一部分，而不是全部。其次，你要关注自己的需要。这个世界上生活着亿万人，但并不是每个人都适合做你的朋友和伙伴，而且人的精力也有限，我们只能选择很少一部分人去认识并结交。所以，首先要思考「我想成为什么样的人」？想清楚这点之后，你才能做出正确的选择。好朋友、好伙伴的标志是他/她能拓展你的边界，让你认识到更大的世界，以及不断激励自己，和你一起不断成长、共同进步。目前，我似乎还没有遇到这样的人，但是我相信迟早有一天会遇上的，但前提是我自己得先成为这样的人，我必须不断学习，努力变得更好，让自己成为值得交往的人。</p><h4 id="8-月-24-日-把工作变成自己的爱好"><a href="#8-月-24-日-把工作变成自己的爱好" class="headerlink" title="8 月 24 日 - 把工作变成自己的爱好"></a>8 月 24 日 - 把工作变成自己的爱好</h4><p>如何提升工作的幸福度？一个简单的窍门是把工作变成自己的爱好。当你的工作变成了爱好的时候，你也就不再需要去花时间在其它爱好上，因为你的工作就是自己最喜欢做的事，你也会有更大的动力去提升自己的能力。另外，人是在解决难题的过程中获得成长的。我们要想办法让自己解决更大的难题。而获得解决更多、更大的难题的机会，一要靠不断提升个人能力，二要看运气。但其实运气也是可以靠自己创造出来的，当你积累了足够多的解决问题的经验，很多时候好运会自动找上门。那么，如何把工作变成爱好？最关键的是，给自己立下一些简单可行的目标，比如，用一个月时间学会一门之前没有使用过的语言或技术；用三周时间完成一个独立小项目；优化当前项目中的某个功能等等。随着你花的时间越来越多，你会变得越来越擅长自己的工作，而且也能解决越来越多的问题。与此同时，你会获得更多选择的机会，而这也会让你更有动力去不断提升自己。持续这个循环下去，慢慢地，你就会成为别人眼中的专家，你拥有的机会和选择也会越来越多。</p><h4 id="8-月-25-日-珍惜身边的缘分"><a href="#8-月-25-日-珍惜身边的缘分" class="headerlink" title="8 月 25 日 - 珍惜身边的缘分"></a>8 月 25 日 - 珍惜身边的缘分</h4><p>人只能活一次，保持积极的生活态度。每次跑完步心情都会变得明亮、愉悦起来，昨晚跑完步同样如此，于是发出了这样的感慨。这也是运动的意义之一吧，不仅仅是可以强健体魄，也能改善激素分泌，让自己的心情变好。看着街上来来往往的人，虽然我都不认识，但是不知道为什么，我觉得从某种程度上来看，我们是一体的。一方面，这是事实，因为身处市场经济，我们每个人都既是生产者又是消费者，我们提供的服务虽然不是直接服务对方，但是有时候这种服务经过几次中间过程的处理，最终也能抵达素不相识的对方。这样看来，我们每个人都在接受他人提供的商品和服务，同时也在服务他人和创造价值。另一方面，我觉得每个人都是整个人类群体的一部分，我们能够遇上彼此本身就是非常难得的事了。虽然仅仅是一面之缘，但是如果考虑到人口总量和时间的因素，我们能够在这个时间点刚好遇见彼此，也是一种缘分。所以，我们要好好珍惜那些出现在你生命中并且与你产生交集的人，因为这是更加难得的缘分，比如小区保安、同事、室友等等。至于你的家人和朋友，他们是你生命中最最珍贵的缘分，要加倍珍惜。</p><h4 id="8-月-26-日-寻求改变和保持平静"><a href="#8-月-26-日-寻求改变和保持平静" class="headerlink" title="8 月 26 日 - 寻求改变和保持平静"></a>8 月 26 日 - 寻求改变和保持平静</h4><p>每当我们觉得自己的生活缺少变化和挑战的时候，就意味着我们需要改变自己的生活方式。虽然变化不一定总是好的，按部就班不一定总是不好的，但是只要能让我们生活得更加健康和幸福，那么就值得尝试。不过，我们也需要识别出哪些改变可能会是有害的，以及我们是出于什么样的目的才想要尝试这种改变。比如，我是真的想要这么做还是只是出于焦虑？如果只是为了缓解自己的焦虑情绪，我有没有什么更好的做法？</p><p>也许人只有在年轻的时候才会有「觉得自己生活需要改变」的想法吧，因为年轻，所以想要尝试尽可能多的选择，而不是维持一种生活方式很多年。但是等到自己年纪再大一些，也许就会想要生活尽可能保持平静，不要发生太多变化。这也从侧面反应出我对当下生活并不满意，并没有感到足够幸福，所以才会想要寻求改变的可能性。改变生活方式从来都不容易，而且归根结底，最终需要我们改变的是我们自己的态度。我们如何对待自己，如何与周围的世界相处，如何保持内心和外界环境的和谐，这是需要用一生修炼的智慧。</p><h4 id="8-月-27-日-沟通以及换位思考"><a href="#8-月-27-日-沟通以及换位思考" class="headerlink" title="8 月 27 日 - 沟通以及换位思考"></a>8 月 27 日 - 沟通以及换位思考</h4><p>不要做一个糟糕的沟通者，学会换位思考。只有在和他人沟通发生不愉快的时候，你才会意识到沟通方式的重要性，有时候表达同样的含义，如果你能换个方式，他人的接受程度、给周围人的感觉都完全不同。这就是沟通的艺术吧。所以，好的沟通者往往都会注意自己的用词，确保自己说的每一句话都能得到最大的功效，从而更好地服务于实现自己的目标。对我自己来说，我从来不是一个好的沟通者。第一，沟通太少。如果你不刻意练习，怎么能获得进步呢？第二，太随心所欲。虽然和别人沟通的时候，我能发现他人的问题，但是轮到我自己的时候，可能会犯同样的错误。要想改变这点，同样需要我们做足够多的练习，直至养成习惯。尤其是在我们占有主导权的对话中，更加需要注意到自己的措辞，因为这个时候我们更放松，容易暴露自己的本性，因此也更容易犯错。除此之外，好的沟通者往往也非常善于换位思考。站在他人的角度，如果他们这样说，我心里会是什么样的感受？己所不欲，勿施于人，这个道理无论放在哪个场景下都适用。</p><h4 id="8-月-28-日-学会使用思维模型"><a href="#8-月-28-日-学会使用思维模型" class="headerlink" title="8 月 28 日 - 学会使用思维模型"></a>8 月 28 日 - 学会使用思维模型</h4><p>最近在看熊秉元的《解释的工具》，其中提到了 A-A<sub>1</sub> 思维模型：通过将问题抽象化和图解化，寻找出其它类似的概念或事物，再通过对照和衬托探索出潜在的、更好的可能性。这的确是个非常有用的思维模型，而且无论做什么事，似乎都可以先用这个思维模型去优化一番，然后再决定是否应该这么做。比如，在开始解决问题 A 之前，我们可以先问问自己，问题 A 的本质是什么，它有哪几个部分组成，最关键的部分是什么，是否有更好的方法去达到目的，按现有解决方案需要投入多少时间和精力，解决之后能够给我带来哪些收益，现在行动和之后行动的差别在哪。这是我第二次在阅读过程中意识到思维模型的重要性，第一次是在阅读《穷查理宝典》的时候。另外，我其实还在收藏了在社交平台上看到的一些思维模型。其实每个人都应该收集一些常用的思维模型，并且在现实生活中不断运用和逐渐掌握它们，只有这样，我们才能在不同的情境下使用不同的思维模型来思考和解决问题。</p><h4 id="8-月-29-日-保持目标感，使它们具体且可执行"><a href="#8-月-29-日-保持目标感，使它们具体且可执行" class="headerlink" title="8 月 29 日 - 保持目标感，使它们具体且可执行"></a>8 月 29 日 - 保持目标感，使它们具体且可执行</h4><p>如果没有家人和朋友，我是否还能在这个世界上生存下去？如果我是孤身一人，我能否靠自己生活得幸福快乐？这是我最近突然想到的问题。回顾自己过去的经历，从出生到长大成人，从学生时代到进入职场工作，我和这个世界最大的联系似乎就只有家人，连朋友都不多。的确，现在的自己的确已经获得了一定的经济能力，能够养活自己了，但是，我是否找到了继续努力前进下去的动力？除了家人之外，我关心的人好像并不多。人需要和他人建立连接，但是我似乎缺乏和他人建立连接的能力。然而这并不是最大的问题，最大的问题是我常常失去目标感。我羡慕那些知道自己想要什么并且为之不断努力的人。我知道生活得幸福快乐是自己的一个目标，但是有时候还是会陷入迷茫和不知所措的状态。工作可以填补一部分生命的意义感，并且可以维持我们的生活，但是总觉得少了点什么。阅读和旅行可以扩展自己的眼界，帮助自己建立更完整的世界观，也可以改变自己的生活态度。维持良好的生活习惯可以保证对自己生活的掌控感，并且生活得更加健康。除此之外，还有什么是我可以做的呢？我觉得我需要一个计划，让自己能够得到激励的计划，不仅仅是长期的目标，还需要有具体的目标，具体到每天、每周、每月需要完成哪些事，只有这样才能让自己获得不断前进的动力。无论是为了财富或者别的什么，一定要让自己的人生充满目标感，并且要让它们具体可执行。</p><h4 id="8-月-30-日-成长就是逐渐获得自主力的过程"><a href="#8-月-30-日-成长就是逐渐获得自主力的过程" class="headerlink" title="8 月 30 日 - 成长就是逐渐获得自主力的过程"></a>8 月 30 日 - 成长就是逐渐获得自主力的过程</h4><p>通常来说，在刚踏入职场的时候，我们往往处于自主力最少的阶段，但是随着你的能力的增长，你会获得越来越多的自主力。所谓的自主力，指的是一个人决定自己应该做什么的权力。我们能力越强，就越是对自己应该做什么、如何做，以及解决什么样的问题、如何解决，拥有越来越多的决定权。我们不再仅限于完成别人布置给自己的任务，而是自己给自己布置任务。我们知道自己的能力边界，也知道应该去学习、改进哪些方面的能力。我们会有针对性地做自己最擅长做的事，然后把其它的事交给比自己做得更好的人去做。这样，我们就能够把自己的注意力放在最重要的事情上。但是，自主力的获得是一个缓慢的过程，是一个随着我们的成长逐渐累积的过程。对于现阶段的我来说，不敢说已经完全获得了自主力，但是相比过去已经获得了比较大的自主力。一方面，和工作环境以及老板有关系，另一方面，也和自己的能力提升有关系。所以，我应该做的是，继续不断努力提升自己的能力，争取有一天能够获得更完全的自主力。</p><h4 id="8-月-31-日-经济学与市场"><a href="#8-月-31-日-经济学与市场" class="headerlink" title="8 月 31 日 - 经济学与市场"></a>8 月 31 日 - 经济学与市场</h4><p>为什么对经济学感兴趣？选择它只是一个切入点，因为所有的学科最终都会回到人和世界的关系上，经济学也一样。财产只有在一群人之中才有可能产生，一个人拥有再多的财富，如果不能用于和他人交易，那么也不能称之为财富。我们为什么要保护私人财产，因为这是人类社会不断发展和进步的源泉。每个人都是理性且自利的，所以我们会尽自己最大的努力让自己的付出得到最大的回报。而这一点离不开市场，我们需要通过交易才能让自己的产品的价值得到最大化，才能得到自己所需要的其他物品。从人类学会交换开始，市场就产生了，而这促使人类学会了分工合作，同时也使得资本积累成为了可能，而后者为大规模的分工合作和科学技术的进步奠定了基础。人们在市场上交易的过程中，出现的干预越少，市场就运行地越好。运行良好的意思指的是所有商品和服务都能体现出其真实的价值，所有人的需求都能得到最大程度的满足。也就是说，越是自由的市场，人们就越是生活得富足。既然如此，为什么这个世界还是存在不是完全自由交易的市场？解答这个问题涉及到就不仅仅是经济学的知识了，还需要融合社会学、政治学等等其它学科。简单来说，人们还没有准备好迎接这样的市场的到来。但是，我相信，总有一天，它会变为现实。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信 SDK 支持 Universal Links</title>
      <link href="/wechat-sdk-universal-links/"/>
      <url>/wechat-sdk-universal-links/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2021-08-15/universe-nebula.jpg" alt="universe-nebula"></p><blockquote><p>微信 SDK 更新到 1.8.6 之后，由于适配了 iOS 13，添加了对 Universal Links 的支持，因此开发者也需要对此做一些适配工作。本篇主要记录接入 Universal Links 的过程，主要参考了<a href="https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Access_Guide/iOS.html">微信文档</a>和<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html">苹果开发者文档</a>。</p></blockquote><p>在开始之前先了解一下 <a href="https://en.wikipedia.org/wiki/Deep_linking">Deep linking</a>，与 Web 开发不同，移动开发中的 Deep linking 是指直接通过链接打开指定的应用甚至是应用中的某个页面。对于 iOS 来说，实现 Deep linking 有两种方式，一种是 <a href="https://developer.apple.com/documentation/xcode/defining-a-custom-url-scheme-for-your-app">URL Scheme</a>，另一种是 <a href="https://developer.apple.com/documentation/xcode/supporting-universal-links-in-your-app">Universal Links</a>，后者用于取代 URL Scheme。</p><span id="more"></span><p>作为对比，安卓中也有类似的技术，被称为 <a href="https://developer.android.com/training/app-links">App Links</a>，且一共有三种。第一种是 <a href="https://developer.android.com/training/app-links#deep-links">Deep links</a>，用于告诉系统当前应用可以打开哪些类型的页面，当用户点击链接的时候会显示一个弹框（消歧义弹窗），供用户选择要在哪个应用中打开该页面。<a href="https://developer.android.com/training/app-links#web-links">Web links</a>，与 Deep links 类似，只不过针对的是 HTTP 链接，表示应用可以打开特定的 HTTP 链接，点击时同样会显示一个弹窗，供用户选择在哪个应用中打开。Android 12 之后，所有的 web links 将只能在浏览器中打开。<a href="https://developer.android.com/training/app-links#android-app-links">Android App Links</a>，只在 Android 6.0 (API level 23) 之后的系统中可用，是一种特殊的 web links，可以打开 HTTP 或者 HTTPS 协议的页面，并且包含 <code>autoVerify</code> 属性，该属性可以使得 App 成为打开某个链接的默认应用，而不是每次都展示一个选择弹窗，用户可以在应用设置页查看某个应用可以默认打开的链接。</p><p>iOS 中的 Universal Links 的工作方式和安卓中类似，只不过为了安全，操作相对复杂一些。</p><h3 id="开启步骤"><a href="#开启步骤" class="headerlink" title="开启步骤"></a>开启步骤</h3><h4 id="创建并上传-Association-文件"><a href="#创建并上传-Association-文件" class="headerlink" title="创建并上传 Association 文件"></a>创建并上传 Association 文件</h4><p>创建一个名为 <code>apple-app-site-association</code> 的文件，并且上传到 Web 服务器的根目录。苹果通过访问该文件来了解你的网站和哪些应用建立了关联。</p><p>该 JSON 文件内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;applinks&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;apps&quot;</span>: [<br>      <br>    ],<br>    <span class="hljs-attr">&quot;details&quot;</span>: [<br>      &#123;<br>        <span class="hljs-attr">&quot;appID&quot;</span>: <span class="hljs-string">&quot;[App ID Prefix].[Bundle ID]&quot;</span>,<span class="hljs-comment">// 在开发者账号的 Identifier 详情中可以看到</span><br>        <span class="hljs-attr">&quot;paths&quot;</span>: [<br>          <span class="hljs-string">&quot;/app/*&quot;</span><br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>确保 GET 请求能够访问到该文件就可以了。</p><h4 id="开启-Associated-Domains"><a href="#开启-Associated-Domains" class="headerlink" title="开启 Associated Domains"></a>开启 <a href="https://developer.apple.com/documentation/Xcode/supporting-associated-domains">Associated Domains</a></h4><p>Associated Domains 是应用能否可以打开某个链接的关键。首先在开发者账号管理后台中，找到应用的 Identifier，然后在 Capabilities 中开启 Associated Domains，如下图：</p><img src="../assets/2021-08-15/accociated-domains.png" alt="Accociated Domains" style="zoom:50%;" /><p>开启之后我们还需要更新 XCode 中的证书描述文件，然后在 Capability 中添加 Associated Domains，Domains 中填写：<code>applinks:your.domain.com</code>。其中，scheme 必须是 <code>applinks</code>，后面的 url 是你的网站地址，也就是 Universal Links 中的域名部分。</p><img src="../assets/2021-08-15/accociated-domains-xcode.png" alt="Accociated Domains in Xcode" style="zoom:50%;" /><p>经过上面这样的设置之后，重新运行项目，在浏览器中打开你的 Universal Links，这个时候你的应用应该就可以响应打开这个链接了。如果不行，说明上面步骤中存在错误的地方，请仔细阅读文档和检查配置过程。大部分情况下，很有可能是 <code>apple-app-site-association</code> 配置有误，请检查 App ID 和 Bundle Id 是否复制错了。</p><h4 id="配置-Universal-Links"><a href="#配置-Universal-Links" class="headerlink" title="配置 Universal Links"></a>配置 Universal Links</h4><p>在微信开放平台管理页面中填写 Universal Links，形式如：<a href="https://your.domain.com/app/%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%BF%85%E9%A1%BB%E4%BB%A5">https://your.domain.com/app/，注意必须以</a> <code>https</code> 开头和以 <code>/</code> 结尾。</p><p>在项目中初始化 SDK 的地方，填写相同的 Universal Links，以 fluwx 为例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">registerWxApi(appId: <span class="hljs-string">&#x27;wx*********&#x27;</span>, universalLink: <span class="hljs-string">&#x27;https://your.domain.com/app/&#x27;</span>);<br></code></pre></td></tr></table></figure><p>最后，还需要在 Xcode 项目配置面板的 Info 选项卡中，找到 <code>LSApplicationQueriesSchemes</code> 并添加一条 <code>weixinULAPI</code> 入口。</p><img src="../assets/2021-08-15/Info-LSApplicationQueriesSchemes.png" alt="LSApplicationQueriesSchemes in Xcode" style="zoom:50%;" /><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>作为一名非 iOS 开发者，没想到仅仅是开启 Universtal Links 就已经如此麻烦，虽然这里只写了三个关键步骤，但其实真正操作起来可能还会遇到许多的问题，所以还是要靠自己多搜索和查阅文档才能解决。尽管如此，在一番摸索之后终于配置成功，看到终于可以在应用中打开微信小程序了，也算是一件非常开心的事。文末附上了我参考的文章和文档的链接，希望对你有帮助。</p><p><a href="">　</a></p><p><strong>参考链接</strong></p><ul><li>Apple Developer Documentation<ul><li><a href="https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content">Allowing Apps and Websites to Link to Your Content</a></li><li><a href="https://developer.apple.com/documentation/xcode/supporting-universal-links-in-your-app">Supporting Universal Links in Your App</a></li><li><a href="https://developer.apple.com/documentation/Xcode/supporting-associated-domains">Supporting Associated Domains</a></li><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html">Support Universal Links</a></li></ul></li><li><a href="https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Access_Guide/iOS.html">微信开发平台文档</a></li><li><a href="https://juejin.cn/post/6844904051042156551">掘金文章</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保持谦卑</title>
      <link href="/2021-7/"/>
      <url>/2021-7/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/LUccF58bgwY" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>这个月开始做第一个正式的 Flutter 项目，到现在也差不多快要完成了，想谈谈 Flutter 的开发体验，但是好像和 React-Native 比起来，并没有什么特别的地方。目前 Flutter 的生态已经非常完善了，大部分问题都可以通过搜索引擎解决，很多常见的功能都有官方或者第三方维护的开源插件可用。现在开始用 Flutter 开发应用，相比前两年，要踩的坑会少很多。所以，能够在这个时间点开始学习并使用 Flutter 开发，我也算是运气比较好吧。另外，其实想要学习的东西还有很多，比如 JetPack Compose UI、iOS 开发、Linux 相关，最近因为重新用到一点前端的知识，所以还想从头开始学习前端。对于充满好奇心的人来说，程序员真的是这个世界上现存的最棒的职业了，因为有无限的细分领域可供学习和研究。这也提醒了自己，要永远保持谦卑，你所看到的只是世界的一角，这个世界的丰富多彩程度远超我们的想象。</p></blockquote><span id="more"></span><h4 id="7-月-1-日-看不见的人的生活"><a href="#7-月-1-日-看不见的人的生活" class="headerlink" title="7 月 1 日 - 看不见的人的生活"></a>7 月 1 日 - 看不见的人的生活</h4><p>昨晚跑步跑进一个很大的老小区，里面有成排的老式居民楼，有新建的像宿舍一样的带走廊的居民楼，也有一户户独栋独院的小别墅。小区里烟火气很浓，主街上的小吃店门口坐满了人，边上一个小广场上也很热闹，有跳广场舞的阿姨，打乒乓球的大爷，小足球场里踢球的小孩子，还有坐在路边树底下闲聊的人。小区里的路虽然直来直去的，但我也差点绕迷路了。后来经过一片更老的居民楼，发现了更多有意思的人。那些平时经常见到的路边小贩，原来就住在这里啊。然后意识到，我好像从来都没有想过，这些平时根本注意不到的人都过着什么的生活。其实他们也在非常努力地生活，有自己的家庭，每天忙碌地工作，只为多赚一点钱。但是回到家之后，他们也是某个孩子的爸爸或妈妈，也会和家人一起吃饭闲聊等等。虽然白天的工作非常辛苦，但是到了晚上，这些时刻就是他们短暂且简单的幸福时光，尽管有些人可能连自己也意识不到。我觉得身处这个时代最大的幸运是，无论你是什么背景的人，每个人都可以凭借自己的努力，追求属于自己的幸福。告诉自己，时常感恩，珍惜自己所拥有的一切。</p><h4 id="7-月-2-日-生命宝贵，远离政治"><a href="#7-月-2-日-生命宝贵，远离政治" class="headerlink" title="7 月 2 日 - 生命宝贵，远离政治"></a>7 月 2 日 - 生命宝贵，远离政治</h4><p>发现自己最近很喜欢看一些政治时事的视频，而且一看就停不下来。我觉得自己是个 liberal，但其实骨子里还是保留了一点 nationalist 的思维方式。虽然这两者并不矛盾，但是我觉得真正的自由主义者不应该是民族主义者，因为自由主义的要义就是尊重自由市场和私有产权，而民族主义者则觉得有比这两者更重要的东西。我觉得每个人都应该少关心政治，政府只是服务人的工具，而不应该被赋予代表某个群体的功能，只有每个人自己才能代表我们自己。我们应该花更多的时间想办法提高自己的生活水平，追求幸福，为他人创造价值，而不是将希望寄托在外界，比如意识形态上的胜利，或者寻求某种认同以及归属感。一个人如果需要从某个更大的群体中才能获得归属感，要么说明这个人非常狂妄，要么就非常卑微。生命太宝贵，少花时间在这种无意义的事情上。</p><h4 id="7-月-3-日-直面恐惧的勇气"><a href="#7-月-3-日-直面恐惧的勇气" class="headerlink" title="7 月 3 日 - 直面恐惧的勇气"></a>7 月 3 日 - 直面恐惧的勇气</h4><p>下午出门玩滑板，在江边坐了一会儿，望着江面发呆，回想自己过去的经历，突然有一个顿悟：<strong>一个人要想获得心灵上的自由，就必须学会识别并战胜让自己恐惧的东西。</strong>我们为什么会感到不快乐，要么是得不到自己想要的东西，要么是不知道应该追求什么。尽管每个人都有自己的局限性，都有想要而不得的时刻，但在现如今的市场经济下，从物质上来说，这样的东西可以说是很少很少了，我能想到的只有人际关系或者精神上的一些东西，比如亲密关系和内心的宁静等。一个人只要愿意花时间去追寻他想要的东西，最终一般都能得到满足或者找到替代品。唯一能够阻碍他实现自己的愿望的，只有他自己内心的恐惧。对失败的恐惧，被他人在背后指指点点的恐惧，被视为另类、奇葩的恐惧，直面真实自我的恐惧，等等。只要你能战胜内心的恐惧，并且决心无论如何都要行动起来，恐惧往往都会立马消失得无影无踪。所以，一切问题都成了：如何才能获得勇气去战胜自己的恐惧？为什么有的人可以一直有勇气面对自己的恐惧，有的人却不行？也许这才是真正的问题所在。而能否具备勇气也是一种天赋。</p><p>对我来说，我最大的恐惧是什么？没有朋友？孤独终老？都不是。我害怕自己永远都找不到自己想做的事，虚度一生。我害怕变得平庸和无趣，过上自己不喜欢却又无法选择的生活。我害怕自己没有能力照顾好自己的家人和我爱的人。我害怕死亡。我害怕 10 年、20 年之后依旧会害怕这些东西。</p><p>如何获得勇气去战胜这些恐惧？我不知道。但是我知道我可以从眼前的小事做起，比如看完这本书，然后再看下一本。每天按时起床，工作，吃饭，运动，学习，睡觉，少花时间在会让自己感到后悔的事情上，多做真正让自己感到开心和满足的事情。也许，这样坚持下去，勇气就会积攒得越来越多吧。</p><h4 id="7-月-4-日-让他人听到你的声音"><a href="#7-月-4-日-让他人听到你的声音" class="headerlink" title="7 月 4 日 - 让他人听到你的声音"></a>7 月 4 日 - 让他人听到你的声音</h4><p>我觉得自己目前最大的问题之一是，不会向他人展示自己。学会如何推销自己也是非常重要的一个技能，如果你不去主动展示自己，向外界表达你所知道的一切，没有人会知道你是个什么样的人。能够埋头做事当然很重要，尤其是在你的能力不是很强的时候，但是，学会适当地向他人展示、推销自己，往往能让你获得更多他人的注意，还有可能创造出更多和他人的连接，也能推动你不断向前，走出自己的舒适区，不断变得更好。不要害怕得不到他人的认同或者被人误解，只要你开始发出自己的声音，你就能吸引到和自己同频的人，你们可以互相借鉴、鼓励彼此，共同进步。人生太短暂了，没有必要花时间去担心那些对自己来说无关紧要的人的想法，你只需要找到认同彼此理念的人，和他们成为朋友，丰富自己的生活，然后一起探索这个多彩的世界。</p><h4 id="7-月-5-日-不要「面子」"><a href="#7-月-5-日-不要「面子」" class="headerlink" title="7 月 5 日 - 不要「面子」"></a>7 月 5 日 - 不要「面子」</h4><p>我们这代人和父母这代人相比，最大的不同之处在于，我们这代人更在意自己的感受，而不会为了所谓的「面子」去做一些自己不想做的事。但是有时候却觉得，相比父母，我的确更不在乎面子，可还是会在做一件事之前，考虑他人的想法，在意外界会如何看待自己。这其实也是『面子』的一种。真正的活出自我，不是完全不考虑他人的想法，而是始终以自己的想法作为决定性因素。他人的想法不应该成为阻碍你行动的因素。别人怎么想是他们的事。而且这不是你能控制的，你只管做自己想做的事，只要没有伤害到他人就没事。做自己，不要在乎面子。</p><h4 id="7-月-6-日-生命的美好与面对衰老和死亡"><a href="#7-月-6-日-生命的美好与面对衰老和死亡" class="headerlink" title="7 月 6 日 - 生命的美好与面对衰老和死亡"></a>7 月 6 日 - 生命的美好与面对衰老和死亡</h4><p>昨天工作间隙下楼溜达的时候，看到这样一幅画面：一个小女孩蹲在塑胶跑道边上，在出神地观察草坪上一群毛绒绒的小黄鸭，她妈妈在边上偷偷地用手机拍她；周围绿茵环绕，所有树木的每一片树叶都绿的发亮，人工湖里的天鹅引颈振翅，蜻蜓在湖边的草丛上方飞舞；不远处的天空中有大块大块的云朵，在阳光的照射下白得耀眼，看上去真的像一朵朵巨型棉花糖。这样的夏日场景太过美好，我有点后悔没带手机下来，记录下这个瞬间。所以，现在只能靠回忆用文字记录下来，希望以后看到这段文字就能想起这个场景，想起这个初夏的某个下午让我感受到的生命的美好与灿烂。</p><p>昨晚没去跑步，于是开始看《最好的告别》，意识到变老的确是件残酷的事，而且每个人都不得不去面对这件事。即使医学技术一直在进步，人的寿命也一直在增加，但是无论如何我们还是无法战胜死亡（至少现在是这样）。在生命的最后一段旅程中，很难保证自己依旧活得有尊严，更别说活得幸福快乐了。看过很多影视作品，里面把老年人的临终生活描写得过于浪漫，然而所有人都知道这离真实情况相差很远。真正的变老是身体机能上的衰退，骨密度下降和肌肉丧失造成体力下降和行动不便，听力、视力、记忆力甚至智力都会逐渐衰退，各种身体器官的功能性失调造成疾病缠身，更别提还有可怕的肿瘤和癌症。</p><p>大多数人都不愿去想甚至不愿提起「我也会变老」这件事。我们应该如何面对衰老，如何面对死亡？简单翻了下这本书，其实书中也没有给出一个明确的答案。加大对老年病医护的投入的确有帮助，但是依旧无法帮助老人们获得生命的意义感和价值感，尤其是那些失去另一半的老人。想起爱德华·特鲁多医生的墓志铭：有时是治愈，常常是帮助，总是去安慰。希望未来自己变老的时候也能常常得到陪伴和安慰，并且有足够的信念支撑自己勇敢、坚韧地生活下去，直到最终时刻的来临。</p><h4 id="7-月-7-日-人生目标以及观念第一"><a href="#7-月-7-日-人生目标以及观念第一" class="headerlink" title="7 月 7 日 - 人生目标以及观念第一"></a>7 月 7 日 - 人生目标以及观念第一</h4><p>在人生到达终点的时候，我希望看到自己达成了哪些目标或者获得哪些成就？很奇怪，我这样性格内向不喜社交的人的答案居然是：<strong>希望能影响到更多人，改变更多人的生活，让更多人生活得更积极乐观、幸福快乐。</strong>为什么会这样想？因为人是社交动物，虽然可以独自生活，但是最终还是要通过和他人的交往来获得价值感和意义感。那么，我现在为什么没有增加自己的社交生活？因为我觉得现阶段的自己，最重要的任务是先建立自己的技能集，让自己能够做更多的事，积累财富的同时也学会理财，让未来的自己可以不用担心物质条件方面的限制。我觉得我很幸运，在年轻的时候就已经明白了这些，虽然过去浪费了很多时间，但是只要观念发生改变，行动上的改变可以很迅速地发生。每天朝着自己的目标进步一点点，日积月累，其实这目标并不难实现。我们每个人的成长空间都是无限的，意识到这一点，是解放自己心灵的第一步。行动宜速，享受宜缓。</p><h4 id="7-月-8-日-个人主义和忠诚"><a href="#7-月-8-日-个人主义和忠诚" class="headerlink" title="7 月 8 日 - 个人主义和忠诚"></a>7 月 8 日 - 个人主义和忠诚</h4><p>如何平衡好个人主义和忠诚之间的关系？西方文化强调个人主义，比如更多地关注自身的利益和幸福，而东方文化则更强调和谐统一，不应该只关注个人，而应该关注整体，个人只是集体的一部分。比如，我们要服从于自己的角色，在家庭中，做好一个妻子/丈夫、子女/家长、晚辈/长辈该做的事；忠于集体主义、国家主义；强调牺牲，为了理想而奉献出自己的一生是件值得赞许的事。我的观点倾向于后者，仅有个人主义是不够的，我们还是需要忠于某种价值观或者理念才能让生命获得意义感和价值感。忠于爱情，或者事业，或者某个理想，又或者只是为了实现某个心愿，其意义对于他/她本人来说都是一样的，那就是：<strong>让他/她获得一种超越生命本身的东西，一种让生命继续存在下去的驱动力。</strong>这也是爱情和终身职业如此重要的原因，它们让我们的存在有了意义，为他人或者某种理念付出，让我们体会到了超越自身的价值感。</p><h4 id="7-月-9-日-求同存异，共同成长"><a href="#7-月-9-日-求同存异，共同成长" class="headerlink" title="7 月 9 日 - 求同存异，共同成长"></a>7 月 9 日 - 求同存异，共同成长</h4><p>如何与自己不同的人相处？由于经历、学识、所处人生阶段的不同，我们的观念很难一致，这使得我们在和对方相处时不理解对方的想法以及做法。原则上来说，我们应该尽量避免与彼此观念相差很大的人相处，因为观念决定了我们看待事物的角度和方式，决定了我们对待一切事物的态度，包括如何看待我们自身，拥有多大的责任感等等，和观念不一致的人相处是一种折磨。但是，生活总归不会是完美的，我们都会遇到与自己不同的人，并且无法避免地需要和他们相处，比如同事或合作伙伴，我觉得最佳的做法是：<strong>忽略我们身上的不同，全力做好该做的事。</strong>比如同事之间，那就不需要讨论太多工作之外的事，避开彼此身上的不同之处，找到彼此的共同点，找到彼此共同的诉求，互相帮助，共同成长。以这样的态度，你会发现大多数看上去和我们「不同」的人其实并没有那么不同。说到底，我们都只是普通人而已，都有自己的缺陷，并且需要不断弥补它们、完善自身。只不过有些时候你走在了别人的前面，而有些时候别人走在了你的前面。不要被这些不同限制了自己的视野。说到底就是八个字：<strong>求同存异，共同成长。</strong></p><h4 id="7-月-10-日-尊重和理解我们的父母"><a href="#7-月-10-日-尊重和理解我们的父母" class="headerlink" title="7 月 10 日 - 尊重和理解我们的父母"></a>7 月 10 日 - 尊重和理解我们的父母</h4><p>不要埋怨父母。我们这代人成长的环境比起父母那代人来说真的优渥太多了，这也是造成我们和父母难以沟通的原因：我们所受的教育和价值观的差距太大了。但是，我觉得我们应该认识到这一点，并且学会理解我们的父母。尽管有时候他们的沟通方式不是我们喜欢的，但是我们要意识到：他们已经尽自己最大的努力来适应我们了，他们是爱我们的。有时候总是会忘记这一点，每次相处不愉快之后，心里总是会有抱怨的声音出现。哪怕我们真的是不同类型的人也没关系，无论如何，我们都是彼此生命中最重要的人。学会感恩，学会彼此尊重。另外，他们也有自己的生活，要尊重他们的意愿，不要把自己的价值观强加到他们身上。我们每个人都应该有权利选择按照自己的想法去生活。</p><h4 id="7-月-11-日-停止自我批判，要有赞美陌生人的勇气"><a href="#7-月-11-日-停止自我批判，要有赞美陌生人的勇气" class="headerlink" title="7 月 11 日 - 停止自我批判，要有赞美陌生人的勇气"></a>7 月 11 日 - 停止自我批判，要有赞美陌生人的勇气</h4><p>晚上跑步回来的路上，经过一个路口，一个长发女孩走在了我的前面，我从背后看到她穿了一件黑色吊带，斜挎一个小包，身材挺匀称，从背影上看就让人觉得她应该挺好看的，所以我也偷偷地、更仔细地观察了一下她。我发现她走路的姿势很可爱，有时候会大幅度前后甩着手，经过路口的时候会停下来等车先过去。当我内心在纠结要不要上去搭讪的时候，发现自己已经走到小区转角的路口了，于是就这样错过了一次锻炼自己胆量的机会。其实有那么一刻，我就在她身后几步远，近到我可以闻到她身上淡淡的香水味，可惜最终还是没能鼓起勇气走上去说一句：你好，我觉得你很好看，想认识一下你。</p><p>洗澡的时候我一直在回忆那个场景，我为什么不敢上去搭讪？怕吓到对方？可能有点吧，但最主要的还是我脑海中各种自我否定的声音阻止了我走上前去。其实每个人都有足够的勇气，只不过我们选择用负面消极的想法限制了自己的行动。在这个场景下，我的心理活动是：我长得不够帅、不够富有、身高也不高，肯定配不上她，所以还是不要浪费时间了吧。现在回想起来，这种想法完全错误。首先，外在条件无法改变，比外在重要的地方多太多了，如果对方仅仅因为外在就拒绝你，要么说明你是真的丑，要么说明她不够聪明。其次，这个年纪特别富有的人不会很多，而人生是场长跑，只要你对自己的未来有所规划，相信对方一定能够发现并且察觉到。最后，我觉得我们不应该用自我批判的态度对待自己想要和他人交往的愿望，哪怕事实真的是我们彼此相差很大，作为一个懂得欣赏美的人类，你也可以礼貌地走上去，面带微笑地说上一句「你好，我觉得你很漂亮」，如果对方心情好，可能会接受你的赞美，然后回报给你一个微笑。有时候，这就够了。希望下次再遇到这种情况的时候，我能够克服自己的心理障碍。</p><h4 id="7-月-12-日-制定计划并定期回顾"><a href="#7-月-12-日-制定计划并定期回顾" class="headerlink" title="7 月 12 日 - 制定计划并定期回顾"></a>7 月 12 日 - 制定计划并定期回顾</h4><p>发现自己已经有一段时间没有做周计划或者月计划了，我觉得应该重新捡起来这个习惯。虽然现在的生活比较规律，但是没有计划的生活总让人觉得似乎不够理智。我这个礼拜最大的目标是什么？这个月最大的目标是什么？乃至今年想要完成那些目标？年初时候立下的目标和计划现在完成多少了？制定计划后如果没有定期回顾、复盘的习惯，其实意义也不大。</p><h4 id="7-月-13-日-Action-leads-mood-主动帮助他人"><a href="#7-月-13-日-Action-leads-mood-主动帮助他人" class="headerlink" title="7 月 13 日 - Action leads mood: 主动帮助他人"></a>7 月 13 日 - Action leads mood: 主动帮助他人</h4><p>如何克服心中的羞怯感，一个好的办法是<strong>主动帮助他人</strong>。因为我们往往在给予的时候会感受到更大的满足感，在帮助他人的时候，我们通常更容易暂时忘记心中的羞怯和畏惧，转而全身心投入到眼下自己能做的那件事中。这也是战胜社交恐惧的最终极的办法：投入到你所擅长的事中去。我们在与陌生人相处时为什么会感到有压力和约束感？原因之一是我们不确定对方会做出怎样的反应，我们害怕惹恼他们，或者给身边人留下不佳的印象。从几十万年前开始，智人就一直是社会性动物，如果得不到同类的支持，我们将很难获得继续生存下去所需要的一切。所以，我们会尽全力让他人喜欢自己，即使是最不合群的人也一样。主动帮助他人给我们制造出一个理由，让我们在心理上克服「我应该这样做吗」的顾虑，在你的情绪做出反应之前就开始行动，也许，在事后你才会意识到「我当时能那样做，真的太不像我自己了」，这就是 action leads mood 的又一个例子。</p><h4 id="7-月-14-日-无法「知行合一」的原因"><a href="#7-月-14-日-无法「知行合一」的原因" class="headerlink" title="7 月 14 日 - 无法「知行合一」的原因"></a>7 月 14 日 - 无法「知行合一」的原因</h4><p>我们为什么无法知行合一？首先，什么是「知行合一」？我理解的知行合一是<strong>思想和行动保持一致</strong>。如果这两者无法保持一致，其实不是你的行动力不足，更主要的原因是你并没有完全接受这一思想或者想法。我们不是「知道了却做不到」，而是并没有完全理解这件事，其背后的运行机制以及对自己的意义，也就是<strong>你觉得它不重要</strong>。举个例子，比如我们都知道养成运动的习惯很重要，但是为什么还是做不到每天锻炼半小时呢？你知道运动会给自己带来很多变化，比如会改变自己的饮食习惯，会让自己的身材变好，能帮助自己恢复精力，让情绪和身体保持最佳状态等等。但是，到了真正应该付出行动的时候，我们却总是会被各种「麻烦事」影响了计划。其实，阻碍我们行动的真正原因是，你心里并不是真的认同这一想法，或者这件事对自己来说不够重要，或者目前还有别的优先级更高的事，你没有动力完全按照计划持续地执行下去。所以，想要知行合一其实很简单：罗列出做这件事的好处；问自己这件事能够给自己带来多大的变化；为了安排时间做这件事，我需要放弃做哪些事；通过比较之后，你会发现，它的优先级提高了。当我们了解一件事的所有细节及其重要性之后，执行的时候就不会有任何纠结和摇摆的心理了，因为不做这件事才是损失。</p><h4 id="7-月-15-日-正确的行动比选择更重要"><a href="#7-月-15-日-正确的行动比选择更重要" class="headerlink" title="7 月 15 日 - 正确的行动比选择更重要"></a>7 月 15 日 - 正确的行动比选择更重要</h4><p>有选择必有遗憾，如何坦然面对选择后的结果？最重要的一点是不怕犯错。人生很长，除了少部分的决定能对我们的一生造成重大影响之外，绝大部分的选择其实都是一个试错的过程。一个选择反应了我们当下的状态，我们的认知水平、努力程度、人生态度，乃至周围环境，都会影响到我们的选择。从短期来看，是我们做出了选择，但是长期来看，是当下的状态决定了我们的选择。我们过去的行为影响到我们可以做出的选择，而每一个选择又都塑造了我们未来一段时期的生活——我们就是这样一步步走入自己为自己设计的生活的。所以，不要为一个选择是否正确而纠结或者后悔，而是要问问自己，我有在持续地做出正确的行动吗？我现在所创造出的结果会是将来的自己想要看到的吗？</p><h4 id="7-月-16-日-保持简单"><a href="#7-月-16-日-保持简单" class="headerlink" title="7 月 16 日 - 保持简单"></a>7 月 16 日 - 保持简单</h4><p>尽可能维持简单的生活方式。目前看来，自己的生活方式正在变得越来越简单，从起床开始的每一件事都是根据过去一段时间所养成的习惯来进行的：写碎碎念、腹肌撕裂者、早餐、冥想、阅读、去公司，开始一天的工作；午餐，回小区午睡，回公司开始下午的工作，中间下楼散会儿步，继续工作两小时；然后回小区，吃水果、阅读，出门跑步，洗澡，阅读或工作，最后上床睡觉。周末基本也维持着差不多的生活节奏，只不过会用更多的阅读和学习时间替代工作时间。我觉得人只有在形成了固定的生活和工作模式之后，才能将更多的精力省出来用来思考真正重要的事情。另外，越是简单的生活方式维护起来也越容易，而且也能帮助我们适应变化。有时候工作上比较忙，此时工作会占用我们更多的精力，但是由于我们的生活节奏固定可把控，所以调节起来不会太难；而有时候生活中出现一些意味，我们同样可以调整工作节奏来适应生活。实际上，我觉得不仅仅是生活方式，我们生命中的一切事物，都应该尽量保持简单：你的人际关系、你拥有的物品、你的思想、你的精神，等等。但是，简单并不意味着容易，需要你能够分辨出什么是重要的，什么是多余的，最本质的东西又是哪些。而且只有不断优化下去，才能达到至简的效果。Keep It Stupid Simple, KISS.</p><h4 id="7-月-17-日-关注收获而非损失，理解他人"><a href="#7-月-17-日-关注收获而非损失，理解他人" class="headerlink" title="7 月 17 日 - 关注收获而非损失，理解他人"></a>7 月 17 日 - 关注收获而非损失，理解他人</h4><p>只要你还在某个公司或机构工作，无论你的角色或者职级是什么，一定都会有觉得自己无法完全掌控自己时间的时候。我们要做的不是去否认或者抵抗，而是去尝试改变自己的态度。问问自己，「我能从这件事中收获什么？」，而不是「我失去了什么？」。当你尝试去理解这件事对自己和他人的意义的时候，尤其是对发起这件事的人而言具有什么样的意义，你会发现，站在他的角度看待这件事，它可能并非像你想象得那么简单。每当我们尝试去理解和同情他人的时候，其实也是在告诉自己：我们都不完美，但是都在竭尽全力做到最好。</p><h4 id="7-月-18-日-默认合作关系，而不是竞争关系"><a href="#7-月-18-日-默认合作关系，而不是竞争关系" class="headerlink" title="7 月 18 日 - 默认合作关系，而不是竞争关系"></a>7 月 18 日 - 默认合作关系，而不是竞争关系</h4><p>生活在这个时代，最重要的技能是什么？我觉得是与人合作的能力。必须承认，自己这方面的能力的确非常欠缺，而且我总是会用一种相互竞争的视角来看待自己和他人的关系。我觉得自己需要转变这种态度，从默认竞争的态度转变到默认合作的态度。要相信他人的意图总是好的。这样，你才能更容易看到他人身上的优点，然后，才会发现彼此合作的可能性，才能认识到这会给我们带来多少好处。即便后来发现对方并不是一开始你想象的那样，此时再去改变自己的合作方式也还来得及，并不会损失太多——有时候通过吃一点亏认清一个人的真实面貌也是一件好事，可以避免以后吃更大的亏。另外，相互合作意味着你要让对方看到与你合作有价值，否则就变成了单方面的讨好。所以，这又要求我们让自己成为一个更值得交往的人。不断提升自我价值，不断与人合作，不断变得更好，与更多优秀的人合作。一旦进入这样的正向循环，你的人生就充满了无限可能。</p><h4 id="7-月-19-日-诚实面对自己的欲望"><a href="#7-月-19-日-诚实面对自己的欲望" class="headerlink" title="7 月 19 日 - 诚实面对自己的欲望"></a>7 月 19 日 - 诚实面对自己的欲望</h4><p>很多时候我们感到痛苦是因为我们无法诚实面对自己的欲望——内心想要的和我们告诉自己的不一致，所以造成了自我的矛盾。那么，如何才能更加诚实地面对自己的欲望？首先，不要打压自己的欲望。时刻注意自己的想法，当某个想法出现的时候，告诉自己「我注意到它了」，仅此而已。然后再考虑是否应该付诸行动，标准是做了之后我是否会感到后悔，或者是如果现在不做我以后是否会后悔。比如走在大街上的时候，如果我看到某个很漂亮的女生，我想要认识她。我应该做的是，注意到自己的想法——我想要认识那个漂亮的女生。然后问自己，如果我现在什么都不做的话事后回想起来是否会感到后悔？答案是会的。那么，我现在就应该立即采取行动，走上去告诉她「你好，虽然我不认识你，但是我觉得你长的很漂亮」，然后根据对方的反应聊上几句，哪怕对方不理你或者不想认识你，至少你诚实地表达了自己的愿望，所以不会因为错过了机会而自责。当我们对自己越是诚实，我们就越是感到轻松，因为我们想说的、想做的与自己的实际行动始终保持一致，所以不会有任何心灵上的不和谐。长此以往，我们会越来越容易感到幸福和快乐，也越来越自由。</p><h4 id="7-月-20-日-少即是多"><a href="#7-月-20-日-少即是多" class="headerlink" title="7 月 20 日 - 少即是多"></a>7 月 20 日 - 少即是多</h4><p>当我们想要完成一个越大的项目，开始时候的阻力往往越大。因为要考虑的东西很多，有各种细节，还有可能会遇到的困难等等。这也是为什么大多数项目都会无疾而终。相反，那些看似简单的项目，随着快速启动，以后反而有可能会越做越大，越做越复杂。这种现象其实无处不在。如果你能把每一件小事都做好，那么在做一件复杂的事的时候，你也能做好。因为你知道如何拆分和分解，如何处理优先级，每次完成一小部分，哪怕最终结果和自己预想的不一样也没关系，因为至少看到成果了。这也是敏捷开发受到如此广泛应用的原因：只有把大目标拆分成可完成的小目标，我们才更有动力去完成它。完成一小部分比力求完美却没有任何产出好的多。很多时候，一个不完美的产品或功能都是通过不断地打磨才最终得以呈现出比较完美的状态的。我们自己也是一样，在给自己立目标的时候，不用想着非常远大或者「雄心壮志」的目标，制定小一点的目标，然后一个个去完成就够了。慢慢地，随着时间的推移，你会惊叹于自己最终取得的成果。</p><h4 id="7-月-21-日-卓越三要素"><a href="#7-月-21-日-卓越三要素" class="headerlink" title="7 月 21 日 - 卓越三要素"></a>7 月 21 日 - 卓越三要素</h4><p>追求卓越应该是每个人的目标，但是，很少有人能够达到卓越，我们应该问问自己：是什么阻止了自己成为一个卓越的人？对我来说，懒惰是我的第一大敌人。原本可以用来学习提高自己的时间，我却都用来娱乐放松了；原本可以选择做难一点的事，我却选择了走一条看似简单的路，结果发现其实并不简单，而且使我更容易分心，消耗更多的精力在不重要的事情上。追求卓越意味着<strong>要和勤奋为伍，永远选择做难一点的事。</strong>其次，容易感到满足也是阻碍我变得更好的原因。明明有还有非常大的提升空间，但是我却告诉自己「现在可以休息一下了」，结果就这样沉浸在自己为自己创造的舒适圈里，不再想着去突破自己，直到受到现实的打击之后才发现「原来我已经落后那么多了」。追求卓越意味着你<strong>不能止步不前</strong>，只有不断探索更多的可能性，你才能拓展自己能力的边界。最后，不够专注也是我的最明显的缺点。如果你不能坚持在一个领域花足够长的时间，你是很难达到专家的水平的。只有保持专注，你才能达成自己的目标。虽然一万小时理论不一定适合所有领域，但是绝大多时候，随着观察、学习、实践、思考，不断重复的次数越来越多，你会构建出足够的心理表征，你对这一领域会越来越熟悉。当你精通一门技能的之后，你学习这门技能所获得的经验仍然有用，可以迁移应用到其它领域。追求卓越意味着<strong>保持专注和不断重复</strong>，直到它们变成你身体的一部分。</p><h4 id="7-月-22-日-全情投入地去做一件事"><a href="#7-月-22-日-全情投入地去做一件事" class="headerlink" title="7 月 22 日 - 全情投入地去做一件事"></a>7 月 22 日 - 全情投入地去做一件事</h4><p>好的人生体验（自己过的爽）和给世界留下点有用的东西，这两者之间是彼此矛盾的吗？我觉得不是，最关键的是要让自己能够<strong>全情投入地去做一件事</strong>。无论这件事是做出伟大的发明，创造一家伟大的公司，又或者是让自己觉得有价值的工作。只要你能想办法让自己能够完全沉浸其中，相信其价值和意义，那么你就能既享受过程，又能做出一些让自己感到骄傲的东西。从古至今，所有那些我们听说过的了不起的人物都是这样做的，他们把自己做的事当成一种信仰，即使在开始的时候只有少数人才能理解其价值和意义，即使需要投入巨大的努力和克服各种各样的困难，即使他们自己也不知道最终结果会如何，他们依旧选择投入自己全部的时间和精力去达成自己的目标和理想。他们享受自己的人生，同时也享受创造的乐趣，最终也给世界留下了宝贵的遗产。我们要做的，是向他们学习。也许不一定能够做出伟大的成就——历史上也有很多销声匿迹的、并没有留下名字的人——但是，他们至少度过了让自己满意的人生。即使只能完成一半，也已经非常了不起了。</p><h4 id="7-月-23-日-贝索斯和蓝色起源"><a href="#7-月-23-日-贝索斯和蓝色起源" class="headerlink" title="7 月 23 日 - 贝索斯和蓝色起源"></a>7 月 23 日 - 贝索斯和蓝色起源</h4><p>昨晚看了贝索斯乘坐蓝色起源去到近地轨道并且安全返回地球后的采访视频，不得不感叹：生活在这个时代真的是非常幸运的一件事。贝索斯作为世界上最富有的人之一，在为世界创造了巨大的价值之后，依旧在为下一代人思考，在为地球的未来思考。当说起这次太空之行的感受的时候，他说他有种三十年前刚创立亚马逊时的相同感受。我们此时正站在一个新时代的开端，而蓝色起源以及所有这一领域中的其它企业都在做一件相同的事，搭建一个新时代所需要的基础建设。未来我们以及我们的后代也许可以像乘坐飞机一样乘坐可重复使用的火箭往返地球和太空之间，每次想到这一点就觉得兴奋。虽然自己不一定能活到那一天，但是至少在我生活的时代中，能够见证这一切是如何开始的，并且在可预见的未来里还会持续地、快速地发展下去。这也提醒了自己，要多思考自己能做什么，去为这个世界做出贡献。即使微不足道，也是有意义的。另外，这个世界有太多美好的事物，太多值得你花费时间和精力去研究的东西，没必要为了那些琐碎的、无关紧要的东西浪费时间。</p><h4 id="7-月-24-日-不够宽容及如何应对"><a href="#7-月-24-日-不够宽容及如何应对" class="headerlink" title="7 月 24 日 - 不够宽容及如何应对"></a>7 月 24 日 - 不够宽容及如何应对</h4><p>我觉得我喜欢独处以及身边朋友很少的一个重要的原因是<strong>我不够宽容</strong>。我常常很快就能发现一个人身上的缺点，有些其实也算不上是缺点，只能算是个人的小特质。很多人身上都有一些伴随成长过程中养成的小习惯或者小特质，但是，如果我觉得自己无法忍受这样的习惯或者特质，我会选择尽可能远离这个人。为什么要让自己忍受不喜欢的东西？不够宽容的另一个方面是，一旦我觉得自己被他人「不公正」对待或者「不被尊重」，我也会选择不再主动和这个人进行更多有意义的交流，哪怕这种不公正或者不被尊重只是我个人的感受而并非事实。不够宽容第三个方面是我无法忍受不够聪明或者懒惰的人，我觉得他们在浪费自己和他人的时间。而且和他们交流太累了，也得不到有意义的结果。最后一点是，当我发现彼此的观念不同时，我也会失去继续交流的欲望。</p><p>我需要改变自己吗？首先，我觉得第一点没有必要去改变，我们无法假装喜欢自己不喜欢的东西。但是至少应该对他人保持尊重，尊重彼此的不同。既然相遇在一起，那就是缘分，没必要为了那一点点分歧而搞得不愉快甚至仇视彼此。至于第二点，我觉得我应该尽可能地改变自己。我需要学会多从他人的角度看待问题，而不是将太多的注意力放在自己身上。<strong>自尊心意味着知道自己的价值、自我接纳和爱自己。</strong>太容易受伤的人往往意味着自尊心不足。你无法控制他人如何对待自己，但是你可以控制自己如何感受。第三点，其实自己也算不上非常聪明或者勤奋，聪明和勤奋同样可以算是一种个人特质吧，只不过每个人的程度不同。当遇到不如自己聪明或者不够努力的人，不用觉得讨厌，因为换位思考，你也会遇到比自己更聪明和努力的人。聪明与否无法改变，是否勤奋也不能立马就能判断出来——也许别人在你看不到的背后付出了很多时间努力。即使对方真的既不聪明又不努力，那你首先要反省自己，其次再思考如何帮助他改变。最后一点，观念不同还有必要继续交流吗？如果是陌生人，当然没必要，但如果这个人是你的家人、同事或同学呢？我觉得最重要的一点是，要互相理解和彼此克制地影响对方。如果观念差异大到不可调和，那就应该避免谈论会造成分歧的话题。虽然有点消极，但好在我们还可以选择自己的朋友。观念一致的好友才是我们的最终归宿。</p><h4 id="7-月-25-日-分享你所知道的一切"><a href="#7-月-25-日-分享你所知道的一切" class="headerlink" title="7 月 25 日 - 分享你所知道的一切"></a>7 月 25 日 - 分享你所知道的一切</h4><p>我有什么可以分享给这个世界的？每当感到迷茫的时候都可以问问自己这个问题。你可以不知道自己想要什么，不知道自己的使命是什么，即使如此，你也一定有东西可以分享给这个世界，无论这东西是你个人身上的某种特质，又或者是通过自己的行动创造出的一些有价值的物品或者是某种娱乐效果，又或者仅仅是因为你的存在就能够对他人造成影响，比如让他人获得某种情感上的慰藉。当你能找到越来越多自己可以分享给这个世界的东西，你的人生就能收获越来越多的价值和意义。但是，这种能力也是需要慢慢培养起来的。也许一开始，你会觉得自己没有什么可以分享的，但其实只要你还生活在这个星球上，你的生活经验、所思所想、所学所用，就一定会对一小部分人有启发，或者对和你有着相似经历的某个人有用。从小到大，从窄到广；分享越多，收获越大。努力去分享你所知道的一切吧。</p><h4 id="7-月-26-日-Libertarianism-amp-Education"><a href="#7-月-26-日-Libertarianism-amp-Education" class="headerlink" title="7 月 26 日 - Libertarianism &amp; Education"></a>7 月 26 日 - Libertarianism &amp; Education</h4><p>昨天一天没出门，在家看书+发呆。看完罗斯巴德的《自由的伦理》，联想到现状，不失落是不可能的。作为一个普通的个体，似乎没有任何办法去改变现状，能做的也只有尽量传播自由主义的思想和价值观。但是，我觉得能够接受的人一定是自愿去了解并接受的，根本不需要别人来传授。也许是自己太消极了吧。即使无法让他们去接受它，至少可以影响其中的一小部分人发生兴趣，去了解自由主义是什么，以及其政治哲学的合理性。一切本该如此，只不过我们习惯了它的强制，被它的宣传蒙蔽了思想。</p><p>除此之外，还思考了关于如何改变自己的现状，以及「我到底应该追求什么」的问题。又陷入了两种矛盾的立场当中：一方面，不断追问自己『我喜欢什么』；另一方面，又告诉自己要追求『建立稀缺又有价值的技能』。前者指引我去寻找能立马获得成就感、愉悦感但是不一定能获得足够回报的事情；后者让我去思考自己职业的未来以及发展方向。我觉得为了解除这种矛盾，我需要问问自己『什么才是真正重要的东西？』，这个问题的答案比自己是否喜欢以及能否得到市场的奖励更重要。目前能想到的答案只有<strong>教育</strong>。对一个人来说，没有什么能比好的教育对他/她的一生造成的影响更大的了。而且这里的『<strong>好</strong>』才是最重要的，和一个人的教育阶段无关。无论是幼儿、青少年又或者是成年之后，<strong>好</strong>的教育会伴随人的一生。而且我也相信，人始终是可以被教育改变的，因为我自己就是一个例子。那么，如何才能让参与其中呢？从目前大环境来看，限制越来越多，自由市场被政府不断打压。如何才能找到一个好的切入口呢？</p><h4 id="7-月-27-日-面对衰老和死亡"><a href="#7-月-27-日-面对衰老和死亡" class="headerlink" title="7 月 27 日 - 面对衰老和死亡"></a>7 月 27 日 - 面对衰老和死亡</h4><p>当生命走向终点的时候，最重要的是什么？绝大多数人都以为自己可以在安详中离开这个世界，但那只是人群中的少数幸运儿，现代医学消灭了大多数难以医治的疾病，但是我们依旧会被各种各样的长期疾病带来的痛苦所折磨。所以，很多人的临终愿望变成了希望能够减少痛苦，能够和家人朋友一起度过一段有质量的生活，直到最后一刻的到来。我对自己的临终生活同样没有太多期待：尽可能少的痛苦，尽可能保持尊严（虽然不太可能），能够按自己的想法去生活，就够了。除此之外，我觉得真正重要的事是，在自己还能够思考以及创造价值的时候，尽可能多地去做自己想做的事，体验这个世界的丰富多彩之处。只有这样，当面临行动力丧失和无法独立生活的现实之后，我们依旧能够靠回忆和讲述自己的故事，来丰富自己和他人的生活。也许那时候记忆力和体力都不足以支撑自己进行一些复杂的智力活动，但是只要还能保持住心智，至少还可以丰富自己的内心世界，而不会感到过于孤独与无助。另外，我自己本身就是一个独处惯了的人，我觉得自己到时候应该也能够适应这样的生活。</p><h4 id="7-月-28-日-活到下个世纪"><a href="#7-月-28-日-活到下个世纪" class="headerlink" title="7 月 28 日 - 活到下个世纪"></a>7 月 28 日 - 活到下个世纪</h4><p>每当心中有无法解答的疑惑，或者是难以面对的困难的时候，我就会问自己，10 年后这个问题还会像现在这样困扰我吗？通常站在 10 年后的角度来看，眼前的问题都不算是难以解决的问题了。就像 10 年前，当我还是一名高中生的时候，那个时候的很多困难对现在的我来说，其实已经是一种无法企及的幸福了。那么，有什么理由不用更乐观的态度去面对眼下的一切呢？环境一直在变，人的能力也在不断提高，没必要对未来感到恐惧或者迷茫。你的境遇一方面取决于运气，另一方面取决于过去的表现，而这两者都是自己无法控制的。所以，无论在你身上发生了什么，除了坦然接受，没有别的办法。始终要相信眼下的困难迟早都是会被克服的，你的疑惑也会得到解答。即使没有得到解答，随着时间的沉淀，至少也能收获更多看待问题的视角。人的智慧是随着年龄的增加而增加的，当你活到 90 岁的时候，对人生有更多的认识，对自己和世界的关系看得更加清晰，对生死、人生意义等终极问题也能有不一样的答案吧。突然想到了一个新的人生目标，那就是：活到下个世纪。</p><h4 id="7-月-29-日-找到你的位置"><a href="#7-月-29-日-找到你的位置" class="headerlink" title="7 月 29 日 - 找到你的位置"></a>7 月 29 日 - 找到你的位置</h4><p>对大多数人来说，工作占据了我们生活的很大一部分——对有的人来说，工作可能就是他的全部生活。然而，我们有认真花时间思考自己和工作的关系吗？除了获得报酬、价值感、成就感，提升个人能力以适应生活的复杂性之外，工作对我们来说还有其它的意义吗？我觉得工作对大多数人来说，最重要的意义就是：让我们<strong>在这个世界上拥有了自己的一个位置</strong>。看看大多数人的自我介绍就知道了，大部分人都会用自己的职业来介绍自己。通过告诉别人「我是干什么的」来让他人了解我们，而我们对他人的价值也大多来自于此。那么，你有问过自己，这个位置是你真正想要的吗？你希望能有一个别的方式来定位自己吗？此心安处是吾乡，真正让你感到心安的事是什么？如果给你一个重新选择的机会，你会选择从事什么样的工作？</p><h4 id="7-月-30-日-做事的心态"><a href="#7-月-30-日-做事的心态" class="headerlink" title="7 月 30 日 - 做事的心态"></a>7 月 30 日 - 做事的心态</h4><p>这个世界上真正稀缺的东西只有时间，无论贫富，每个人每天拥有的时间都是一样的，你选择如何度过今天以及以后的每一天决定了生命对你的意义。如果我们每天不是在做自己最想要做的事，那就是在浪费时间和生命。所以我们要经常问问自己：我为什么要做这件事，这件事对我来说有什么意义？有哪些人因为这件事受益？我必须要做这件事吗？是否有其他人比我做得更好？我是为了完成别人交给我的任务吗？如果是，怎样把它变成我自己的事，让自己也成为其中的受益者？当我们不得不去做自己不喜欢的事的时候，也要问问自己：我是真的不喜欢这件事还是只是讨厌在别人的要求下去做这件事？如果是后者，那么大可不必这么想，因为只要这件事不妨碍你做自己喜欢的事就没关系。你需要不断调节自己的心态才能一直保持做到最好。另外，人生总归是有很多需要妥协的时刻，如果你不得不为了生存而去做自己不喜欢的事，只要这件事不触碰法律和道德的底线，就没什么大不了的。靠自己的劳动获得报酬，是一件光荣的事，没什么好感到羞愧的。不要管别人怎么想，你怎么想最重要。</p><h4 id="7-月-31-日-保持诚实"><a href="#7-月-31-日-保持诚实" class="headerlink" title="7 月 31 日 - 保持诚实"></a>7 月 31 日 - 保持诚实</h4><p>我们为什么会撒谎？通常是为了掩盖某些我们不想让他人知道的事实。为什么不想让其他人知道？因为我们害怕他们知道真相后会对我们产生负面的看法。然而我们没有意识到的是，每次撒谎，我们看似掩盖了一些事实并且避免了对自己不利的结果，但无论怎样，谎言还是会在我们内心造成不协调——我们知道自己撒谎了，并且需要一个理由告诉自己这是合理的。久而久之，我们会不断寻找一些虚假的理由说服自己去做违反自己本意的事。一个谎言需要用另一个谎言去填补，很多时候的确如此。阻止自己撒谎的最好的办法是：一开始就说出事实。有时候（尤其是当我们犯了错的时候），只说出部分事实通常是个「减轻」自己错误的好办法。但是这么做弊大于利，因为当别人追究起来的时候，你迟早还是得说出真相，此时你只会给他人造成更加不好的印象。所以，最好的做法是一开始就说出真相，也许会造成一些负面评价，承担比较大的压力，甚至遭受惩罚，但是，相比撒谎带来的后果，这些只是一时的。<strong>真正重要的，是你的信誉。</strong>损害个人信誉是撒谎所需要付出的最大的代价。而恢复受损的信誉，难度相当大。所以，无论如何，请保持诚实。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不停地浇灌下去吧</title>
      <link href="/2021-6/"/>
      <url>/2021-6/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/Cw4IM3PEuJQ" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>六月，日子过得非常平淡，平淡到去翻时间日志的时候才发现，好像每天做的事都差不太多。唯一的变化是，从月中开始，重新捡起了阅读的习惯。花更多的空闲时间看书，感觉生活充实了不少，两个多礼拜里看完了《了不起的盖茨比》、Naval 宝典、Rework 和《窗边的小豆豆》，基本都是随意从书架上挑的书，还有的是无意间在书签里发现的，所以类型完全不同。不过，我却觉得这样没有目的的阅读反而更加让人觉得充实，因为没有目的，不为解决任何问题，只是为了享受阅读的乐趣。有时候觉得，阅读其实也是逃离现实的一种方式，尤其是阅读小说的时候，跟着主人公去体验他们的生活，感受他们的喜怒哀乐，然后从中汲取精神力量去面对我们的现实生活。勇气、爱、秩序、力量、善良，这些都是阅读能提供给我的养料，而梦想就是心中那颗需要培养的种子，想要让它最终生根发芽，需要有足够的耐心。不停地浇灌下去吧。</p></blockquote><span id="more"></span><h4 id="6-月-1-日-利用好你的大脑：构建心灵栖息之地"><a href="#6-月-1-日-利用好你的大脑：构建心灵栖息之地" class="headerlink" title="6 月 1 日 - 利用好你的大脑：构建心灵栖息之地"></a>6 月 1 日 - 利用好你的大脑：构建心灵栖息之地</h4><p>如何快速让自己平静下来？冥想是一个好办法。我觉得每个人都需要在大脑中构建一个心灵栖息之地，这样，当我们冥想的时候，只要想象自己进入那个地方，马上就能感受到平静和幸福。对我来说，我的心灵栖息之地是一座麦田上的木桥：一望无际的麦田，风吹麦浪滚动，而我就坐在木桥上一条长凳上，感受风吹拂过我的脸颊。每当我进入这个世界之中，我的心立马就能安静下来，从身体到心灵都完全放松，进入冥想状态，我会开始感受自己每一次的呼吸以及每一个身体器官的感觉。想起了黑客帝国，其实我们每个人都具有科幻片里的超能力，只不过不知道如何去使用它们。人的想象力是无穷的，一旦你开始向内探索，你就可以利用自己不受限的想象力为自己构造出另外一个世界，这个世界完全是由你自己控制的，就像黑客帝国里的练习程序或者盗梦空间里的筑梦者。我们的大脑是世界上现存的最先进的计算机，我们可以用它创造出任何我们想要创造的东西。</p><h4 id="6-月-2-日-自我优化的游戏"><a href="#6-月-2-日-自我优化的游戏" class="headerlink" title="6 月 2 日 - 自我优化的游戏"></a>6 月 2 日 - 自我优化的游戏</h4><p>如何改掉坏习惯？当我们意识到自己有一个坏习惯需要改变时，第一步是问自己：这个习惯给自己造成了哪些损失？主要是时间、精力、财务三个维度上造成的损失。然后再问问自己：如果要改掉这个习惯，我可以用省下的精力和金钱去做哪些我喜欢且想做的事？当思考完这两个问题之后，改掉坏习惯的动力一般就变得非常充足了，这样我们就可以省下不必要的心理斗争在自我消耗上。</p><p>第二步是制订计划，计划在某一时间某一地点下，把原本会用来做坏习惯的事用做自己想做的事代替。比如，下班回到房间后第一件事是换上运动服出门跑步，如果下雨天没法出门跑步，那就去小区附近散步；而不是像过去那样，吃点东西然后躺在椅子里刷手机刷到忘记时间。洗完澡之后第一件事是打开想看的书看几页，而不是拿起手机。休息的时候不要拿起手机，而是站起来在房间里活动一下或者做几组拉伸。</p><p>我觉得我们可以把那些需要优化的习惯当作是游戏来看待，我们自己既是游戏的玩家，同时又是游戏的主体，目标是不断养成更多好习惯，生活得更加健康、产出更加高效。这种不断自我优化的游戏可以一直玩下去玩到老，想想也挺有趣的。</p><h4 id="6-月-3-日-多多探索"><a href="#6-月-3-日-多多探索" class="headerlink" title="6 月 3 日 - 多多探索"></a>6 月 3 日 - 多多探索</h4><p>我们生活得是否精彩取决于我们对待生活的态度。有时候我们觉得自己的生活有些无趣，其实不是因为我们没有足够的时间或者金钱去追求乐趣，而是缺乏乐观的心态以及寻找乐趣的动力。有的人比较善于发现寻常生活中那些好玩的东西，而有的人习惯过着每天重复单调的生活。比如有人会在下班后，买点面包去喂园区湖里的鱼，这样就能看到平时看不到的鱼群了，像我这样的人可能只有在旅游的时候才会想到去做这样的事吧。但是，如果你把自己平常的生活也看作是旅行，那么其实每天都有很多新鲜有趣的事值得一试。附近那条平时很少去走的街，某家没吃过的小吃店，某个小广场的夜景，哪怕只是路边小贩的水果摊你也可以去尝试一下。一个人可以做的事情太多了，你缺的只是一颗爱探索的心。</p><h4 id="6-月-4-日-不断改变、超越自己"><a href="#6-月-4-日-不断改变、超越自己" class="headerlink" title="6 月 4 日 - 不断改变、超越自己"></a>6 月 4 日 - 不断改变、超越自己</h4><p>当我们放纵自己的时候，我们在想什么？其实我们知道放纵的后果，但还是会选择继续这么做，我觉得最主要的原因是我们积累了太多的压力。所以，除了保持日常的生活习惯，有时候也要学会使用一些犒劳自己的手段来释放掉压力。偶尔的放纵是可以接受的，只要它能帮助我们养成更多好习惯以及提高我们未来的工作和学习效率。但是，切忌因为一两次的放纵就觉得自己不行，放弃过去好不容易养成的好习惯，开始彻底放飞自我。大多数时候，我们去做一些本不该做的事，其实也是过去养成的习惯导致的。我们想要回到自己熟悉的模式，但是体验之后又会觉得没什么意义，因为现在的习惯的确能让我们生活得更加健康、更有意义。所以，也不用怕自己会回到过去的模式，因为人只要体验过更好，就不会再去选择普通甚至更差的模式。这点要感谢选择不断改变、不断进步的自己，如果没有一开始起的头，你可能不会成为今天的自己。人一旦走上了不断自我进化的道路，想要停下来是很难的。</p><h4 id="6-月-5-日-Zettelkasten"><a href="#6-月-5-日-Zettelkasten" class="headerlink" title="6 月 5 日 - Zettelkasten"></a>6 月 5 日 - Zettelkasten</h4><p>最近接触到一个新概念：Zettelkasten。这个单词来自于一位高产的德国社会学家 Niklas Luhmann，他一生出版了超过 50 本书，发表了 600 多篇文章，他把自己的所有成果归功于他自创的被称为 <em>Zettelkasten</em> 的知识管理系统。Zettel 是德语中笔记的意思，kasten 是盒子，合起来就是笔记盒子。Luhmann 的笔记系统说起来也很简单，就是把他所有的想法和阅读过的资料按照相关性分门别类进行保存，并且设定一种检索规则，等到需要使用的时候就可以快速寻找到他想要的资料，也可以方便地对某一类别下的资料进行修改或者扩充。其实有点像是个人的 Wikipedia。它和我之前关注到的 digital garden 的概念很相似，都是对个人知识的管理，但是 Zettlekasten 更具体，只针对「如何管理笔记」这个问题，而 digital garden 的概念更加广泛一些，可以用于记录自己的一切。不过，无论是 digital garden 还是 zettelkasten，它们最大的目的是管理自己的知识，提高产出。作为知识工作者，我们每天的工作内容无非就是利用已有的知识和技能去解决一些问题，这就需要我们对自己的知识网络形成一个清晰的脉络，以便在需要使用的时候可以快速寻找到。而且我们每天都会消费大量的文字、图片和视频，如果没有把它们纳入自己的知识管理系统，那么这其中大部分的内容其实都不会产生任何价值。记笔记可以让我们的知识网络变得更加丰富，并且反过来也会促使我们有意识地对自己的信息源进行筛选。记笔记是第一步，用于形成自己的知识网络，帮助我们解决问题；第二步是利用已有的知识创造出新的知识，产生更大的价值。</p><h4 id="6-月-6-日-保持平常心"><a href="#6-月-6-日-保持平常心" class="headerlink" title="6 月 6 日 - 保持平常心"></a>6 月 6 日 - 保持平常心</h4><p>在家就忍不住复盘下自己最近的状态。入职新公司快两个月了，但是似乎都没有做什么事，只是偶尔改一点小 bug，添加了个把小功能，大部分时间都是在看文档，学 flutter，学 kotlin，学 coroutine 等等。利用工作时间学习，本来是一件挺幸福的事情，但是长时间只是学习没有产出，难免会觉得有点心虚。不过，下周开始可能就有新项目要 kick-off 了，应该会变得忙起来。除此之外，这几周的状态真的说不上太好，下了班如果不出门跑步的话，常常不知道自己应该干嘛，于是常常把时间挥霍在漫无目的地刷手机上，甚至连好好吃饭、好好睡觉也做不到。</p><p>我觉得造成这些问题的最大的原因是最近没有花时间阅读了，接下来要重新开始养成看书的习惯，什么书都可以，书架上还有好多书等着我拆封。另外，还是要慢慢习惯一个人的生活，学会享受独处，保持平常心，同时学会给生活制造一些乐趣，无论是通过新的兴趣爱好还是认识新朋友。后者可能对现在的我来说更加紧迫一些，但是交朋友这种事还是随缘比较好吧，最关键的还是要做好自己该做的事。好好工作，好好生活，先学会独处和爱自己，然后再去和其他人分享自己的生活以及学会如何去爱。幸福生活的秘诀其实非常简单，说到底就是「平常心」三个字。降低期望，保持随和的心态，保持愉悦，时常感恩，做个容易感到快乐的人，要意识到平平淡淡才是生活的本来面貌。</p><h4 id="6-月-7-日-期望管理"><a href="#6-月-7-日-期望管理" class="headerlink" title="6 月 7 日 - 期望管理"></a>6 月 7 日 - 期望管理</h4><p>阻碍我们感到幸福快乐的最主要原因是我们<strong>不切实际的期望</strong>，所以期望管理就成了一件特别重要的事了。首先分析自己目前的现状，然后再对事情最终可能产生的结果做出预判。必须抱着客观、实事求是的态度，最好是在自己心情平静的情况下，才对事情做出最终的判断，避免因为情绪高涨对结果做出过高的期望，或者情绪低落视角更为悲观带来的负面影响。期望管理其实不仅仅是降低期望这么简单，背后更本质的要求是我们要保持绝对清醒的头脑，更客观公正地看待自己和他人，不自我麻痹，也不被他人的观点影响，避免自我服务的倾向，以及迅速接受现实并进行调整的能力。</p><h4 id="6-月-8-日-正确的观念"><a href="#6-月-8-日-正确的观念" class="headerlink" title="6 月 8 日 - 正确的观念"></a>6 月 8 日 - 正确的观念</h4><p>人是观念的产物。观念指导行动，我们选择什么样的生活方式，每天的日常生活习惯，如何工作等等，都是由我们的观念决定的。换句话说，我们是被自身观念塑造出来的产物。所以，我们必须学会筛选自己每天接触到的信息源，确保它们是有利于我们形成正确的观念的。如何判断观念是否「正确」，什么是「正确」？我觉得能够促使人更积极地面对生活、为自己和他人创造价值、传播良善、追求美好的品德的，就是正确的观念。</p><h4 id="6-月-9-日-每天进步一点点"><a href="#6-月-9-日-每天进步一点点" class="headerlink" title="6 月 9 日 - 每天进步一点点"></a>6 月 9 日 - 每天进步一点点</h4><p>最近在搭一个基础架构项目，尝试封装一些通用的功能，但是，对比了别人写的代码和我的代码之后，突然有种自己不会写代码的感觉，尤其是看到别人用了一些自己平时不会使用的设计模式、没见过的系统或第三方类库等，就会觉得自己真的好菜。不过，焦虑也没用，只能一点点学习进步。先从模仿开始，学习如何写出类似的代码，等熟练之后自然就能理解背后的原理了。编程这东西主要还是靠实践，很多东西看着感觉自己会了，但是等实际上手的时候才发现并不是那么一回事儿。加油吧，每天进步一点点。</p><h4 id="6-月-10-日-学会记录以及减少无效的信息摄入"><a href="#6-月-10-日-学会记录以及减少无效的信息摄入" class="headerlink" title="6 月 10 日 - 学会记录以及减少无效的信息摄入"></a>6 月 10 日 - 学会记录以及减少无效的信息摄入</h4><p>我发现自己每天都会阅读大量的信息，公众号文章、社交网站、邮件列表、新闻，还有文档、博客、搜索引擎结果等等，其中很多信息基本都是看过之后就忘了，并没有在自己的脑海中留下什么有价值的信息。所以，越发觉得应该养成记笔记的习惯，把自己看过文章之后产生的想法记录下来，或者干脆就不去看，这样就可以节约时间做真正重要的事，或者用于思考最关键的问题。</p><h4 id="6-月-11-日-保持住童心"><a href="#6-月-11-日-保持住童心" class="headerlink" title="6 月 11 日 - 保持住童心"></a>6 月 11 日 - 保持住童心</h4><p>和很多成年人比起来，小孩子的优势是既能大声说出自己的愿望也能直接了当地说不。成年人总是会瞻前顾后，会被低自尊和毫无意义的面子拖累，也会为了维护人际关系和个人利益而言不由衷。小孩子也有各种各样的局限性，但是他们乐于承认自己的局限性，而成年人往往做不到这一点。所以，能够保持住童心以及拥有孩子般自由率真性格的人非常难得，可能只有对自己足够自信（精神上和物质上）的人才能做到吧。</p><h4 id="6-月-12-日-提高能力最重要，多花时间学习"><a href="#6-月-12-日-提高能力最重要，多花时间学习" class="headerlink" title="6 月 12 日 - 提高能力最重要，多花时间学习"></a>6 月 12 日 - 提高能力最重要，多花时间学习</h4><p>对现在的我来说，最重要的事情是<strong>提高自己的能力</strong>，其他一切都应该以此为核心。无论是交友还是工作，一个人的能力始终是第一位的，只有能力强了才能让自己成为一个值得交往的人，才能帮助到更多的人，同时也能解决更多的问题。工作也一样，能力强的人才有资格去选择做自己喜欢做的事，才能获得更好的机会和待遇。以自己目前的状况来看，的确应该更加努力一点，这样才有选择权，好好提高技术才能进入想去的公司。目前运动的习惯有了，最需要养成的是学习的习惯。每天下班后，少看手机和视频，少花时间在娱乐上，挤出时间学习。真正坚持一段时间之后，一定会有效果的。觉得无法坚持的时候，想想那些条件不如自己但是现在却做得比你好的人。既然他们可以，你也一定可以。加油。</p><h4 id="6-月-13-日-学会享受当下的生活，面对困难以及解决问题时的心态"><a href="#6-月-13-日-学会享受当下的生活，面对困难以及解决问题时的心态" class="headerlink" title="6 月 13 日 - 学会享受当下的生活，面对困难以及解决问题时的心态"></a>6 月 13 日 - 学会享受当下的生活，面对困难以及解决问题时的心态</h4><p>你喜欢自己当下的生活状态吗？可能只有在答案为否的时候我们才会想到问自己这个问题吧。既然如此，那就应该做点什么去改变自己。但是，当我们达到理想中的生活状态之后，我们就不会感到厌倦和困惑、永远幸福快乐下去了吗？我觉得并不会。我们还是会遇到不如意的事，依旧会感到焦虑和想要寻求改变。生活的本质就是永远会有新的挑战出现，认清这点能让我们以更平和的心态面对当下的困难。没有一种生活是完美的，接受此刻生活对自己的安排。学会享受当下，享受解决问题的过程。珍惜你所拥有的一切，然后朝着目标不断努力下去。你的能力决定了你能解决多大的问题，你选择解决什么样的问题决定了你能拥有什么样的生活。所以，不要急于摆脱当下的生活状态，找到真正的问题所在，选择你想要解决的困难，以自我完善和不断进步作为驱动力，去解决这些问题和困难。只有这样，你才能学会享受当下的生活。</p><h4 id="6-月-14-日-关于财富和幸福，没有完美的人生模式"><a href="#6-月-14-日-关于财富和幸福，没有完美的人生模式" class="headerlink" title="6 月 14 日 - 关于财富和幸福，没有完美的人生模式"></a>6 月 14 日 - 关于财富和幸福，没有完美的人生模式</h4><p>端午假期马上就结束了，宅在家的两天非常惬意：玩滑板，补了几期我住，看完了《了不起的盖茨比》，又看了一遍电影版的，以及瘫在椅子里刷手机等等。昨天晚上睡觉前无意间在收藏的书签里翻出一本 <a href="https://www.yuque.com/qingmiyang/naval">Naval</a> 的书，看了一会儿，不免又有点焦虑起来。目前的自己的确没法像 Naval 说的那样，拥有可以让自己积累财富的特殊知识。我也有点怀疑自己是否真的热爱现在的工作，因为宅在家这两天，一行代码都没写。虽然也想过要学习，但是明显动力不足。刚好前两天也在便签中写下这样一个问题：</p><blockquote><p>认真想象自己 3 年、5 年甚至是 10 年后的生活，再回过头来思考，眼下的工作是你想做的事吗？如果不是，你真正想做的是什么？你有什么备选项吗？</p></blockquote><p>人总归会有自我怀疑的时刻，每当这个时候就应该跳出当下的情境，用更长远的眼光看待自己的工作和生活。追求财富和幸福是目前大多数人的人生主题，但是如何去做的确是值得我们花更多时间思考的问题。不过，自己毕竟还很年轻，还有很多东西需要学习，也依旧有重新选择和重新开始的机会。正因如此，才更应该努力去探索，根据自己的好奇心、渴望以及特质，走出属于自己的人生道路。哪怕最终结果只是过着普通的生活，但是只要是自己努力探索之后想要的结果，那就是完美的。没有什么好后悔的，不断学习、不断改变、不断行动下去就好了。</p><h4 id="6-月-15-日-发呆自由"><a href="#6-月-15-日-发呆自由" class="headerlink" title="6 月 15 日 - 发呆自由"></a>6 月 15 日 - 发呆自由</h4><p>相比其它自由，我觉得真正宝贵的是发呆自由。因为它说明了一个人不但对自己的时间有完全的掌控，而且也不会焦虑未来。而且发呆对自己的大脑来说，也是一种休息和调整，我们可以从聚焦模式切换到发散模式，很多需要创意的工作都依赖于这种模式才能产生灵感。发呆对身体来说也是一种休息，你的身体器官会进入自动驾驶模式，可以让原来紧张的肌肉、身体节奏渐渐轻松下来。对于精神来说也是一样。</p><p>但是，发呆自由是不是意味着你的时间不值钱？也许吧。如果你对自己的人生完全没有规划，那么，不需要太多物质也可以做到发呆自由。不过，我觉得我们还是应该追求财富和幸福，只不过要注意停下来休息，学会发呆，让自己获得喘息和放松，然后继续向前。</p><h4 id="6-月-16-日-睡前阅读的习惯"><a href="#6-月-16-日-睡前阅读的习惯" class="headerlink" title="6 月 16 日 - 睡前阅读的习惯"></a>6 月 16 日 - 睡前阅读的习惯</h4><p>最近打算养成睡前阅读的习惯。过去睡前的时间总是利用得不是很好，不是刷手机就是看视频，如果能把睡前的时间用来阅读，每天阅读 1 小时，那么一周至少可以读完一本书，而且睡前阅读对提高睡眠质量也有帮助。现在关键的问题是晚上运动完洗完澡总是忍不住想要休息放松，然后时间又把握得不是很好。之前尝试过一段时间定时开关机的办法，但是效果不是很好，因为有时候的确需要用到手机。接下来打算在阅读期间使用 Zen Mode，看下自己的阅读效率能否提高。先养成睡前阅读的习惯，每天 10 点之后，强迫自己坐到书桌前阅读 1 小时。然后再养成晚上学习充电的习惯，玩手机前设置闹钟，最多只能使用半小时。当一个人拥有了改变的欲望的时候，他就一定能找到方法。</p><h4 id="6-月-17-日-做一个立体的人"><a href="#6-月-17-日-做一个立体的人" class="headerlink" title="6 月 17 日 - 做一个立体的人"></a>6 月 17 日 - 做一个立体的人</h4><p>现在大家好像都习惯了拥有多种身份，我们会在不同的场景下使用不同的身份，然后展现不同的自我。比如在家里，我们是父母的好孩子，表现得乖巧懂事，讨父母欢心。在工作中，则是不苟言谈、敬业认真的形象，会尽量表现出自己作为一个职场人士的专业素养。而和朋友在一块的时候就表现得随意一些，不过有时候还是会忍不住表现自己的优越感或者向朋友诉苦来让自己感到舒服一些。自己一个人呆着的时候，有时候觉得自在满意，有时候又会感到孤独，不过最大的不同之处是，所有的行为都是围绕着自己的，不需要为了照顾他人的感受或者满足他人的期待而行动。无论在什么场合下都保持一致，是很难做到的。因为我们在不同的角色下，和不同的人相处，有不同的目的和期望。调整自我以符合当下的情境是自动发生的。</p><p>但是，最近意识到，如果想做一个更立体的人，就应该尽量展现出真实的自我，无论是和谁在一起，也无论在哪里，只要不影响工作和冒犯到他人，<strong>和同事或者其他人相处时都应该像和朋友相处或者自己独处时一样</strong>。如果我们能始终保持想法、语言和行为的一致，向他人毫无保留地展现出一个立体的自我，而不是部分的自己，我们会变得更加有魅力，也能活得更舒展，更快乐，更有生命力。</p><h4 id="6-月-18-日-我对电商促销活动的态度的转变"><a href="#6-月-18-日-我对电商促销活动的态度的转变" class="headerlink" title="6 月 18 日 - 我对电商促销活动的态度的转变"></a>6 月 18 日 - 我对电商促销活动的态度的转变</h4><p>今天 618，曾经的我也非常不屑于参加类似的电商活动，但是因为想给爸妈换电脑和手机，这两天我也开始关注某东 618 的促销活动了。这种转变还挺有趣的，可能说明自己变成熟了？因为觉得确实能省点钱。过去不屑最主要的原因是觉得对于自己喜欢的东西买就买了，为什么要等到搞活动促销才买？现在觉得，如果能省钱的话，那就等促销的时候再买吧。毕竟现在大部分想买的东西都是出于「改善」需求，而不是「硬」需求。而且除了房子之外，也没有什么东西是真的「买不起」的。所以，现在的心态会更平和，也不会着急马上拥有它。等过一段时间之后，有可能想买的东西降价了，也有可能发现自己不再想要了。毕竟，等等党永不为奴。</p><p>所以，人是不断变化的。如果你觉得自己永远不会改变，那你一定是对人的本性了解得不够多。另外，也不要害怕这种变化。如果我们永远不改变，那么我们就不会有任何进步。始终不变的人是不存在的，即使存在，那样的人也太无聊了吧？你过 10 年去看他，发现他和 10 年前一模一样，你还会有和他交流的欲望吗？</p><h4 id="6-月-19-日-不够优秀也可以爱人和被爱"><a href="#6-月-19-日-不够优秀也可以爱人和被爱" class="headerlink" title="6 月 19 日 - 不够优秀也可以爱人和被爱"></a>6 月 19 日 - 不够优秀也可以爱人和被爱</h4><p>昨晚刷牙的时候意识到，我为什么会选择单身，其实不是因为身边没有机会，而是我觉得自己<strong>还不够好</strong>。不够优秀，不够聪明，不够富有，不够有趣，所以，我应该先努力提高自己的能力，努力增长见识，去阅读、体验更多的事情，这样之后才能<em>有资格</em> 去认识其他人。但现实是，你永远都不可能变得足够优秀、富有和有趣，因为这些都是可以永无止境地追求下去的。所以，即使此刻的自己没有达到自己的期望，但是你依旧可以去追求和其他人产生连接。只要你保持真诚，和他人的交流就可以很自然地发生。沟通交流不一定是要以结果和目标作为导向的，有的时候只是互相陪伴、互相分享彼此的生活而已。所以，不要有太多思想负担，你只要向他人展示出真实的自己就可以了。另外，降低自己的期望，不要期望会遇到一个「灵魂知己」。那样的人是不存在的。只要愿意倾听彼此，坦诚地进行沟通，这就已经非常难得了。还有，不要对自己的身份感到自卑，人的出身、外貌等无法改变，接受这样的设定就好了。改变你能改变的部分，比如如何变得更有趣、更幽默等等。</p><h4 id="6-月-20-日-父子关系也是人际关系中的一种"><a href="#6-月-20-日-父子关系也是人际关系中的一种" class="headerlink" title="6 月 20 日 - 父子关系也是人际关系中的一种"></a>6 月 20 日 - 父子关系也是人际关系中的一种</h4><p>今天父亲节，想写下我的老爸，但是不知道该从哪开始写。我的爸爸对我的影响挺大的，我现在的性格、思考的方式、为人处世等等，多多少少都留下了一点他的影子。有时候觉得，其实我和他没什么区别，我只是他的一面镜子；有时候却又觉得，我们是完全不同的人，我不要成为他那样的人。为什么会这样矛盾？可能只是为了寻求解释吧，解释自己为什么成为现在的样子，想告诉自己「我继承了他身上xxx的优点」，也想把自己的缺点归咎于他的遗传。不过，随着年龄的增长，越来越觉得，决定我们成为什么样的人的，其实是我们自己。父亲是我们生命中的一个重要的角色，他陪伴我们成长，在我们需要的时候给我们提供帮助。但是，大多数父亲本身也只是一个普通人而已，他也有七情六欲，有优点也有缺点，有每个活着的人都有的局限性。所以，我们不应该对这个角色有太多要求，或者把他放到一个很高的位置，而应该像对待普通人一样，赞赏他的优点的同时，也允许他有自己的缺点。父子关系，说到底也只是人际关系的一种。我们同样是在一种奇妙的缘分之下，才能拥有这样的关系。我很幸运，拥有一位身上的优点也多于缺点同时也很爱我的父亲，而我觉得我也是爱他的。珍惜生命，珍惜你所拥有的一切。</p><h4 id="6-月-21-日-把眼下的事情做好，兴趣是靠自己培养出来的"><a href="#6-月-21-日-把眼下的事情做好，兴趣是靠自己培养出来的" class="headerlink" title="6 月 21 日 - 把眼下的事情做好，兴趣是靠自己培养出来的"></a>6 月 21 日 - 把眼下的事情做好，兴趣是靠自己培养出来的</h4><p>最近又开始自我怀疑，经常问自己「我到底喜欢什么？」、「我适合做什么？」等类似的问题，昨晚跑完步有了一个顿悟：没有时间去浪费，只要是在创造价值，随便做什么都可以。不要觉得眼下的事不是我最喜欢的就想要去寻找其他事做，这样的寻找只会让自己更加迷茫，浪费更多的时间，因为你会永无止境地寻找下去。相反，你应该用心把此刻在做的事情做好。比如如果是工作上的项目，那就好好研究如何把项目做好然后不断优化，如果有什么想要尝试做的私人项目那就立刻开始去做，不要觉得浪费时间或者工作上用不到就不去研究了。这样日积月累下来，慢慢的，你就会积累其越来越多的经验，然后可能也会对你所做的事越来越感兴趣。</p><h4 id="6-月-22-日-创造学习的意义和动机"><a href="#6-月-22-日-创造学习的意义和动机" class="headerlink" title="6 月 22 日 - 创造学习的意义和动机"></a>6 月 22 日 - 创造学习的意义和动机</h4><p>这两天发现自己工作状态越来越不好，由于没有正式的项目，每天只是在做一些小打小闹的东西，然后好像也没有真正学进去什么东西，每天都期盼着早点下班。这种状态真的不是自己想要的。如何让自己更加投入呢？我觉得首先需要改变自己的态度。要重视自己的时间，不要觉得手上没有项目就可以漫无目的地学习了，要学会给自己制订目标和计划。比如今天要学会哪些组件和模式的使用，掌握和熟悉一个第三方类库的使用等等。其次，要对自己做的事感兴趣。比如告诉自己学会它能够给自己带来哪些好处，未来有哪些地方可能会派上用场等等。人只有在做自己觉得有意义且重要的事的时候，才能全身心投入进去，并且会不断想办法去优化它。最后，要学会奖励自己，给自己创造一些期待。比如如果今天我学会了xxx，我就可以用xxx奖励自己。对我来说，这周不下雨，晚上能出去玩滑板就是一种奖励。虽然学习有方法，但是更重要的是<strong>学会创造意义和动机</strong>，这样我们才能找到更加高效的方法去学习。</p><h4 id="6-月-23-日-用理性大脑欺骗生理大脑"><a href="#6-月-23-日-用理性大脑欺骗生理大脑" class="headerlink" title="6 月 23 日 - 用理性大脑欺骗生理大脑"></a>6 月 23 日 - 用理性大脑欺骗生理大脑</h4><p>有时候明明知道做某事对自己有利，比如每天晚上花 1 小时阅读，但是还是不会去做，这是为什么？我觉得这一方面是因为人天生具有好逸恶劳的本性，大脑只喜欢做一些简单的、不会耗费太多能量的事情，这也是为什么现在短视频、游戏如此流行，而其它需要我们长时间倾注注意力的事情，比如阅读，就很难让人坚持下来。不过，我觉得我们可以利用一些小技巧，<strong>用理性大脑欺骗生理大脑</strong>，也就是<em>让生理大脑也以为这件我们想做的事是值得做的</em>。这也是《掌控习惯》中提出的策略，也就是渴望（让它有吸引力）和奖励（让它令人愉悦）两个原则。比如，把我们想做的事和一件我们喜欢但是不让自己做的事联系在一起，比如达成指定的阅读时间之后看一个喜欢的视频。再比如，给自己制订每天的阅读目标，周末按这一周完成阅读目标的天数奖励自己，完成的天数越多，奖励越丰厚，等等。当然，要想让这些策略生效，最关键的部分是执行和自制力，不能耍赖或者中途放弃。</p><h4 id="6-月-24-日-用实际行动代替假设和幻想"><a href="#6-月-24-日-用实际行动代替假设和幻想" class="headerlink" title="6 月 24 日 - 用实际行动代替假设和幻想"></a>6 月 24 日 - 用实际行动代替假设和幻想</h4><p>我发现自己有时候会有这种心态：假如我有更多的好习惯，假如我能更勇敢、更善于人际交往，我就可以做更多的事，完成某个目标，认识某个人等等。但是，我觉得这种心态是有害的，只是在用幻想满足自己的期待，它会阻止我们去真正改变自己。和这种幻想相反，我们应该用更为实际的态度去面对自己的渴望。比如认清现状，此刻的自己还不具备某种能力，但是却想要达到某种状态，那么我应该怎么做才能促使这种变化的发生呢？</p><p>当我们用更<strong>具体实际的思路</strong>去解决某个问题，而不是用不会造成任何影响的<strong>假设和幻想</strong>来对待现实中的问题时，我们会离我们的目标更近，我们的心态也会更加积极。毕竟，除了死亡，这个世界上很少有什么事是我们一点办法都没有的。</p><h4 id="6-月-25-日-社交账号也是观念筛选器"><a href="#6-月-25-日-社交账号也是观念筛选器" class="headerlink" title="6 月 25 日 - 社交账号也是观念筛选器"></a>6 月 25 日 - 社交账号也是观念筛选器</h4><p>有时候觉得，我们和某种观念的相遇和认识一个陌生人一样，都是看缘分的。如果你的阅历、信念、知识结构不支持你接受某种观念，那么即使和这种观念相遇了，最终你们也会渐行渐远。所以，最终能留在我们身边的，一般都是我们愿意接受且认同的人和观念。这一点也提醒了自己，我们在社交媒体上关注的每一个账号都是一个筛选器，其中提供的信息都是我们认同且觉得有用的。但是，随着我们阅历的增加，一些账号可能会随着时间的推移，慢慢不再那么吸引我们了，这是因为我们在不断成长、发生变化。所以，定期清理你的社交帐号，选择高质量的信息源，只有那些能帮助我们成长同时他们自己也能不断成长的，才有可能长时间留在我们身边。</p><h4 id="6-月-26-日-允许自己的不同，也接受他人的不同"><a href="#6-月-26-日-允许自己的不同，也接受他人的不同" class="headerlink" title="6 月 26 日 - 允许自己的不同，也接受他人的不同"></a>6 月 26 日 - 允许自己的不同，也接受他人的不同</h4><p>有时候会觉得自己太与众不同，比如喜欢独来独往。而且我总是能很快就嗅到一个人身上的缺点，通常是第一次相处几分钟之后，我就能知道这个人最大的问题是什么。这种「孤僻」和「敏感」让我很难和他人亲密无间地相处。但是，现在我好像想通了，这样其实也没什么不好。只要自己舒服，又没有影响到他人，那就没关系。不过，对待他人还是要尽量宽容一点。没有人是完美的，一个人身上的缺点也是他的个人特点。如果每个人都完美无缺，一模一样，那这个世界也太无聊了。接受他人和自己不同，学会欣赏这种不同，同时保持尊重和善意，他人会感受到你的真诚，自然也会开始和你分享更多关于他们自己的事。而你也应该多展示出真实的自己，展示出一个更加全面的自我，只有这样才能真正让他人对你感兴趣。我身上也有各种各样的缺点和一些小特质，比如容易紧张，一紧张就出很多汗，总是在意自己的牙齿不好看，等等。但是，这也是真实自我的一部分，不要抗拒它们，只有你自己先慢慢开始接纳它们，这样别人才有可能也接纳它们。而且，除了你自己之外，其他人真的不在乎这些你眼中的「缺陷」。所以，尽管去做自己、大胆展示自己的不同吧。</p><h4 id="6-月-27-日-维持适度的焦虑感"><a href="#6-月-27-日-维持适度的焦虑感" class="headerlink" title="6 月 27 日 - 维持适度的焦虑感"></a>6 月 27 日 - 维持适度的焦虑感</h4><p>我们感到焦虑，最根本的原因是对自己不够自信。对自己外貌的不自信促使我们去锻炼身体、健身、提升自我形象等，对财务的不自信促使我们不断提高工作能力、获得更多技能、增加收入来源等，对智力的不自信促使我们去阅读、去寻找导师等。所以，焦虑未必不是好事，它也是催人上进的动力，不过，前提是我们能够把焦虑控制在一个合理的区间内。太焦虑会让人心烦意乱，失去做事的动力。</p><p>当我处于过度焦虑的状态的时候，我会做一些让自己开心的事，比如狂吃一大堆零食、连续玩几个小时游戏、上P站等。情绪释放完毕之后，心里虽然会觉得那些时间被浪费掉了，但是转念一想，只要把压力释放出来了，第二天能以更好的状态恢复正常的工作、生活节奏，不也挺好的吗？而当觉得自己太过安逸、焦虑感不足的时候，我会问自己这样一个问题：<strong>我现在有选择工作的自由吗？5 年后呢？10 年后呢？</strong>通常这都能立马唤醒适度的焦虑感，然后提醒自己继续努力下去。说到底，一定要做自己喜欢的事，即使做不到非常喜欢，至少也要觉得这是对自己和他人有益的事情，否则你会失去做事的动力。</p><h4 id="6-月-28-日-找到你的导师"><a href="#6-月-28-日-找到你的导师" class="headerlink" title="6 月 28 日 - 找到你的导师"></a>6 月 28 日 - 找到你的导师</h4><p>前两天看了一个 TedX 视频，一个想法一直在我脑海里打转，那就是<strong>我有没有现实生活中的榜样</strong>（role models）？答案似乎是没有。绝大多数我崇拜的人都是通过网络才知道他们的。这是一个巨大的问题。因为这样的话，我就无法经常和他们交流，让他们做自己的导师（mentor），遇到问题时向他们寻求建议等。所以，我有两种选择，要么去到他们身边生活，要么去寻找自己身边的榜样。榜样或者导师为什么这么重要？因为他们不但可以帮助我们成长，还能点播我们，让我们看清某个阶段下的自己最重要的目标是什么。不过，我觉得即使现阶段没有遇到自己的导师也没关系，最好的导师其实远不止一位，书才是相伴我们终身的最好的导师。无论你有什么样的迷惑和疑问，去相关的书籍中寻找答案才是正确的选择。即使书中没有答案，至少也能为你提供解决问题的思路。现实生活中的导师最大的意义是帮助自己建立信心，扫清眼前的障碍，看清迷雾中的方向，而不是为了解决具体的某个问题。耐心+沉着冷静，也许未来你也可以成为某些人的榜样和导师。</p><h4 id="6-月-29-日-认清自己的价值"><a href="#6-月-29-日-认清自己的价值" class="headerlink" title="6 月 29 日 - 认清自己的价值"></a>6 月 29 日 - 认清自己的价值</h4><p>认清自己的价值——我觉得这是一件非常难做到的事，无论是在年轻的时候还是年长的时候。我能做什么，我能影响多少人，我是否发挥了自己全部的潜力，这些是影响我们能否看清自身价值的三个方面。能做什么是最直接的一面，你的能力是外界评判你的标准，虽然有时候它并不能代表全部。能影响到多少人其实也是能力的一种，只不过它是一种综合能力的体现。你能影响到的人越多，说明你的能力越强，不过也有可能你的运气比较好。是否发挥了全部潜力则说明了你对自己的认知，提示我们应该如何选择前进的方向，这也是认清自己价值的最大的作用。</p><h4 id="6-月-30-日-保持好奇心和探索欲"><a href="#6-月-30-日-保持好奇心和探索欲" class="headerlink" title="6 月 30 日 - 保持好奇心和探索欲"></a>6 月 30 日 - 保持好奇心和探索欲</h4><p>昨晚看了几个旅游 Vlog 视频，印尼几个大城市以及旅游景点的航拍，点燃了我出去浪的渴望，虽然知道现在并没有实现愿望的可能。最大的感慨是这个世界远比我们想象的更加丰富多彩，只有去亲身经历过，才能体会到这一点。之前列过一个想去的地方的清单，不知道有生之年能否全都去一遍。也许可以吧，毕竟人生路那么长，为什么要否定未来的可能性呢？当然，除非「疯狂」一把，不然从现实的角度来看，一旦选择了安稳的生活方式，出于经济条件和时间的限制，未来不太可能会实现这个目标，一年顶多能去一两个地方就算不错了。但是，只要始终抱着探索的心态，少去几个地方也没关系。能够通过他人视角来见识这个世界，我就已经挺满足的了。而且即使自己真的去游览了，也不一定能捕捉到那些 Vlogger 所拥有的视角下的景色。最重要的是，要始终保持好奇。正因为我们无法亲自去探索这个世界的全部，所以才要借他人之眼去发现我们不曾发现的这个世界的另一面，无论是通过阅读、视频或者他人的讲述等等。另外，非常期待未来科技的发展，到时候也许可以让人足不出户就能去地球的另一面探索游览了，而且体验与实地游览相差不大。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写作的意义</title>
      <link href="/2021-5/"/>
      <url>/2021-5/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/ZuE1XL6_lxo" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>去年的这个时候发布了<a href="https://ajiew.github.io/2020-5/">第一篇</a>碎碎念，那时的想法是通过碎碎念记录自己每天的想法以及锻炼写作的能力，没想到这么快一年过去了，每天不过三五百字的量，累积起来到现在居然也有十几万字了，差不多是一本小书的长度。写碎碎念带给我最大的变化是，我能够更加诚实地面对自己了。无论是生活中出现的烦恼或者是当天的感悟，通过文字记录下来之后，我能看到自己真实的想法到底是什么，并且发现真正的问题在哪。也就是说，通过写作我能更好地认识我自己。我觉得光凭这一点，我就应该继续写下去。虽然没有人看，产生的价值也有限，但是我自己就是最大的观众。每个人都可以通过记录自己每天的想法剖析自己、观察自我成长的轨迹。</p></blockquote><span id="more"></span><h4 id="5-月-1-日-做一个高应答性的人"><a href="#5-月-1-日-做一个高应答性的人" class="headerlink" title="5 月 1 日 - 做一个高应答性的人"></a>5 月 1 日 - 做一个高应答性的人</h4><p>我发现自己最大的问题是应答性很低，尤其是在多人的场合下，比如在办公室里，我几乎不会和其他人闲聊，只有他人主动向我发起的聊天我才会回应。为什么会这样？一方面，我觉得还是自己的虚荣心在作怪，害怕暴露自己的无知，当觉得自己比不上他人时感到自卑，当觉得他人不如自己时又感到不值得与他们交流。另一方面，自己闲聊的技能的确很弱，总是容易想很多。有时候内心戏太多，等准备好说什么的时候，时机已经过了。</p><p>所以，首先要摆正自己的心态，不要害怕暴露自己的弱点和无知的一面，只有通过他人的指点你才能获得成长，这才是我们与他人交流最大的意义。而且也不要害怕比较，每个人都有自己独特的价值，不能因为你某一方面不如他人或者他人不如你，就贬低自己或者他人，我们都是彼此人生的过客，不是只有通过比较才能证明自己的价值的。不要因为自己某一方面不如别人而感到自卑，因为我们都不完美。把身边的所有人都当成自己的老师，看到他人的长处，弥补自己的短板。如果对方各方面都优于自己，那你更应该感到庆幸，因为你身边多了一位段位比自己高很多的好老师，你要运气很好才能有幸遇到各方面都比自己强的人，全方面向他学习就好了。</p><p>心理关过了之后，技能方面就只能靠不断地练习了：不要想太多，大胆开口说就行了。哪怕「说错话」那也只是你自以为的，也许对方根本不把这件事放在心上，只要心里保持始终尊重对方的态度就好了。我的目标是：多表达自己，多向他人揭露自己，做一个高应答性的人。</p><h4 id="5-月-2-日-陪爸妈、降低期望以及理想婚礼"><a href="#5-月-2-日-陪爸妈、降低期望以及理想婚礼" class="headerlink" title="5 月 2 日 - 陪爸妈、降低期望以及理想婚礼"></a>5 月 2 日 - 陪爸妈、降低期望以及理想婚礼</h4><p>在家时间过得总是特别快，哪怕不玩手机、不看视频，坐着聊天发呆，时间也是一会儿就过去了。人在不同的环境下，生活习惯也会发生变化。为什么在家就不能养成固定的生活作息呢？因为变量太多，计划总是容易被各种各样的琐事打断。而且心态也不一样，在家就总是想要休息，会以为自己有很多时间可以随意挥霍，但其实一天依旧是 24 小时，稍不注意，时间很快就过去了。</p><p>不过每次回家都越来越意识到，自己是极其幸运的人。离家近，几乎每个月都能回一趟家，见见爸妈，吃老妈做的饭菜，这也是为什么相比其他人，我几乎从来都不会想家的原因吧。但是，还是应该多利用好自己的优势。既然现在离父母这么近，而且他们都身体健康，就应该多花时间陪陪他们。同时也要更努力地工作，提升自己的能力，寻求更好的机会，争取让他们也能享受到我喜欢的好产品和好服务，还有带他们一起出去旅游等等。当然，他们现在最关心的可能还是我的「终身」大事。但是，这件事不是仅仅靠个人努力就能改变得了的，还是要看一点点缘分和运气。我也希望自己能尽快脱单，找到一个合适的人一起生活，一起面对未来，也有在积极探索身边可能的机会，但最大的困难是：我不知道自己喜欢什么类型的人。可能还是需要多一点耐心吧。保持开放的心态，保持活跃，降低期望，降低姿态，这样更容易有惊喜出现。与此同时，积极向内探索，找到自己的使命感，明确自己的目标，越具体越好，这样也许对自己的未来会看得越来越清晰。</p><hr><p>中午去亲戚家喝喜酒，早早就过去坐着，见到了一些平时很少见到的亲戚，有一搭没一搭地聊着总算是吃完了，然后一个人早早就回来了。老实说，看到新郎、新娘以及伴郎们一桌桌地敬酒，我心底的想法是传统习俗真的好麻烦，这么折腾真的有必要吗？还有看到这么多桌的酒席，接亲的婚车、摩托车队，我心里想的是这大概要花掉多少钱。果然成年人想的都是算计以及成本和收益比，不仅仅就只是觉得好玩了。不过，自己毕竟也到了谈婚论嫁的年龄，差不多也该考虑这些事了。有些事是不得不去做的，还有些是为了做给别人看的。但如果是为了自己爱的人，那么就什么都可以忍受，什么都可以心甘情愿地去做。但是，我还是希望能够遇到一个彼此观念接近的人，我的理想婚礼是旅行结婚，最好是带上双方的父母，给彼此和彼此的家人带去一段幸福难忘的回忆就够了。然而要遇到观念一致的人，真的太难了，只能祝自己好运吧。</p><h4 id="5-月-3-日-立马接受现实、迅速调整心态的能力"><a href="#5-月-3-日-立马接受现实、迅速调整心态的能力" class="headerlink" title="5 月 3 日 - 立马接受现实、迅速调整心态的能力"></a>5 月 3 日 - 立马接受现实、迅速调整心态的能力</h4><p>我觉得自己需要改进的地方是：立马接受现实、迅速调整自己心态的能力。尤其是当你处于逆境下的时候，这种能力就显得非常重要了。我们在不利的情景下，本能的反应是想要抗争，不想承认现实，甚至想要逃避，但是已经发生的事情无法挽回。而且很多事情不是我们能决定它是否要发生的，所以只能选择接受它，只不过时间早晚而已。但是，如果我们能在事情发生的那一刻就立刻接受现实，可以省去很多不必要的摩擦（心理上的和现实中的），以及避免错过调整计划的时机。<strong>抗拒不利的现实是人的本能，但是务实能让我们走出困境</strong>。在困境中，我们更加需要迅速调整自己的心态的能力，想办法如何解决问题，而不是如何逃避问题。的确，有时候我们能力有限，靠自己一个人可能根本无法解决眼下的难题。但是，逃避只会让问题变得更加严重，只有接受现实，才会开始积极努力地想办法去解决它。即使实在解决不了，那也应该寻求外界的帮助。要相信问题总有一天是会被解决的，你越早开始行动，问题造成的后果和不利的影响就越小，最终你的损失也越少。越是拖延，问题越是有可能像雪球一样越滚越大，最终可能真的变得无法解决。</p><h4 id="5-月-4-日-专注和耐心"><a href="#5-月-4-日-专注和耐心" class="headerlink" title="5 月 4 日 - 专注和耐心"></a>5 月 4 日 - 专注和耐心</h4><p>如何变得更有专注、更耐心，尤其是在解决问题的时候？我发现最近自己最缺乏的就是耐心和聚焦的能力。我们的生活中到处都充满了各种各样的诱惑以及让人分心的事物，如何保证自己不因为被打扰而分散注意力？我觉得首先需要锻炼自己<strong>聚焦做一件事的能力</strong>。比如此刻当我坐在电脑前写碎碎念的时候，就不要再去想其它。有时候会觉得不想写或者觉得没话题可写，然后就会想去做下别的事，比如看看手机，然后不知不觉就浪费了十几分钟。其实，只要我们专注当下，强迫自己把一件事做完之后再做下一件事，我们慢慢就会养成专注的习惯。而且全心全意只做一件事也会提高我们的效率。</p><p>对于解决问题也一样，寻找一个安静的环境，写下自己的问题，然后专注思考如何解决它。问题的难点在哪里？可能的解决方案是什么？如果尝试进行解决的话应该从哪一步开始？然后一步步验证自己的猜想，直到最终找到问题的答案。至于耐心，当我们坚持做这样的专注练习，并且长时间只做一件事、只解决一个问题，随着我们解决的问题越来越多、解决问题的能力也越来越强，耐心自然而然就培养起来了。生活中几乎所有的问题都可以通过这种方式来解决。</p><p>另外，还有一些辅助的手段，比如冥想、阅读和写作。冥想会让我们变得更平静，更能控制自己的心境，而阅读让我们获得更多解决问题的视角以及拓宽我们的知识面，写作则是培养我们的思考能力，对已有知识的进行复盘和记录，让我们能够形成自己的知识网络，这样才能在未来解决更大的难题。</p><h4 id="5-月-5-日-自我接纳以及改变你能改变的"><a href="#5-月-5-日-自我接纳以及改变你能改变的" class="headerlink" title="5 月 5 日 - 自我接纳以及改变你能改变的"></a>5 月 5 日 - 自我接纳以及改变你能改变的</h4><p>自我接纳到底是什么？其实就是接纳自己的一切，承认自己只是个普通人，也会犯错，有优点和缺点。不用刻意掩盖自己的缺陷，也不用刻意向他人展示自己的优势，寻求外界的认可。每天看到镜子中的自己，从微笑到大笑，即使笑得并不好看也要笑，因为这就是自己真实的样子。他人的看法并不重要。你怎样对待他人，他人就会怎样对待你。这个世界上绝大多数人都是善良的，只有一小部分人是怀有恶意的，但是也没关系，远离他们就好了。他们损失的是他人的信任以及自己变得更好的机会，最终伤害的也是他们自己以及他们身边的人。接纳自己，从认识到自己并不完美开始，承认自己有各种各样的不足，从外貌到认知再到行为习惯，接受人生中那些我们无法改变的部分，包括身高、外貌、家境等等，然后寻求积极的改变，比如通过锻炼让自己的身材变得更好，通过阅读和学习让自己获得更多的知识、提高能力，通过工作和理财投资逐步改善自己的生活，通过表达自己和交更多的朋友让自己的观念得到传播、获得更多的支持等等。接纳自己是拥有自信的基础，而自信又是一个人尝试新挑战以及最终能把事情做好的关键所在。</p><p>老实说，关于自我接纳我过去的确做得不是很好，体现在对自己外表的不自信，以及有时候会对自己的家境感到自卑。但是，这些都是无法改变的事情，所以我需要承认现实，接纳它们就好了。我真正应该做的，是花更多的时间在那些我能够改变的事情上，比如怎样把自己的工作做得更好，怎样获得更多的机会，怎样让自己和自己的家人生活得更加开心快乐和幸福等等。「改变你能改变的」，这句话可能比自己想象的更有用。</p><h4 id="5-月-6-日-寻找自己出错的证据"><a href="#5-月-6-日-寻找自己出错的证据" class="headerlink" title="5 月 6 日 - 寻找自己出错的证据"></a>5 月 6 日 - 寻找自己出错的证据</h4><p>早上厕所阅读时读到我们在认识陌生人时存在<strong>首因效应</strong>以及<strong>自我验证谬误</strong>。仔细回想下，的确如此。我们容易被首先观察到的现象影响，匆忙给对方下定论，或者根据自己过去的经验把对方归为某一类人，然后在后来的接触中从对方行为的蛛丝马迹中寻找验证自己猜想的证据。也就是说，<strong>我们只会看到自己想要看到的</strong>。我们没有意识到的是，第一印象也有可能是会错的。当我们的直觉告诉我们的和事实有差异时，我们一般只能看到证明我们正确的「事实」而忽略了其它，此时，对他人的偏见就形成了。所以，我们应该反过来想：当形成对某人的第一印象之后，反过来去<strong>寻找自己出错的证据</strong>。比如，如果你对某人的第一印象是热情、外向、勇敢、机敏、聪明、友善的，那你应该去寻找自己是错误的证据，比如对比你们单独相处时以及在公共场合时对方的表现是否一致；对一些社会地位不如 Ta 的人，Ta 的表现又如何，等等。而如果对方在你眼里是冷漠、木讷、不善言谈、内向、自私、愚蠢的人，你也应该想想自己犯错的可能。通过每一次与对方的接触中寻找自己犯错的迹象，不抱任何偏见地去看待对方的行为，当发现自己是错的时候，及时更新或者改变自己的想法和态度，只有这样，我们才能保证自己不会在未来犯更大的错。</p><h4 id="5-月-7-日-享受孤独，耐心成长"><a href="#5-月-7-日-享受孤独，耐心成长" class="headerlink" title="5 月 7 日 - 享受孤独，耐心成长"></a>5 月 7 日 - 享受孤独，耐心成长</h4><p>我发现当你越是急于摆脱一个人的状态的时候就越是容易陷入被孤独感包围的境地。最好的做法是享受一个人的状态，做自己喜欢的事，然后以自己舒服的方式向外界发出你的善意的信号，再寻求与他人建立起连接。我觉得这是一个漫长的尝试过程。每个人都有自己的探索以及与周围世界互动的方式，找到适合自己的方式需要时间。但是，最重要的还是自我成长，你的工作能力，解决问题的能力，与人沟通的能力等等。如果你能创造足够大的价值，身边自然会吸引到越来越多和你一样的人，而和他们一起工作本身就是一种奖赏，会让你收获满足和幸福，也就不需要刻意去寻求连接了。所以，耐心地提高自己吧，学会享受一个人的状态，珍惜每一天的时间，锻炼、阅读、学习、创造，以及养成更多的好习惯，你会变得越来越好的。</p><h4 id="5-月-8-日-承担责任和降低期望"><a href="#5-月-8-日-承担责任和降低期望" class="headerlink" title="5 月 8 日 - 承担责任和降低期望"></a>5 月 8 日 - 承担责任和降低期望</h4><p>前两年常听人说起一个概念「低欲望青年」，最近突然意识到，现在的自己就挺符合这个概念所描述的人群的：厌恶风险，喜欢存钱，没有债务，也对暴富无感；物欲很低，对吃穿用都是越简单越好；不想买车，对婚姻的态度是可有可无。唯一不同的地方是，我依旧憧憬爱情，也想在城市里买房定居，而且我希望自己能够越长寿越好，因为我对未来依旧有期待和好奇，希望能看到未来世界是什么样子。至于剩下的一切，随缘就好。想要的就努力争取，争取不到也没关系，我可以降低自己的期望或者干脆修改目标；已经拥有的我会好好珍惜；并且感恩所有那些帮助过我的人，也会努力回馈他人，尽可能帮助身边的每一个人。至于其它东西，比如他人怎么想，对待我的态度，做出什么反馈等等，真的不是我能控制得了的，随缘就好。当你不再抱有期望的时候，别人偶然的善意也能给你惊喜。但是，你自己要始终保持对他人的善意，努力做好自己能做的部分，尽可能多地为他人提供价值。至于剩下的部分，平常心就好。承担起自己的责任，降低欲望和期望，活得开心最重要。</p><h4 id="5-月-9-日-少和他人比较，专注于自我成长"><a href="#5-月-9-日-少和他人比较，专注于自我成长" class="headerlink" title="5 月 9 日 - 少和他人比较，专注于自我成长"></a>5 月 9 日 - 少和他人比较，专注于自我成长</h4><p>有时候常常会陷入自我怀疑之中，怀疑自己做的事有没有意义，因为对比那些大人物做的事，觉得自己付出的所有努力都只是为了自己的生存，创造的价值非常有限。我觉得这种心态本身就是有问题的。我们每个人都有自己的使命，你不需要和别人去比较。当然，有远大的梦想是好的。但是，这并不意味着眼下我们做的事就是没有意义的。所有的改变都是从一点一滴开始的，所有的大人物一开始做的也是非常微小和简单的事。把自己的问题解决好，再去考虑解决更多人的问题，这种先己后人的顺序才是合理的，而不是反过来。要耐心地生活，耐心地成长。我们绝大多数人都只是普通人而已，能把自己的生活过好、把自己的家人照顾好，就是非常了不起的成就了。能够改变世界的，都是人群中极为罕见的幸运儿。所以，专注于自我成长吧，不要去和他人比较，同时积极对待生活，尽量向身边的人传递好的观念和积极的生活态度，这样也是对这个世界造成有益的影响了。</p><h4 id="5-月-10-日-帮助身边的人变好"><a href="#5-月-10-日-帮助身边的人变好" class="headerlink" title="5 月 10 日 - 帮助身边的人变好"></a>5 月 10 日 - 帮助身边的人变好</h4><p>让你身边的人状况变好，这样你自己的状况也会变得越来越好。如果你周围的人都处于一个向上的氛围之中，那么，你也很大概率会跟上这样的节奏。所以，我们应该尽自己可能地去帮助身边的人。<strong>帮助他人向上就是在帮自己。</strong>虽然有时候短期之内可能看不到这样的趋势，但是长期来看，如果你身边的人一直都能受到你的帮助，那么，你也一定能得到他人的帮助，这种能量一定是相互的。除此之外，利他行为会让我们感到更加幸福。这也是帮助他人变好的动力之一。那么，应该从什么地方做起呢？就从你身边最亲近的人开始，向你的家人和朋友分享你的观点和日常生活，让他们感受到你的真诚，然后慢慢接受你的好观念。再有就是你的同事，主动分享你的经验和心得，和大家一起成长。还有就是那些陌生人，做一个友善而快乐的人，你的态度和行为会影响到他人。也许一个人的力量有限，但是这种能量总归会传递到一部分人身上，继而让他们感到愉快并且将这种能力传递下去。<strong>没有人是一座孤岛，自己变好的同时帮助身边的人变好，你也能获得加速成长。</strong></p><h4 id="5-月-11-日-拥有无限资源的时候，你会做什么？"><a href="#5-月-11-日-拥有无限资源的时候，你会做什么？" class="headerlink" title="5 月 11 日 - 拥有无限资源的时候，你会做什么？"></a>5 月 11 日 - 拥有无限资源的时候，你会做什么？</h4><p>找到自己所爱的一个方法是，问自己一个问题：如果拥有无限的资源（包括时间），你会做什么？当你不需要为了金钱去工作的时候，当你有无限广阔的选择权的时候，你会做什么？听起来有点不切实际，因为这个世界上的绝大多数人都会在某个时刻需要被迫去做一些事。但是，这样的假设可以让我们认清当下的某件事对我们来说究竟有多大的意义。如果你现在所做的工作不能给你带来除了金钱以外其它方面的成长，你就应该开始反思自己是不是应该继续做下去了。</p><p>你选择做这件事有什么长期的目标吗？对于你自己以及对外界而言，这件事最终能创造出哪些价值？如果你不做这件事，有其他人能代替你做吗？相比他们，你的优势在哪？思考过这些问题之后，我发现一个人最根本的追求不应该是为了获得更多的资源，而应该是为了提升自我，不断成长、不断超越自我，为他人创造价值，以及更深入地了解这个世界，学习如何让自己生活得更加健康和幸福，还有帮助这个星球上的所有其他人感到同样如此。</p><h4 id="5-月-12-日-行动起来，改变靠自己"><a href="#5-月-12-日-行动起来，改变靠自己" class="headerlink" title="5 月 12 日 - 行动起来，改变靠自己"></a>5 月 12 日 - 行动起来，改变靠自己</h4><p>突然意识到一个问题，关注 Social Animal 有半年多了，但是在认识陌生人、表达自己方面，我依旧没有任何大的进步。之前还可以用「处于一个较为封闭的环境，机会不多」作为借口，但是现在搬家之后，这样的理由就不成立了。这里有很多和我一样的同龄人，机会到处都是。所以到底是什么阻止了自己去改变？我觉得最关键的一点还是自己太过封闭自己了，总觉得当下的生活就挺好的，所以不想去改变，不想去做一些让自己感到不舒服的事情。明明知道战胜自己的怯懦和恐惧感能够给自己带来成长，但是现实中却依旧无法做出任何行动。这样的人不就是自己讨厌的那种人吗？赶紧行动起来吧，改变还是要靠自己。</p><h4 id="5-月-13-日-用他人的视角观察世界"><a href="#5-月-13-日-用他人的视角观察世界" class="headerlink" title="5 月 13 日 - 用他人的视角观察世界"></a>5 月 13 日 - 用他人的视角观察世界</h4><p>我发现看电影、阅读、和他人聊天等本质都是一样的，其实就是我们慢慢放下心中的戒备，使用他人的世界观观察这个世界的过程。就像是一场旅行，我们会遇到好玩的事，或者听到之前没有听到过的新概念，或者了解到一种新的看问题的角度。如果我们愿意的话，可以通过这一过程汲取他人的新观念来丰富我们自身。不过，无论如何，当故事结束之后，我们最终将会回到自己的世界，会在心中默默决定这一趟旅行中，哪些内容会沉淀下来，变成我们自身的知识和观念的一部分。我们总是会根据自己的经验对他人的经历做出评判，所以我们需要训练自己进入他人的视角去观察这个世界的能力，只有这样我们才能真正理解一个人。</p><h4 id="5-月-14-日-选择正面的自我证实"><a href="#5-月-14-日-选择正面的自我证实" class="headerlink" title="5 月 14 日 - 选择正面的自我证实"></a>5 月 14 日 - 选择正面的自我证实</h4><p>人是自证预言的产物。我们觉得自己是个什么的人，最终就会变成那种人。我们觉得他人是什么样的人，他人就会表现出我们期望的行为。我们觉得事实如何，事态就会按照我们预想的那样发展。我们相信什么，最终就会吸引到具有类似价值观的人到我们身边。如何让自证预言为我所用？除了尽量保持乐观和开放，用积极的心态看待身边的人与事，最重要的是，放下心中的偏见，停止用过去负面的经验给当下的新情景下定论。对于人而言，要相信对方是真诚、善良、聪明的，要以热情、友好、积极的态度与对方相处。一句话，凡事尽量往好处想，对人尽量把对方当成好人。</p><h4 id="5-月-15-日-财富观与副业收入"><a href="#5-月-15-日-财富观与副业收入" class="headerlink" title="5 月 15 日 - 财富观与副业收入"></a>5 月 15 日 - 财富观与副业收入</h4><p>聊聊财富观。首先，要承认的是，没有人是不爱钱的，我们工作的一大目的就是为了赚钱。拥有更多的金钱意味着拥有更多的选择权，比如选择在哪里生活，选择过什么样的生活方式，选择自己的事业，等等。但是，钱说到底只是工具，能否过得开心幸福还是取决于你的信念。如果我们的人生目标变成了无止境的对数字的追求，即使拥有了可观的财富，这样的人生也很难说是幸运。财富只是获得幸福的手段和工具，而不是终极目标。我们应该专注于建立起健康的生活习惯，规划好自己的人生使命，并且不断地为之努力下去。但这并不是说钱就是不重要的，钱非常非常重要，这关系到我们能否专注于完成自己的目标。我们都希望自己可以心无杂念地做事，而不是经常担心自己是否在某一项支出上花费了太多的金钱。绝大多数人都是需要花很多时间关心钱的事的，所以还是要从简单的小事开始做起，比如记账和做预算，节省开支，定投等等。</p><p>另外，我发现自己最近常常在两种观点之间反复横跳：拥有多份收入，增加副业收入 vs 专注于主业，提升工作能力。一方面，很多人建议要有多份收入来源，这样不会太过依赖某一份收入，能增加自己抵抗风险的能力。另一方面，也有人说要做好自己的主业，专注于提升自己的工作能力，这样才能保持自己的竞争力。作为一名程序员，的确，要学的东西实在太多了，往往主业都很难兼顾好，更别说去做其它副业了。而缺乏副业的影响也很明显，当 10 年之后，自己的技能被过时了，或者发现自己不再喜欢这一行了，那么这个时候的自己该何去何从？拥有副业至少可以让自己有选择的权利。而且靠打工是很难获得财富自由的，做副业也是一种探索以及创业的尝试，如果做得不错，未来也能作为自己的主业来做。</p><p>但是，最大的问题是：有什么副业是我可以做的？能否保证在不影响我的主业的情况下开展？</p><h4 id="5-月-16-日-坚持自己的想法"><a href="#5-月-16-日-坚持自己的想法" class="headerlink" title="5 月 16 日 - 坚持自己的想法"></a>5 月 16 日 - 坚持自己的想法</h4><p>昨晚和老妈视频完才睡觉，失眠了。其实也并没有聊什么，还是那些「老生常谈」的话题，女朋友、买房之类的。老妈说男孩子嘛，主动一点，尽快确定关系然后见家长。我说这事八字还没一撇呢。还有就是让我去试试买房摇号，我说我连摇的资格都没有，然后她就又把话题转向谈恋爱了。我觉得他们心底可能比我还焦虑。我在想这是为什么？按理说，他们现在的生活应该非常无忧无虑，为什么偏偏要为下一代这么操心？可能这也算是甜蜜的负担吧。我希望他们能生活得开心幸福，但是他们却想要更多地帮我一把。相比那些不断吸血或者给子女制造麻烦的父母，我已经算是非常幸运了。但是，很多事情最好的做法都是顺其自然，每个人的能力水平不同，每个人也都有自己的课题需要解决，干涉他人的课题只会徒增自己的烦恼。</p><p>不过，让我翻来覆去无法入睡的最大的原因还是，他们的观念和我的观念之间的鸿沟。我的想法是，现在的自己其实还很年轻，谈恋爱、成家对我来说其实并不是那么紧急。提升自己的能力、增长见识、努力工作才更重要。但是他们却觉得，一旦到 30 岁还不结婚的话，就会被人说闲话，再往后想成家的难度也会提高。我理解他们的担心，但是却不赞同他们的想法。我觉得结婚不是必选项，一个人也可以生活得很好，而且我们应该为了爱情结婚而不是为了结婚而结婚。我觉得其实我们谁也无法说服谁，他们那一代人有他们的局限性，而我也有我的固执。不过，生活最终还是自己的，只有我们自己才能决定选择什么样的生活方式。既然如此，那就接受现实，好好过好当下的每一天，然后走一步算一步吧。</p><h4 id="5-月-17-日-知足常乐，保持愉悦"><a href="#5-月-17-日-知足常乐，保持愉悦" class="headerlink" title="5 月 17 日 - 知足常乐，保持愉悦"></a>5 月 17 日 - 知足常乐，保持愉悦</h4><p>「世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它。」这个世界本就是不公平的，我们的起点不一样，性格、天赋水平不一样，甚至运气也不一样。但是靠抱怨并不能解决问题，只能选择接受现实，然后努力去改变自己能改变的。首先要接受自己是个普通人，能做的非常有限，能把自己和自己的家人照顾好就非常棒了。其次，降低期待和欲望。做一个快乐的人成本并不高，只要改变自己的心态就好了。知足常乐，保持愉悦。别人的赞美也好，批评也好，置之一笑就行了。要学会过自己的日子，每天都乐乐呵呵的，就算身边没有朋友，也要学会享受生活，享受一个人的状态，而且这样的人拥有好运气的概率也更高一些。最后，很多事情都是在偶然间发生的，也就是概率问题，并没有什么规律可循。所以，不要试图去解释所有的问题，事情发生了就是发生了，意外也好，惊喜也罢，最终都会过去的。要相信活着的每一天都是上天对你的恩赐。</p><h4 id="5-月-18-日-保持开放"><a href="#5-月-18-日-保持开放" class="headerlink" title="5 月 18 日 - 保持开放"></a>5 月 18 日 - 保持开放</h4><p>使用交友软件有一段时间了，但是一直没取得什么进展。即使加了对方，真正能聊起来的也比较少，基本上聊个几次就很难再继续聊下去了。一方面是对彼此的不熟悉，所以自然而然，我们会刻意拉开距离。即使我表现得比较随和开放，但是对方不一定会用同样的姿态和你交流。而且当对方表现出的热情度达不到自己的期待时，我也会感到兴趣寥寥了。还有就是现在网络交友毕竟有一定的风险，我们需要对对方保持一定程度的戒心。不过，我觉得这也是一个尝试的过程，你不可能立马就找到与自己适配的人。无论怎样，现在的平台算法还是比较初级的，在所有使用该平台的人当中，可能只有很小很小一部分人与你是适配的，而想要与这一小部分人相遇，除了调整个人信息以匹配算法的推荐，还有就是坚持，也许要尝试几十次之后才能碰到合适的人。另外，也不能太过依赖交友软件，毕竟，线下的交流才是最主要的，多出去走走，去参加一些线下的活动。我还是相信大部分合适的人其实就生活在我们附近，只是需要一点缘分才能认识彼此。只要你能保持开放的心态，相信他人是善良的，同时也能坚持自己的原则，合适的人总有一天会出现的。</p><h4 id="5-月-19-日-让自己进步的最快的方法：做难一点的事"><a href="#5-月-19-日-让自己进步的最快的方法：做难一点的事" class="headerlink" title="5 月 19 日 - 让自己进步的最快的方法：做难一点的事"></a>5 月 19 日 - 让自己进步的最快的方法：做难一点的事</h4><p>有时候会觉得自己是在装腔作势，觉得自己的能力并不足以胜任当前的任务，所以即使是在一些自己能做的事情面前，也会觉得自己可能无法做好。有点像 <a href="https://en.wikipedia.org/wiki/Impostor_syndrome">Impostor syndrome</a>，但是自己并不成功。所以，如何改变自己的这种心态呢？因为自证预言的存在，人很难完全不被这种消极的心态影响。最关键的一点还是要做好充足的准备吧，以抵消内心的不安全感以及自我怀疑。这也是变相的逼迫自己去学习和成长。所以，我觉得选择做难一点的任务，但是又不是难到完全超过自己的能力范围，真的是一个明智的选择。这是让自己进步的最快的方法。</p><h4 id="5-月-20-日-多花时间和精力在交友和恋爱上"><a href="#5-月-20-日-多花时间和精力在交友和恋爱上" class="headerlink" title="5 月 20 日 - 多花时间和精力在交友和恋爱上"></a>5 月 20 日 - 多花时间和精力在交友和恋爱上</h4><p>今天 5·20，早上起来看了辉哥的几篇文章，突然觉得有点伤感，因为老实说，的确，我现在的情况就和他所说的「没有爱与欲」的那类人相符合。不过，我一开始并不觉得有什么不好。只要能享受当下的状态，有没有自己爱的人陪伴在身边又有什么关系呢？关键是如何让自己保持享受一个人的状态，而不是想要摆脱一个人的状态而不得。这两种状态本身是互相矛盾的，但是在不同的阶段下却都有可能体验到。我在想，也许，我期待的并不是爱情，而是希望能有更多的朋友吧，至少要有一个能够无话不谈同时又能理解对方的人。但是，大多数时候，身边就只有熟人而已。那些日常的沟通都是流于表面的，而且不太可能随随便便就遇到一个会打开心扉和你聊彼此内心深处最真实的想法的人，比如那些看起来毫无意义的话题以及你的一些私密的、显得有点滑稽可笑的困惑。突然想起来，工作、交友、恋爱，这是阿德勒心理学所说的人生三大课题，能把这三个课题处理好的人，过得幸福是必然的。这样说起来，自己在后两个课题上花的时间和精力的确都有点少。但是也没办法，一步步来吧，改变都是从点滴开始的。</p><h4 id="5-月-21-日-尽可能保持真实"><a href="#5-月-21-日-尽可能保持真实" class="headerlink" title="5 月 21 日 - 尽可能保持真实"></a>5 月 21 日 - 尽可能保持真实</h4><p>人的想法一直在变，今天的我和昨天的我虽然身体组成没有变化，但是在心理状态和感受上可能判若两人。没有人能解释我们为什么会发生这种变化，而且我们也无法控制这种变化的发生。有时候可能就是灵光一闪。过去的经历，读过的文字，甚至最近饮食方式的改变，造成荷尔蒙分泌的变化，最终促成了我们的改变。而且这种改变除了不受我们控制之外，也不能说是好的或者是坏的。<strong>我们唯一可以控制的是，尽可能地保持真实。</strong>每天都能越来越真实地面对自己。我是什么样的人？我想要成为什么样的人？我所做的事有没有价值？我是在做正确的事吗？还是只是在做别人告诉我应该做的事？真实的含义是听从自己的内心，选择善良和爱，为他人创造价值，尽可能地保持简单和直接。很难，但是坚持下去，效果总会慢慢显现出来。你不再感到害怕和恐惧，你会变得更加勇敢，更能体会到幸福和快乐。我们需要的东西其实并不多，一点点食物和水，以及晚上有个睡觉的地方，其它任何东西都是多余的。阻碍我们感到幸福的，其实是我们内心的欲望。当你意识到自己的价值不在于拥有多少物质的时候，你所做的事都是为了自己和他人的幸福的时候，你会发现那些纠结、迷茫、受挫感和过高的期望都是没有必要的，只要用心做好眼下的那一件件小事就好了。活着的每一天都是上天的恩赐。</p><h4 id="5-月-22-日-洪流中的一滴小水珠"><a href="#5-月-22-日-洪流中的一滴小水珠" class="headerlink" title="5 月 22 日 - 洪流中的一滴小水珠"></a>5 月 22 日 - 洪流中的一滴小水珠</h4><p>关于人生意义的话题已经谈过很多次，但是最近想的比较多，那就再聊聊吧。我觉得人生本质上是没有意义的。我们从最初来到这个世界上就是极偶然的事件，一开始就要躲过各种复杂的险境才能最终变成胚胎。而形成胚胎后到出生前的这段时期里能否安全成长为健康的婴儿，又取决于各种复杂的变量，包括一开始的基因，还有环境中各种诱发基因发生突变的因素。等到出生以后，基因和胚胎环境就不是唯一需要考虑的变量了，我们的家庭和社会环境开始接手缓慢塑造我们的过程。而在成长为具有独立思考能力的个体之前，我们还需要经历无数感到困惑不解的时刻，需要解决各种各样的困难，包括身体上的和认知上的，才能最终获得自由。</p><p>接下来，我们会根据已有的经验慢慢地对这个世界形成自己的认知，或随波逐流，或追逐欲望，或追逐内心，大多数人都会在探索、尝试和误打误撞中过完自己的一生。「人总是按照他自己的想法去塑造身边的世界，最终他只能看到他想要看到的世界。」我们努力奋斗的动力来自于我们相信什么，我们觉得什么东西是有价值的、值得追求的，以及我们想要过什么样的生活。而这些想法可能并不是来源于我们自身，而是来源于我们所受的教育，包括之前生活在这个星球上的人的知识和经验，另外再加上所处社会环境对我们的期待，以及我们自身想要获得认可的欲望，最终我们形成了自己的那些「独特」的理想。</p><p>对个体而言，过上自己想要的生活，完成自己的目标，实现自己的理想，把世界改造成自己想要看到的样子，这就是全部的人生意义了。但是，对于人类整体而言，其实我们并没有改变任何东西。人类的进步是非常缓慢的。绝大多数人都无法做出改变人类的创造或者贡献。那样的人在人类历史上都屈指可数。我们靠的是一点一滴的积累。大多数人存在的最大的意义是对基因的传承。没错，就只是为了繁殖而已。不过，正是因为从宏观的角度看，我们的人生并没有什么意义，所以现在才有越来越多的人开始追求寻找个体的人生意义，比如获得幸福和快乐。我觉得这是一个好的趋势，越多人加入这个行列，这个世界就越是变得更加丰富多彩。而我，也只是这个洪流中的一滴小水珠而已。</p><h4 id="5-月-23-日-抵抗大脑中的噪音"><a href="#5-月-23-日-抵抗大脑中的噪音" class="headerlink" title="5 月 23 日 - 抵抗大脑中的噪音"></a>5 月 23 日 - 抵抗大脑中的噪音</h4><p>如何抵抗大脑中的噪音？我们有时候感到迷茫，其实不是不知道该追求什么，而只是在他人观点的影响下，开始怀疑自己。想的越多，就越是心烦意乱。其实他们的观点也没错，只不过不适合当下的场景而已。你要做的，是坚守自己的本心。要相信自己的判断和选择。他人无法为你的生活做决定，只有你自己才能决定如何生活。即使最终证明这是一个错误，你也只有在犯错之后才能得到教训，获得成长。年轻的时候，犯错并不可怕，我们的经验来源于过去走过的弯路，我们需要从中学习，从而避免犯同样的错误。智慧就是这样慢慢增长的。做自己擅长的事，勤奋一点，不走捷径，不怕孤独，有耐心，慢慢成长，能做到这样就很了不起了。加油！</p><h4 id="5-月-24-日-让心安定"><a href="#5-月-24-日-让心安定" class="headerlink" title="5 月 24 日 - 让心安定"></a>5 月 24 日 - 让心安定</h4><p>昨晚半夜做梦醒来，然后就失眠了。躺在床上想了很多，关于家人，关于朋友，关于未来。最后想明白了，孤独对我来说其实没什么影响，让自己感到焦虑的，归根结底，还是自己的能力。以前总是以为要有很多朋友围绕在自己身边才会开心，但其实不是的，我希望我的好朋友以及恋人都是优秀的人，但是这需要自己的能力配得上才行。能力就是能做多大的事，你的工作就反应了你的能力。工作其实不仅仅是为了获得立身之本，更是为了让自己得到一个心安的归宿，这也是为什么那么多人强调要找到自己的「热爱」所在。只要你做的事情能够让你的心安定下来，即使在外人看来是在吃苦，但只要你不觉得，并且也愿意一直做下去，那么你就不会感到害怕。朋友也好，恋人也好，他们都无法帮你完成这个任务，只有你自己才能想清楚自己的道路在哪。当你找到自己的使命所在，并且决定要做出一番事业的时候，这个时候如果再加上有朋友恋人的帮助、指导和安慰，你才能走得更远。</p><h4 id="5-月-25-日-焦虑促使改变"><a href="#5-月-25-日-焦虑促使改变" class="headerlink" title="5 月 25 日 - 焦虑促使改变"></a>5 月 25 日 - 焦虑促使改变</h4><p>现在觉得，焦虑其实也不完全是负面的，如果利用好它，可以让人朝好的方向改变。最近一段时间，焦虑到每晚失眠，内心对自我极度贬低，心态失衡。但是，冷静之后，发现这一切除了说明自己还有很多地方需要提高之外，并没有其它意义。承认自己的能力没有达到过去的预期，面对现实，然后从现在开始慢慢积累，就行了。从技术能力到人际交往方面，既然过去没做好，那现在就开始好好行动起来，不要再逃避这些问题。焦虑并不能解决问题，但是能让你意识到问题在哪，然后逼迫自己去改变。虽然改变也是一条漫长的道路，可能还会反复出现这样的场景，但是人生就是这样吧，不断犯错，不断面对新的困难和挑战。不过，只要我们能保持反省和自我纠正的习惯，总归是会获得一些成长的。</p><h4 id="5-月-26-日-每日自省"><a href="#5-月-26-日-每日自省" class="headerlink" title="5 月 26 日 - 每日自省"></a>5 月 26 日 - 每日自省</h4><p>我觉得自己目前身上最大的问题是，不会和人沟通。自己本身是性格内向的人，又加上非常害羞，遇到难题从来不会寻求别人的帮助，总是一个人扛着，直到随着时间越拖越久，问题暴露出来引起他人的注意之后，才不得不让他人介入来帮我一把，其实本来自己早一点主动把问题说出来就好了。这一方面是自己性格的原因，但最关键的还是心态问题。我总是非常恐惧他人对我的负面评价，害怕他人不喜欢我，害怕暴露出自己的弱点，但其实你越是这样，他人对你的印象反而不好。没有人是完美的，只要你能展现真实的自己，别人如何评价你又有什么重要的呢？还有就是，要对自己的能力有自信，不要以为自己不如别人，尤其是和同事相处的时候。既然你们能当同事，那就说明你不比别人差，即使别人真的比你强很多，那你向他学习不就好了，真正的强者都是乐于帮助别人的。再有就是接受现实的能力，如果你无法改变现状，那就坦然接受它。</p><h4 id="5-月-27-日-半梦半醒时做的梦"><a href="#5-月-27-日-半梦半醒时做的梦" class="headerlink" title="5 月 27 日 - 半梦半醒时做的梦"></a>5 月 27 日 - 半梦半醒时做的梦</h4><p>第一个梦：去一个地方，路过一家人，主人家小孩和小侄子在一起玩，然后不知怎么他俩闹矛盾了，主人家小孩受了伤躺在床上，最后我们却偷偷溜走了。回来路上又经过相同的地方，看到了袋鼠钻进气球里跳跃的画面。我们决定上那家人家里给主人家小孩赔礼道歉，主人家小孩终于原谅小侄子了，我们如释重负，但是没想到他俩刚一接触，主人家小孩一张嘴把小侄子的整只手给咬了下去，还像蛇一样一直往下吞。然后我就吓醒了。</p><p>第二个梦：去一个地方，有很多人，还有不少亲戚也在，我特别活跃，说了很多话，大家都很开心，后来我躺在一个从外面看上去像个笼子、用竹藤做的转床里，我看着天花板一直转啊转，然后突然在某一刻停了下来，我又醒了。</p><p>我觉得一个人必须具备的能力是：无论遇到什么样的困难，他都能有勇气独自面对，并且相信自己一定能解决它。</p><h4 id="5-月-28-日-痛苦使人成长"><a href="#5-月-28-日-痛苦使人成长" class="headerlink" title="5 月 28 日 - 痛苦使人成长"></a>5 月 28 日 - 痛苦使人成长</h4><p>这段时间过得真的挺不堪的。虽然从外表上几乎看不出来，每天照常早睡早起、锻炼、冥想、上下班、跑步，但是内心经历了各种纠结和痛苦。一是被焦虑折磨，觉得自己没钱，能力也不够，未来可能无法过上自己想要的生活；二是交友问题，长这么大还没有经历过任何一段亲密关系，身边也没有好朋友，就连普通朋友也一个都没有，觉得自己可能要一直这么下去直到孤独终老；三是工作问题，不喜欢当下的工作环境，公司和第一家公司没啥区别，现在主要靠接外包项目运转，没想到自己到头来还是跳回了这样的环境，而且和同事关系也相处得不怎么好，每天都感到孤独，还找不到可以倾诉的人。</p><p>不过，事情还是迎来了转机。早上看了一篇<a href="https://mp.weixin.qq.com/s/_kQi6ELdX3vlycE0pFwX_Q">推送文章</a>，突然间觉得非常害臊，想起过去的自己，眼前的这点困难算什么？而且我当初选择这一行的初心是什么，不就是因为这一行靠努力就能改变自己的生活吗？既然对当下现状不满意，不是应该更加努力才对吗？有那么多过的比你好、面对的困难比你大的多的人都在更勤奋努力地工作、为他人创造价值，你不是应该更加努力吗？每天进步一点点，不是靠嘴上说就有用的，还是得拿出实际行动来才行。所以，好好工作，好好生活。光是焦虑有用的话，那么这个世界上就不会有那么多郁郁不得志的醉汉了。另外，心态要摆正。现在公司老板算是不错的了，作为员工你也要好好干活。不过，谁也不欠谁的，保持互相尊重就好了。至于同事喜不喜欢自己，无所谓的啦，不要有太多心理负担。</p><p>至于交友问题，主要还是得靠自己。都说 30 以后就很难再交到好朋友了，但是我不这么认为。我觉得一个人只要保持开放，保持学习，哪怕到 40 岁、50 岁，都是可以交到知心的好朋友的。就看你愿不愿意改变自己了。我一直是一个被动的人，我觉得这是我最需要改变的地方。首先，要维护好现有的人际关系，比如多主动联系家人和不常沟通的朋友，然后是积极拓展人脉，无论是在线上还是在线下。多参加一些线下的活动，在网上变得活跃一些等等。最最重要的一点是，要不断提高自己的价值，让自己成为一个大家都想要与你交往的人。</p><h4 id="5-月-29-日-更积极的生活态度"><a href="#5-月-29-日-更积极的生活态度" class="headerlink" title="5 月 29 日 - 更积极的生活态度"></a>5 月 29 日 - 更积极的生活态度</h4><p>有时候想想，自己真的挺幸福的，有支持、理解我的家人，有还算不错的工作，有好观念，没有拖累我的人际关系，想做什么就可以去做，还有什么可抱怨的呢？我觉得这样的人生就挺完美的了。如果一定要和他人比较，那么肯定会感到不幸福，因为永远都有比你拥有得更多的人。但是，我觉得人应该学会知足。想要什么还是得靠自己去争取，我们往往不会珍惜轻易就能够得到的东西。而且人生最珍贵的东西还是经历吧，拥有的物质多少并不重要，只有自己的体验才是最真实宝贵的。每个人都有自己的路，每种人生都是独一无二的，我们无法感受他人所能感受到的东西。所以，把握好自己的人生，尽全力去体验更多不曾体验过的经历和情感，去面对自己必须面对的困难，去阅读、去接触各种未曾思考过的问题和思想，去尽可能多地认识这个世界，去认识各种各样不同的人，挖掘出人生更多的可能性，去努力追逐自己的梦想，去学习自己想学的东西，去积累财富，去养成新习惯，去感受希望和失望。保持开放，保持学习，保持积极向上的心态，尽可能地把每一天都过得充实，这寻找人生的意义所在。</p><h4 id="5-月-30-日-努力去认识这个丰富多彩的世界"><a href="#5-月-30-日-努力去认识这个丰富多彩的世界" class="headerlink" title="5 月 30 日 - 努力去认识这个丰富多彩的世界"></a>5 月 30 日 - 努力去认识这个丰富多彩的世界</h4><p>「这个世界比你想象的大多了」，这是我昨天在刷 YouTube 时候的感慨。东南亚丰富的美食、沙滩、宗教，还有华侨、日侨、韩侨、印度人在这里建立的社区等等，马来、新加坡简直就是各个民族的大熔炉，印尼广阔的穆斯林人口和独特的文化。欧洲就更不用说了，文化、语言、历史都丰富到令人目不暇接，从北欧到南欧，从英伦三岛到巴尔干半岛，光是宗教建筑就让人不得不感叹人类的创造力实在是丰富。还有中东，对中国人来说，这里简直就是另外一个世界，这里孕育了人类最早的城市，拥有古老的历史，文化、宗教也都极度繁荣。往北各种斯坦国家，从地表的景色来看，也是和我们国家完全不同。还有俄罗斯，从莫斯科到远东，生活着从长相看起来就完全不同的人。即使是与我们相邻的蒙古，对这个国家的了解也不多，而他们的生活、饮食和文化其实也非常有意思。往南，巴基斯坦、印度、孟加拉，人口加起来都快 18 亿了，那里的人的生活方式、城市景色的丰富多样也远远超过我们的想象。亚、欧只是这个世界的一部分，还有中美洲、加勒比地区、南美洲，那是完全不同的另一块大陆，更不要说整个非洲大陆几十个国家了。这个世界太大了，而人生这么短暂，希望自己有生之年可以有机会多去走走看看。不过，当下的要务是努力成长，不断积累，无论是财富，还是学识和眼界。努力吧！</p><h4 id="5-月-31-日-养成好习惯"><a href="#5-月-31-日-养成好习惯" class="headerlink" title="5 月 31 日 - 养成好习惯"></a>5 月 31 日 - 养成好习惯</h4><p>养成一个习惯真的太难了，从一开始的改变自己的行为模式，到长期坚持下去所需要的毅力，还有偶尔打破习惯后重新开始的勇气，每一个好习惯都见证了我们和自己的原始欲望和懒惰抗争的过程。不过也正因如此，我们才更应该珍惜那些好不容易才养成的好习惯。我觉得一个人只要养成了一个好习惯，比如跑步，那么他就一定可以慢慢养成其它好习惯，因为一个人只要有一次机会能认识到，改变自己过去的习惯给自己的生活能多大带来的变化，他就会忍不住不断地去挑战自己的舒适区。不过，坚持一个习惯又是另外一件事了，需要我们不断提醒自己这件事的好处，让它变得有吸引力，而且具有奖励性，有时还需要一些手段来让它显而易见和更容易开始行动，只有这样我们才能真正养成一个好习惯。不过，一旦习惯养成之后，我们只需要享受它给我们生活带来的便利就好了，它会变成我们日常生活的一部分，我们甚至意识不到自己过去和现在的生活已经发生了多大的改变。这就是习惯的力量。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 学习笔记</title>
      <link href="/kotlin-notes/"/>
      <url>/kotlin-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Kotlin_logo_2021.svg/1280px-Kotlin_logo_2021.svg.png" alt="kotlin_logo"></p><blockquote><p>阅读<a href="https://kotlinlang.org/docs/home.html">文档</a>和《<a href="https://book.douban.com/subject/27093660/">Kotlin in Action</a>》做的一些笔记。</p></blockquote><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a><a href="https://kotlinlang.org/docs/coding-conventions.html">代码规范</a></h2><h3 id="源码组织"><a href="#源码组织" class="headerlink" title="源码组织"></a>源码组织</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>在纯 Kotlin 的项目中，推荐的目录结构是省略根包名。如果包名是 <code>com.example.kotlin</code>，那么所有的代码都应该在这个根目录之下，比如 <code>org.example.kotlin.network.socket</code> 中的文件就应该放在 <code>network/socket</code> 子目录下。</p><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><p>如果文件中只包含一个类（包括顶层声明），则它的文件名应该和类名保持一致。如果文件包含多个类、顶层声明等，则应该选择最能描述这些类作用的命名，尽量选择清晰易懂的名称，如果做不到就应该使用多个文件分别保存。对于命名风格应该选择大驼峰命名法，并且应该避免使用一些无意义的后缀，比如 util 等。</p><span id="more"></span><h4 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h4><p>如果多个类相互关系密切，并且描述的是同一个功能，那么推荐将它们放在同一个文件，只要最终的文件不是太长就可以。尤其是当我们需要为类定义一些扩展方法的时候，如果扩展方法只和当前类有关，那么就应该把这些扩展方法放到类一起，而不是单独创建一个文件用于保存扩展方法。</p><h4 id="类的内容排布"><a href="#类的内容排布" class="headerlink" title="类的内容排布"></a>类的内容排布</h4><p>类的各部分排列应该按照以下顺序：</p><ol><li>属性声明和初始化代码块</li><li>从构造器</li><li>方法声明</li><li>伴生对象</li></ol><p>初次之外，不要将方法根据首字母顺序排序，或者根据可见性排序，也不要将普通方法和扩展方法分开来，而是应该将相关的方法放在一起，根据功能依次排列，这样阅读你的代码的人才能方便地从上到下阅读你的代码，而不是频繁地来回跳转寻找相关代码。推荐将关键方法放到上面，然后是较基础和底层的方法。</p><p>对于嵌套类来说，推荐将它们放到使用到这些类的地方。如果嵌套类只是被外界使用，则可以将它们放到类的底部，位于伴生对象之后。</p><h4 id="实现接口时的排布"><a href="#实现接口时的排布" class="headerlink" title="实现接口时的排布"></a>实现接口时的排布</h4><p>保持类中实现的各个方法的顺序和接口中方法定义顺序一致，如果有私有方法的话，应该放在实现的方法附近。</p><h4 id="重载方法的排布"><a href="#重载方法的排布" class="headerlink" title="重载方法的排布"></a>重载方法的排布</h4><p>永远要把重载方法放在一起，方便阅读者看到一个方法全部的重载方法。</p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>包名和类名的命名规则：</p><ul><li>包名由小写单词和 <code>.</code> 构成，且不能使用下划线，多个单词推荐使用 <code>.</code> 分割或者直接拼接。</li><li>类名使用 UpperCamelCase，大驼峰命名。</li></ul><h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>方法名、属性名、局部变量都应该使用小写字母开头，并且使用驼峰命名法，且不能使用下划线。只有工厂方法才可以使用与类名相同的方法名。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span></span>: Foo &#123; <span class="hljs-keyword">return</span> FooImpl() &#125;<br></code></pre></td></tr></table></figure><h4 id="测试方法的命名"><a href="#测试方法的命名" class="headerlink" title="测试方法的命名"></a>测试方法的命名</h4><p>只有在测试方法中才可以使用反引号，但是注意安卓运行环境下并不支持这种方式，不过可以使用下划线。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestCase</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> `ensure everything works`<span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">/*...*/</span> &#125;<br><br>    <span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ensureEverythingWorks_onAndroid</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">/*...*/</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="属性名"><a href="#属性名" class="headerlink" title="属性名"></a>属性名</h4><p>常量，被标记为 <code>const val</code> 的属性，以及没有自定义 getter、数据不可变的 <code>val</code> 属性应该使用大写字符+下划线分割：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MAX_COUNT = <span class="hljs-number">8</span><br><span class="hljs-keyword">val</span> USER_NAME_FIELD = <span class="hljs-string">&quot;UserName&quot;</span><br></code></pre></td></tr></table></figure><p>顶层变量或者类的成员属性如果携带可变数据，则应该使用小驼峰命名法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> mutableCollection: MutableSet&lt;String&gt; = HashSet()<br></code></pre></td></tr></table></figure><p>如果表示单例对象，则命名应该和对象声明保持一致：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> PersonComparator: Comparator&lt;Person&gt; = <span class="hljs-comment">/*...*/</span><br></code></pre></td></tr></table></figure><p>枚举类的命名应该和 Java 中的命名保持一致：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span> </span>&#123; RED, GREEN, LIGHT_BLUE &#125;<br></code></pre></td></tr></table></figure><h4 id="幕后属性的命名"><a href="#幕后属性的命名" class="headerlink" title="幕后属性的命名"></a>幕后属性的命名</h4><h5 id="幕后字段"><a href="#幕后字段" class="headerlink" title="幕后字段"></a>幕后字段</h5><p>一个类中通常包含属性（Property）和字段（Field），外界不可直接访问字段，一般是通过属性提供对字段的访问，有时属性中还包括对字段的计算和转换，然后再返回。Kotlin 中的属性分为只读的（通过 <code>val</code> 声明）和可变的（通过 <code>var</code> 声明），除此之外，我们还可以为属性提供自定义的访问器（getters &amp; setters）。</p><p>Kotlin 中的字段无法显式被声明（我们只能创建属性），但是，当属性需要用到字段的时候，Kotlin 会默认它自动生成幕后字段（backing field），这个幕后字段可以在访问器通过 <code>field</code> 关键字进行调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span> <span class="hljs-comment">// the initializer assigns the backing field directly</span><br>    <span class="hljs-keyword">set</span>(value) &#123;<br>        <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0</span>)<br>            field = value<br>            <span class="hljs-comment">// ERROR StackOverflow: Using actual name &#x27;counter&#x27; would make setter recursive</span><br>            <span class="hljs-comment">// counter = value</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>只有在使用了至少一个默认的访问器或者自定义访问器中引用了 <code>field</code> 才会生成幕后字段，下面这个例子中就没有幕后字段：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 没有初始化器而且自定义访问器中没有调用 field，此时就不会有幕后字段。</span><br><span class="hljs-keyword">val</span> isEmpty: <span class="hljs-built_in">Boolean</span> <span class="hljs-comment">// 只要有初始化器，则必定会生成幕后字段；没有幕后字段就不能被初始化。</span><br>    <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span>.size == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="幕后属性"><a href="#幕后属性" class="headerlink" title="幕后属性"></a>幕后属性</h5><p>如果你不喜欢这种隐式的幕后字段，则可以使用幕后属性，也就是通过在类的内部维护一个可读可写的属性，然后对外界提供一个只读的属性：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><br><span class="hljs-strong"><span class="markdown"><span class="hljs-comment"> <span class="hljs-emphasis">* 外部只能通过 table 来访问，但实际上访问的是 _table</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="markdown"><span class="hljs-comment"> *</span> 类似于 Java 中通过设置 Getter 和 Setter 来控制对属性的访问</span></span></span><br><span class="hljs-strong"><span class="markdown"><span class="hljs-comment"> <span class="hljs-emphasis">* *</span>/</span></span></span><br>private <span class="hljs-keyword">var</span> _table: <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Int&gt;? = <span class="hljs-keyword">null</span><br>val table: <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Int&gt;<br>    <span class="hljs-keyword">get</span>() &#123;<br>        <span class="hljs-keyword">if</span> (_table == <span class="hljs-keyword">null</span>) &#123;<br>            _table = HashMap()<br>        &#125;<br>        <span class="hljs-keyword">return</span> _table ?: <span class="hljs-keyword">throw</span> AssertionError(<span class="hljs-string">&quot;Set to null by another thread&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure><p>在命名幕后字段时，私有属性应该使用下划线作为开头。</p><h4 id="如何选择名称"><a href="#如何选择名称" class="headerlink" title="如何选择名称"></a>如何选择名称</h4><p>类名应该以名词为结尾，描述该类的作用或功能。类名应该避免使用一些无意义的单词，比如前面提到过的 Util，还有 Manager/Wrapper 等等。</p><p>方法名应该是动词或者动词短语，描述方法的功能或执行哪些操作，并且应该表明是否会修改对象或者返回一个新的对象，比如 sort 和 sorted。</p><p>对于缩写词，应该尽量少用，除非是特别常见的，比如 <code>IO</code>/<code>TV</code> 等等，或者是在当前项目的文档中注明过的常见缩写。如果是两个字母以上的缩写，应该当做普通的单词使用，比如 <code>HttpConnection</code>/<code>XmlParser</code> 等等。</p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>打开 IDE (IDEA/Android Studio) 的 <strong>Preferences &gt; Editor &gt; Code Style &gt; Kotlin</strong>，使用默认设置，全部看一遍就够了。</p><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>使用四个空格作为缩进，不要使用 Tab。</p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>如果类的签名很长，主构造函数中的参数很多，实现的接口很多时，都应该使用换行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<br>    id: <span class="hljs-built_in">Int</span>,<br>    name: String,<br>    surname: String<br>) : Human(id, name),<br>    KotlinMaker,<br>    SomeOtherInterface,<br>    AndAnotherOne &#123;<br>    <br>    <span class="hljs-comment">// 这种情况下类的第一行应该使用空白行增加可读性</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>同理，如果方法签名很长，应该使用换行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">longMethodName</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    argument: <span class="hljs-type">ArgumentType</span> = defaultValue,</span></span><br><span class="hljs-params"><span class="hljs-function">    argument2: <span class="hljs-type">AnotherArgumentType</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: ReturnType &#123;<br><br>    <span class="hljs-comment">// body</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="表达体"><a href="#表达体" class="headerlink" title="表达体"></a>表达体</h4><p>如果方法体只有一行代码，或者只有返回值，则应该使用表达体：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// = 后面就是表达体(expression bodies)</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> = value.size()<br><br><span class="hljs-comment">// 当表达体很长时，使用换行并添加 4 个空格</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f</span><span class="hljs-params">(x: <span class="hljs-type">String</span>, y: <span class="hljs-type">String</span>, z: <span class="hljs-type">String</span>)</span></span> =<br>    veryLongFunctionCallWithManyWords(andLongParametersToo(), x, y, z)<br></code></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>如果是比较简单的属性，应该放在同一行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> isEmpty: <span class="hljs-built_in">Boolean</span> <span class="hljs-keyword">get</span>() = size == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>如果 getters/setters 比较复杂，则应该换行并使用缩进：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> foo: String<br>    <span class="hljs-keyword">get</span>() &#123;<br>        <span class="hljs-comment">// body</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>如果初始化器比较长，同样应该换行并使用缩进：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> defaultCharset: Charset? =<br>    EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)<br></code></pre></td></tr></table></figure><h4 id="控制流程语句"><a href="#控制流程语句" class="headerlink" title="控制流程语句"></a>控制流程语句</h4><p>如果 if 或 when 中包含多个语句，必须使用花括号，并且每个条件或者语句都要使用缩进，与第一个语句条件对齐：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (!component.isSyncing &amp;&amp;<br>    !hasAnyKotlinRuntimeInScope(module) ||<br>    (someOtherCondition &amp;&amp; andSomeMore)<br>) &#123;<br>    <span class="hljs-keyword">return</span> createKotlinNotConfiguredPanel(module)<br>&#125;<br></code></pre></td></tr></table></figure><p>when 语句中，只有在分支包含多个表达式时才使用花括号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parsePropertyValue</span><span class="hljs-params">(propName: <span class="hljs-type">String</span>, token: <span class="hljs-type">Token</span>)</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (token) &#123;<br>        condition1 -&gt; shortCondition()<br>        <span class="hljs-keyword">is</span> Token.ValueToken -&gt;<br>            callback.visitValue(propName, token.value)<br>      <br>        Token.LBRACE -&gt; &#123;<br>          <span class="hljs-comment">// long body</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>如果方法的参数较多，使用换行，并将多个相近的参数放在同一行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">drawSquare(<br>    x = <span class="hljs-number">10</span>, y = <span class="hljs-number">10</span>,<br>    width = <span class="hljs-number">100</span>, height = <span class="hljs-number">100</span>,<br>    fill = <span class="hljs-literal">true</span><br>)<br></code></pre></td></tr></table></figure><h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> anchor = owner<br>    ?.firstChild!!<br>    .siblings(forward = <span class="hljs-literal">true</span>)<br>    .dropWhile &#123; it <span class="hljs-keyword">is</span> PsiComment || it <span class="hljs-keyword">is</span> PsiWhiteSpace &#125;<br></code></pre></td></tr></table></figure><h4 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h4><p>如果方法只接收一个 lambda 表达式，方法体应该放在括号外面并省略括号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">list.filter &#123; it &gt; <span class="hljs-number">10</span> &#125;<br></code></pre></td></tr></table></figure><p>如果给 lambda 指定了标签，标签和花括号之间不能有空格：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    ints.forEach <span class="hljs-symbol">lit@</span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 lambda 中指定了参数名，则应该使用换行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">appendCommaSeparated(properties) &#123; prop -&gt;<br>    <span class="hljs-keyword">val</span> propertyValue = prop.<span class="hljs-keyword">get</span>(obj)<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果 lambda 中的参数列表很长，则应该使用换行并将 <code>-&gt;</code> 单独放在一行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">foo &#123;<br>   context: Context,<br>   environment: Env<br>   -&gt;<br>   context.configureEnv(environment)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拖尾逗号"><a href="#拖尾逗号" class="headerlink" title="拖尾逗号"></a>拖尾逗号</h4><p>当参数或者值的列表很长时，应该使用拖尾逗号 (<em>Trailing commas</em>)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@ApplicableFor([</span><br><span class="hljs-meta">    <span class="hljs-meta-string">&quot;serializer&quot;</span>,</span><br><span class="hljs-meta">    <span class="hljs-meta-string">&quot;balancer&quot;</span>,</span><br><span class="hljs-meta">    <span class="hljs-meta-string">&quot;database&quot;</span>,</span><br><span class="hljs-meta">    <span class="hljs-meta-string">&quot;inMemoryCache&quot;</span>, // trailing comma</span><br><span class="hljs-meta">])</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<br>    <span class="hljs-keyword">val</span> firstName: String,<br>    <span class="hljs-keyword">val</span> lastName: String,<br>    <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>, <span class="hljs-comment">// trailing comma</span><br>) &#123;<br><br>    <span class="hljs-keyword">val</span> colors = listOf(<br>        <span class="hljs-string">&quot;red&quot;</span>,<br>        <span class="hljs-string">&quot;green&quot;</span>,<br>        <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-comment">// trailing comma</span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>当文档注释较长时，应该使用换行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This is a summary, what this class does, blablabla...</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * More detailed description, explain how this works,</span><br><span class="hljs-comment"> * how to use it, and maybe add some sample codes.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwesomeClass</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>文档注释中，尽量不要使用 @param 或者 @return，而是尽可能地使用叙述性的文字，这样可以增加可读性。只有在参数特别多、解释性文字特别长时，才使用它们。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the absolute value of the given [number].</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">abs</span><span class="hljs-params">(number: <span class="hljs-type">Int</span>)</span></span> &#123; <span class="hljs-comment">/*...*/</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="习惯用法"><a href="#习惯用法" class="headerlink" title="习惯用法"></a>习惯用法</h3><h4 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h4><p>倾向于使用不可变的数据。对于局部变量而言，如果初始化之后不会再进行修改的话，尽量使用 <code>val</code> 声明而不是 <code>var</code>。尽量创建不可变的集合以及使用不可变的集合作为参数，以避免在使用过程中集合被意外改变后产生的各种错误。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Bad: use of mutable collection type for value which will not be mutated</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">validateValue</span><span class="hljs-params">(actualValue: <span class="hljs-type">String</span>, allowedValues: <span class="hljs-type">HashSet</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123; ... &#125;<br><br><span class="hljs-comment">// Good: immutable collection type used instead</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">validateValue</span><span class="hljs-params">(actualValue: <span class="hljs-type">String</span>, allowedValues: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123; ... &#125;<br><br><span class="hljs-comment">// Bad: arrayListOf() returns ArrayList&lt;T&gt;, which is a mutable collection type</span><br><span class="hljs-keyword">val</span> allowedValues = arrayListOf(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>)<br><br><span class="hljs-comment">// Good: listOf() returns List&lt;T&gt;</span><br><span class="hljs-keyword">val</span> allowedValues = listOf(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>尽量为方法创建默认参数。</p><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>如果某个方法签名或者类型参数在你的代码库中被多次使用，那就应该为它创建类型别名：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">typealias</span> MouseClickHandler = (Any, MouseEvent) -&gt; <span class="hljs-built_in">Unit</span><br><span class="hljs-keyword">typealias</span> PersonIndex = Map&lt;String, Person&gt;<br></code></pre></td></tr></table></figure><p>尽量使用 <code>import xxx as xxx</code> 避免命名冲突。</p><h4 id="Lambda-参数"><a href="#Lambda-参数" class="headerlink" title="Lambda 参数"></a>Lambda 参数</h4><p>Lambda 中尽量使用 <code>it</code> 而不是显式指定参数名称，但是如果是在嵌套的 lambda 中，则应该为每个 lambda 表达式指定参数。</p><h4 id="Lambda-返回值"><a href="#Lambda-返回值" class="headerlink" title="Lambda 返回值"></a>Lambda 返回值</h4><p>尽量使得 lambda 表达式的返回值只有一个出口，而不是在多处使用 return，如果无法做到则应该使用匿名方法代替 lambda 表达式。</p><h4 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h4><p>如果调用的方法参数很多且有多个相同类型的参数，或者包含多个布尔值，则应该使用命名参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">drawSquare(x = <span class="hljs-number">10</span>, y = <span class="hljs-number">10</span>, width = <span class="hljs-number">100</span>, height = <span class="hljs-number">100</span>, fill = <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><p>尽量使用条件表达式的返回值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// if </span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (x) foo() <span class="hljs-keyword">else</span> bar()<br><br><span class="hljs-comment">// when</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span>(x) &#123;<br>    <span class="hljs-number">0</span> -&gt; <span class="hljs-string">&quot;zero&quot;</span><br>    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">&quot;nonzero&quot;</span><br>&#125;<br><br><span class="hljs-comment">// try..catch</span><br><span class="hljs-keyword">val</span> readFromInput: <span class="hljs-built_in">Int</span>? = <span class="hljs-keyword">try</span> &#123;<br>    parseInt(input)<br>&#125; <span class="hljs-keyword">catch</span> (e: NumberFormatException) &#123;<br>    <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h4><p>尽量使用高阶函数 (<code>filter</code>, <code>map</code> 等) 而不是循环，除了 <code>forEach</code>。</p><p>在决定使用高阶函数还是循环时，需要考虑使用场景和操作的性能消耗。</p><h4 id="Loops-on-range"><a href="#Loops-on-range" class="headerlink" title="Loops on range"></a>Loops on range</h4><p>需要关闭区间时使用 <code>until</code> 而不是 <code>x..n-1</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// bad:</span><br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.n - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/*...*/</span> &#125;<br><span class="hljs-comment">// good:</span><br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until n) &#123; <span class="hljs-comment">/*...*/</span> &#125;<br></code></pre></td></tr></table></figure><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>尽量使用字符串模板而不是字符串拼接。当需要换行时，优先使用多行字符串而不是 <code>\n</code>。</p><h4 id="Functions-vs-properties"><a href="#Functions-vs-properties" class="headerlink" title="Functions vs properties"></a>Functions vs properties</h4><p>对于没有参数的方法而言，其作用和自定义 getter 的属性是类似的。如果满足下列条件，则应该使用属性：</p><ul><li>不会抛出异常；</li><li>结果的计算是比较轻量级的操作；</li><li>只要对象的状态没有发生变化，调用的结果就不会发生变化；</li></ul><h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4><p>请自由使用扩展方法，如果一个方法在某个对象上被多次调用，那就应该把它设为扩展方法。为了减少 API 污染，应该注意扩展方法的可见性。</p><h4 id="中缀方法-Infix-functions"><a href="#中缀方法-Infix-functions" class="headerlink" title="中缀方法 (Infix functions﻿)"></a>中缀方法 (Infix functions﻿)</h4><p>只有在两个对象角色（功能）类似时才使用中缀方法，正确示例：<code>and</code>, <code>to</code>, <code>zip</code>，错误示例：<code>add</code>。</p><p>不要将一个会改变接收对象的方法定义为中缀方法。</p><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>工厂方法名尽量不要定义成和类名一样，尽量使用能体现其作用的命名，比如 <code>fromXxx</code> 等等。</p><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="Scope-functions"><a href="#Scope-functions" class="headerlink" title="Scope functions"></a>Scope functions</h3><p>Kotlin 标准库中包含了一些在对象的上下文中执行代码块的方法，比如 <code>let</code>, <code>run</code>, <code>with</code>, <code>apply</code>, <code>also</code> 等，在调用这些方法时，会在 lambda 表达式中形成一个临时的 scope，在这个 scope 中，你可以直接访问对象的属性和方法。</p><p>举个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 传统方式调用，需要创建一个变量，然后通过变量来调用其方法</span><br><span class="hljs-keyword">val</span> alice = Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Amsterdam&quot;</span>)<br>println(alice)<br>alice.moveTo(<span class="hljs-string">&quot;London&quot;</span>)<br>alice.incrementAge()<br>println(alice)<br><br><span class="hljs-comment">// 使用 let</span><br>Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Amsterdam&quot;</span>).let &#123;<br>    println(it)<br>    it.moveTo(<span class="hljs-string">&quot;London&quot;</span>)<br>    it.incrementAge()<br>    println(it)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到使用 scope function 可以使我们的代码更简短以及具有可读性。</p><p>本质上来看，所有这些方法的执行效果都是相同的，唯一不同的是对象被调用的方式以及返回的结果不同。所以，我们了解并区分它们的区别，并在合适的场景下调用它们。</p><p>最简单的使用原则可以参考以下几点：</p><ul><li><p>执行一段 lambda 表达式：<code>let</code></p></li><li><p>在当前上下文中，创建一个表达式并使用其结果作为变量：<code>let</code></p></li><li><p>对象构建，比如使用 Builder 模式：<code>apply</code></p></li><li><p>配置对象属性并计算结果：<code>run</code></p></li><li><p>执行需要含有表达式的语句：<code>run</code></p></li><li><p>添加更多效果：<code>also</code></p></li><li><p>将多个方法调用合并到一起：<code>with</code></p></li></ul><p>可以看到，有些功能并不是只有一种方法才能实现，以上只是推荐的做法。另外，虽然使用 scope functions 可以使你的代码更灵活，但是如果过度使用比如使用嵌套等也会降低你的代码的可读性。另外，也要注意链式调用时 context 的变化，比如对象的参数由 <code>it</code> 变成了 <code>this</code> 或者由 <code>this</code> 变成了 <code>it</code>。</p><h4 id="Distinctions"><a href="#Distinctions" class="headerlink" title="Distinctions"></a>Distinctions</h4><p>Scope functions 之间最明显的区别主要有两个：如何引用 context 对象以及返回值。</p><h5 id="Context-object-this-or-it"><a href="#Context-object-this-or-it" class="headerlink" title="Context object: this or it"></a>Context object: this or it</h5><p><code>run</code>, <code>with</code>, <code>apply</code> 都通过 <code>this</code> 引用当前的 context 对象，因此，我们可以像在对象中一样访问它的属性和方法。当然，我们也可以省略 <code>this</code> 关键字，但是，这样做有时候会造成与外部其它代码造成名字冲突，所以，推荐的做法是加上 <code>this.</code> 来访问对象的属性和方法。</p><p>而 <code>let</code> 和 <code>also</code> 则通过 <code>it</code> 引用当前的 context 对象，而且我们需要手动调用 <code>it</code> 来访问对象上的属性和方法，不过这样可以使我们的代码显得更清晰。</p><h5 id="Return-value"><a href="#Return-value" class="headerlink" title="Return value"></a>Return value</h5><p><code>apply</code>, <code>also</code> 返回的是当前的 context 对象本身。因此，它们可以使用链式调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> numberList = mutableListOf&lt;<span class="hljs-built_in">Double</span>&gt;()<br>numberList.also &#123; println(<span class="hljs-string">&quot;Populating the list&quot;</span>) &#125;<br>    .apply &#123;<br>        add(<span class="hljs-number">2.71</span>)<br>        add(<span class="hljs-number">3.14</span>)<br>        add(<span class="hljs-number">1.0</span>)<br>    &#125;<br>    .also &#123; println(<span class="hljs-string">&quot;Sorting the list&quot;</span>) &#125;<br>    .sort()<br></code></pre></td></tr></table></figure><p>也可以被用在 return 语句中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getRandomInt</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> Random.nextInt(<span class="hljs-number">100</span>).also &#123;<br>        writeToLog(<span class="hljs-string">&quot;getRandomInt() generated value <span class="hljs-variable">$it</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>let</code>, <code>run</code>, <code>with</code> 返回的 lambda 表达式的结果。所以，你可以用它们给变量赋值，也可以使用链式调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> numbers = mutableListOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)<br><span class="hljs-keyword">val</span> countEndsWithE = numbers.run &#123; <br>    add(<span class="hljs-string">&quot;four&quot;</span>)<br>    add(<span class="hljs-string">&quot;five&quot;</span>)<br>    count &#123; it.endsWith(<span class="hljs-string">&quot;e&quot;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>在 let 方法中，context 对象以参数 <code>it</code> 的形式存在，返回值是 lambda 表达式的结果。</p><p>使用 let 方法可以帮我们减少创建一些临时变量，尤其是不打破链式调用的结构：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> numbers = mutableListOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>)<br>numbers.map &#123; it.length &#125;.filter &#123; it &gt; <span class="hljs-number">3</span> &#125;.let &#123; <br>    println(it)<br>    <span class="hljs-comment">// and more function calls if needed</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，如果 let 中只包含一个方法调用，可以使用方法引用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">numbers.map &#123; it.length &#125;.filter &#123; it &gt; <span class="hljs-number">3</span> &#125;.let(::println)<br></code></pre></td></tr></table></figure><p>第三种用法是为变量创建一个局部 scope 提升代码的可读性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 需要在第一个数字上做一些操作</span><br><span class="hljs-keyword">val</span> modifiedFirstItem = numbers.first().let &#123; firstItem -&gt;<br>    println(<span class="hljs-string">&quot;The first item of the list is &#x27;<span class="hljs-variable">$firstItem</span>&#x27;&quot;</span>)<br>    <span class="hljs-keyword">if</span> (firstItem.length &gt;= <span class="hljs-number">5</span>) firstItem <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;!&quot;</span> + firstItem + <span class="hljs-string">&quot;!&quot;</span><br>&#125;.uppercase()<br></code></pre></td></tr></table></figure><h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>with 方法是一个非扩展函数，context 对象通过 <code>this</code> 访问，返回值是 lambda 表达式的结果。但是不推荐在 with 方法中返回结果，最好只做一些操作，表示 “<em>with this object, do the following.</em>“</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> numbers = mutableListOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)<br>with(numbers) &#123;<br>    println(<span class="hljs-string">&quot;&#x27;with&#x27; is called with argument <span class="hljs-variable">$this</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;It contains <span class="hljs-variable">$size</span> elements&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>另一种使用场景是使用对象的属性和方法计算值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> numbers = mutableListOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)<br><span class="hljs-keyword">val</span> firstAndLast = with(numbers) &#123;<br>    <span class="hljs-string">&quot;The first element is <span class="hljs-subst">$&#123;first()&#125;</span>,&quot;</span> +<br>    <span class="hljs-string">&quot; the last element is <span class="hljs-subst">$&#123;last()&#125;</span>&quot;</span><br>&#125;<br>println(firstAndLast)<br></code></pre></td></tr></table></figure><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>context 对象通过 <code>this</code> 访问，返回值是 lambda 表达式的结果。</p><p>run 方法的效果和 with 的效果一致，但是调用方式和 let 一样，作为扩展方法。run 适合在既需要对对象进行初始化配置，也需要对结果进行计算的情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> service = MultiportService(<span class="hljs-string">&quot;https://example.kotlinlang.org&quot;</span>, <span class="hljs-number">80</span>)<br><br><span class="hljs-keyword">val</span> result = service.run &#123;<br>    port = <span class="hljs-number">8080</span><br>    query(prepareRequest() + <span class="hljs-string">&quot; to port <span class="hljs-variable">$port</span>&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 使用 let</span><br><span class="hljs-keyword">val</span> letResult = service.let &#123;<br>    it.port = <span class="hljs-number">8080</span><br>    it.query(it.prepareRequest() + <span class="hljs-string">&quot; to port <span class="hljs-subst">$&#123;it.port&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，run 方法还有一个非扩展方法，我们可以用它执行一些需要执行表达式的语句，比如变量声明时：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> hexNumberRegex = run &#123;<br>    <span class="hljs-keyword">val</span> digits = <span class="hljs-string">&quot;0-9&quot;</span><br>    <span class="hljs-keyword">val</span> hexDigits = <span class="hljs-string">&quot;A-Fa-f&quot;</span><br>    <span class="hljs-keyword">val</span> sign = <span class="hljs-string">&quot;+-&quot;</span><br><br>    Regex(<span class="hljs-string">&quot;[<span class="hljs-variable">$sign</span>]?[<span class="hljs-variable">$digits</span><span class="hljs-variable">$hexDigits</span>]+&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>context 对象通过 <code>this</code> 访问，返回值是对象本身。</p><p>当不需要返回值，且主要对对象的成员和方法进行操作的时候可以使用 apply，最常见的是对象初始化配置：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> adam = Person(<span class="hljs-string">&quot;Adam&quot;</span>).apply &#123;<br>    age = <span class="hljs-number">32</span><br>    city = <span class="hljs-string">&quot;London&quot;</span>        <br>&#125;<br></code></pre></td></tr></table></figure><p>由于返回的是对象本身，所以我们可以很方便地进行链式调用。</p><h4 id="also"><a href="#also" class="headerlink" title="also"></a>also</h4><p>context 对象通过 <code>it</code> 访问，返回值是对象本身。</p><p>also 适用于需要对象的引用而不是其属性和方法的场景下，以及你不想污染 <code>this</code> 关键字的时候，可以将其理解为 “<em>and also do the following with the object.</em>“</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> numbers = mutableListOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)<br>numbers<br>    .also &#123; println(<span class="hljs-string">&quot;The list elements before adding new one: <span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>    .add(<span class="hljs-string">&quot;four&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="takeIf-and-takeUnless"><a href="#takeIf-and-takeUnless" class="headerlink" title="takeIf and takeUnless"></a>takeIf and takeUnless</h4><p>除了 scope functions 之外，标准库中还提供了 <code>takeIf</code> 和 <code>takeUnless</code> 方法，可以让我们在使用对象之前对其状态进行检查。</p><p><code>takeIf</code> 只有在对象满足断言时才返回对象，否则返回 null，<code>takeUnless</code> 则恰恰相反，只有在对象不满足断言时才返回对象，否则返回 null，所以 <code>takeIf</code> 和 <code>takeUnless</code> 是对单个对象的筛选方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> number = Random.nextInt(<span class="hljs-number">100</span>)<br><br><span class="hljs-keyword">val</span> evenOrNull = number.takeIf &#123; it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#125;<br><span class="hljs-keyword">val</span> oddOrNull = number.takeUnless &#123; it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#125;<br><br>evenOrNull?.let &#123;<br>    println(<span class="hljs-string">&quot;even: <span class="hljs-variable">$evenOrNull</span>&quot;</span>)<br>&#125;<br>oddOrNull?.let &#123;<br>    println(<span class="hljs-string">&quot;odd: <span class="hljs-variable">$oddOrNull</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于返回值可能为空，所以必须使用 <code>?.</code>。而且可以看到 <code>takeIf</code> 和 <code>takeUnless</code> 非常适合配合 scope functions 使用。</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>和 Java 中一样，Kotlin 中也有类型参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-type">T</span>&gt;</span>(t: T) &#123;<br>    <span class="hljs-keyword">var</span> value = t<br>&#125;<br></code></pre></td></tr></table></figure><p>如果通过构造器创建对象，类型参数也可以被推断出来，所以可以省略：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> box = Box(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="型变"><a href="#型变" class="headerlink" title="型变"></a>型变</h4><p>Java 中的泛型不是型变的，因此会带来很多问题，所以我们一般需要使用通配符来为泛型确定上下边界。Kotlin 中没有通配符类型，而是引入了声明处型变（declaration-site variance）和类型投影（type projections）。</p><h5 id="声明处型变"><a href="#声明处型变" class="headerlink" title="声明处型变"></a>声明处型变</h5><p>先看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br>List&lt;Number&gt; numberList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="hljs-comment">// Incompatible types</span><br></code></pre></td></tr></table></figure><p>类似 <code>List</code> 这样的声明在 Java 中是不被允许的，因为 Java 中泛型不支持<em>协变</em>（Covariant，即 <code>A</code> 是 <code>B</code> 的父类，同时 <code>List&lt;A&gt;</code> 也是 <code>List&lt;B&gt;</code> 的父类，则称 List 类是协变的），我们需要使用通配符来告诉编译器这种声明是安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;? extends Number&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>而在 Kotlin 中，我们通过 <code>out</code> 标注类型参数来支持协变，并且确保它只是被返回（生产）从不被消费：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">List</span>&lt;<span class="hljs-type">out T</span>&gt; : <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>)</span></span>: T <span class="hljs-comment">// 返回类型叫 out 位置，生产类型为 T 的元素</span><br>  <br>    <span class="hljs-comment">// 参数类型叫 in 位置，它消费类型为 T 的值。使用 @UnsafeVariance 是为了避免编译器报错</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(element: @<span class="hljs-type">UnsafeVariance</span> <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">copyList</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> source: List&lt;Number&gt; = list <span class="hljs-comment">// 现在可以被允许了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个原则，如果一个类 C 的类型参数 <code>T</code> 被声明为 <code>out</code> 时，它就只能出现在 C 的成员的输出位置（返回类型），回报是 <code>C&lt;Base&gt;</code> 可以安全地作为 <code>C&lt;Derived&gt;</code> 的父类。这样，我们就可以称类型参数 <code>T</code> 在 C 上是协变的。你可以认为 C 是 <code>T</code> 的生产者，而不是 <code>T</code> 的消费者。</p><p><code>out</code> 修饰符称为<em>型变注解</em>，并且由于它在类型参数声明处提供，所以我们称之为<strong>声明处型变</strong>。Java 中是在使用处通过通配符使得类型型变，Kotlin 与之正好相反。</p><p>另外，与之相对的，Kotlin 中还提供了另一个型变注释 <code>in</code>，它的作用是使得类型参数<em>逆变</em>（Contravariant，如果 <code>A</code> 是 <code>B</code> 的父类，那么 <code>List&lt;A&gt;</code> 就是 <code>List&lt;B&gt;</code> 的子类型），只可以被消费而不能被生产。逆变类型的一个很好的例子是 <code>Comparable</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-type">in T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(other: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showContravariant</span><span class="hljs-params">(x: <span class="hljs-type">Comparable</span>&lt;<span class="hljs-type">Number</span>&gt;)</span></span> &#123;<br>    x.compareTo(<span class="hljs-number">1.0</span>) <span class="hljs-comment">// 参数 1.0 的类型 Double，它是 Number 的子类型</span><br>    <span class="hljs-comment">// 因此，我们可以将 x 赋给类型为 Comparable&lt;Double&gt; 的变量</span><br>    <span class="hljs-keyword">val</span> y: Comparable&lt;<span class="hljs-built_in">Double</span>&gt; = x <span class="hljs-comment">// OK！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下，我们使用 <code>out</code> 关键字把类声明成是<em>协变</em> 的，并且要求 T 只能在 out 位置（被生产），只有这样才能确保子类型才是安全的：<code>List&lt;Int&gt;</code> 是 <code>List&lt;Number&gt;</code> 的子类型。使用 <code>in</code> 关键字使得类是逆变的，并且要求 T 只能在 in 位置（被消费）。</p><h5 id="使用处型变"><a href="#使用处型变" class="headerlink" title="使用处型变"></a>使用处型变</h5><p>同样先看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">copy</span><span class="hljs-params">(from: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Number</span>&gt;, to: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Number</span>&gt;)</span></span> &#123;<br>    assert(from.size == to.size)<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> from.indices)<br>        to[i] = from[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> ints: Array&lt;<span class="hljs-built_in">Int</span>&gt; = arrayOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">val</span> nums = Array&lt;Number&gt;(<span class="hljs-number">3</span>) &#123; <span class="hljs-number">3.3</span> &#125;<br>    <span class="hljs-comment">// 无法调用 copy 方法，因为 Array&lt;Int&gt; 不是 Array&lt;Number&gt;！</span><br>    <span class="hljs-comment">// copy(ints, nums) // Type mismatch</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Array</code> 类需要能被读和写，因此既不能是协变的也不能是逆变的，这就带来了一个问题，<code>Array&lt;Number&gt;</code> 不能被转换为 <code>Array&lt;Int&gt;</code>，因此，我们需要在<em><strong>使用处</strong></em> 也就是 from 的类型参数前添加 <code>out</code> 关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">copy</span><span class="hljs-params">(from: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Number</span>&gt;, to: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Number</span>&gt;)</span></span> &#123; …… &#125;<br></code></pre></td></tr></table></figure><p>我们把 from 称为一个受限制 (<em>projected</em>) 的数组，只可以调用返回类型为 <code>T</code> 的方法，这被叫做 <em>type projection</em>（不知道怎么翻译，Kotlin 中文网翻译为<em>类型投影</em> ）。</p><p>这其实就是 Kotlin 中的<strong>使用处型变</strong>，对应与 Java 中的 <code>Array&lt;? extends Number&gt;</code>，限制泛型类型的上边界。当然，我们也可以使用 <code>in</code> 关键字，它对应于 Java 中的 <code>Array&lt;? super Number&gt;</code>，限制泛型类型的下边界。不过，和 Java 中不同，我们可以在这样的限制了下边界的数组中，添加任何父类及子类元素：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> arr: Array&lt;<span class="hljs-keyword">in</span> String&gt; = arrayOf(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">123</span>, Origin(), <span class="hljs-literal">null</span>) <span class="hljs-comment">// 连 null 也可以添加</span><br></code></pre></td></tr></table></figure><h5 id="Star-projections"><a href="#Star-projections" class="headerlink" title="Star-projections"></a>Star-projections</h5><p>如果你对泛型参数的类型一无所知，但是依旧想要使用它，则可以使用 star-projections，用 <code>*</code> 表示。我觉得有点类似于 Java 中的捕获转换，使用无界通配符 <code>&lt;?&gt;</code> 去捕捉类型。</p><ul><li>如果用 <code>House&lt;*&gt;</code> 去捕获签名为 <code>House&lt;out T : Human&gt;</code> 的类，则捕获到的具体类型为 <code>House&lt;out Human&gt;</code>，这样你就可以安全地调用 <code>House</code> 中的成员方法和属性了。</li><li>如果用 <code>House&lt;*&gt;</code> 去捕获签名为 <code>House&lt;in T&gt;</code> 的类，由于类型参数 T 是逆变的，而且没有任何有关 T 的类型，所以捕获到的类型为 <code>House&lt;in Nothing&gt;</code>，此时往 <code>House</code> 添加任何对象都是不安全的。</li><li>如果用 <code>House&lt;*&gt;</code> 去捕获签名为 <code>House&lt;T : Human&gt;</code> 的类，则对于读取而言捕获到的是 <code>House&lt;out Human&gt;</code>，对于写入而言捕获到的是 <code>House&lt;in Nothing&gt;</code>。</li></ul><p>如果类的类型参数有多个，则每个类型参数都可以被单独 <em>projected</em>。比如类型声明为 <code>interface Function&lt;in T, out U&gt;</code>，则它的 proection 可以分为以下几种情况：</p><ul><li><code>Function&lt;*, String&gt;</code> 表示 <code>Function&lt;in Nothing, String&gt;</code>；</li><li><code>Function&lt;String, *&gt;</code> 表示 <code>Function&lt;String, out Any?&gt;</code>；</li><li><code>Function&lt;*, *&gt;</code> 表示 <code>Function&lt;in Nothing, out Any?&gt;</code>。</li></ul><h4 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h4><p>Kotlin 中的泛型函数和 Java 中的泛型方法类似，类型参数要放在方法名之前：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 声明泛型方法</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">singletonList</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>: List&lt;T&gt; &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br><span class="hljs-comment">// 调用方法</span><br><span class="hljs-keyword">val</span> list = singletonList&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>我们可以给泛型参数限定其可能的类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 使用 : 限定其上界，如果没有指定，默认的上界是 Any?</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="hljs-title">sort</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br><span class="hljs-comment">// 如果同一个类型参数需要使用多个上界，则应该使用 where-clause</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">copyWhenGreater</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;, threshold: <span class="hljs-type">T</span>)</span></span>: List&lt;String&gt;<br>    <span class="hljs-keyword">where</span> T : CharSequence,<br>          T : Comparable&lt;T&gt; &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>与 Java 中类似，泛型的类型安全检测仅在编译期有效，运行时泛型类的实例不保留其类型实参的任何信息，其类型信息被擦除了，比如 <code>Foo&lt;Bar&gt;</code> 和 <code>Foo&lt;Baz&gt;</code> 都会被擦除为 <code>Foo&lt;*&gt;</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> foo: Box&lt;String&gt; = Box(<span class="hljs-string">&quot;foo&quot;</span>)<br><span class="hljs-keyword">val</span> bar: Box&lt;Number&gt; = Box(<span class="hljs-number">1</span>)<br><br>println(foo <span class="hljs-keyword">is</span> Box&lt;*&gt;) <span class="hljs-comment">// true</span><br>println(bar <span class="hljs-keyword">is</span> Box&lt;*&gt;) <span class="hljs-comment">// true</span><br>println(foo.javaClass.toGenericString()) <span class="hljs-comment">// Box&lt;T&gt;</span><br>println(bar.javaClass.toGenericString()) <span class="hljs-comment">// Box&lt;T&gt;</span><br></code></pre></td></tr></table></figure><h2 id="函数与-Lambda-表达式"><a href="#函数与-Lambda-表达式" class="headerlink" title="函数与 Lambda 表达式"></a>函数与 Lambda 表达式</h2><p>Kotlin 中函数是头等的，这意味着函数可以存储在变量、参数、数据结构中，或者从其它高等函数中被返回。可以简单理解为，函数也可以被当做变量使用。</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是指接收函数作为参数或者返回一个函数的函数。最具代表性的是 <code>fold</code> 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> Collection<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">fold</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    initial: <span class="hljs-type">R</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    combine: (<span class="hljs-type">acc</span>: <span class="hljs-type">R</span>, <span class="hljs-type">nextElement</span>: <span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: R &#123;<br>    <span class="hljs-keyword">var</span> accumulator: R = initial<br>    <span class="hljs-keyword">for</span> (element: T <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) &#123;<br>        accumulator = combine(accumulator, element)<br>    &#125;<br>    <span class="hljs-keyword">return</span> accumulator<br>&#125;<br></code></pre></td></tr></table></figure><p>它接收一个初始值和一个计算函数。计算函数中包含一个累积值和 next 元素值，在方法体中将集合遍历，将遍历到的元素通过计算函数计算，得到新的累积值，并替换原有的累积值，最终返回结果。</p><p>我们可以通过以下方式调用该方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">items.fold(<span class="hljs-number">0</span>, &#123; acc: <span class="hljs-built_in">Int</span>, i: <span class="hljs-built_in">Int</span> -&gt; <span class="hljs-comment">// 参数后用 -&gt; 分割</span><br>    <span class="hljs-comment">// 方法主体</span><br>    print(<span class="hljs-string">&quot;acc = <span class="hljs-variable">$acc</span>, i = <span class="hljs-variable">$i</span>, &quot;</span>)<br>    <span class="hljs-keyword">val</span> result = acc + i<br>    println(<span class="hljs-string">&quot;result = <span class="hljs-variable">$result</span>&quot;</span>)<br>    <span class="hljs-comment">// 最后一个表达式作为返回值     </span><br>    result<br>&#125;)<br><br><span class="hljs-comment">// 参数类型如果可以被推断出来则可以省略</span><br>items.fold(<span class="hljs-string">&quot;Elements:&quot;</span>) &#123; acc, i -&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$acc</span> <span class="hljs-variable">$i</span>&quot;</span> &#125;<br><br><span class="hljs-comment">// 也可以使用方法引用</span><br>items.fold(<span class="hljs-number">1</span>, <span class="hljs-built_in">Int</span>::times)<br></code></pre></td></tr></table></figure><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>Kotlin 中用 <code>(Int) -&gt; String</code> 这样的形式声明一个函数类型的变量，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> onClick: () -&gt; <span class="hljs-built_in">Unit</span> = <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>函数类型主要形式如下：</p><ul><li>所有函数类型都有一个圆括号括起来的参数类型列表以及一个返回类型：<code>(A, B) -&gt; C</code>，表示它接受类型分别为 <code>A</code> 与 <code>B</code> 的两个参数，并返回一个 <code>C</code> 类型的值。参数类型列表可以为空，比如 <code>() -&gt; A</code>；如果没有返回值则必须注明，比如 <code>(A, B) -&gt; Unit</code>。</li><li>函数类型可以有一个额外的<em>接收者</em> 类型，通过 <code>A.</code> 这样的形式表示。当调用函数时，第一个参数是该接收者，然后才是函数参数。另外，函数中可以通过 <code>this</code> 关键字引用该对象。带与不带接收者的函数类型可以互换。</li><li><a href="https://kotlinlang.org/docs/coroutines-basics.html#extract-function-refactoring">挂起函数</a>是一种特殊的函数类型，表示法中包含一个 <code>suspend</code> 修饰符，如 <code>suspend () -&gt; Unit</code>。</li></ul><p>声明函数类型时，函数的参数名是可选的。下面看几个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 可为空的函数类型</span><br><span class="hljs-keyword">val</span> nullableFun : ((<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span>)? = <span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// 函数的返回值也为函数类型，使用 () 括起来就可以了</span><br><span class="hljs-keyword">val</span> returnFun : (<span class="hljs-built_in">Int</span>) -&gt; ((<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Unit</span>) = <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>我们还可以通过<a href="https://kotlinlang.org/docs/type-aliases.html">类型别名</a>给函数起一个别名：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">typealias</span> ClickHandler = (View) -&gt; <span class="hljs-built_in">Unit</span><br></code></pre></td></tr></table></figure><h4 id="函数类型实例化"><a href="#函数类型实例化" class="headerlink" title="函数类型实例化"></a>函数类型实例化</h4><p>我们主要可以通过以下几种方法获得函数类型的实例：</p><ul><li><p>使用函数字面值的代码块</p><ul><li>lambda 表达式：<code>&#123; a, b -&gt; a + b &#125;</code></li><li>匿名函数：<code>fun(s: String): Int &#123; return s.toIntOrNull() ?: 0 &#125;</code></li></ul></li><li><p>使用已声明的可调用引用：</p><ul><li>顶层、局部、成员、扩展函数：<code>::isOdd</code>、 <code>String::toInt</code></li><li>顶层、成员、扩展属性：<code>List&lt;Int&gt;::size</code></li><li>构造函数：<code>::Regex</code></li></ul></li><li><p>使用实现函数类型接口的自定义类的实例:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntTransformer</span>: <span class="hljs-type"></span></span>(<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = TODO()<br>&#125;<br><br><span class="hljs-keyword">val</span> intFunction: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = IntTransformer() <span class="hljs-comment">// 实例化</span><br></code></pre></td></tr></table></figure></li></ul><p>如果有足够信息，编译器可以推断出具体的函数类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = &#123; i: <span class="hljs-built_in">Int</span> -&gt; i + <span class="hljs-number">1</span> &#125; <span class="hljs-comment">// 推断出的类型是 (Int) -&gt; Int</span><br></code></pre></td></tr></table></figure><p>不过，函数类型推断默认推断出的是<em>没有接收者</em>的函数类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = &#123; i: <span class="hljs-built_in">Int</span>, s: String -&gt; s + i &#125;<br></code></pre></td></tr></table></figure><p>上面的例子中，默认推断出的是 <code>(String, Int) -&gt; String</code> 而不是 <code>String.(Int) -&gt; String</code>。如果这不符合你的需要，请显式指定函数类型。</p><h4 id="函数类型实例调用"><a href="#函数类型实例调用" class="headerlink" title="函数类型实例调用"></a>函数类型实例调用</h4><p>除了直接调用之外，我们还可以使用 <code>invoke()</code> 对函数进行调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> stringPlus: (String, String) -&gt; String = String::plus<br><br>println(stringPlus(<span class="hljs-string">&quot;Hello, &quot;</span>, <span class="hljs-string">&quot;world!&quot;</span>)) <br>println(stringPlus.invoke(<span class="hljs-string">&quot;&lt;-&quot;</span>, <span class="hljs-string">&quot;-&gt;&quot;</span>))<br></code></pre></td></tr></table></figure><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>完整语法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 声明一个名称为 sum 的函数类型，并使用 lambda 表达式初始化</span><br><span class="hljs-keyword">val</span> sum: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123; x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x + y &#125;<br></code></pre></td></tr></table></figure><p>Lambda 表达式总是括在花括号中，完整语法形式的参数声明放在花括号内，并有可选的类型标注，函数体跟在一个 <code>-&gt;</code> 符号之后。如果推断出的该 lambda 的返回类型不是 <code>Unit</code>，那么该 lambda 主体中的最后一个表达式会被视为返回值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> result = &#123;<br>    <span class="hljs-keyword">val</span> s = <span class="hljs-string">&quot;hi&quot;</span><br>    s.length<br>&#125;<br>println(result <span class="hljs-keyword">is</span> Function&lt;<span class="hljs-built_in">Int</span>&gt;) <span class="hljs-comment">// 返回值是 Int</span><br></code></pre></td></tr></table></figure><h4 id="传递末尾的-lambda-表达式"><a href="#传递末尾的-lambda-表达式" class="headerlink" title="传递末尾的 lambda 表达式"></a>传递末尾的 lambda 表达式</h4><p>如果函数的最后一个参数是函数类型，那么作为参数传入的 lambda 表达式可以放在圆括号之外：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> product = items.fold(<span class="hljs-number">1</span>) &#123; acc, e -&gt; acc * e &#125;<br></code></pre></td></tr></table></figure><p>这种语法叫做拖尾 lambda (<em>trailing lambdas</em>﻿)，如果该 lambda 表达式是调用时唯一的参数，那么圆括号可以省略：<code>run &#123; println(&quot;...&quot;) &#125;</code>。</p><h4 id="it：单个参数的隐式名称"><a href="#it：单个参数的隐式名称" class="headerlink" title="it：单个参数的隐式名称"></a><code>it</code>：单个参数的隐式名称</h4><p>如果 lambda 表达式中只有一个参数，那么我们可以省略它以及 <code>-&gt;</code>，该参数会被隐式声明为 <code>it</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ints.filter &#123; it &gt; <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><h4 id="从-lambda-表达式中返回值"><a href="#从-lambda-表达式中返回值" class="headerlink" title="从 lambda 表达式中返回值"></a>从 lambda 表达式中返回值</h4><p>我们可以使用<a href="https://kotlinlang.org/docs/returns.html#return-at-labels">标签返回</a>的语法从 lambda 显式返回一个值。 否则，将隐式返回最后一个表达式的值。</p><h4 id="下划线用于未使用的变量"><a href="#下划线用于未使用的变量" class="headerlink" title="下划线用于未使用的变量"></a>下划线用于未使用的变量</h4><p>如果 lambda 表达式的参数未使用，那么可以用下划线取代其名称：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">map.forEach &#123; _, value -&gt; println(<span class="hljs-string">&quot;<span class="hljs-variable">$value</span>!&quot;</span>) &#125;<br></code></pre></td></tr></table></figure><h4 id="lambda-表达式中的解构声明"><a href="#lambda-表达式中的解构声明" class="headerlink" title="lambda 表达式中的解构声明"></a>lambda 表达式中的解构声明</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">map.mapValues &#123; (key, value) -&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$value</span>!&quot;</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>Lambda 表达式缺少指定函数的返回类型的能力。在大多数情况下，这是不必要的，因为返回值类型可以被推断出来，但是如果你需要显式指定返回值类型，就可以使用匿名函数代替 lambda 表达式。</p><p>匿名函数与普通函数的唯一区别是匿名函数省略了函数名称。其使用方式和 lambda 表达式基本一致：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> add = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = x + y<br></code></pre></td></tr></table></figure><p>不过，不同的是，匿名函数的参数必须在括号内才能传递。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ints.filter(<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(item)</span></span> = item &gt; <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>除此之外，还有<a href="https://kotlinlang.org/docs/inline-functions.html#non-local-returns">非局部返回</a>的不同。非 lambda 表达式中，不带标签的 return 总是在函数中直接返回，而 lambda 表达式是从包含它的函数返回，所以在 lambda 表达式中如果要正确地 return 需要使用标签：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ints.filter &#123;<br>    <span class="hljs-keyword">val</span> mold = it % <span class="hljs-number">2</span><br>    println(mold)<br>    <span class="hljs-keyword">return</span><span class="hljs-symbol">@filter</span> mold == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>Lambda 表达式或者匿名函数（以及<a href="https://kotlinlang.org/docs/functions.html#local-functions">局部函数</a>和<a href="https://kotlinlang.org/docs/object-declarations.html#object-declarations">对象表达式</a>） 可以访问其<em>闭包</em> ，即在外部作用域中声明的变量。与 Java 不同，Kotlin 中不但允许访问闭包中的非 final 变量，还允许直接修改它们：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>ints.filter &#123; it &gt; <span class="hljs-number">0</span> &#125;.forEach &#123;<br>    <span class="hljs-comment">// 修改闭包中的变量</span><br>    sum += it<br>&#125;<br>print(sum)<br></code></pre></td></tr></table></figure><p>其实现原理是，Kotlin 为我们捕捉并保存了可变变量的引用，然后在我们修改其值的时候改变引用。所以，如果变量被 lambda 表达式捕捉，其声明周期会和 lambda 的表达式的生命周期一致。</p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包，即在那些函数体内会访问到的变量，对于函数对象和类的内存分配和虚拟调用会引入运行时开销。举个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">lock(l) &#123; foo() &#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，<code>foo()</code> 方法其实只有在被调用到时才起作用，其他时候只是作为参数传递，所以我们期望的行为是希望编译器可以帮我们生成这样一个方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">lock.lock()<br><span class="hljs-keyword">try</span> &#123;<br>    body() <span class="hljs-comment">// 对目标方法进行调用</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p>为了让编译器这么做，我们需要使用 <code>inline</code> 关键字。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">lock</span><span class="hljs-params">(lock: <span class="hljs-type">Lock</span>, body: () -&gt; <span class="hljs-type">T</span>)</span></span>: T &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p><code>inline</code> 修饰符影响函数和传给它的 lambda 表达式：所有这些都被内联到调用的地方。也就是 lambda 表达式成为函数调用者定义的一部分，而不是保存在匿名类中。</p><p>内联虽然有可能会导致生成的方法数增加，但是只要内联的方法体不是太大就可以节省性能开销。</p><h4 id="禁用内联"><a href="#禁用内联" class="headerlink" title="禁用内联"></a>禁用内联</h4><p>如果希望只内联一部分函数，我们可以在内联函数上使用 <code>noinline</code> 关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(inlined: () -&gt; <span class="hljs-type">Unit</span>, <span class="hljs-keyword">noinline</span> notInlined: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><h4 id="非局部返回"><a href="#非局部返回" class="headerlink" title="非局部返回"></a>非局部返回</h4><p>在 Kotlin 中，我们只能对具名或匿名函数使用正常的、非限定的 return 来退出。 但是，如果一个 lambda 表达式是内联的，那么就可以使用<em>非局部返回</em>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(s: <span class="hljs-type">String</span>)</span></span> &#123;<br>    s.let &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-comment">// OK：该 lambda 表达式是内联的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不仅仅是 let，所有的 scope functions 都是内联的。</p><p>一些内联函数可能调用传给它们的不是直接来自函数体、而是来自另一个执行上下文的 lambda 表达式参数，例如来自局部对象或嵌套函数。在这种情况下，该 lambda 表达式中也不允许非局部控制流。为了标识这种情况，该 lambda 表达式参数需要用 <code>crossinline</code> 修饰符标记：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 使用 crossinline 修饰，不允许局部返回</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> body: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> f = <span class="hljs-keyword">object</span>: Runnable &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> = body() <span class="hljs-comment">// 比如这段代码执行的 context 和当前 context 不同</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="具体化的类型参数"><a href="#具体化的类型参数" class="headerlink" title="具体化的类型参数"></a>具体化的类型参数</h4><p>有时候，我们需要得到类型参数的具体信息，这个时候可以在内联函数中使用 <code>reified</code> 关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Number&gt;</span> TreeNode.<span class="hljs-title">findParentOfType</span><span class="hljs-params">()</span></span>: T? &#123;<br>    <span class="hljs-keyword">var</span> p = parent<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; p !<span class="hljs-keyword">is</span> T) &#123;<br>        p = p.parent<br>    &#125;<br>    <span class="hljs-keyword">return</span> p <span class="hljs-keyword">as</span> T?<br>&#125;<br></code></pre></td></tr></table></figure><p>例子中，由于函数是内联的，不需要反射，所以 <code>!is</code> 和 <code>as</code> 都可以使用了。</p><h4 id="内联属性"><a href="#内联属性" class="headerlink" title="内联属性"></a>内联属性</h4><p><code>inline</code> 修饰符可用于没有幕后字段的属性的访问器。既可以单独标注某个属性访问器，也可以标注整个属性使得两个访问器都是内联的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> foo: Foo<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">get</span>() = Foo()<br><br><span class="hljs-keyword">var</span> bar: Bar<br>    <span class="hljs-keyword">get</span>() = <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">set</span>(v) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">var</span> bar: Bar<br>    <span class="hljs-keyword">get</span>() = <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">set</span>(v) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="异步编程技术"><a href="#异步编程技术" class="headerlink" title="异步编程技术"></a>异步编程技术</h3><p>在学习协程之前，让我们先回顾一下已有的异步编程方案。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程可能是目前为止最著名的防止程序造成阻塞的方案。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postItem</span><span class="hljs-params">(item: <span class="hljs-type">Item</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> token = preparePost()<br>    <span class="hljs-keyword">val</span> post = submitPost(token, item)<br>    processPost(post)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">preparePost</span><span class="hljs-params">()</span></span>: Token &#123;<br>    <span class="hljs-comment">// makes a request and consequently blocks the main thread</span><br>    <span class="hljs-keyword">return</span> token<br>&#125;<br></code></pre></td></tr></table></figure><p>比如上面这段代码中，我们需要在 <code>preparePost()</code> 方法中做网络请求获取数据，我们可以把它放在子线程中来防止 UI 被阻塞，但是这样做有一些缺陷：</p><ul><li>创建线程所需的性能开销并不低。线程造成的上下文切换非常昂贵。</li><li>线程不是无限制的。可创建的线程数量受限于当前操作系统，如果是服务端的应用程序，这会造成主要的瓶颈。</li><li>线程不一定总是可用。在一些平台，比如在 JavaScript 中就不支持线程。</li><li>线程的使用并不简单。在多线程编程中，多线程应用的调试和避免出现竞争状况是常见的问题。</li></ul><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>另一种思路是使用回调，也就是将目标方法作为参数传递到另一个函数中，在任务结束时再对目标函数进行调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postItem</span><span class="hljs-params">(item: <span class="hljs-type">Item</span>)</span></span> &#123;<br>    preparePostAsync &#123; token -&gt;<br>        submitPostAsync(token, item) &#123; post -&gt;<br>            processPost(post)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">preparePostAsync</span><span class="hljs-params">(callback: (<span class="hljs-type">Token</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-comment">// make request and return immediately</span><br>    <span class="hljs-comment">// arrange callback to be invoked later</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用回调看起来优雅了许多，但是依旧存在一些问题：</p><ul><li>多层嵌套导致代码变复杂。</li><li>错误处理变得异常困难。</li></ul><h4 id="Futures-Promises-及其它"><a href="#Futures-Promises-及其它" class="headerlink" title="Futures / Promises 及其它"></a>Futures / Promises 及其它</h4><p>Future / Promises 背后的思想是当我们调用了异步请求之后，我们会得到一个 Promise 对象，其中包含了异步请求成功或失败的结果，然后我们可以对它进行处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postItem</span><span class="hljs-params">(item: <span class="hljs-type">Item</span>)</span></span> &#123;<br>    preparePostAsync()<br>        .thenCompose &#123; token -&gt;<br>            submitPostAsync(token, item)<br>        &#125;<br>        .thenAccept &#123; post -&gt;<br>            processPost(post)<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">preparePostAsync</span><span class="hljs-params">()</span></span>: Promise&lt;Token&gt; &#123;<br>    <span class="hljs-comment">// makes request and returns a promise that is completed later</span><br>    <span class="hljs-keyword">return</span> promise<br>&#125;<br></code></pre></td></tr></table></figure><p>这种解决方式需要我们改变编程方式，具体而言：</p><ul><li>不同的编程模型。从自上而下的命令式编程到通过链式调用的组合式编程。</li><li>需要学习如何使用一套全新的 API。</li><li>指定返回值类型。返回值从原始的真实数据到 Promise 对象。</li><li>错误处理变得异常复杂。</li></ul><h4 id="响应式插件"><a href="#响应式插件" class="headerlink" title="响应式插件"></a>响应式插件</h4><p>响应式插件 (<em>Reactive Extensions</em>, <em>Rx</em>) 最初是在 C# 中被 <a href="https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)">Erik Meijer</a> 提出的，后来 Netflix 将它移植到了 Java 中创造了 RxJava，于是慢慢受到了越来越多人的青睐。其背后的思想是 <code>observable streams</code>，数据以可被观察的流的形式存在。与 Future 返回具体的对象不同，Rx 返回的是数据流，并且使用观察者模式。</p><p>如果你接受并理解了 Rx 的核心理念，那么这种编程习惯的确可以很快被应用到其它平台上，而且其错误处理也比前面提到的几种更好一些。</p><h4 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h4><p>Kotlin 处理异步代码的方式是通过协程，其思想核心是<em>可挂起的运算</em>：函数可以将它的执行挂起，并在稍后继续执行。协程最大的优势是开发者可以像写阻塞式代码一样写非阻塞式代码（写出的异步代码和顺序执行的代码一样）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postItem</span><span class="hljs-params">(item: <span class="hljs-type">Item</span>)</span></span> &#123;<br>    launch &#123;<br>        <span class="hljs-keyword">val</span> token = preparePost()<br>        <span class="hljs-keyword">val</span> post = submitPost(token, item)<br>        processPost(post)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">preparePost</span><span class="hljs-params">()</span></span>: Token &#123;<br>    <span class="hljs-comment">// makes a request and suspends the coroutine</span><br>    <span class="hljs-keyword">return</span> suspendCoroutine &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面这个例子中，<code>postItem</code> 中会执行一些耗时操作，但是它不会阻塞主线程，<code>preparePost)()</code> 就是一个可挂起的函数，它会在执行并返回结果之后，再继续往下执行其它代码。</p><p>相比前面的一些方案，协程具有以下优势：</p><ul><li>方法签名不需要改变；</li><li>代码结构也不需要改变，我们可以像写同步代码一样编写异步代码；</li><li>编程模型和 API 保持可用，比如使用循环、异常处理等保持一致；</li><li>平台独立性，无论是针对 JVM、JavaScript 或者其它平台，代码始终保持一致，编译器会为我们适配到各自的平台。</li></ul><p>Kotlin 并不是唯一采用这种异步编程思想的语言，比如 C# Go 等语言很早就开始使用了。比较特殊的是，除了 <code>suspend</code> 关键字之外，Kotlin 中协程功能全都是以库的形式提供的，我们需要导入 <code>kotlinx.coroutines</code> 包才能使用协程。</p><h3 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h3><p>一个协程是一个可终止运算的实例。从概念上看，它与线程相似，因为它需要运行一块与其余代码块同时工作的代码块。但是，协程不绑定到任何特定线程，它可以在一个线程中暂停执行，然后在另一个线程中恢复执行。因此，协程可以被看作是轻量级的线程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123; <span class="hljs-comment">// runBlocking 用于连接阻塞式代码和协程代码</span><br>    <span class="hljs-keyword">val</span> job = GlobalScope.launch &#123; <span class="hljs-comment">// 启动一个新协程并保持对这个 job 的引用</span><br>        delay(<span class="hljs-number">1000L</span>)<br>        println(<span class="hljs-string">&quot;World!&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Hello,&quot;</span>)<br>    job.join() <span class="hljs-comment">// 等待直到子协程执行结束</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h4><p>以上示例中，我们创建了一个顶层协程，保持对其的引用并将协程挂起直至 job 执行结束。这存在一些问题，比如创建顶层协程需要消耗更多的资源，手动保持对协程的引用容易出错等等。</p><p>更好的做法是使用<strong>结构化并发</strong>。我们可以在 runBlocking 所在的 CoroutineScope 中直接启动一个新协程，这样就毋需显式 join 它了。正因为在同一个作用域中，所以会等待所有启动的协程都执行完毕后才会退出：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123; <span class="hljs-comment">// this: CoroutineScope</span><br>    launch &#123; <span class="hljs-comment">// 在 runBlocking 作用域中启动一个新协程</span><br>        delay(<span class="hljs-number">1000L</span>)<br>        println(<span class="hljs-string">&quot;World!&quot;</span>)<br>    &#125;<br>    print(<span class="hljs-string">&quot;Hello &quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>依次介绍下这里涉及到的几个协程函数：</p><ul><li><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch </a>是一个协程构造器，它会相对其余代码并发地启动一个新的协程，并且与它们保持相互独立。这也是为什么 “Hello “ 会被先打印出来。</li><li><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a> 是一个特殊的挂起函数，它会将当前协程挂起指定的一段时间。挂起一个协程不会阻塞当前所在的线程，但是会允许其它协程运行并且使用当前线程运行它们的代码。</li><li><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a> 也是一个协程构造器，它桥接起了外部非协程代码和方法体中的协程代码。</li></ul><p>所谓的<strong>结构化并发</strong>指的是新的协程只能在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> 中才能启动，这样就限定了该协程的生命周期。在真实的使用场景中，我们通常会启动非常多的协程，结构化并发保证了这些协程不会被丢失或者泄露。外部的协程只有等待内部的子协程全都执行完毕才会退出。另外，结构化并发也保证了当代码出错的时候，错误能够被正确地抛出而且不会被丢失。</p><h5 id="CoroutineScope-vs-CoroutineContext"><a href="#CoroutineScope-vs-CoroutineContext" class="headerlink" title="CoroutineScope vs CoroutineContext"></a>CoroutineScope vs CoroutineContext</h5><p>CoroutineScope 除了提供一个 CoroutineContext，还负责保存并发结构以及多个协程间的父子关系，我们只能在 CoroutineScope 中启动一个新协程。CoroutineContext 则保存了协程相关的信息。</p><h4 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h4><p>我们可以将上面打印 “World!” 的部分代码提取到一个 <code>printWorld()</code> 方法中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 挂起函数</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doWorld</span><span class="hljs-params">()</span></span> &#123;<br>    delay(<span class="hljs-number">1000L</span>)<br>    println(<span class="hljs-string">&quot;World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到提取该方法时，IDE 为我们自动添加了 <code>suspend</code> 修饰符，这样的函数被称为挂起函数 (<em>suspending function</em>)。挂起函数的作用是可以让我们在协程中调用其它挂起函数，并且暂停执行。</p><h4 id="作用域构建器"><a href="#作用域构建器" class="headerlink" title="作用域构建器"></a>作用域构建器</h4><p>我们还可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a> 创建自己的协程作用域，它和 runBlocking 一样会等待代码主体和子协程执行完毕，唯一的不同之处是 runBlocking 会阻塞当前线程，但 coroutineScope 只是<em>挂起</em>，它会释放占有的当前线程下的资源。正因如此，coroutineScope 是一个挂起函数，而 runBlocking 只是普通的函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    doWorld()<br>    println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doWorld</span><span class="hljs-params">()</span></span> = coroutineScope &#123;<br>    launch &#123;<br>        delay(<span class="hljs-number">2000L</span>)<br>        println(<span class="hljs-string">&quot;World 2&quot;</span>)<br>    &#125;<br>    launch &#123;<br>        delay(<span class="hljs-number">1000L</span>)<br>        println(<span class="hljs-string">&quot;World 1&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Hello&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 输出：</span><br>Hello<br>World <span class="hljs-number">1</span><br>World <span class="hljs-number">2</span><br>Done<br></code></pre></td></tr></table></figure><p>在上面这个例子中，由于 coroutineScope 不会阻塞当前线程，所以当它在内部启动两个协程之后，这些代码会被同步执行。而 runBlocking 是阻塞式运行的，所以它会等待 <code>doWorld()</code> 执行完毕。所以，最先被打印的是 “Hello”，然后是 delay 了 1 秒的 “World 1”，再然后是 delay 了 2 秒的 “World 2”，最后才是 “Done”。</p><h4 id="全局协程像守护线程"><a href="#全局协程像守护线程" class="headerlink" title="全局协程像守护线程"></a>全局协程像守护线程</h4><p>看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">GlobalScope.launch &#123;<br>    repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;<br>        println(<span class="hljs-string">&quot;I&#x27;m sleeping <span class="hljs-variable">$i</span> ...&quot;</span>)<br>        delay(<span class="hljs-number">500L</span>)<br>    &#125;<br>&#125;<br>delay(<span class="hljs-number">1300L</span>)<br></code></pre></td></tr></table></figure><p>这里打印的结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">I&#x27;m sleeping 0 ...<br>I&#x27;m sleeping 1 ...<br>I&#x27;m sleeping 2 ...<br></code></pre></td></tr></table></figure><p>原因是在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html">GlobalScope</a> 中启动的活动协程并不会使进程保活，它们就像守护线程。</p><h3 id="取消与超时"><a href="#取消与超时" class="headerlink" title="取消与超时"></a>取消与超时</h3><h4 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">job.cancel()<br><span class="hljs-comment">// or</span><br>job.cancelAndJoin()<br></code></pre></td></tr></table></figure><p>如果协程没有检查取消状态，那么仅仅调用 <code>cancel()</code> 是无法被取消的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancelIsCooperative</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> startTime = System.currentTimeMillis()<br>    <span class="hljs-keyword">val</span> job = launch(Dispatchers.Default) &#123;<br>        <span class="hljs-keyword">var</span> nextPrintTime = startTime<br>        <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>            <span class="hljs-keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;<br>                println(<span class="hljs-string">&quot;job: I&#x27;m sleeping <span class="hljs-subst">$&#123;i++&#125;</span> ...&quot;</span>)<br>                nextPrintTime += <span class="hljs-number">500L</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    delay(<span class="hljs-number">1300L</span>)<br>    println(<span class="hljs-string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)<br>    job.cancelAndJoin() <span class="hljs-comment">// 取消 job 并且等待它结束</span><br>    println(<span class="hljs-string">&quot;main: Now I can quit.&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br>job: I<span class="hljs-string">&#x27;m sleeping 0 ...</span><br><span class="hljs-string">job: I&#x27;</span>m sleeping <span class="hljs-number">1</span> ...<br>job: I<span class="hljs-string">&#x27;m sleeping 2 ...</span><br><span class="hljs-string">main: I&#x27;</span>m tired of waiting!<br>job: I<span class="hljs-string">&#x27;m sleeping 3 ...</span><br><span class="hljs-string">job: I&#x27;</span>m sleeping <span class="hljs-number">4</span> ...<br>main: Now I can quit.<br></code></pre></td></tr></table></figure><p>为了使取消起作用，我们需要对子协程做以下修改：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// isActive 是 CoroutineScope 的扩展属性</span><br><span class="hljs-keyword">while</span> (isActive) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以在 <code>finally</code> 代码块中释放资源：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">try</span> &#123;<br>    repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;<br>        println(<span class="hljs-string">&quot;job: I&#x27;m sleeping <span class="hljs-variable">$i</span> ...&quot;</span>)<br>        delay(<span class="hljs-number">500L</span>)<br>    &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    println(<span class="hljs-string">&quot;job: I&#x27;m running finally&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>对于不可取消的协程还可以在 <code>finally</code> 中判断：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">try</span> &#123;<br>    repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;<br>        println(<span class="hljs-string">&quot;job: I&#x27;m sleeping <span class="hljs-variable">$i</span> ...&quot;</span>)<br>        delay(<span class="hljs-number">500L</span>)<br>    &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// NonCancellable 是一个对象，且需要结合 withContext 方法使用</span><br>    withContext(NonCancellable) &#123;<br>        println(<span class="hljs-string">&quot;job: I&#x27;m running finally&quot;</span>)<br>        delay(<span class="hljs-number">1000L</span>)<br>        println(<span class="hljs-string">&quot;job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p>由于协程很有可能会超时，所以协程库为我们提供了 <code>withTimeout()</code> 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runWithTimeout</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    withTimeout(<span class="hljs-number">1300L</span>) &#123;<br>        repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;<br>            println(<span class="hljs-string">&quot;I&#x27;m sleeping <span class="hljs-variable">$i</span> ...&quot;</span>)<br>            delay(<span class="hljs-number">500L</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果会抛出 <code>TimeoutCancellationException</code> 异常，它是 <code>CancellationException</code> 的子类，我们之前没有看到这个异常是因为被取消的协程中，即使抛出 <code>CancellationExcetption</code> 也被认为是正确退出的。</p><p>如果不想看到异常，我们可以使用 <code>withTimeoutOrNull()</code> 方法，该方法中对 <code>TimeoutCancellationException</code> 进行了捕捉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">withTimeoutOrNull</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>, block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">T</span>)</span></span>: T? &#123;<br>    <span class="hljs-keyword">if</span> (timeMillis &lt;= <span class="hljs-number">0L</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">var</span> coroutine: TimeoutCoroutine&lt;T?, T?&gt;? = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;<br>            <span class="hljs-keyword">val</span> timeoutCoroutine = TimeoutCoroutine(timeMillis, uCont)<br>            coroutine = timeoutCoroutine<br>            setupTimeout&lt;T?, T?&gt;(timeoutCoroutine, block)<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e: TimeoutCancellationException) &#123;<br>        <span class="hljs-keyword">if</span> (e.coroutine === coroutine) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>        &#125;<br>        <span class="hljs-keyword">throw</span> e<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>withTimeout</code> 中的 timeout 事件是异步的，并且有可能在任何时间点发生，甚至在内部代码块返回值被返回之前。来看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> acquired = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> released = <span class="hljs-number">0</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resource</span> </span>&#123;<br>    <span class="hljs-keyword">init</span> &#123;<br>        acquired++<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span> &#123;<br>        released++<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 由于 timeout 事件是异步的，所以最终，acquired 事件触发的此时有可能多于 released 事件</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runTimeoutWithCloseResource</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        repeat(<span class="hljs-number">100_000</span>) &#123;<br>            launch &#123;<br>                <span class="hljs-keyword">val</span> resource = withTimeout(<span class="hljs-number">60</span>) &#123;<br>                    delay(<span class="hljs-number">50</span>)<br>                    Resource() <span class="hljs-comment">// 由于 timeout 事件随时都有可能被触发，所以这里有可能会被调用多次</span><br>                &#125;<br>                resource.close()<br>            &#125;<br>        &#125;<br>    &#125;<br>    println(acquired)<br>    println(released)<br>&#125;<br></code></pre></td></tr></table></figure><p>为了解决这个问题，我们可以使用 try..finally 语句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 try..finally 保证 Resource 的 acquire 和 release 都是成对的</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runTimeoutWithCloseResourceSafely</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        repeat(<span class="hljs-number">100_000</span>) &#123;<br>            launch &#123;<br>                <span class="hljs-comment">// 不依赖 withTimeout 的返回值</span><br>                <span class="hljs-keyword">var</span> resource: Resource? = <span class="hljs-literal">null</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    withTimeout(<span class="hljs-number">60</span>) &#123;<br>                        delay(<span class="hljs-number">50</span>)<br>                        resource = Resource()<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    resource?.close()<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    println(acquired)<br>    println(released)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合挂起函数"><a href="#组合挂起函数" class="headerlink" title="组合挂起函数"></a>组合挂起函数</h3><p>首先看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    sequentialInvocation()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sequentialInvocation</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        <span class="hljs-keyword">val</span> one = doSomethingUsefulOne()<br>        <span class="hljs-keyword">val</span> two = doSomethingUsefulTwo()<br>        println(<span class="hljs-string">&quot;The answer is <span class="hljs-subst">$&#123;one + two&#125;</span>&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Completed in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomethingUsefulOne</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    println(<span class="hljs-string">&quot;Calculating one...&quot;</span>)<br>    delay(<span class="hljs-number">1000L</span>) <span class="hljs-comment">// 假设我们在这里做了一些有用的事</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">13</span><br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomethingUsefulTwo</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    println(<span class="hljs-string">&quot;Calculating two...&quot;</span>)<br>    delay(<span class="hljs-number">1000L</span>) <span class="hljs-comment">// 假设我们在这里也做了一些有用的事</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">29</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于它们都是运行在协程中的，所以如果按顺序调用，则它们也会像常规方法一样，按顺序被执行。</p><h4 id="使用-async-并发"><a href="#使用-async-并发" class="headerlink" title="使用 async 并发"></a>使用 async 并发</h4><p>上面的例子中，<code>doSomethingUsefulOne</code> 和 <code>doSomethingUsefulTwo</code> 之间并没有依赖，为了更快地得到结果，我们可以对它们使用并发，这需要用到 <code>async</code> 关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">concurrentAsync</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        <span class="hljs-keyword">val</span> one = async &#123; doSomethingUsefulOne() &#125;<br>        <span class="hljs-keyword">val</span> two = async &#123; doSomethingUsefulTwo() &#125;<br>        println(<span class="hljs-string">&quot;The answer is <span class="hljs-subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Completed in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>async</code> 是 <code>CoroutineScope</code> 的扩展方法，默认会在调用后立即执行，并且返回一个 <code>Deferred</code> 作为结果，我们可以在 <code>Deferred</code> 上调用 <code>await()</code> 获取结果值。</p><h4 id="惰性启动的-async"><a href="#惰性启动的-async" class="headerlink" title="惰性启动的 async"></a>惰性启动的 async</h4><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> 可以通过将 <code>start</code> 参数设置为 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html">CoroutineStart.LAZY</a> 而变为惰性的。在这个模式下，只有结果通过 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html">await</a> 获取的时候协程才会启动，或者在 <code>Job</code> 的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html">start</a> 函数调用的时候。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">concurrentAsyncLazy</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        <span class="hljs-keyword">val</span> one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125;<br>        <span class="hljs-keyword">val</span> two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125;<br>        one.start()<br>        two.start()<br>        println(<span class="hljs-string">&quot;The answer is <span class="hljs-subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Completed in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="async-风格的函数"><a href="#async-风格的函数" class="headerlink" title="async 风格的函数"></a>async 风格的函数</h4><p>我们可以定义异步风格的函数来<em>异步</em> 地调用 <code>doSomethingUsefulOne</code> 和 <code>doSomethingUsefulTwo</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        <span class="hljs-comment">// 我们可以在协程外面启动异步执行</span><br>        <span class="hljs-keyword">val</span> one = somethingUsefulOneAsync()<br>        <span class="hljs-keyword">val</span> two = somethingUsefulTwoAsync()<br>        <span class="hljs-comment">// 但是等待结果必须调用其它的挂起或者阻塞</span><br>        <span class="hljs-comment">// 当我们等待结果的时候，这里我们使用 `runBlocking &#123; …… &#125;` 来阻塞主线程</span><br>        runBlocking &#123;<br>            println(<span class="hljs-string">&quot;The answer is <span class="hljs-subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>    println(<span class="hljs-string">&quot;Completed in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">somethingUsefulOneAsync</span><span class="hljs-params">()</span></span> = GlobalScope.async &#123;<br>    doSomethingUsefulOne()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">somethingUsefulTwoAsync</span><span class="hljs-params">()</span></span> = GlobalScope.async &#123;<br>    doSomethingUsefulTwo()<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们通过 <code>GlobalScope</code> 对象创建出来的 <code>CoroutineScope</code> 创建出一个 async 协程，并在其中调用我们的挂起函数。这样，我们就可以在协程外调用该方法了，因为该方法不依赖外界是否是 <code>CoroutineScope</code>。而且这些方法总是异步且并发被执行的（在顶层协程中）。不过，在获取运行结果 (<code>Deferred.await()</code>) 的时候，我们需要等待挂起函数执行的结果，这里的例子里我们使用了 <code>runBlocking</code> 阻塞主线程并创建了一个 <code>CoroutineScope</code> 来等待执行结束。</p><h4 id="使用-async-的结构化并发"><a href="#使用-async-的结构化并发" class="headerlink" title="使用 async 的结构化并发"></a>使用 async 的结构化并发</h4><p>上面的例子中，虽然我们可以这么做，但是 Kotlin 中并不推荐这种异步编程的风格。考虑一下，如果程序在 <code>somethingUsefulOneAsync</code> 或者在 <code>one.await()</code> 中发生错误抛出了异常，那么，<code>somethingUsefulTwoAsync</code> 依旧会被执行，这明显破坏了结构化并发的原则。所以我们可以对代码做以下修改：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">concurrentSum</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = coroutineScope &#123;<br>    <span class="hljs-keyword">val</span> one = async &#123; doSomethingUsefulOne() &#125;<br>    <span class="hljs-keyword">val</span> two = async &#123; doSomethingUsefulTwo() &#125;<br>    one.await() + two.await()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们把 <code>doSomethingUsefulOne</code> 和 <code>doSomethingUsefulTwo</code> 放到了同一个 CoroutineScope 中，这样，当程序抛出异常的时候，所有在当前作用域内启动的协程都会被取消：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFailedConcurrentSum</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        failedConcurrentSum()<br>    &#125; <span class="hljs-keyword">catch</span> (e: ArithmeticException) &#123;<br>        println(<span class="hljs-string">&quot;Computation failed with ArithmeticException&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">failedConcurrentSum</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = coroutineScope &#123;<br>    <span class="hljs-keyword">val</span> one = async &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            delay(<span class="hljs-built_in">Long</span>.MAX_VALUE) <span class="hljs-comment">// 模拟一个长时间的运算</span><br>            <span class="hljs-number">42</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 结束或者取消时会被打印</span><br>            println(<span class="hljs-string">&quot;First child was cancelled&quot;</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">val</span> two = async&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>        println(<span class="hljs-string">&quot;Second child throws an exception&quot;</span>)<br>        <span class="hljs-keyword">throw</span> ArithmeticException()<br>    &#125;<br>    one.await() + two.await()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="协程上下文与调度器"><a href="#协程上下文与调度器" class="headerlink" title="协程上下文与调度器"></a>协程上下文与调度器</h3><p>协程总是运行在一些以 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a> 类型为代表的上下文中。协程上下文是各种不同元素的集合，其中主元素是协程中的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>。</p><h4 id="调度器与线程"><a href="#调度器与线程" class="headerlink" title="调度器与线程"></a>调度器与线程</h4><p>协程上下文包含一个<em>协程调度器</em> <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher，</a>它确定了相关的协程在哪个线程或哪些线程上执行。协程调度器可以将协程限制在一个特定的线程执行，或将它分派到一个线程池，亦或是让它不受限地运行。</p><p>所有的协程构建器诸如 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a> 和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> 接收一个可选的 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a> 参数，它可以被用来显式的为一个新协程或其它上下文元素指定一个调度器。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    launch &#123; <span class="hljs-comment">// 运行在父协程的上下文中，即 runBlocking 主协程</span><br>        println(<span class="hljs-string">&quot;main runBlocking      : I&#x27;m working in thread <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>    &#125;<br>    launch(Dispatchers.Unconfined) &#123; <span class="hljs-comment">// 不受限的——将工作在主线程中</span><br>        println(<span class="hljs-string">&quot;Unconfined            : I&#x27;m working in thread <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>    &#125;<br>    launch(Dispatchers.Default) &#123; <span class="hljs-comment">// 将会获取默认调度器</span><br>        println(<span class="hljs-string">&quot;Default               : I&#x27;m working in thread <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>    &#125;<br>    launch(newSingleThreadContext(<span class="hljs-string">&quot;MyOwnThread&quot;</span>)) &#123; <span class="hljs-comment">// 将使它获得一个新的线程</span><br>        println(<span class="hljs-string">&quot;newSingleThreadContext: I&#x27;m working in thread <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h3><p>挂起函数可以异步的返回单个值，但是该如何异步返回多个计算好的值呢？这正是 Kotlin 流（Flow）的用武之地。</p><h4 id="序列与流"><a href="#序列与流" class="headerlink" title="序列与流"></a>序列与流</h4><p>如果使用一些消耗 CPU 资源的阻塞代码计算数字（每次计算需要 100 毫秒）那么我们可以使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/index.html">Sequence</a> 来表示数字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printSequenceList</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> sequence: Sequence&lt;<span class="hljs-built_in">Int</span>&gt; = sequence &#123; <span class="hljs-comment">// 序列构建器</span><br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>            Thread.sleep(<span class="hljs-number">300</span>) <span class="hljs-comment">// 假装我们正在计算</span><br>            yield(i) <span class="hljs-comment">// 产生下一个值</span><br>        &#125;<br>    &#125;<br><br>    sequence.forEach &#123; println(it) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用挂起函数，在不阻塞的情况下执行其工作并将结果作为列表返回：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printDelayedList</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    launch &#123;<br>        <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>            println(<span class="hljs-string">&quot;I&#x27;m not blocked <span class="hljs-variable">$k</span>&quot;</span>)<br>            delay(<span class="hljs-number">300</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> list = mutableListOf&lt;<span class="hljs-built_in">Int</span>&gt;()<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>        delay(<span class="hljs-number">300</span>) <span class="hljs-comment">// delay 函数不是阻塞式的</span><br>        list.add(i)<br>    &#125;<br><br>    list.forEach &#123; println(it) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 List 结果类型，意味着我们只能一次返回所有值。 为了表示异步计算的值流（stream），我们可以使用 <code>Flow</code> 类型（正如同步计算值会使用 <code>Sequence</code> 类型）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">flowList</span><span class="hljs-params">()</span></span> = flow &#123; <span class="hljs-comment">// 流构建器</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>        delay(<span class="hljs-number">100</span>) <span class="hljs-comment">// 假装我们在这里做了一些有用的事情</span><br>        println(<span class="hljs-string">&quot;Emitting <span class="hljs-variable">$i</span>&quot;</span>)<br>        emit(i) <span class="hljs-comment">// 发送下一个值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printFlowList</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    launch &#123;<br>        <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>            println(<span class="hljs-string">&quot;I&#x27;m not blocked <span class="hljs-variable">$k</span>&quot;</span>)<br>            delay(<span class="hljs-number">300</span>)<br>        &#125;<br>    &#125;<br>    flowList().collect &#123; println(it) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>flow</code> 具有以下特点：</p><ul><li>名为 <code>flow</code> 的构建器函数</li><li><code>flow &#123; ... &#125;</code> 构建块中的代码可以挂起</li><li><code>flow</code> 不是 suspend 函数</li><li><code>flow</code> 使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">emit</a> 函数<em>发射</em> 值</li><li><code>flow</code> 使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> 函数<em>收集</em> 值</li></ul><h4 id="流的取消"><a href="#流的取消" class="headerlink" title="流的取消"></a>流的取消</h4><p>流采用与协程同样的协作取消。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithTimeOut</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    withTimeoutOrNull(<span class="hljs-number">800</span>) &#123; <span class="hljs-comment">// 超时后 flow 不再继续执行</span><br>        flowList().collect &#123; value -&gt; println(value) &#125;<br>    &#125;<br>    println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="流是冷的"><a href="#流是冷的" class="headerlink" title="流是冷的"></a>流是冷的</h4><p>Flow 是一种类似于序列的冷流——只有在被 <code>collect</code> 的时候才会运行。</p><h4 id="流是连续的"><a href="#流是连续的" class="headerlink" title="流是连续的"></a>流是连续的</h4><ul><li>流的每次单独收集都是按顺序执行的，除非进行特殊操作的操作符使用多个流。</li><li>收集过程直接在当前协程中运行，默认情况下不启动新协程。</li><li>从上游到下游每个过渡操作符都会处理每个发射出的值然后再交给末端操作符。</li></ul><h4 id="流上下文"><a href="#流上下文" class="headerlink" title="流上下文"></a>流上下文</h4><p>流的收集总是在调用协程的上下文中发生，流的该属性称为<em>上下文保存</em> 。默认情况下，<code>flow &#123; ... &#125;</code> 构建器中的代码总是运行在相应流的收集器提供的上下文中。</p><h5 id="withContext-发出错误"><a href="#withContext-发出错误" class="headerlink" title="withContext 发出错误"></a>withContext 发出错误</h5><p>然而，长时间运行的消耗 CPU 的代码也许需要在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Dispatchers.Default</a> 上下文中执行，并且更新 UI 的代码也许需要在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html">Dispatchers.Main</a> 中执行。通常，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html">withContext</a> 用于在 Kotlin 协程中改变代码的上下文，但是 <code>flow &#123;...&#125;</code> 构建器中的代码必须遵循上下文一致原则，并且不允许从其他上下文中发射（<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">emit</a>）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithContextDispatchers</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    flow &#123;<br>        <span class="hljs-comment">// 在流构建器中更改上下文，会抛出异常：</span><br>        <span class="hljs-comment">// java.lang.IllegalStateException: Flow invariant is violated</span><br>        withContext(Dispatchers.Default) &#123;<br>            <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>                delay(<span class="hljs-number">300</span>)<br>                emit(i)<br>            &#125;<br>        &#125;<br>    &#125;.collect &#123; println(it) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="流构建器"><a href="#流构建器" class="headerlink" title="流构建器"></a>流构建器</h4><p>除了使用 <code>flow &#123; ... &#125;</code> 构建 <code>Flow</code> 之外，我们还可以使用：</p><ul><li><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-of.html">flowOf</a>：定义了一个发射固定值集的流</li><li><code>.asFlow()</code>：扩展函数，可以将各种集合与序列转换为流</li></ul><p>比如可以将一个整数区间转换为流：<code>(1..3).asFlow().collect &#123; value -&gt; println(value) &#125;</code></p><h4 id="流操作符"><a href="#流操作符" class="headerlink" title="流操作符"></a>流操作符</h4><h5 id="过渡操作符-map"><a href="#过渡操作符-map" class="headerlink" title="过渡操作符 map"></a>过渡操作符 <code>map</code></h5><p>我们可以像使用集合与序列一样，使用操作符对流进行转换，比如 <code>filter</code> 和 <code>map</code>。过渡操作符应用于上游流，并返回下游流，而且像流一样也是冷操作符。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">performRequest</span><span class="hljs-params">(request: <span class="hljs-type">Int</span>)</span></span>: String &#123;<br>    delay(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 模仿长时间运行的异步工作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;response <span class="hljs-variable">$request</span>&quot;</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithFilterAndMap</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow() <span class="hljs-comment">// 一个请求流</span><br>        .filter &#123; request -&gt; request &gt; <span class="hljs-number">1</span> &#125;<br>        .map &#123; request -&gt; performRequest(request) &#125;<br>        .collect &#123; response -&gt; println(response) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="转换操作符-transform"><a href="#转换操作符-transform" class="headerlink" title="转换操作符 transform"></a>转换操作符 <code>transform</code></h5><p>我们还可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform.html">转换操作符</a> 实现更为复杂的转换，使用形式 <code>transformXxx</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithTransform</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow() <span class="hljs-comment">// 一个请求流</span><br>        .transform &#123; request -&gt;<br>            emit(<span class="hljs-string">&quot;Making request <span class="hljs-variable">$request</span>&quot;</span>)<br>            emit(performRequest(request))<br>        &#125;<br>        .collect &#123; response -&gt; println(response) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="限长操作符-take"><a href="#限长操作符-take" class="headerlink" title="限长操作符 take"></a>限长操作符 <code>take</code></h5><p>我们可以使用限长操作符在流触及相应限制的时候，将它的执行取消。形式如 <code>takeXxx</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithTake</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow()<br>        .take(<span class="hljs-number">2</span>)<br>        .collect &#123; response -&gt; println(response) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="末端操作符"><a href="#末端操作符" class="headerlink" title="末端操作符"></a>末端操作符</h5><p>末端操作符是在流上用于启动流收集的<em>挂起函数</em>。 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> 是最基础的末端操作符，但是还有另外一些更方便使用的末端操作符：</p><ul><li>转化为各种集合，例如 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html"><code>toList</code></a> 与 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-set.html"><code>toSet</code></a></li><li>获取第一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/first.html"><code>first</code></a> 值与确保流发射单个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/single.html"><code>single</code></a> 值的操作符</li><li>使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/reduce.html"><code>reduce</code></a> 与 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/fold.html"><code>fold</code></a> 将流规约到单个值</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithTerminalOperators</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.5</span>).asFlow()<br>        .map &#123; it * it &#125; <span class="hljs-comment">// 数字 1 至 5 的平方</span><br>        <span class="hljs-comment">// .toList()</span><br>        .reduce &#123; a, b -&gt; a + b &#125; <span class="hljs-comment">// 求和</span><br>        .let &#123; println(it) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="flowOn-操作符"><a href="#flowOn-操作符" class="headerlink" title="flowOn 操作符"></a><code>flowOn</code> 操作符</h5><p>前面说过不允许直接使用 <code>withContext</code> 修改上下文，所以正确更改流发射的上下文需要通过 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html"><code>flowOn</code></a> 操作符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithFlowOn</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    flowList()<br>        .flowOn(Dispatchers.Default)<br>        .collect &#123; println(it) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="缓冲操作符"><a href="#缓冲操作符" class="headerlink" title="缓冲操作符"></a>缓冲操作符</h5><p>我们可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html">buffer</a> 操作符来并发运行上流中发射元素的代码以及 collect 中的代码，而不是顺序运行它们：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithBuffer</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        flowList()<br>            .buffer() <span class="hljs-comment">// 缓冲发射项，无需等待</span><br>            .collect &#123; value -&gt;<br>                delay(<span class="hljs-number">300</span>)<br>                println(value)<br>            &#125;<br>    &#125;<br>    println(<span class="hljs-string">&quot;Collected in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="conflate"><a href="#conflate" class="headerlink" title="conflate"></a><code>conflate</code></h6><p>当流只代表部分操作结果或操作状态更新时，可能没有必要处理每个值，而是只处理最新的值。当收集器处理它们太慢的时候，我们可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html">conflate</a> 操作符，用于跳过中间值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithConflate</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        flowList()<br>            .conflate() <span class="hljs-comment">// 合并发射项，不对每个值进行处理</span><br>            .collect &#123; value -&gt;<br>                delay(<span class="hljs-number">300</span>)<br>                println(value)<br>            &#125;<br>    &#125;<br>    println(<span class="hljs-string">&quot;Collected in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Emitting</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">Emitting</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">Emitting</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">3</span><br><span class="hljs-attribute">Collected</span> in <span class="hljs-number">797</span> ms<br></code></pre></td></tr></table></figure><p>可以看到，虽然第一个数字仍在处理中，但第二个和第三个数字已经产生，因此第二个被 <em>conflated</em>，只有最新的（第三个）被交付给收集器。</p><h6 id="collectLatest"><a href="#collectLatest" class="headerlink" title="collectLatest"></a><code>collectLatest</code></h6><p>当发射器和收集器都很慢的时候，合并是加快处理速度的一种方式，它通过删除发射值来实现。另一种方式是取消缓慢的收集器，并在每次发射新值的时候再收集：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithCollectLatest</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        flowList()<br>            .collectLatest &#123; value -&gt; <span class="hljs-comment">// 只收集最新的值</span><br>                println(<span class="hljs-string">&quot;Collecting <span class="hljs-variable">$value</span>&quot;</span>)<br>                delay(<span class="hljs-number">300</span>)<br>                println(<span class="hljs-string">&quot;Done with <span class="hljs-variable">$value</span>&quot;</span>)<br>            &#125;<br>    &#125;<br>    println(<span class="hljs-string">&quot;Collected in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，由于 <code>flowList</code> 每个 100ms 发射一个新值，但是收集的时候会被 <code>delay</code> 300ms，所以只有最后一个值才会被收集。</p><h5 id="合并操作符"><a href="#合并操作符" class="headerlink" title="合并操作符"></a>合并操作符</h5><h6 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a><code>Zip</code></h6><p>与标准库中的 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/zip.html">Sequence.zip</a> 扩展函数一样，流拥有一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html">zip</a> 操作符用于组合两个流：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithZip</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> nums = (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow()<br>    <span class="hljs-keyword">val</span> strs = flowOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)<br>    nums.zip(strs) &#123; a, b -&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -&gt; <span class="hljs-variable">$b</span>&quot;</span> &#125; <span class="hljs-comment">// 组合成新的字符串</span><br>        .collect &#123; println(it) &#125; <span class="hljs-comment">// 收集并打印</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="combine"><a href="#combine" class="headerlink" title="combine"></a><code>combine</code></h6><p>当流表示一个变量或操作的最新值时，可能需要执行计算，我们可以使用 combine 来对上游流进行重新计算：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 各个时间节点下产生的单个和合并后的事件</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *    Time       : 300   400     600     800     900     1200</span><br><span class="hljs-comment"> * Single Event  :  1    one      2      two      3      three</span><br><span class="hljs-comment"> * Combined Event:     1-&gt;one  2-&gt;one  2-&gt;two  3-&gt;two  3-&gt;three</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithCombine</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> nums = (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow().onEach &#123; delay(<span class="hljs-number">300</span>) &#125; <span class="hljs-comment">// 发射数字 1..3，间隔 300 毫秒</span><br>    <span class="hljs-keyword">val</span> strs = flowOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>).onEach &#123; delay(<span class="hljs-number">400</span>) &#125; <span class="hljs-comment">// 每 400 毫秒发射一次字符串</span><br>    <span class="hljs-keyword">val</span> startTime = System.currentTimeMillis() <span class="hljs-comment">// 记录开始的时间</span><br>    nums.combine(strs) &#123; a, b -&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>-&gt;<span class="hljs-variable">$b</span>&quot;</span> &#125; <span class="hljs-comment">// 使用“zip”组合单个字符串</span><br>        .collect &#123; value -&gt; <span class="hljs-comment">// 收集并打印</span><br>            println(<span class="hljs-string">&quot;<span class="hljs-variable">$value</span> at <span class="hljs-subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="展平操作符"><a href="#展平操作符" class="headerlink" title="展平操作符"></a>展平操作符</h5><p>流表示异步接收的值的序列，所以很容易遇到这样的情况：每个值都会触发对另一个值序列的请求。所有当我们对流进行操作的时候会出现包含流的流，这个时候我们就需要对流进行展平 (<em>flatten</em>) 然后再进行其它操作。</p><h6 id="flatMapConcat"><a href="#flatMapConcat" class="headerlink" title="flatMapConcat"></a><code>flatMapConcat</code></h6><p>展平连接主要由 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html">flatMapConcat</a> 与 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-concat.html">flattenConcat</a> 操作符实现。</p><h6 id="flatMapMerge"><a href="#flatMapMerge" class="headerlink" title="flatMapMerge"></a><code>flatMapMerge</code></h6><p>另一种展平模式是并发收集所有传入的流，并将它们的值合并到一个单独的流，以便尽快的发射值。 它由 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-merge.html">flatMapMerge</a> 与 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-merge.html">flattenMerge</a> 操作符实现。他们都接收可选的用于限制并发收集的流的个数的 <code>concurrency</code> 参数（默认情况下，它等于 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-d-e-f-a-u-l-t_-c-o-n-c-u-r-r-e-n-c-y.html">DEFAULT_CONCURRENCY</a>）。</p><h6 id="flatMapLatest"><a href="#flatMapLatest" class="headerlink" title="flatMapLatest"></a><code>flatMapLatest</code></h6><p>与 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html">collectLatest</a> 操作符类似，在发出新流后立即取消先前流的收集，这由 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html">flatMapLatest</a> 操作符来实现。</p><h5 id="异常操作符"><a href="#异常操作符" class="headerlink" title="异常操作符"></a>异常操作符</h5><p>当运算符中的发射器或代码抛出异常时，我们可以使用异常操作符对异常进行处理。</p><h6 id="使用-try-catch-捕获异常"><a href="#使用-try-catch-捕获异常" class="headerlink" title="使用 try..catch 捕获异常"></a>使用 try..catch 捕获异常</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFlowWithTryCatch</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        flowList().collect &#123; value -&gt;<br>            println(value)<br>            check(value &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-string">&quot;Collected <span class="hljs-variable">$value</span>&quot;</span> &#125; <span class="hljs-comment">// 值 &gt; 1 的时候抛出一个 IllegalStateException</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;<br>        println(<span class="hljs-string">&quot;Caught <span class="hljs-variable">$e</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，上面这个例子中实际上捕获了任何在发射器或者过渡操作符、末端操作符中抛出的异常。</p><h6 id="catch-操作符"><a href="#catch-操作符" class="headerlink" title="catch 操作符"></a><code>catch</code> 操作符</h6><p>发射器可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch</a> 操作符来保留此异常的透明性并允许封装它的异常处理。<code>catch</code> 操作符的代码块可以分析异常并根据捕获到的异常以不同的方式对其做出反应，它的特点是：</p><ul><li>可以使用 <code>throw</code> 重新抛出异常</li><li>可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">emit</a> 将异常转换为值发射出去</li><li>可以将异常忽略，或用日志打印，或使用一些其他代码处理它</li><li>仅捕获上游异常</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">catchFlowException</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        flowListWithException()<br>            .<span class="hljs-keyword">catch</span> &#123; e -&gt; emit(<span class="hljs-string">&quot;Caught <span class="hljs-variable">$e</span>&quot;</span>) &#125; <span class="hljs-comment">// 发射一个异常</span><br>            .collect &#123; value -&gt;<br>                check(value.length &lt; <span class="hljs-number">20</span>) &#123; <span class="hljs-string">&quot;Collected <span class="hljs-variable">$value</span>&quot;</span> &#125; <span class="hljs-comment">// 仅捕获上游异常</span><br>                println(<span class="hljs-string">&quot;Collect <span class="hljs-variable">$value</span>&quot;</span>)<br>            &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>        <span class="hljs-comment">// 捕获下游的异常</span><br>        println(<span class="hljs-string">&quot;Collect Exception: <span class="hljs-variable">$e</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="声明式捕获-onEach"><a href="#声明式捕获-onEach" class="headerlink" title="声明式捕获 onEach"></a>声明式捕获 <code>onEach</code></h6><p>我们可以将 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch</a> 操作符的声明性与处理所有异常的期望相结合，将 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> 操作符的代码块移动到 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html">onEach</a> 中，并将其放到 <code>catch</code> 操作符之前。收集该流必须由调用无参的 <code>collect()</code> 来触发：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">catchFlowExceptionOnEach</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    flowListWithException()<br>        .onEach &#123;<br>            check(it.length &gt; <span class="hljs-number">10</span>) &#123; <span class="hljs-string">&quot;Collected <span class="hljs-variable">$it</span>&quot;</span> &#125;<br>            println(it)<br>        &#125;<br>        .<span class="hljs-keyword">catch</span> &#123; println(<span class="hljs-string">&quot;Caught <span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>        .collect()<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="完成操作符"><a href="#完成操作符" class="headerlink" title="完成操作符"></a>完成操作符</h5><p>当流收集完成时（普通情况或异常情况），它可能需要执行一个动作。我们可以使用命令式或声明式在流完成时做一些操作。</p><h6 id="命令式-finally-块"><a href="#命令式-finally-块" class="headerlink" title="命令式 finally 块"></a>命令式 finally 块</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">flowWithFinally</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        flowList().collect &#123; println(<span class="hljs-string">&quot;Collected <span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        println(<span class="hljs-string">&quot;Done&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="声明式处理-onCompletion"><a href="#声明式处理-onCompletion" class="headerlink" title="声明式处理 onCompletion"></a>声明式处理 <code>onCompletion</code></h6><p>我们可以使用 <code>onCompletion</code> 操作符在流完成收集时进行调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">flowOnCompletion</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    flowList()<br>        .onCompletion &#123; println(<span class="hljs-string">&quot;Done&quot;</span>) &#125;<br>        .collect &#123; println(<span class="hljs-string">&quot;Collected <span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的输出和使用 <code>finally</code> 代码块的输出一致，除此之外，如果流完成时抛出了异常我们还可以通过 <code>onCompletion</code> 中的可空参数进行捕捉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">flowOnCompletionWithUpStreamException</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    flowListWithException()<br>        .onCompletion &#123; cause -&gt; cause?.let &#123; println(<span class="hljs-string">&quot;Flow completed but has exceptions: <span class="hljs-variable">$it</span>&quot;</span>) &#125; &#125;<br>        .<span class="hljs-keyword">catch</span> &#123; println(<span class="hljs-string">&quot;Exception: <span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>        .collect &#123; println(<span class="hljs-string">&quot;Collected <span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，<code>onCompletion</code> 不会对异常进行处理，而是交由后面的 <code>catch</code> 操作符进行处理。并且与 <code>catch</code> 操作符不同，收集时抛出的异常在 <code>onCompletion</code> 也会感知到：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">flowOnCompletionWithDownStreamException</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    flowList()<br>        <span class="hljs-comment">// onCompletion 能观察到所有的异常，包括下游收集时抛出的异常</span><br>        .onCompletion &#123; cause -&gt; cause?.let &#123; println(<span class="hljs-string">&quot;Flow completed but has exceptions: <span class="hljs-variable">$it</span>&quot;</span>) &#125; &#125;<br>        .<span class="hljs-keyword">catch</span> &#123; println(<span class="hljs-string">&quot;Exception: <span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>        .collect &#123;<br>            check(it &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-string">&quot;Illegal value: <span class="hljs-variable">$it</span>&quot;</span> &#125;<br>            println(<span class="hljs-string">&quot;Collected <span class="hljs-variable">$it</span>&quot;</span>)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>选择命令式或者声明式对异常和流完成进行处理，取决于我们的需求和喜好，两种方式都是有效的。</p><h5 id="启动操作符"><a href="#启动操作符" class="headerlink" title="启动操作符"></a>启动操作符</h5><p>我们可以使用 <code>launchIn</code> 替换 <code>collect</code>，在单独的协程中启动流的收集。我们需要通过指定参数 <code>CoroutineScope</code> 用以确定哪一个协程来启动流的收集。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">flowWithLaunchIn</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    flowList()<br>        .onEach &#123; event -&gt; println(<span class="hljs-string">&quot;Event: <span class="hljs-variable">$event</span>&quot;</span>) &#125;<br>        .launchIn(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// &lt;--- 在单独的协程中执行流</span><br>    println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在实际的应用中，作用域来自于一个寿命有限的实体。在该实体的寿命终止后，相应的作用域就会被取消，即取消相应流的收集。这种成对的 <code>onEach &#123; ... &#125;.launchIn(scope)</code> 工作方式就像 <code>addEventListener</code> 一样。而且，这不需要相应的 <code>removeEventListener</code> 函数， 因为取消与结构化并发可以达成这个目的。</p><p>另外，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/launch-in.html">launchIn</a> 也会返回一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>，可以在不取消整个作用域的情况下仅<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/cancel.html">取消</a>相应的流收集或对其进行 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html">join</a>。</p><h6 id="可取消的流"><a href="#可取消的流" class="headerlink" title="可取消的流"></a>可取消的流</h6><p>使用 <code>flow &#123; ... &#125;</code> 创建的流会对每个发射值执行附加的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/ensure-active.html">ensureActive</a> 检测以进行取消，但是大多数其它流（比如 <code>asFlow()</code>）都不会自行执行取消检测，不过我们可以在 <code>onEach</code> 中对添加 <code>currentCoroutineContext().ensureActive()</code> 或者使用 <code>cancellable</code> 操作符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeFlowCancellable</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.5</span>).asFlow().cancellable().collect &#123; value -&gt;<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-number">3</span>) cancel()<br>        println(value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Flow-与-Rx"><a href="#Flow-与-Rx" class="headerlink" title="Flow 与 Rx"></a>Flow 与 Rx</h4><p>熟悉 RxJava 的人会觉得 Flow 非常相似，这是因为 Flow 的设计灵感正是来源于响应式流及其各种实现。虽然略有不同，但从概念上讲，Flow <em>依然是</em> 响应式流。</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>通道提供了一种在流中传输值的方法。</p><h4 id="通道基础"><a href="#通道基础" class="headerlink" title="通道基础"></a>通道基础</h4><p>一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html">Channel</a> 是一个和 <code>BlockingQueue</code> 非常相似的概念。其中一个不同是它代替了阻塞的 <code>put</code> 操作并提供了挂起的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/send.html">send</a>，还替代了阻塞的 <code>take</code> 操作并提供了挂起的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html">receive</a>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">headFirstChannel</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;() <span class="hljs-comment">// 实现了 SendChannel 和 ReceiveChannel</span><br>    launch &#123;<br>        <span class="hljs-comment">// 这里可能是消耗大量 CPU 运算的异步逻辑，我们将仅仅做 5 次整数的平方并发送</span><br>        <span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span>) channel.send(x * x)<br>    &#125;<br>    <span class="hljs-comment">// 这里我们打印了 5 次被接收的整数：</span><br>    repeat(<span class="hljs-number">5</span>) &#123; println(channel.receive()) &#125;<br>    println(<span class="hljs-string">&quot;Done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="通道的关闭与迭代"><a href="#通道的关闭与迭代" class="headerlink" title="通道的关闭与迭代"></a>通道的关闭与迭代</h5><p>和队列不同，一个通道可以通过被关闭来表明没有更多的元素将会进入通道。在接收者中可以使用 <code>for</code> 循环来从通道中接收元素：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">closeAndIterateChannel</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;()<br>    launch &#123;<br>        <span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span>) channel.send(x * x)<br>        channel.close()<br>    &#125;<br>    <span class="hljs-keyword">for</span> (c <span class="hljs-keyword">in</span> channel) println(c)<br>    println(<span class="hljs-string">&quot;Done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="构建通道生产者"><a href="#构建通道生产者" class="headerlink" title="构建通道生产者"></a>构建通道生产者</h5><p>使用生产者-消费者模式对通道进行创建和使用，需要注意这些接口是实验性的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produceAndConsumeChannel</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    produce &#123;<br>        <span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span>) send(x * x)<br>    &#125;.consumeEach &#123; println(it) &#125;<br>    println(<span class="hljs-string">&quot;Done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道是指在一个协程中创建拥有无穷多个值的流。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">infiniteNumberPipeline</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> numbers = produce &#123;<br>        <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) send(x++)<br>    &#125;<br>    <span class="hljs-keyword">val</span> squares = produce &#123;<br>        <span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> numbers) send(x * x)<br>    &#125;<br>    repeat(<span class="hljs-number">10</span>) &#123;<br>        print(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;squares.receive()&#125;</span>, &quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Done!&quot;</span>)<br><br>    <span class="hljs-comment">// 获取 coroutineContext 取消所有后续的 job</span><br>    coroutineContext.cancelChildren()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="扇出"><a href="#扇出" class="headerlink" title="扇出"></a>扇出</h4><p>多个协程也许会接收相同的管道，它们之间可以进行分布式的工作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">panOut</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> producer = infiniteDelayedNumbers(<span class="hljs-number">1</span>)<br>    repeat(<span class="hljs-number">5</span>) &#123; launchProcessors(it, producer) &#125;<br>    delay(<span class="hljs-number">950</span>) <span class="hljs-comment">// 等待一会儿</span><br>    producer.cancel() <span class="hljs-comment">// 取消 channel</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="扇入"><a href="#扇入" class="headerlink" title="扇入"></a>扇入</h4><p>多个协程可以发送到同一个通道。 比如说，让我们创建一个字符串的通道，并且在这个通道中以指定的延迟反复发送一个字符串：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">panIn</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> channel = Channel&lt;String&gt;()<br>    launch &#123; sendString(channel, <span class="hljs-string">&quot;Foo&quot;</span>, <span class="hljs-number">200</span>) &#125;<br>    launch &#123; sendString(channel, <span class="hljs-string">&quot;Bar&quot;</span>, <span class="hljs-number">500</span>) &#125;<br>    repeat(<span class="hljs-number">6</span>) &#123; println(channel.receive()) &#125;<br>    coroutineContext.cancelChildren()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="带缓冲的通道"><a href="#带缓冲的通道" class="headerlink" title="带缓冲的通道"></a>带缓冲的通道</h4><p>到目前为止展示的通道都是没有缓冲区的。无缓冲的通道在发送者和接收者相遇时才传输元素，也叫<em>对接</em>。如果发送先被调用，则它将被挂起直到接收被调用；如果接收先被调用，则它将被挂起直到发送被调用。</p><p><code>Channel</code> 构造器与 <code>produce</code> 建造器通过一个可选的参数 <code>capacity</code> 来指定<em>缓冲区的大小</em>。缓冲允许发送者在被挂起前发送多个元素， 就像 <code>BlockingQueue</code> 有指定的容量一样，当缓冲区被占满的时候将会引起阻塞。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bufferedChannels</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">val</span> sender = launch &#123;<br>        repeat(<span class="hljs-number">10</span>) &#123;<br>            println(<span class="hljs-string">&quot;Sending <span class="hljs-variable">$it</span>&quot;</span>)<br>            channel.send(it)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 不对其进行接收，只是等待</span><br>    delay(<span class="hljs-number">1000</span>)<br>    sender.cancel()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="通道是公平的"><a href="#通道是公平的" class="headerlink" title="通道是公平的"></a>通道是公平的</h4><p>发送和接收操作是<em>公平的</em> 并且尊重调用它们的多个协程。它们遵守先进先出原则，可以看到第一个协程调用 <code>receive</code> 并得到了元素。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">channelIsSequential</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ball</span></span>(<span class="hljs-keyword">var</span> hits: <span class="hljs-built_in">Int</span>)<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">player</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, table: <span class="hljs-type">Channel</span>&lt;<span class="hljs-type">Ball</span>&gt;)</span></span> &#123;<br>        <span class="hljs-keyword">for</span> (ball <span class="hljs-keyword">in</span> table) &#123; <span class="hljs-comment">// 在循环中接收球</span><br>            ball.hits++<br>            println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> <span class="hljs-variable">$ball</span>&quot;</span>)<br>            delay(<span class="hljs-number">300</span>) <span class="hljs-comment">// 等待一段时间</span><br>            table.send(ball) <span class="hljs-comment">// 将球发送回去</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> table = Channel&lt;Ball&gt;()<br>    <span class="hljs-comment">// 先启动的协程先接收到事件</span><br>    launch &#123; player(<span class="hljs-string">&quot;ping&quot;</span>, table) &#125;<br>    launch &#123; player(<span class="hljs-string">&quot;pong&quot;</span>, table) &#125;<br>    table.send(Ball(<span class="hljs-number">0</span>))<br>    delay(<span class="hljs-number">2000</span>)<br>    coroutineContext.cancelChildren()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="计时器通道"><a href="#计时器通道" class="headerlink" title="计时器通道"></a>计时器通道</h4><p>计时器通道是一种特别的会合通道 (<code>ReceiveChannel</code>)，每次经过特定的延迟都会从该通道进行消费并产生 <code>Unit</code>。虽然它看起来似乎没用，它被用来构建分段来创建复杂的基于时间的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html">produce</a> 管道和进行窗口化操作以及其它时间相关的处理。可以在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html">select</a> 中使用计时器通道来进行“打勾”操作。</p><p>使用工厂方法 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html">ticker</a> 来创建这些通道，使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html">ReceiveChannel.cancel</a> 方法关闭通道。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tickerChannel</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> tickerChannel = ticker(delayMillis = <span class="hljs-number">1000</span>, initialDelayMillis = <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">var</span> nextElement = withTimeoutOrNull(<span class="hljs-number">1</span>) &#123; tickerChannel.receive() &#125;<br>    println(<span class="hljs-string">&quot;Initial element is available immediately: <span class="hljs-variable">$nextElement</span>&quot;</span>)<br><br>    nextElement = withTimeoutOrNull(<span class="hljs-number">500</span>) &#123; tickerChannel.receive() &#125;<br>    println(<span class="hljs-string">&quot;Next element is not available in 500ms: <span class="hljs-variable">$nextElement</span>&quot;</span>)<br><br>    nextElement = withTimeoutOrNull(<span class="hljs-number">600</span>) &#123; tickerChannel.receive() &#125;<br>    println(<span class="hljs-string">&quot;Next element is available in 1100ms: <span class="hljs-variable">$nextElement</span>&quot;</span>)<br><br>    println(<span class="hljs-string">&quot;Consumer pauses for 1500ms&quot;</span>)<br>    delay(<span class="hljs-number">1500</span>)<br><br>    nextElement = withTimeoutOrNull(<span class="hljs-number">1</span>) &#123; tickerChannel.receive() &#125;<br>    println(<span class="hljs-string">&quot;Next element is available after delay: <span class="hljs-variable">$nextElement</span>&quot;</span>)<br><br>    nextElement = withTimeoutOrNull(<span class="hljs-number">600</span>) &#123; tickerChannel.receive() &#125;<br>    println(<span class="hljs-string">&quot;Next element is available sooner because of the previous delay: <span class="hljs-variable">$nextElement</span>&quot;</span>)<br><br>    tickerChannel.cancel()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异常处理与监督"><a href="#异常处理与监督" class="headerlink" title="异常处理与监督"></a>异常处理与监督</h3><p>我们已经知道被取消的协程会在挂起点抛出 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a> 并且它会被协程的机制所忽略。在这里我们会看看在取消过程中抛出异常或同一个协程的多个子协程抛出异常时会发生什么。</p><h4 id="异常的传播"><a href="#异常的传播" class="headerlink" title="异常的传播"></a>异常的传播</h4><p>协程构建器有两种形式：自动传播异常（<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a> 与 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html">actor</a>）或向用户暴露异常（<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> 与 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html">produce</a>）。当这些构建器用于创建一个<em>根</em> 协程时，即该协程不是另一个协程的<em>子</em> 协程，前者这类构建器将异常视为<strong>未捕获</strong>异常，类似 Java 的 <code>Thread.uncaughtExceptionHandler</code>，而后者则依赖用户来最终消费异常，例如通过 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html">await</a> 或 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html">receive</a>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">exceptionPropagation</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> job = GlobalScope.launch &#123; <span class="hljs-comment">// launch 自动传播异常</span><br>        println(<span class="hljs-string">&quot;Throwing exception from launch&quot;</span>)<br>        <span class="hljs-keyword">throw</span> IndexOutOfBoundsException()<br>    &#125;<br>    job.join()<br>    println(<span class="hljs-string">&quot;Joined failed job&quot;</span>)<br>    <span class="hljs-keyword">val</span> deferred = GlobalScope.async &#123; <span class="hljs-comment">// async 用户调用处消费异常</span><br>        println(<span class="hljs-string">&quot;Throwing exception from async&quot;</span>)<br>        <span class="hljs-keyword">throw</span> ArithmeticException() <span class="hljs-comment">// 没有打印任何东西，依赖用户去调用等待</span><br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        deferred.await()<br>        println(<span class="hljs-string">&quot;Unreached&quot;</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (e: ArithmeticException) &#123;<br>        println(<span class="hljs-string">&quot;Caught ArithmeticException&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="CoroutineExceptionHandler"><a href="#CoroutineExceptionHandler" class="headerlink" title="CoroutineExceptionHandler"></a>CoroutineExceptionHandler</h4><p>将<strong>未捕获</strong>异常打印到控制台的默认行为是可自定义的。<em>根</em> 协程中的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html">CoroutineExceptionHandler</a> 上下文元素可以被用于这个根协程通用的 <code>catch</code> 块，及其所有可能自定义了异常处理的子协程。 </p><p>它类似于 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><code>Thread.uncaughtExceptionHandler</code></a> 。你无法从 <code>CoroutineExceptionHandler</code> 的异常中恢复。当调用处理者的时候，协程已经完成并带有相应的异常。通常，该处理者用于记录异常，显示某种错误消息，终止和（或）重新启动应用程序。</p><h4 id="取消与异常"><a href="#取消与异常" class="headerlink" title="取消与异常"></a>取消与异常</h4><p>取消与异常紧密相关。协程内部使用 <code>CancellationException</code> 来进行取消，这个异常会被所有的处理者忽略，所以那些可以被 <code>catch</code> 代码块捕获的异常仅仅应该被用来作为额外调试信息的资源。当一个协程使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/cancel.html">Job.cancel</a> 取消的时候，它会被终止，但是它不会取消它的父协程。</p><h4 id="异常聚合"><a href="#异常聚合" class="headerlink" title="异常聚合"></a>异常聚合</h4><p>当协程的多个子协程因异常而失败时，一般规则是“取第一个异常”，因此将处理第一个异常。在第一个异常之后发生的所有其他异常都作为被抑制的异常绑定至第一个异常。</p><h4 id="监督"><a href="#监督" class="headerlink" title="监督"></a>监督</h4><p>取消是在协程的整个层次结构中传播的双向关系。让我们看一下需要单向取消的情况。</p><p>此类需求的一个良好示例是在其作用域内定义作业的 UI 组件。如果任何一个 UI 的子作业执行失败了，它并不总是有必要取消（有效地杀死）整个 UI 组件， 但是如果 UI 组件被销毁了（并且它的作业也被取消了），由于它的结果不再被需要了，它有必要使所有的子作业执行失败。</p><p>另一个例子是服务进程孵化了一些子作业并且需要<em>监督</em> 它们的执行，追踪它们的故障并在这些子作业执行失败的时候重启。</p><h5 id="监督作业"><a href="#监督作业" class="headerlink" title="监督作业"></a>监督作业</h5><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-supervisor-job.html">SupervisorJob</a> 可以用于这些目的。它类似于常规的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job.html">Job</a>，唯一的不同是：<code>SupervisorJob</code> 的取消只会向下传播：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">supervisorJobExample</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> supervisor = SupervisorJob()<br>    with(CoroutineScope(coroutineContext + supervisor)) &#123;<br>        <span class="hljs-comment">// 启动第一个子作业——这个示例将会忽略它的异常（不要在实践中这么做！）</span><br>        <span class="hljs-keyword">val</span> firstChild = launch(CoroutineExceptionHandler &#123; _, _ -&gt;  &#125;) &#123;<br>            println(<span class="hljs-string">&quot;The first child is failing&quot;</span>)<br>            <span class="hljs-keyword">throw</span> AssertionError(<span class="hljs-string">&quot;The first child is cancelled&quot;</span>)<br>        &#125;<br>        <span class="hljs-comment">// 启动第二个子作业</span><br>        <span class="hljs-keyword">val</span> secondChild = launch &#123;<br>            firstChild.join()<br>            <span class="hljs-comment">// 取消了第一个子作业且没有传播给第二个子作业</span><br>            println(<span class="hljs-string">&quot;The first child is cancelled: <span class="hljs-subst">$&#123;firstChild.isCancelled&#125;</span>, but the second one is still active&quot;</span>)<br>            <span class="hljs-keyword">try</span> &#123;<br>                delay(<span class="hljs-built_in">Long</span>.MAX_VALUE)<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 但是取消了监督的传播</span><br>                println(<span class="hljs-string">&quot;The second child is cancelled because the supervisor was cancelled&quot;</span>)<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 等待直到第一个子作业失败且执行完成</span><br>        firstChild.join()<br>        println(<span class="hljs-string">&quot;Cancelling the supervisor&quot;</span>)<br>        supervisor.cancel()<br>        secondChild.join()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="监督作用域"><a href="#监督作用域" class="headerlink" title="监督作用域"></a>监督作用域</h5><p>对于<em>作用域</em> 的并发，可以用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html">supervisorScope</a> 来替代 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a> 来实现相同的目的。它只会单向的传播并且当作业自身执行失败的时候将所有子作业全部取消。作业自身也会在所有的子作业执行结束前等待，就像 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a> 所做的那样。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">supervisorScopeExample</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        supervisorScope &#123;<br>            <span class="hljs-keyword">val</span> child = launch &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    println(<span class="hljs-string">&quot;The child is sleeping&quot;</span>)<br>                    delay(<span class="hljs-built_in">Long</span>.MAX_VALUE)<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    println(<span class="hljs-string">&quot;The child is cancelled&quot;</span>)<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 使用 yield 来给我们的子作业一个机会来执行打印</span><br>            yield()<br>            println(<span class="hljs-string">&quot;Throwing an exception from the scope&quot;</span>)<br>            <span class="hljs-keyword">throw</span> AssertionError()<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e: AssertionError) &#123;<br>        println(<span class="hljs-string">&quot;Caught an assertion error&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="监督协程中的异常"><a href="#监督协程中的异常" class="headerlink" title="监督协程中的异常"></a>监督协程中的异常</h5><p>常规的作业和监督作业之间的另一个重要区别是异常处理。监督协程中的每一个子作业应该通过异常处理机制处理自身的异常。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">coroutineExceptionHandler</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> handler = CoroutineExceptionHandler &#123; _, exception -&gt;<br>        println(<span class="hljs-string">&quot;CoroutineExceptionHandler got <span class="hljs-variable">$exception</span>&quot;</span>)<br>    &#125;<br>    supervisorScope &#123;<br>        <span class="hljs-keyword">val</span> child = launch(handler) &#123;<br>            println(<span class="hljs-string">&quot;The child throws an exception&quot;</span>)<br>            <span class="hljs-keyword">throw</span> AssertionError()<br>        &#125;<br>        println(<span class="hljs-string">&quot;The scope is completing&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;The scope is completed&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="共享的可变状态与并发"><a href="#共享的可变状态与并发" class="headerlink" title="共享的可变状态与并发"></a>共享的可变状态与并发</h3><p>协程可被多线程调度器并发地执行，这会造成常见的并发问题。主要的问题是同步访问<strong>共享的可变状态</strong>。</p><h4 id="线程安全的数据结构"><a href="#线程安全的数据结构" class="headerlink" title="线程安全的数据结构"></a>线程安全的数据结构</h4><p>一种对线程、协程都有效的常规解决方法，就是使用线程安全（也称为同步的、 可线性化、原子）的数据结构，它为需要在共享状态上执行的相应操作提供所有必需的同步处理。比如使用 <code>AtomicInteger</code> 类代替 Int 类。</p><h4 id="以细粒度限制线程"><a href="#以细粒度限制线程" class="headerlink" title="以细粒度限制线程"></a>以细粒度限制线程</h4><p><em>限制线程</em> 是解决共享可变状态问题的一种方案：对特定共享状态的所有访问权都限制在单个线程中。它通常应用于 UI 程序中：所有 UI 状态都局限于单个事件分发线程或应用主线程中。这在协程中很容易实现，通过使用一个单线程上下文。</p><h4 id="以粗粒度限制线程"><a href="#以粗粒度限制线程" class="headerlink" title="以粗粒度限制线程"></a>以粗粒度限制线程</h4><p>在实践中，线程限制是在大段代码中执行的，比如在单线程上下文中运行每个协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">massiveRunExecutorCoarseGrained</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    withContext(coroutineContext) &#123;<br>        massiveRun &#123;<br>            counter++<br>        &#125;<br>    &#125;<br>    println(<span class="hljs-string">&quot;Counter = <span class="hljs-variable">$counter</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>另外我们还可以使用互斥解决方案：使用永远不会同时执行的<em>关键代码块</em> 来保护共享状态的所有修改。</p><p>在阻塞的世界中，你通常会为此目的使用 <code>synchronized</code> 或者 <code>ReentrantLock</code>。 在协程中的替代品叫做 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html">Mutex</a>，它具有 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html">lock</a> 和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html">unlock</a> 方法，可以隔离关键的部分。关键的区别在于 <code>Mutex.lock()</code> 是一个挂起函数，它不会阻塞线程。</p><p>还有 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html">withLock</a> 扩展函数，可以方便的替代常用的 <code>mutex.lock(); try &#123; …… &#125; finally &#123; mutex.unlock() &#125;</code> 模式。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>耐心地生活</title>
      <link href="/2021-4/"/>
      <url>/2021-4/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/9Uo6mMx_wYU" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>这个四月，对我来说，应该是具有特殊意义的一个月，工作和生活上都发生了重大的变化，从虎哥离职加入拾米网络，从余杭搬家到滨江。面对新的工作和生活环境，在适应了两个礼拜之后，差不多也找回并调整到了适合当下的生活节奏：每天早起写日记，冥想，去公司，学习/敲代码，吃饭/散步/休息/午睡，继续学习/敲代码，回家，跑步，洗澡，放松+练打字，睡觉。也许略显沉闷，但是每个人对生活所抱的期望不同，我觉得这样的生活就挺适合自己的。可能这就是年纪渐长的好处吧，别人的评价对我来说已经不像过去那样有分量了。生活是自己的，只要过得开心、充实就很好了。当然，还是会期待爱情，期待结交更多新朋友，但是，事情总是要一件件发生的，当你还没准备好的时候，即使好事发生到你身上你也接不住。</p><p>所以，还是要更有耐心一点啊，耐心地阅读，耐心地成长，同时耐心地感受生活中的每一个琐碎的瞬间——美好就藏在那些你注意不到的细节里。路边一排排盛开的百合花，早上和你打招呼的小区阿姨，跑步时和你暗暗较劲的陌生人，同事请吃的冰激凌，等等等等。生活其实就是这样吧，当你用心感受，时常感恩，不需要太多物质上的刺激也能感受到幸福。能够努力做事的同时又能感受到每天生活中的细腻瞬间，这差不多就是我向往的美好人生了吧。希望自己能努力维持住这样的生活状态，当然，也希望未来我能帮助更多人找到这样的生活状态。</p></blockquote><span id="more"></span><h4 id="4-月-1-日-先修身然后再想其他"><a href="#4-月-1-日-先修身然后再想其他" class="headerlink" title="4 月 1 日 - 先修身然后再想其他"></a>4 月 1 日 - 先修身然后再想其他</h4><p>能够拥有好观念的确是一种优势，但是仅仅拥有好观念是不够的，你需要在好观念的影响下去行动，去产生价值。回看自己过去写的碎碎念，的确，我有好的意图，但是最终产生了多大的结果？影响了多少人的生活？并不见得有多少。所以，我觉得此刻的自己最需要的是<strong>专注</strong>，专注地把一件事情做好，把一个技能打磨好，然后用它产生社会价值。这样，你的好意图才是有意义的，才是有说服力的。如果你连一件令自己感到骄傲的事情都没有，那还怎么让别人信服？同样一句话，被不同的人说出来，份量是不同的。当你的能力达到某种高度的时候，你的影响力也会随之提高，这个时候你的好意图才能得到最大程度的体现。当然，这并不是说，当我们能力还不够的时候就不该去实践这些好的意图、去帮助他人，只不过我们应该花更多的时间提高自己。其实说了这么多，用古人的一句话就够了：修身，齐家，治国，平天下。该修身的时候先修身，然后再想其他。</p><h4 id="4-月-2-日-关于工作中的成长"><a href="#4-月-2-日-关于工作中的成长" class="headerlink" title="4 月 2 日 - 关于工作中的成长"></a>4 月 2 日 - 关于工作中的成长</h4><p>对当下的我来说，工作中最重要的问题是：<strong>我获得了哪些成长？</strong>其它的一切都是次要的，比如薪资待遇，未来的发展，同事关系等等。在人生的不同阶段，对于一段工作经历，我们期望获得的东西是不同的。比如刚毕业的时候，我们期望自己的能力能够得到锻炼，能够快速成长。等到工作几年之后，积累了一定的经验，我们开始更看重平台和未来的发展。等到你到进入成熟期之后，有了成家立业的压力，于是开始看重待遇和公司发展的前景以及是否稳定等等。这些需求本身并没有错，但是，我们的这些愿望背后其实暗含一个潜在的要求，那就是我们自身要能够不断成长，我们的各方面能力能够随着年岁的增长而增长。当你停止自我更新、停止成长的时候，也就意味着你未来的发展道路即将陷入停滞，对于能否保持住当前的状态也是堪忧的。</p><p>另外，还需要意识到的是，无论加入哪一家公司，能够为你规划未来的人只有你自己，你的领导没有义务也无法为你规划你的职业发展道路。因为<strong>没有人能为你的成长负责，只有你自己才能为你的成长负责</strong>。只有你自己才能真正了解你自己，只有你自己才能清楚地知道什么是适合自己的。如果你把自己的未来交给他人，那么最终大概率只能收获到不幸。当然，能够得到有经验的人的指导会更有利于你找到自己的职业发展方向，但是最终做决定的还是你自己，你需要进行长期的、独立的思考，结合个人的能力和兴趣点，在实践中，慢慢朝着自己规划的方向前进，同时一边不断修正自己的方向。没有人或者很少有人是一开始就知道自己的发展方向的，只有靠不断地摸索和试验，还有就是要积极地行动起来，光靠坐着空想是没用的。</p><h4 id="4-月-3-日-爱别人之前先爱自己"><a href="#4-月-3-日-爱别人之前先爱自己" class="headerlink" title="4 月 3 日 - 爱别人之前先爱自己"></a>4 月 3 日 - 爱别人之前先爱自己</h4><p>昨晚回家路上想了很多，关于未来还有爱情。老实说，我对自己的未来其实没有太多的规划，一直是走一步算一步的状态。知道这样不对，应该要有目标和计划，但是却不知道从哪里开始。关于爱情也是一样，知道要找到自己爱的人，但是几次尝试都以失败告终。我不知道自己到底哪里出了问题。</p><p>找到自己热爱的事业其实还简单一些，只要不断尝试，然后从可选项中选择一些自己不讨厌的开始做，等到自己熟悉并且积累了一些经验之后再深入下去，慢慢发现并享受其中的乐趣就好了。但是爱情，涉及到两个人，难度就高上很多了。需要你对自身有清晰的定位，你们的成长经历、教育经历、所拥有的观念、个人喜好等等各方面，再加上彼此性格以及相处是否融洽。在相识的初阶段能否产生化学反应决定了你们能否走到一起，而在加深了对彼此的了解之后，能否依旧对对方保持兴趣，在彼此身上发现更多的惊喜，决定了你们能走多远。最重要的一点是，你们两个人的灵魂必须是一致的，你们能够共同成长，愿意为对方去改变，愿意向对方分享各自的人生，对未来有一致的目标和规划，直到最终走向死亡。</p><p>所以，爱情永远都是奢侈品。大多数人都只是相伴度过一生而已。我甚至觉得「灵魂契合」也只不过是一个假象，事实上，没有人能够完全理解自己。语言仅仅能表达一部分的自己，其它的绝大部分都隐藏在那些不能言说的地方。正因如此，我们才需要有艺术，很多时候只有诗歌、音乐、画作等才能表达我们内心最深处的想法和情感，才能在那些言语无法触及的地方，让彼此的灵魂发生碰撞。我爱你，多么简单的一句话，但是只有 Ta 本人才知道 Ta 在这句话背后投射了多少的情感，以及感到多么地幸福和快乐。但是，在找到自己的爱情之前，还是要先好好爱自己，而爱自己又要从接纳自己开始，对自己少一些苛责，多一些包容和鼓励。不断进步是对自己最好的褒奖。</p><h4 id="4-月-4-日-追求极致和激励他人"><a href="#4-月-4-日-追求极致和激励他人" class="headerlink" title="4 月 4 日 - 追求极致和激励他人"></a>4 月 4 日 - 追求极致和激励他人</h4><p>这两天在想职业规划的事，不停地反问自己：我现在做的事是我想做的吗？我是否愿意做一辈子？说实话，心里其实是有点犹豫的。我想大多数人都类似吧。但是，如果能够抱着把自己所做的事情做到极致的心态，那么其实做什么都无所谓了。喜欢只不过是因为你很熟悉、能做得非常好，如果你能把自己的工作能做到让别人刮目相看的程度，那么自然就能获得成就感，也会觉得可以一直做下去，并且还能享受其中、越做越好。所以，我们需要的只不过是投入。投入足够的时间和精力，让自己能够不断成长。当你每天都抱着这样的心态去工作，同时保持思考和反省的习惯，随着你做这一行的时间足够长，你自然就能成为这一行的专家。而且就像很多人说过的那样，很多知识都是可以迁移的，任何一个行业的知识都可以被应用到其他行业，或者至少能够给其他行业的从业者一些启发。未来也许我们都会从事一个以上的行业，所以，要相信我们的经验在其他行业也是能发挥作用的。一切都是相连的。</p><p>除此之外，我觉得我们还应该有更长远的目标。改变自己是第一步，当解决自身的问题之后，还要思考如何激励他人。不要以为自己只是普通人，不是明星或者网红，也不是领导人或者企业家，也没有那么大的影响力。其实我们每时每刻都在影响他人，只要还活着，我们就需要和他人打交道，你说的每一句话做的每一件事都是在传播你的价值观，无论是在线上还是在线下。所以，我们一定要始终抱有一种责任感，去传递正确的价值观。不仅仅是向自己的家人，还有整个社会大众。你的一言一行都能影响到他人，要尽量对他人造成正面的影响，让他们也能像你一样热爱生活，认真对待自己的工作，关心身边的陌生人，传递善良和爱，拥有更加健康、快乐和幸福的生活。</p><h4 id="4-月-5-日-孤独需要我们直面内心"><a href="#4-月-5-日-孤独需要我们直面内心" class="headerlink" title="4 月 5 日 - 孤独需要我们直面内心"></a>4 月 5 日 - 孤独需要我们直面内心</h4><p>有时候觉得孤独即是一种不幸又是一种幸运。不幸是因为缺乏足够的社交，所以不能像那些善于社交的人一样，可以有丰富多彩的社交生活，而且很多时候都得不到足够的情感支持，在情绪糟糕的时候只能靠自己独自化解不良的情绪。但是另一方面，因为缺乏社交所以我有更多的时间去反省自己，直面自己的内心。你不得不去面对孤独，然后去给自己找一些事情做，比如阅读、运动，建立自己的爱好等。因为有着大把和自己相处的时间，你会去思考很多其他人思考得比较少的事情，比如个人幸福、人生意义等等。虽然这些问题本来就没有答案，但是随着你花的时间越多，你对自己现状和未来会有更多的感知：我是否喜欢现在的生活？我为什么要过现在这样的生活？我应该追求什么样的生活？一开始这些问题会让人感到恐惧，但是时间长了之后，你会慢慢习惯它们。无论是做好当下的每一件事，还是积极寻求新的改变，这些都是我们第一步需要面对的问题。</p><p>孤独并不可怕，只要我们能够保持反省的习惯，同时不断努力寻求给自己的生活带来积极的改变，我们同样能够生活得越来越幸福。而且我们一旦建立了人生的使命感之后，随着我们能力的不断提高，能产生的价值越来越大，感到孤独的时刻会越来越少。独处其实更多是一种个人放松和给自己充电的方式，我们需要通过独处来思考自己的未来，决定自己下一步的行动等等。改变孤独的状态，其实只需要我们改变自己的心态，很多时候我们不是渴望更多的社交或者想要向他人倾诉，而是想要逃避自己的问题，害怕面对自己的内心。所以，每当产生孤独感的时候，问问自己，我现在最想要的是什么？我在害怕什么？</p><h4 id="4-月-6-日-构建你的决策系统"><a href="#4-月-6-日-构建你的决策系统" class="headerlink" title="4 月 6 日 - 构建你的决策系统"></a>4 月 6 日 - 构建你的决策系统</h4><p>日常生活中，我们和卓越的人的差距体现在哪里？最主要的还是我们有不同的系统，具体来说是思考方式，知识和技能，生活习惯，决策方式。今天来说说决策系统。首先，卓越的人都非常擅长分辨出什么是最重要的，也就是他们遵循「要事第一」的原则，也就是常常听到的 First Principle。他们能快速判断出一件事的本质，然后选择其中最关键的难题去解决，等到关键问题解决之后剩下的就只是优化了。其次，当我们需要做两难抉择的时候，我们可以问问自己：如果选择 A，我将来后悔的概率是多大？选 B 呢？后悔的程度哪个更深？这就是「最少后悔」原则。它同样适用于要不要做某事的抉择。除此之外，我们还需要学会风险评估。做一件事之前，需要考虑失败的风险有多大，我能否承受最差的结果，而期望的获益范围如何，最糟糕的结果下获得最低的受益我是否能接受？如果可以的话，那就值得去做。不要只看到最佳受益的情况，首先要看最差结果。另外，还有一个帮助我们做决定的方式是，问问自己的内心：我「想要」和「不想要」的倾向有多大。当经过反复思考之后（尤其是冥想之后），如果感受到自己身体里的不想要的倾向大于想要的倾向，那么说明这件事可能并不值得去做。</p><h4 id="4-月-7-日-提供好服务与衡量的标准"><a href="#4-月-7-日-提供好服务与衡量的标准" class="headerlink" title="4 月 7 日 - 提供好服务与衡量的标准"></a>4 月 7 日 - 提供好服务与衡量的标准</h4><p>只要你能提供好的服务，你就能拥有自己忠实的客户，最宝贵的是客户的信任。这是我在理发的时候得到的感悟。每次回家都会去同一家理发店理发，我印象中从我上小学 4、5 年纪开始，几乎每次都去那家理发店。这种长时间积累起来的信任是很难轻易就被改变的。我喜欢让他给我理发，其实并不是因为他理的发别人就理不了了，而是他提供的服务。因为他会观察你、询问你的需求，然后理发过程中会和你确认，态度一丝不苟。即使是熟悉之后，他依旧会在每次剪完之后征求你的意见。我觉得这就是他能获得我的信任的原因。相比其他理发师，他们只是做一份工作而已。即使询问了你的意见，给人的感觉也是在例行公事，问了和没问没什么区别，他们还是会按照自己的想法去剪，并没有真正参考客户的意见。</p><p>我觉得这其实就是态度的问题。如果你能做到认真对待自己的工作，追求提供一流的服务，你永远也不会缺少客户，也不会缺少忠实的、信任你的客户。这也给了我启发，对于我的工作来说，我提供的服务是，解决工作中的问题，通过和同事的合作，做出好产品，写出高质量的代码，获得老板的信任。这对于我来说是件难事吗？我觉得相比获取自己的用户而言，其实难度也不小。而且最关键的是，无法获得及时反馈。比如某个技巧能否帮我获得更多的客户，这点是我没法评判的。我只能通过上级对我的工作是否满意，我是否获得升职加薪来判断自己做得是否足够好。但是，这种情况下衡量标准就变得复杂了，因为这取决于你的领导是如何做决策的，即使是公正且以客户为导向的领导，难免还是会有个人的喜好，一旦参杂了情感因素，那么这种判断标准就不是完全透明的了。所以，最好的做法还是去创业，去获得自己的用户，市场会给你最好的反馈。</p><h4 id="4-月-8-日-幸运与不幸"><a href="#4-月-8-日-幸运与不幸" class="headerlink" title="4 月 8 日 - 幸运与不幸"></a>4 月 8 日 - 幸运与不幸</h4><p>不得不承认，自己真的非常幸运。从小成长在一个完整且有爱的家庭，家庭关系和睦，虽然印象中父母在我小时候也常常吵架、闹矛盾，但是家中的主旋律还是相亲相爱的一家人。除此之外，我几乎没有经历过任何明显的挫折。从小学习成绩还不错，直到初中后期成绩开始退步，后来差点没考上桐中（当地最好的高中）。而且高中生活过得也不算太辛苦，即使高考前变得非常焦虑，但是高考完立马就恢复了，高考成绩虽然不理想，但是爸妈也没干涉我填志愿，学校和专业都是我自己选的。即使上的三本，爸妈也没有多说什么。上大学之后就开始放飞自我了。后来虽然觉得周围的环境不是我想要的，所以开始积极寻求改变。毕业前，靠着自学的编程技能找到了一份实习，之后又顺利入职。工作一年后跳槽到了现在这家公司，然后现在又准备跳槽了，即将进入我人生中的第三家公司。</p><p>虽然我的经历很普通，没有特别出彩的地方，但是我觉得自己挺幸福的。没有经历过苦难就不知道幸福的意义。看过太多不幸的人的遭遇，这让我在审视了自己的人生之后，更加感到感激。老天待我不薄。正因如此，我才需要更加努力，让自己过得更幸福，而且希望未来也能帮助到更多的人，让他们也能过得更幸福。我们无法决定未来会发生什么，但是，我们可以选择如何解读自己的过去。也许你的生活曾经非常不幸或者目前正在经历这种不幸，但是要记住，一切都会过去的。当事情过去之后，只要你能看到这段经历中积极正面的那部分，看到它给自己带来的成长，不幸就不仅仅是不幸，它是磨练我们心性让我们变得更加强大的工具。哪怕是经历了集中营的生活，家人朋友全都被迫害，你也能靠自己的意志力和对人性的爱活下来，找到生命的意义，并且用这段经历启发、激励成千上万的人。我们每个人都可以做到的，你比自己想象得更加强大。</p><h4 id="4-月-9-日-我的爱情观"><a href="#4-月-9-日-我的爱情观" class="headerlink" title="4 月 9 日 - 我的爱情观"></a>4 月 9 日 - 我的爱情观</h4><p>在寻求建立亲密关系时，常常会有自我怀疑的情绪出现，还会有各种瞻前顾后的担忧，比如觉得对方的外貌没有达到自己的要求，担心对方的家庭环境是否融洽，能否和自己的生活习惯保持一致，甚至觉得最好兴趣爱好都要类似。有时候觉得，虽然对方表达的观念和想法和自己基本一致，但是实际上可能还是存在较大的分歧，只不过那部分分歧没有通过语言表达出来。我相信这些问题每个人都会遇到，而且每个人都有自己的纠结。我觉得解决这些问题的根本还是应该回到最开始的地方。我们寻求亲密关系的目的是什么？是为了通过一段稳定的关系，让彼此生活得更加幸福快乐，也就是说要让 1+1&gt;2。哪些因素会影响到两个人长期生活的质量呢？我觉得最主要的是两个人的金钱观、性爱观、家庭观、工作观，只要在这几个方面能保持一致，其它兴趣爱好之类的就都是小事了。</p><p>至于那些自我怀疑的时刻，觉得对方是不是不喜欢自己或者觉得我配不上对方等等，我相信一开始的时候，每个人或多或少都会有这样的怀疑，但是我觉得随着相处时间长了之后，随着你们彼此之间越来越多的自我揭露，这样的顾虑就会慢慢消散。我们需要给自己和对方时间，想清楚自己想要什么，如果对方想要的和自己一致，那么你们就是彼此契合的，这段关系也就能长久地走下去。还有就是，我们要学会接受现实，控制你能控制的。如果相处下来之后两个人基本观念出现分歧，或者对方觉得你不是 TA 想要找的人，那么就要趁早认输、及时放手。毕竟，谁也不是离开谁就不能活了，现代人生活的容错性还是比较高的。另外一种情况是，有时候会觉得自己是不是能找到更合适的人。我觉得这种心理是无解的，只能靠自己慢慢调整。如果你对这段关系抱的期望过高，那么你就很难享受其中，也不会懂得珍惜眼前人。另外也要意识到，没有人是完美的，做人不能太贪心。</p><p>说到底，爱情到底是什么？为了对方不顾一切才是真爱吗？即使自己得不到任何回应也不在乎，只是为了收获心灵上的满足才是爱情吗？或许这也是爱情的一种吧，但是我对这种「爱」持怀疑态度，不是怀疑其真实性，而是怀疑其意义。这种形式的爱，到最后爱的还是自己吧。只有能够收到回应的爱才是有意义的。不过，其实我觉得只要两个人彼此喜欢，相处起来舒服，并且<strong>想要为对方的幸福负责</strong>，这样就是有爱了。当然，很多人提到的愿意为了对方而改变自己、较高的自我揭露、能够坦诚沟通等等之类的因素，我觉得这些要求其实已经包含在「愿意为对方的幸福负责」之内了。爱情是让我们生活得更加幸福的必要条件，也是人生意义的主要来源。希望我们都能找到属于自己的爱情。</p><h4 id="4-月-10-日-长得好看的诅咒和关注他人"><a href="#4-月-10-日-长得好看的诅咒和关注他人" class="headerlink" title="4 月 10 日 - 长得好看的诅咒和关注他人"></a>4 月 10 日 - 长得好看的诅咒和关注他人</h4><p>越来越觉得其实长得好看也是一种诅咒，因为它会不自觉地让人将更多的精力放到自己的外表上，而且会使人过于关注自己，而忽视了身边的人，也更缺乏目标感。我发现很多长得好看的人都有这样的问题。能够突破长的好看带来的这种负面影响的人，在人群中是极少数。他们可以利用自己的外表优势，在吸引人的注意力的同时，高效地完成自己的工作。但是，他们心中始终充满目标感，他们更多还是关注如何达成自己的目标，外表只是他们可以利用的一个工具而已。他们知道生命中有其它更重要的东西值得追寻，而不会觉得自己的外表是唯一重要的因素。他们关爱身边的人，希望创造出更大的价值，而不仅仅是利用外表优势来让自己获益。简单来说，有崇高理想的人，长得好看仅仅是他们的优势之一。</p><p>我以前是个蛮自恋的人，尤其是青少年时期，由于皮肤白皙，加上五官还算端正，当听到别人说自己长得帅时，往往就听到心里去了，所以一直以为自己真的长得挺好看的。直到上了大学，到了大城市之后，每天遇到更多的人，才发现长得比我帅的人多了去了，而且那些人好像从来不会觉得自己长得帅。这时候我才对自己的外表慢慢有了比较客观的认知，其实我只能算不丑吧。所以，也慢慢开始强迫自己不要太关注自己的外表，只要把自己收拾干净就好了，至于别人怎么看，无所谓了。并不是说外表就不重要了，而是觉得比外表重要的东西太多了，想要获得幸福并不是只要长得好看就可以的，需要在许多方面做出努力。尤其是要花更多的精力在身边人身上。我发现自己过去容易感到羞怯的一个很大的原因是，太过关注自身了，而忽视了身边的人，他们才是你每天生活中开心快乐的来源。你要多关注他人，想办法让别人开心，这样自己也会变得开心快乐起来。听起来很没逻辑，但是的确有效。</p><h4 id="4-月-11-日-看起来富有和看起来聪明"><a href="#4-月-11-日-看起来富有和看起来聪明" class="headerlink" title="4 月 11 日 - 看起来富有和看起来聪明"></a>4 月 11 日 - 看起来富有和看起来聪明</h4><p>爱慕虚荣分为两种，一种是想要看起来显得很富有，一种是想要看起来显得聪明。普通人身上其实多多少少都有这两种倾向，只不过程度不同而已。仔细观察自己之后，对我来说，我的后一种倾向明显大于前一种，常常想要让自己在他人面前显得很聪明。这也是我不怎么喜欢闲聊的原因之一吧，害怕暴露自己的弱点，展示出自己的无知。但是，无论是想要显得富有还是聪明，其实都是我们心底的优越感在作祟。正是因为内心空洞虚弱，才会想要用这种依靠外界条件获得的优越感来让自己显得更有底气一些。所以，说到底还是对自己不够自信。真正自信的人，不需要依赖任何外界的夸耀或者崇拜或者价值确认，也能认识到自我的价值，他们有自己的目标和使命感，一心只关注自己做的事，而不在乎其他人如何评价自己。</p><p>道理都懂，实际要怎么做才能达到这样的状态呢？我觉得除了要改变自己的心态，努力做好自己的工作，找到自己的目标和使命，还可以通过阅读和与人沟通，在坦诚的交流中，认识到自己的价值。我们每个人都有自己的缺陷，没有人是完美的，要学会接受不完美的自己。他人赞许的评价虽然能让我们感到开心一阵子，但是幸福的根本还是要通过高质量的生活，包括充沛而健康的体力，做有意义的事，和谐融洽的人际关系，新知识、新体验带给我们的刺激等等。</p><h4 id="4-月-12-日-人生伴侣以及思维与认知"><a href="#4-月-12-日-人生伴侣以及思维与认知" class="headerlink" title="4 月 12 日 - 人生伴侣以及思维与认知"></a>4 月 12 日 - 人生伴侣以及思维与认知</h4><p>人生伴侣为什么重要？不仅仅是因为亲密关系能够给我们带来爱的体验、感到被接纳和被需要，还有一部分更客观现实的原因是，我们的想法很大程度上会受到我们身边最亲密的人的影响。我们的伴侣的思维模式会影响到我们自己的思维模式。不仅如此，长时间生活之后，可能连彼此的生活习惯都会慢慢趋于接近。所以，如果你的伴侣能够和你一样，保持深度思考和自我反省，那么你们两个人的思想就会彼此点燃，创造出更大的火花；如果你的伴侣只关心肤浅、琐碎的事情，你也会被影响到，慢慢在生活中只会看到这些小事。虽说每个人的价值观不一样，对什么是肤浅有不一样的定义，但是总的来说，两个人的追求、所向往的东西处于同一水平线非常重要。</p><p>了解一个人最好的方式是通过 Ta 的伴侣，我们选择和什么样的人在一起，其实体现的是我们选择什么样的价值观。另外，伴侣其实就是我们自己的一面镜子，我们倾向于选择和自己各方面接近的人在一起。所以，你的人生伴侣是什么样的人，大概也能反映出你是什么样的人。即使出于某种原因选择失误，也说明了以你当时的认知，做出这样的选择已经是最佳状态了，所以没什么好抱怨的，只有不断提高自己的认知水平，才能摆脱当下的困境，重新做出更好的选择。另外，生活在这个时代的幸运之处是，大部分人对于人生伴侣的选择都是可以自己决定的，所以，我们更应该珍惜这样的机会，多去尝试，并且要向他人完全开放，让其他人看到你的想法，只有这样，你才能找到和自己思维一致并且适合自己的人生伴侣。</p><h4 id="4-月-13-日-Judge-and-being-judged"><a href="#4-月-13-日-Judge-and-being-judged" class="headerlink" title="4 月 13 日 - Judge and being judged"></a>4 月 13 日 - Judge and being judged</h4><p>我觉得自己需要改变的地方之一是，喜欢在内心给他人贴标签，容易根据别人说的话或者做的事 judge 他们。但其实没有人是完美的，我们都有自己的知识盲区，即使学识再渊博的人也有可能犯一些低级的错误，而且也不可能做所有的事都周到、满足所有人的愿望。不应该根据别人说的几句「蠢话」或者「傻事」就给别人贴上一些负面的标签，然后从此以后就戴着有色眼睛对待他们。<strong>我们要让自己有更高的容错率</strong>。我们可以要求自己少犯错，但也要允许他人犯错。这点是我需要慢慢改变自己的地方。另外，反过来看，其他人也会这样 judge 我们，所以，我们也要锻炼自己的心理承受能力，<strong>不要害怕被 judge，更不要害怕犯错，犯错是成长的机会</strong>，而别人如何评价我们是他们的事，我们由此可以看出一个人是否宽容。</p><p>我们绝大部分人都只是普通人，都有各种各样的缺陷，我们终其一生都想要通过不断进步，成为更好的自己。另外，我们也要学会接纳自己，看到自己身上的不足的同时，还要能意识到自己身上也有很多优点。做真实的自己，并且感谢上苍让自己有机会这样做。每一个人都是自己的老师，如果你从身边人身上看到的都是他们的优点，并且向他们看齐，也不害怕犯错、暴露出自己的缺点和无知的一面，那么你就能一直进步下去。与此同时，接纳不完美的自己，并且看着自己随着时间一点点成长，享受这种慢慢改变自己的过程。最后，学会感恩。感谢生命中出现的一切美好的人和事，感谢自己曾经拥有过的一切把握住和没有把握住的机会，感谢那些帮助过自己的人，学会珍惜你已经拥有的一切。你会慢慢意识到，我是何其幸运才能拥有这一切。</p><h4 id="4-月-14-日-互联网和阶层跃迁"><a href="#4-月-14-日-互联网和阶层跃迁" class="headerlink" title="4 月 14 日 - 互联网和阶层跃迁"></a>4 月 14 日 - 互联网和阶层跃迁</h4><p>互联网真的是一个伟大的发明，改变了所有人的生活，尤其是移动互联网，让我们随时随地可以拥有连接一切人、事、物的能力。20 年前，估计谁也想不到 20 年后，大家口袋里的一个小设备就可以让人想去哪就去哪，想和谁见面就和谁见面，想买什么就买什么。关键的是，无论是总统还是街边便利店的老板，所有人用的设备都差不多。这在以前是无法想象的。互联网虽然拉近了各个阶层间的距离，让我们可以互相窥探彼此的生活，但是，对于处于低阶的人来说，想要改变自己的生活，依旧会有很多困难，需要我们有决心和毅力，还得付出巨大的努力。其实这也正常，任何年代，想要改变自己的阶层都不容易。不过，相比前人，生活在现代的我们，除了可以享受社会和平发展的福利之外，还拥有更多的机会和资源，所处的环境也更加宽容和开放。市场环境下，我们只需要找到自己擅长做的事且能解决他人的问题，那么我们就能获得回报。所以，生活在这个年代的我们已经非常幸运了。</p><p>想要获得成功，就需要我们有敏锐的洞察力，找到能够产生巨大社会价值的事，或者解决很多人都会遇到的问题，改善人们的生活。当然，并不是所有人都具备这样的视野和能力，大部分人还是需要通过在企业工作，一方面为了维持自己的生活，另一方面这也是一种打磨自身的技能、获得成长的方式。不过，只要我们始终抱着不断学习、探索未知的心态，即使最终没能获得商业上的成功，至少能够享受自己的生活、过得幸福以及获得人生的意义。</p><h4 id="4-月-15-日-再见，虎哥"><a href="#4-月-15-日-再见，虎哥" class="headerlink" title="4 月 15 日 - 再见，虎哥"></a>4 月 15 日 - 再见，虎哥</h4><p>今天是我在虎哥的最后一天，早上去办完交接之后就要彻底和这个公司说再见了。这两天经常在想，我在这里待了差不多 3 年了，最大的收获是什么？工作上，接触了一些原来没接触过的东西，比如热更新和 RN 开发，也有了独立开发一款 app 并上线发布的经历。期间也出过事故，然后意识到靠人的记忆力是多么地不靠谱，唯有流程化和标准化再加上小心仔细才有可能避免事故的发生。还有就是意识到，小公司的业务其实并不需要多么强大的开发团队，平日里更多的是一些维护性的工作和各种琐事。新业务快速迭代没问题，但是需要有经验的团队来运营才能有效果。即将离开这里了，突然意识到，过去让自己感到不满意的其实不是环境，而是在这个环境里的自己。要改变的，也是自己。我们每个人身上都有缺点，遇到问题的时候，如果你选择推卸责任、埋怨别人，那么你永远也无法得到成长。这是我在虎哥学到的最重要的一课，感谢同事们教会我这一点。有时候从他人身上可以认识到自己不想成为哪种人。所以，既然我们无法改变彼此，那就祝彼此各自安好吧。我们都应该也能够找到适合自己的环境。</p><h4 id="4-月-16-日-加入拾米网络"><a href="#4-月-16-日-加入拾米网络" class="headerlink" title="4 月 16 日 - 加入拾米网络"></a>4 月 16 日 - 加入拾米网络</h4><p>今天入职新公司，突然觉得自己有点草率，对一家公司还不怎么了解就决定加入了，只不过和创始人聊了一次，觉得可以信任而已。但是，人生本来就是处处都在碰运气，有的时候一个偶然的决定就改变了一个人的命运。当然，我相信即使是运气，最终决定事情向好或者向坏的方向发展的，还是人自己。拥有好运气，但是自己没有好好把握住机会，改变自己，得到成长，那么最终也无法走得长远，因为你不可能一直拥有好运气。即使运气不佳，那么至少也能得到教训，并且相信自己下一次会做出更好的选择。回到入职新公司的话题，我觉得既然都已经来了，那就要相信自己的决定。入职第一天，尽量让自己表现得热情一些，多主动打招呼，不要太紧张或者显得含蓄，保持微笑，给同事们留下一个好印象。<strong>多倾听，多表达，不懂就问，保持谦虚。</strong>另外，要保持一个平和的心态，因为我们加入一家公司是为了通过工作创造价值、获得回报，最重要的还是用自己的工作能力证明自己，所以，哪怕有人不喜欢自己也没关系，做好自己该做就可以了。</p><h4 id="4-月-17-日-既来之，则安之"><a href="#4-月-17-日-既来之，则安之" class="headerlink" title="4 月 17 日 - 既来之，则安之"></a>4 月 17 日 - 既来之，则安之</h4><p>昨天入职第一天，早上去公司办入职，认识了一下新同事们。第一印象是，公司真的很小，一个房间，十几个人，四张桌子坐满了人，不过不算拥挤。下午去玩蹦床+团建，通过和同事们的相处，我觉得公司的氛围还不错，虽然我不太聊天，但是大家对我都还算比较友好吧。我是一个慢热的人，相信随着以后相处时间长了之后，会慢慢变好。不过，现在最让我纠结的是，通过和同事交流，发现公司现在主要的业务还是依赖外包，这点和我之前想的的确不一样。不过，我觉得既然来都来了，也没法退出了，那就先好好做着，看看情况再说。不要花时间懊悔，把能做的事情先做好，走一步算一步。</p><h4 id="4-月-18-日-用更积极的态度对待生活"><a href="#4-月-18-日-用更积极的态度对待生活" class="headerlink" title="4 月 18 日 - 用更积极的态度对待生活"></a>4 月 18 日 - 用更积极的态度对待生活</h4><p>今天周末，感觉差不多已经适应了新环境了，至少昨天晚上睡得比前两天要好。今天早上 7 点不到就醒了，胡思乱想了一阵，然后突然意识到想太多也没用，action leads mood，还是行动起来比较好。起床、上厕所、洗漱，继续按正常的作息和习惯生活下去，而且在新环境下其实也需要一段时间适应吧。</p><p>其实，我觉得自己已经算是比较幸运的了，能够拥有现在的一切应该感到知足。当然，人的欲望是无止境的，我们永远希望得到更好的机会，未来也一直都会有更大的目标出现。但是，有时候也要学会感受和享受当下。追逐更好是应该的，而如果只盯着目标却忘记了感受当下只会让我们的幸福感降低。另外，起点低的人就应该更有耐心，一步步改变自己和自己所处的环境，<strong>你没法一步做到位的</strong>。相信自己能做好，有耐心慢慢提高，不嫉妒，不苦恼，向身边的人学习，看到他人身上的优点，表达自己，建立联系，享受每一个当下，保持平静和愉悦。能做到这样，生活一定会朝着越来越好的方向发展。</p><h4 id="4-月-19-日-选择善良，警惕自私"><a href="#4-月-19-日-选择善良，警惕自私" class="headerlink" title="4 月 19 日 - 选择善良，警惕自私"></a>4 月 19 日 - 选择善良，警惕自私</h4><p>无论什么时候，我们都应该选择善良，警惕自私，因为你的行为会把你的观念传递给周围的人。如果你选择善良，那么你向世界传递的就是人性中好的一面，你看到的也大多是善良，而如果你选择自私、嫉妒、仇视他人，那么你向世界传递的能量就是消极的。我们无法决定他人的行为，但是我们可以选择如何解读他人的行为。我相信人群中绝大部分人都是普通人，占主导的一定是人性中善良的一面，只不过有时候我们选择忽视那些善良的一面，而只看到他人身上的自私以及其它不好的品质。天生的坏人有吗？也许有吧。但是目前为止，我还没有在现实生活中碰到过。我觉得即使存在天生的恶人，他们也只是缺乏正确的引导，可能是由于婴儿时期需求没有被满足，童年时期缺乏关爱，遭受忽视、虐待，或者家庭教育缺失使得他们只考虑自己，凡事以自我为中心而不会关心身边的人。</p><p>无论如何，大部分人都是可以改变的。我们都有过自私的行为，也都做过一些不大不小的坏事。但是，只要你开始意识到要为自己的行为负责，你是世界的一部分，你能影响到这个世界，他人是你的伙伴，你就不会再去做那些对不起自己良心的事，你会选择善良。因为选择善良之后，世界回报给你的也是善良，你看到的也是善良的人和事。没必要吹毛求疵、斤斤计较，我们都只是这个世界的过客，既然如此，为什么不给这个世界留下一些积极、正面的影响呢？</p><h4 id="4-月-20-日-对现状的评估以及给自己一点时间"><a href="#4-月-20-日-对现状的评估以及给自己一点时间" class="headerlink" title="4 月 20 日 - 对现状的评估以及给自己一点时间"></a>4 月 20 日 - 对现状的评估以及给自己一点时间</h4><p>每当心底有疑惑、纠结甚至痛苦的时候，其实也说明我们拥有了一个成长的机会。我们可以通过不断地反思自己，寻找心底最真实的想法，慢慢思索找出答案。有时候可能也找不到答案，但是至少可以通过思考看清一些方向。</p><p>我发现自己最近就处于这样的状态，虽然换了工作，但是依旧很迷茫。新公司是一家外包公司，由于之前自己的疏忽，没有做足够的背景调查，导致进来之后才发现这个事实。但也没啥可抱怨的，只能怪自己做决定太过草率。不过，至少新公司可以有事做，而且如果能够兑现承诺，其实待遇也还算不错。话虽这么说，但是心底还是觉得有些失落、不甘心，觉得应该去一家有自己的产品的公司，这样不但听上去好听一些，而且也更有技术积累。说到底，还是要提升自己的技术能力，这样才有更大的选择空间。目前这样的情况，只能说是自己能力不足的表现吧。不过，只要能坚持每天进步一点点，加上耐心，相信未来情况会变好。给自己一年的时间，好好积累吧，到时候再看看自己身上会发生哪些变化。</p><h4 id="4-月-21-日-维护好人生三大课题：工作、交友和爱"><a href="#4-月-21-日-维护好人生三大课题：工作、交友和爱" class="headerlink" title="4 月 21 日 - 维护好人生三大课题：工作、交友和爱"></a>4 月 21 日 - 维护好人生三大课题：工作、交友和爱</h4><p>人生三大课题：工作、交友和爱，我们大多数烦恼或者说过得不幸福的原因是这三个课题中的一个或多个出现了问题。工作是我们获得自立的手段，交友是为了达到社会关系的和谐，而爱则是我们确认自身价值、获得人生意义感和幸福感的关键。我们需要不断提高自身的能力去获得更好的工作机会，直到能够建立起自己的事业，长期来看，这也是我们获得自身价值感以及让人生过得不无聊的关键之一。其次，我们需要有良好的人际关系网络，能够在有需要的时候向亲友分享自己的喜悦和悲伤。能够有彼此熟悉，可以沟通心底最深层想法并且产生共鸣的人，这样我们才会觉得自己在这个世界上是不孤单的。最后，爱让我们变得更加强大，更加愿意与这个世界产生更多的互动，它让我们感到自己被需要、被理解、被认可，我们能够从爱人那里得到无限的能量，我们会因为爱人更加热爱这个世界。</p><p>这三大课题，都需要我们不断付出努力，不断提高自己，不断学习，并且花大量的时间和精力才能巩固好它们。但是，这也是我们人生幸福的关键，所以，不要怕麻烦，也不要因为某一个课题而放弃另外一个课题。虽然在人生的不同阶段，这三个课题的优先级有先后之分，但是，永远不要完全忽视掉某一个课题，一定要常常回顾并反思自己需要在哪一个课题上花更多的时间和精力，从而保证自己能够生活得开心舒适、幸福快乐。</p><h4 id="4-月-22-日-表达自己，和他人建立联系"><a href="#4-月-22-日-表达自己，和他人建立联系" class="headerlink" title="4 月 22 日 - 表达自己，和他人建立联系"></a>4 月 22 日 - 表达自己，和他人建立联系</h4><p>我发现自己做的不好的一点是，喜欢隐藏自己真实的想法，无论是对亲密的人也好，还是对身边的人比如同事也好，无法做到毫无保留地说出自己心底的看法。这种做法会导致自己很难和别人建立真正的连结，做到真正了解彼此，而且很容易产生一种疏远感，甚至导致隔阂。那么，我应该如何改变自己呢？首先，从主动和别人打招呼开始，点头微笑，多和他人眼神沟通，然后抓住机会发表自己的看法。再然后是在一些私下的场合，比如吃饭的时候，多表达自己，同时对他人保持足够的兴趣，询问他们一些问题，从一些不是太私人的问题开始。慢慢的，你们会对彼此产生更多的了解，你们的关系会逐渐改善，建立起彼此间更深厚的联系。</p><p>话虽如此，但是最重要的还是行动，不要停留在「知道」这一步，最关键的是要迈出第一步，行动起来。而且要皮糙肉厚，即使被他人拒绝或者没有得到足够的回应，也要兜得住，不要觉得受伤。要有耐心，一次不行就多试几次，实在不行就换个对象，总有人愿意接纳你并且做出足够的回应的。任何事只要你做好足够的心理准备，相信自己能做好，并且愿意付出足够的努力，那么，成功就是一件大概率的事。</p><h4 id="4-月-23-日-不要害怕被认为是个无聊的人"><a href="#4-月-23-日-不要害怕被认为是个无聊的人" class="headerlink" title="4 月 23 日 - 不要害怕被认为是个无聊的人"></a>4 月 23 日 - 不要害怕被认为是个无聊的人</h4><p>我现在最害怕的是什么呢？害怕被认为是个无聊的人。为什么？因为我最讨厌无聊的人。但是，无聊只是一种状态而已，人不可能一直处于情绪高昂、心情畅快的状态，总会有感到无聊的时刻。而且不同的人由于学识、见识、兴趣不同，对无聊的定义也不同，不同的人对你的看法可能完全不一样。即使是同一个人，在不同状态下，可能也会有很大的差别。所以，不要害怕被认为是个无聊的人，因为你无法满足所有人的期待。你只需要找到和自己同频率的人，然后不断磨合，找到彼此交往最舒适的方式。当然，这样的人可能与你在很多方面都是相似的，比如看待事物的方式、沟通方式、工作观、金钱观等等。而且，即使是和这样各方面都彼此契合的人相处，我们也有可能会感到无聊，或者会令对方觉得无聊，不要害怕这样的时刻，因为这是非常正常的事，生活本来就不可能处处完美，习惯就好。最终能让自己不无聊的人只有自己，所以，只要能让自己一直保持有事可做的状态就好了。</p><h4 id="4-月-24-日-直面孤独"><a href="#4-月-24-日-直面孤独" class="headerlink" title="4 月 24 日 - 直面孤独"></a>4 月 24 日 - 直面孤独</h4><p>如何应对孤独？首先，我们为什么会感到孤独，通常是因为现实的社交需求得不到满足。所以，解决办法有两个，一个是积极拓展自己的社交圈，增加社交的频率和质量。另一个是降低期望，让自己能够享受当下的状态。我过去其实一直都挺能独处的，只不过最近因为刚换工作，所以心里会产生更多的期待，觉得自己的生活会发生一些变化，实际上却没有，所以这个时候就会觉得有点失望，有种孤独感。</p><p>所以，还是只能靠自己调节吧。生活是自己的，没有人能告诉你应该过什么样的生活以及如何选择。让自己保持有事可做的状态就不会陷入类似孤独这样的情绪之中了。另外，人，生而孤独，这件事不是说一旦你脱单了，或者身边有一大群朋友就能解决的。我们最终都需要独自面对人生，需要面对存在的意义等「终极问题」，像这样的问题只能靠我们自己才能找到答案。所以，孤独其实也只是人生中的一个问题而已，你需要学会独自解决它，做好自己该做的事，把自己的生活过好，而且要过得幸福快乐。</p><h4 id="4-月-25-日-痛苦-反思-成长"><a href="#4-月-25-日-痛苦-反思-成长" class="headerlink" title="4 月 25 日 - 痛苦+反思=成长"></a>4 月 25 日 - 痛苦+反思=成长</h4><p>都说痛苦+反思才可以收获成长，所以我们不能选择太安逸的生活，并且要常常自省。但是，人的本能总是倾向于选择安稳的生活，我们总是不知不觉地就习惯了当下的生活，觉得一切都是理所当然的，不再去反思自己的生活。所以，我们需要时常跳出自己的日常工作生活节奏，问自己一些严肃的问题，比如我真正想要什么？对我来说，什么才是最重要的？我所做的是让我满足的事吗？我如何做得更好？我最近的和长期的目标是什么？这些问题多少有点让人不舒服，但是习惯性地让自己面对这样的问题，然后尝试回答，会让人学会反思和自省。停止自我欺骗，积极行动起来，真正把时间花在能让自己成长的事情上。哪怕暂时没有答案，你也会对自己有更多的了解，并且开始规划自己的未来。人生真正重要的事情不多，其实就是通过每天有意识地生活，然后尽可能多地认识自己和这个世界，同时不断改变自己，获得成长，为自己和他人创造价值。</p><h4 id="4-月-26-日-没有什么事是非做不可的"><a href="#4-月-26-日-没有什么事是非做不可的" class="headerlink" title="4 月 26 日 - 没有什么事是非做不可的"></a>4 月 26 日 - 没有什么事是非做不可的</h4><p>这个世界上有很多事情值得做，但是没有什么事是非做不可的。所以，不用觉得自己错失了机会，因为机会永远都在，即使真的是仅此一次的机会，那也不用感到太过惋惜，因为那只是一次体验而已，值得体验、美好的事物只会越来越多，而且随着你的经历变丰富，那些过去让你觉得非常奇妙、难得的经历其实会变得越来越没有吸引力。所以，只要往前走就行了。做好自己该做的事，专注于生活中每一个具体的瞬间，好好吃饭，好好工作，好好锻炼，好好珍惜和家人以及朋友在一起的相处时间。至于那些生活中的意外之喜，以坦然、平和的心态迎接就可以了，而不必刻意去追寻它们。当然，有时候还是应该适当给自己的生活增加一些情调，去做一些平时不会做的事。比如出门旅游，尝试一些新的爱好，参加一些有趣的活动，认识新朋友等等。抱着平常心去看待这些事情，而不是刻意去追寻新奇的体验，不抱过高的期望，我们才更容易享受其中。</p><h4 id="4-月-27-日-拥有并保护良质"><a href="#4-月-27-日-拥有并保护良质" class="headerlink" title="4 月 27 日 - 拥有并保护良质"></a>4 月 27 日 - 拥有并保护良质</h4><p>我发现很多人都有的问题是，只是把工作当成谋生的手段。当你抱着这样的心态去工作的时候，你的工作就变成了应付，只是帮别人（老板或者客户）做你不想做的事。如果你恰好处于需要和人打交道的位置，那么你的这种态度将会直接对其他人造成影响，最后痛苦的可能不仅仅是你自己，还有与你接触的人。这也是为什么优秀的人只是少数的原因，大多数人只是为了拿一份薪水干活，他们并不是真的关心自己做的事，也不在乎事情完成的好坏，也就是缺乏「良质」。良质说到底就是关心你所做的事，在乎质量，追求美。我们用到的几乎所有的好产品都是被那些拥有良质的人创造出来的。但是，这并不是说普通人就不需要良质了。想象一下，如果这个社会绝大多数人内心都具有良质，我们整个社会的生产力会产生多么大的进步，每个人的生活都能得到巨大的改善。不过，目前来看，我们离那样的社会还有很长的路要走，拥有良质的人只是人群中的少数，所以，我们只能努力先让自己成为这样的人，然后再慢慢吸引这样的人到自己的身边，或者用金钱买这样的人的服务，或者改变自己所处的环境。</p><p>另外，良质是一种状态，不是一旦拥有之后就能一直保持下去的。我们总归还是会有感到厌倦、想要抱怨、想要应付了事的时候，比如在做一件琐事或者自己不喜欢做的事的时候，这个时候，就需要用到一些技巧，比如找个安静的地方让自己冷静一下，调整自己的呼吸，让自己的情绪恢复平静，做一些简单的运动，正念冥想，使用一些物品或者某些警句提醒自己。直到将自己的情绪调整过来之后，让自己的心理状态恢复到能够继续保持良质。简单来说就是，改变你的态度，你做事的体验也会改变。拥有良质，就是让我们能发挥出自己的最佳水平，同时又能感到愉悦和有成就感。</p><h4 id="4-月-28-日-勤奋、克制和责任感"><a href="#4-月-28-日-勤奋、克制和责任感" class="headerlink" title="4 月 28 日 - 勤奋、克制和责任感"></a>4 月 28 日 - 勤奋、克制和责任感</h4><p>前两天看了连叔的一篇<a href="https://mp.weixin.qq.com/s/zMHSuHbjnF5mlcbESNxIdA">文章</a>，说到一个人只要拥有了勤奋、克制、责任感这些特质，就能拥有好生活。最近几天思考之后对这句话越来越有感触。勤奋自然不用说，一个人无论在哪个领域，想要获得任何成就都得非常勤奋才行。而克制则决定我们能够始终做出正确的决定，不会因为一时的贪婪或者意志不坚定而做出会让自己后悔的事。最最重要的是要有责任感。</p><p>什么是责任感？是对自己的承诺负责，对相信自己的人负责，对自己的行为负责。这种责任感保证了我们不会做出任何对不起自己良心的事，也是我们能够源源不断获得动力努力坚持下去的原因。一个人只要具备了责任感，他做事的动机就不会仅仅是出于为自己获利，而是为了完成某种承诺，无论这种承诺是对自己还是对他人做出的。对家人朋友的责任感，使得我们能够维持亲密的家庭情感纽带、朋友间的友谊；对公司的责任感，使得我们能够铭记自己做事的动机，为自己和他人创造价值。视野再放大一点，如果我们具备了对整个人类的责任感，那么我们所有的行动都是出自为人类整体利益的考虑，为了传播善良和让所有人生活得更加幸福快乐。那么，我们就不会感到苦闷和无聊，因为我们永远都有事可做，也始终感到自己和他人是联系在一起的，也不会为生活中的一些小事苦恼，因为没有人是完美的，我们都需要彼此帮助，一起朝着变得更好的目标而努力下去。</p><h4 id="4-月-29-日-及时当勉励"><a href="#4-月-29-日-及时当勉励" class="headerlink" title="4 月 29 日 - 及时当勉励"></a>4 月 29 日 - 及时当勉励</h4><p>昨晚跑完步，突然意识到，这个阶段的自己也许是人生中最轻松无压力的一段时期：有一份收入过得去的工作，没有房贷、车贷的压力；单身，有大把的时间可以尝试各种各样的事。所以，应该感到知足吧，而且要好好珍惜这样的时光，等以后成家之后，可能就没有那么多完全属于自己的时间了。虽然陪伴孩子、家人也很幸福，但是像现阶段这样自由自在的日子应该是不会再有了。</p><p>另外，也给自己提了个醒，不要太过放纵自己，要克制。你现在的所做所为决定了将来的自己会过上什么样的生活。为了未来的自己能享受到更多的自由，现在的自己就需要牺牲一部分自由。规划好自己的时间，把时间花在提升自己的能力和见识上，锻炼身体，阅读，写作，以及养成更多好习惯。这样，无论到了哪个阶段，你都能拥有选择的机会，而不是被迫接受生活的安排。所有人都在追求的东西不一定就是适合自己的，你需要找到适合自己的生活方式。毕竟，it’s your life，只有你能为自己的人生负责，别人只能给一点建议，最终做决定的还是你自己。希望 10 年、20 年之后，当自己重新看到这段话的时候，能自信地说出「我做到了」。</p><h4 id="4-月-30-日-警惕习惯性偷懒和耍小聪明"><a href="#4-月-30-日-警惕习惯性偷懒和耍小聪明" class="headerlink" title="4 月 30 日 - 警惕习惯性偷懒和耍小聪明"></a>4 月 30 日 - 警惕习惯性偷懒和耍小聪明</h4><p>我发现阻碍自己进步的最大的障碍是习惯性偷懒和耍小聪明。这两点体现在我每天工作和生活中的方方面面。比如办了一张新银行卡，送了一些限时限场景使用的优惠，于是就满脑子想着如何把这些优惠最大化地使用掉。事后回想起来，觉得这就是在耍小聪明，那一点点优惠根本不值得我花这么多的时间和精力，为这种事占据大脑带宽完全就是拣了芝麻丢了西瓜，本来我可以用相同的时间做更多有意义的事，比如思考问题、复习自己学习到的知识、阅读文章等等。再比如写代码的时候，如果一段代码可以复制粘贴我一般就直接复制粘贴了，而不是自己手打一遍，然后体会其中的思路。哪怕只是可以少敲几个单词，我也习惯直接剪切再粘贴过去。很多时候就是这种细微的习惯让自己错过了很多细节以及练习的机会。突然意识到，其实上学的时候，我也有很多这样的「微习惯」，正是这些微习惯导致自己学习态度乃至学习方法出现了问题，不愿意去下苦功夫，自然也掌握不了解决复杂问题的思路。所以，要时刻警惕自己耍小聪明，只有脚踏实地才能慢慢提高自己的能力以及获得成长。另外，也不要偷懒。其实偷懒也是耍小聪明的一种，以为通过偷懒节省了时间、金钱或者其它付出，觉得占了便宜，但隐形的成本会让你在其它方面加倍付出，而且偷懒对人的态度和意志也是一种消耗。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 开发笔记</title>
      <link href="/flutter-dev-notes/"/>
      <url>/flutter-dev-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2021-10-11/flutter-dev.png"></p><blockquote><p>记录下自己在使用 Flutter 开发过程中遇到的问题。</p></blockquote><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><h3 id="Widgets"><a href="#Widgets" class="headerlink" title="Widgets"></a>Widgets</h3><h4 id="AppBar"><a href="#AppBar" class="headerlink" title="AppBar"></a>AppBar</h4><p>当自定义导航栏中的标题栏之后，配合 route 使用有时候会发现导航栏左边会有空白出现，后来才发现，原来是系统默认给添加了返回按钮，解决该问题的方法也很简单，只要在 <code>AppBar</code> 中将 <code>automaticallyImplyLeading</code> 属性设为 <code>false</code> 就可以了，下面是文档中的注释：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">Controls whether we should try to imply the leading widget if null.</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// <span class="markdown">If true and [leading] is null, automatically try to deduce what the leading</span></span><br><span class="hljs-comment">/// <span class="markdown">widget should be. If false and [leading] is null, leading space is given to [title].</span></span><br><span class="hljs-comment">/// <span class="markdown">If leading widget is not null, this parameter has no effect.</span></span><br><span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> automaticallyImplyLeading;<br></code></pre></td></tr></table></figure><p>该属性表示是否应该在未提供 <code>leading</code> 属性时自动检测应该使用何种 <code>leading</code> 组件。设为 <code>false</code> 之后，如果 <code>leading</code> 为空，则 <code>leading</code> 位置会默认让位给标题，也就不会产生上面的空白占位现象了。</p><span id="more"></span><h4 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h4><p><code>Container</code> 是最常用的组件之一，这里列一些 <code>Container</code> 的使用技巧吧。</p><h5 id="设置宽高后不起作用"><a href="#设置宽高后不起作用" class="headerlink" title="设置宽高后不起作用"></a>设置宽高后不起作用</h5><p>多半是因为父组件的 constraint 是不受限的，因此，我们可以在 <code>Container</code> 外面包一层 <code>UnconstrainedBox</code>。</p><h5 id="添加左侧边框发光的效果"><a href="#添加左侧边框发光的效果" class="headerlink" title="添加左侧边框发光的效果"></a>添加左侧边框发光的效果</h5><p>通常我们只能添加上下左右边框，假如想要添加渐变的边框则可以通过 <code>boxShadow</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart">decoration: BoxDecoration(<br>  boxShadow: [<br>    BoxShadow(<br>        color: Colors.grey,<br>        offset: Offset(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>),<br>        blurRadius: <span class="hljs-number">.1</span>,<br>    )<br>  ],<br>),<br></code></pre></td></tr></table></figure><h5 id="添加渐变阴影效果"><a href="#添加渐变阴影效果" class="headerlink" title="添加渐变阴影效果"></a>添加渐变阴影效果</h5><p>比如点击图片后显示菜单栏时，会使用到这种渐变阴影的效果，我们可以使用 foregroundDecoration + gradient 来实现<a href="https://stackoverflow.com/a/60953794/4837812">^1</a>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart">foregroundDecoration: BoxDecoration(<br>  gradient: LinearGradient(<br>    colors: [<br>      Colors.black, <br>      Colors.transparent, <br>      Colors.transparent, <br>      Colors.black,<br>    ],<br>    begin: Alignment.topCenter,<br>    end: Alignment.bottomCenter,<br>    stops: [<span class="hljs-number">0</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">1</span>],<br>  ),<br>),<br></code></pre></td></tr></table></figure><h4 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h4><h5 id="禁用返回键关闭-Dialog"><a href="#禁用返回键关闭-Dialog" class="headerlink" title="禁用返回键关闭 Dialog"></a>禁用返回键关闭 Dialog</h5><p>在 Dialog builder 中使用 <code>WillPopScope</code> 禁用返回键返回：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">WillPopScope(<br>  onWillPop: () <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>  &#125;,<br>  child: Dialog(...),<br>)<br></code></pre></td></tr></table></figure><p>注意：使用此方法同时也会禁用 iOS 上的手势滑动返回功能，推荐判断平台后再使用。</p><h5 id="更新-Dialog-UI"><a href="#更新-Dialog-UI" class="headerlink" title="更新 Dialog UI"></a>更新 Dialog UI</h5><p>修改对话框中的复选框状态，最简便的方法是通过 Element 中的 <code>markNeedsBuild</code> 方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart">Builder(<br>  builder: (BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Checkbox(<br>      value: _withTree,<br>      onChanged: (<span class="hljs-built_in">bool</span> value) &#123;<br>        (context <span class="hljs-keyword">as</span> <span class="hljs-built_in">Element</span>).markNeedsBuild();<br>        _withTree = !_withTree;<br>      &#125;,<br>    );<br>  &#125;,<br>),<br></code></pre></td></tr></table></figure><p>当然，更推荐的做法是通过 <a href="https://api.flutter.dev/flutter/widgets/StatefulBuilder-class.html"><code>StatefulBuilder</code></a>，然后就可以在 Dialog 中调用 <code>setState</code> 方法了，不过在调用 <code>setState</code> 时需要判断 Dialog 是否已经关闭，否则会造成 <code>setState() called after dispose()</code> 的错误，可以通过添加一个标志位来解决，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> showMyDialog() &#123;<br>  <span class="hljs-built_in">bool</span> dialogShown = <span class="hljs-keyword">true</span>;<br><br>  showDialog(builder: (context) &#123;<br>    <span class="hljs-keyword">return</span> StatefulBuilder(builder: (_, StateSetter setState) &#123;<br>      <span class="hljs-keyword">return</span> WillPopScope(<br>        onWillPop: () <span class="hljs-keyword">async</span> &#123;<br>          dialogShown = <span class="hljs-keyword">false</span>;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;,<br>        child: AlertDialog(<br>          title: Text(<span class="hljs-string">&#x27;标题&#x27;</span>),<br>          content: Text(<span class="hljs-string">&#x27;内容&#x27;</span>),<br>          actions: &lt;Widget&gt;[<br>            TextButton(<br>              child: Text(<span class="hljs-string">&#x27;取消&#x27;</span>),<br>              onPressed: () &#123;<br>                dialogShown = <span class="hljs-keyword">false</span>;<br>                Navigator.pop(context);<br>              &#125;,<br>            ),<br>            TextButton(<br>              child: Text(<span class="hljs-string">&#x27;更新&#x27;</span>),<br>              onPressed: () &#123;<br>                <span class="hljs-keyword">if</span> (dialogShown) &#123;<br>                  setState(() &#123;<br>                    <span class="hljs-comment">// 可以安全更新 UI</span><br>                  &#125;);<br>                &#125;<br>              &#125;,<br>            ), <span class="hljs-comment">// TextButton</span><br>          ],<br>        ), <span class="hljs-comment">// AlertDialog</span><br>      ); <span class="hljs-comment">// WillPopScope</span><br>    &#125;); <span class="hljs-comment">// StatefulBuilder</span><br>  &#125;); <span class="hljs-comment">// builder</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h4><p>有时候点击事件会无法触发，通常是在添加了一些容器组件，比如 Container 和 Padding 之后，如果使用 <code>AbsorbPointer</code> 包裹目标组件则又可以接收到点击事件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">GestureDetector(<br>  onTap: _onTab,<br>  child: AbsorbPointer(<br>    child: YourContentWidget(),<br>  ),<br>)<br></code></pre></td></tr></table></figure><p>原因是 GestureDetector 在默认的 <code>behavior</code> 下会忽略不可见的元素，所以，最根本的解决办法是修改它：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff">GestureDetector(<br>  onTap: () &#123;<br>    FocusScope.of(context).requestFocus(FocusNode());<br>  &#125;,<br><span class="hljs-addition">+ behavior: HitTestBehavior.translucent,</span><br>  child: YourContentWidget(),<br>)<br></code></pre></td></tr></table></figure><h4 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h4><h5 id="默认-Padding"><a href="#默认-Padding" class="headerlink" title="默认 Padding"></a>默认 Padding</h5><p>GridView 默认会通过 MediaQuery 获取当前的状态栏高度作为 padding，因此我们会观察到 GridView 底部有一段空白 padding，所以，为了去除可以设置 padding 为 <code>EdgeInsets.zero</code>。</p><h4 id="Hero"><a href="#Hero" class="headerlink" title="Hero"></a>Hero</h4><h5 id="重复的-tag-造成失效"><a href="#重复的-tag-造成失效" class="headerlink" title="重复的 tag 造成失效"></a>重复的 tag 造成失效</h5><p>当一个页面有多组 Hero 动画对象时，为了避免 tag 重复导致动画失效，最好使用变量统一管理。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> heroGroupName;<br><br><span class="hljs-meta">@override</span><br>Widget build(BuildContext context) &#123;<br>  <span class="hljs-keyword">return</span> Column(<br>    children: [<br>      Hero(<br>        tag: <span class="hljs-string">&#x27;heroTypeOne-<span class="hljs-subst">$heroGroupName</span>&#x27;</span>,<br>        child: ...<br>      ),<br>      Hero(<br>        tag: <span class="hljs-string">&#x27;heroTypeTwo-<span class="hljs-subst">$heroGroupName</span>&#x27;</span>,<br>        child: ...<br>      ),<br>    ]<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="文字黄色下划线"><a href="#文字黄色下划线" class="headerlink" title="文字黄色下划线"></a>文字黄色下划线</h5><p>在字体上添加 hero 动画会观察到动画过程中字体有两条黄色的下划线，解决办法是在 MaterialApp 上添加 <code>TransitionBuilder</code> 为 <code>DefaultTextStyle</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">MaterialApp(<br>  ...<br>  builder: (context, child) =&gt; DefaultTextStyle(<br>    style: Theme.of(context).textTheme.bodyMedium!,<br>    child: child!,<br>  ),<br>);<br></code></pre></td></tr></table></figure><p>或者，也可以在 child 组件外包裹一层 <code>Material</code> 组件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">Hero(<br>  tag: <span class="hljs-string">&#x27;heroText&#x27;</span>,<br>  child: Material(<br>    type: MaterialType.transparency,<br>    child: Text(...),<br>  ),<br>)<br></code></pre></td></tr></table></figure><h5 id="文字末端被截取"><a href="#文字末端被截取" class="headerlink" title="文字末端被截取"></a>文字末端被截取</h5><p>Hero 结合文字使用时有很多问题，比如我们有时候还会遇到一种奇怪的现象，当目标页面上的 Hero 使用文字并且字体较大时，字体尾部会被截取，如下图：</p><img src='../assets/2022-flutter/hero-text-clipped.gif' width=40%><p>目前一个临时解决方法是，在文字结尾处添加空白，然后通过 padding 补足偏移量<a href="https://github.com/flutter/flutter/issues/36220#issuecomment-1106441109">^2</a>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">Hero(<br>  tag: <span class="hljs-string">&#x27;heroName-<span class="hljs-subst">$name</span>&#x27;</span>,<br>  child: Padding(<br>    padding: <span class="hljs-keyword">const</span> EdgeInsets.only(left: <span class="hljs-number">16</span>), <span class="hljs-comment">// 添加头部的 padding</span><br>    child: Text(<span class="hljs-string">&#x27;<span class="hljs-subst">$name</span>  &#x27;</span>), <span class="hljs-comment">// &lt;== 尾部添加空格</span><br>  ),<br>),<br></code></pre></td></tr></table></figure><h4 id="InkWell"><a href="#InkWell" class="headerlink" title="InkWell"></a>InkWell</h4><p>当 child 设置了背景色时，为 <code>InkWell</code> 设置的 splashColor 会失效：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart">InkWell(<br>  splashColor: Colors.amber,<br>  onTap: () &#123;&#125;,<br>  child: Container(<br>    alignment: Alignment.center,<br>    child: Text(<span class="hljs-string">&#x27;Text&#x27;</span>),<br>    color: Colors.red, <span class="hljs-comment">// Container 的 color 把 InkWell 的 splashColor 盖住了</span><br>  ),<br>)<br></code></pre></td></tr></table></figure><p>此时，需要用 Material 去除背景色，然后将颜色设置在 InkWell 外部：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart">Container(<br>  color: Colors.red, <span class="hljs-comment">// 背景色设置在 Material 之外</span><br>  child: Material(<br>    color: Colors.transparent, <span class="hljs-comment">// 用透明的 Material 包裹 InkWell，使得 splashColor 得以生效</span><br>    child: InkWell(<br>      splashColor: Colors.amber,<br>      onTap: () &#123;&#125;,<br>      child: Container(<br>        alignment: Alignment.center,<br>        child: Text(<span class="hljs-string">&#x27;Text&#x27;</span>),<br>      ),<br>    ),<br>  ),<br>);<br></code></pre></td></tr></table></figure><h4 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h4><p>当嵌套使用 ListView 时，我们会发现控制台报错 <code>Failed assertion: &#39;child.hasSize&#39;: is not true</code>，解决办法是为内部嵌套的 ListView 添加宽和高即可：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs diff">ListView(<br>  children: [<br><span class="hljs-addition">+   Container(</span><br><span class="hljs-addition">+     height: 120,</span><br>      child: ListView.builder(<br>        scrollDirection: Axis.horizontal,<br>        ...<br>      )<br><span class="hljs-addition">+   )</span><br>  ]<br>)<br></code></pre></td></tr></table></figure><p>上面的例子中，内部嵌套的是一个水平滚动的列表，所以而 ListView 在水平方向上默认是无最大值限制的，所以此时就会报上面的错。</p><h4 id="NestedScrollView"><a href="#NestedScrollView" class="headerlink" title="NestedScrollView"></a>NestedScrollView</h4><p>我们可以使用 NestedScrollView 实现复杂的滑动效果，比如 Android 上常见的 Header 图片收起为导航栏的效果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs dart">NestedScrollView(<br>  controller: scrollController,<br>  headerSliverBuilder: (BuildContext context, <span class="hljs-built_in">bool</span> innerBoxIsScrolled) =&gt; [<br>    SliverAppBar(<br>      backgroundColor: Colors.white,<br>pinned: <span class="hljs-keyword">true</span>,<br>centerTitle: <span class="hljs-keyword">true</span>,<br>elevation: <span class="hljs-number">0.3</span>,<br>forceElevated: <span class="hljs-keyword">true</span>,<br>      expandedHeight: <span class="hljs-number">300</span>,<br>      leading: AdaptableBackButton(),<br>      title: Text(isShrink ? <span class="hljs-string">&#x27;Demo Title&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>),<br>      flexibleSpace: FlexibleSpaceBar(<br>        collapseMode: CollapseMode.pin,<br>        background: Column(<br>          crossAxisAlignment: CrossAxisAlignment.start,<br>          children: [<br>            <span class="hljs-comment">// header content here</span><br>          ],<br>        ),<br>      ),<br>      bottom: TabBar(<br>        controller: tabController,<br>      tabs: <span class="hljs-keyword">const</span> [<br>          Text(<span class="hljs-string">&#x27;Tab 1&#x27;</span>),<br>          Text(<span class="hljs-string">&#x27;Tab 2&#x27;</span>),<br>        ],<br>      ),<br>    )<br>  ],<br>  body: TabBarView(<br>    controller: tabController,<br>    children: [<br>      <span class="hljs-comment">// body content</span><br>    ],<br>  ),<br>)<br></code></pre></td></tr></table></figure><p>但是上面的实现中存在一个小问题，那就是 body 部分滑动的时候会滑动到导航栏之下，一开始以为可以通过动态添加 padding 解决，但是发现这样的话会出现 body 滑动中出现跳动的情况。经过一番搜索之后发现可以通过 <code>SliverOverlapAbsorber</code> 和 <code>SliverOverlapInjector</code> 来解决。</p><p>首先，使用该组件包裹 <code>SliverAppBar</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">SliverOverlapAbsorber(<br>  handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context),<br>  sliver: SliverAppBar(),<br>)<br></code></pre></td></tr></table></figure><p>然后在 body 中使用 <code>SliverOverlapInjector</code> 来注入 <code>SliverAppBar</code> 过度滑动的部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart">Builder(builder: (context) &#123;<br>  <span class="hljs-keyword">return</span> CustomScrollView(<br>    slivers: [<br>      SliverOverlapInjector(<br>          handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context)),<br>      SliverToBoxAdapter(<br>        child: child, <span class="hljs-comment">// body content</span><br>      ),<br>    ],<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p>我开源了一个实现这种效果的组件，感兴趣的可以看看：<a href="https://github.com/aJIEw/collapsible_app_bar">collapsible_app_bar</a>，欢迎 star~</p><h4 id="Scaffold"><a href="#Scaffold" class="headerlink" title="Scaffold"></a>Scaffold</h4><p>Scaffold 提供搭建一个页面的脚手架功能，比如 DefaultTextStyle，没有它的话字体就会出现一条<a href="https://stackoverflow.com/questions/47114639/yellow-lines-under-text-widgets-in-flutter">黄色的下划线</a>。除此之外，我们还可以使用 Scaffold 设置背景色 (<code>backgroundColor</code>)，导航栏 (<code>appbar</code>)，底部导航栏 (<code>bottomNavigationBar</code>)，浮动按钮 (<code>floatingActionButton</code>)，侧边栏 (<code>drawer</code> &amp; <code>endDrawer</code>)。</p><p>其它属性：</p><ul><li><code>extendBody</code>: <code>body</code> 的内容是否延展到底部导航栏下，默认 false。</li><li><code>extendBodyBehindAppBar</code>: <code>body</code> 的内容是否延展到导航栏下，默认 false。</li><li><code>persistentFooterButtons</code>: 位于页面底部的一组按钮，通常是 <code>TextButton</code>。</li></ul><h4 id="ScrollBar"><a href="#ScrollBar" class="headerlink" title="ScrollBar"></a>ScrollBar</h4><p>Flutter 中所有的 list 默认都是没有 ScrollBar 的，必须使用 ScrollBar 组件。ScrollBar 组件通过监听 ScrollView 的 ScrollNotification 来刷新位置，所以 List 的长度必须是固定的。</p><h4 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h4><h5 id="不显示-over-scroll-glow"><a href="#不显示-over-scroll-glow" class="headerlink" title="不显示 over scroll glow"></a>不显示 over scroll glow</h5><p>在安卓上，所有可滚动的组件默认都会在滚动边缘显示发光效果，如果想要避免这种情况，可以使用 <code>BouncingScrollPhysics</code>，也就是 iOS 上默认的滚动到列表边缘的效果。如果想要彻底关闭，则需要借助 ScrollConfiguration 修改 <code>behavior</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">ScrollConfiguration(<br>  behavior: <span class="hljs-keyword">const</span> MaterialScrollBehavior().copyWith(overscroll: <span class="hljs-keyword">false</span>),<br>  child: ListView(...)<br>)<br></code></pre></td></tr></table></figure><h4 id="SingleChildScrollView"><a href="#SingleChildScrollView" class="headerlink" title="SingleChildScrollView"></a>SingleChildScrollView</h4><h5 id="解决组件内容显示不全的问题"><a href="#解决组件内容显示不全的问题" class="headerlink" title="解决组件内容显示不全的问题"></a>解决组件内容显示不全的问题</h5><p>当使用 WebView 等高度不定的组件时会出现内容被截断的情况，此时可以通过在 WebView 外部嵌套 SingleChildScrollView 来解决该问题。</p><h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><p>Flutter 中文字的渲染引擎使用的是 <code>SkParagraph</code>，其上层封装了复杂的 API 用于绘制文字，不过最核心的绘制功能都是由 <code>TextPainter</code> 完成的<a href="https://medium.com/flutter-community/how-text-editing-works-internally-in-flutter-45cde5df54b4">^3</a>。</p><h5 id="设置多行文字垂直方向间隔"><a href="#设置多行文字垂直方向间隔" class="headerlink" title="设置多行文字垂直方向间隔"></a>设置多行文字垂直方向间隔</h5><p><code>TextStyle</code> 无法直接设置文字行间距，不过我们可以通过 <code>height</code> 变相设置间隔，默认为 1 表示高度等于文字高度，假如设为 1.5 则行高为 1.5 倍文字高度，因此行间距也会变大。</p><h4 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h4><h5 id="清除焦点"><a href="#清除焦点" class="headerlink" title="清除焦点"></a>清除焦点</h5><p>当 TextField 获得焦点之后，键盘会弹起，直到失去焦点之后键盘才会收起。所以，如果想要实现点击空白区域收起键盘的效果，我们可以在根 view 上添加点击事件，在其中清除 TextField 的焦点。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">GestureDetector(<br>  onTap: () &#123;<br>    FocusScope.of(context).requestFocus(FocusNode());<br>  &#125;,<br>  child: ...<br>),<br></code></pre></td></tr></table></figure><p>另外，如果在 TextField 上设置了焦点，则如果想要清除焦点，不要调用 <code>focusNode.unfocus()</code>，而是应该像上面一样，通过在新的 FocusNode 上请求焦点来达到清除 TextField 焦点的目的。</p><p>除此之外，如果我们需要根据 TextField 是否拥有焦点来改变 UI 的显示状态，比如是否显示 suffixIcon，可以在 TextField 的 focusNode 上添加监听器。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart">searchFocusNode.addListener(() &#123;<br>  <span class="hljs-keyword">if</span> (searchFocusNode.hasPrimaryFocus) &#123;<br>    setState(() &#123;<br>      textFieldHasFocus = <span class="hljs-keyword">true</span>;<br>    &#125;);<br>  &#125;<br>&#125;);<br><br>TextField(<br>  focusNode: searchFocusNode,<br>)<br></code></pre></td></tr></table></figure><h5 id="输入框被遮盖"><a href="#输入框被遮盖" class="headerlink" title="输入框被遮盖"></a>输入框被遮盖</h5><p>假设这样一种情况，我们使用 Stack 实现了在页面底部放置一个吸底按钮，此时，如果 TextField 获得了焦点，键盘弹出，则吸底按钮默认会跟随键盘升起，而如果 TextField 的位置在页面靠下的位置，则弹出键盘加上吸底按钮可能会将 TextField 的输入焦点遮盖。解决这一问题的方法是在 TextField 上添加 <code>scrollPadding</code> 参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">Configures padding to edges surrounding a [Scrollable] when the Textfield scrolls into view.</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// <span class="markdown">When this widget receives focus and is not completely visible (for example scrolled partially</span></span><br><span class="hljs-comment">/// <span class="markdown">off the screen or overlapped by the keyboard)</span></span><br><span class="hljs-comment">/// <span class="markdown">then it will attempt to make itself visible by scrolling a surrounding [Scrollable], if one is present.</span></span><br><span class="hljs-comment">/// <span class="markdown">This value controls how far from the edges of a [Scrollable] the TextField will be positioned after the scroll.</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// <span class="markdown">Defaults to EdgeInsets.all(20.0).</span></span><br><span class="hljs-keyword">final</span> EdgeInsets scrollPadding;<br></code></pre></td></tr></table></figure><p>如注释所说，该属性主要用于将 TextField 进行滑动偏移，前提是必须包裹在 Scrollable 中。 因此，我们可以将 TextField 包裹在 ListView 或者 SingleChildScrollView 中，然后在 TextField 上将该参数的值设置为大于吸底按钮的高度即可。参考：<a href="https://stackoverflow.com/a/71696817/4837812">stackoverflow - textfield hide by keyboard</a>。</p><h4 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h4><h5 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h5><p>在 Web 中加载网络图片有时会失败，遇到这样的报错：<code>Exception caught by image resource service...</code>，造成该错误的原因通常是图片<a href="https://flutter.cn/docs/development/platform-integration/web-images#cross-origin-resource-sharing-cors">跨域</a>了，最简单的解决办法是，<a href="https://flutter.cn/docs/development/platform-integration/web/renderers">使用 HTML 渲染加载</a>。</p><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><h4 id="Row-或-Column-中的-ScrollView"><a href="#Row-或-Column-中的-ScrollView" class="headerlink" title="Row 或 Column 中的 ScrollView"></a>Row 或 Column 中的 ScrollView</h4><p>如果直接在 Column 中添加 ScrollView，由于 Column 会在垂直方向上最大化扩展子组件，而 ScrollView 又没有固定长度，所以组件会超过屏幕大小，解决方法是可以在 ScrollView 组件之外使用 Expanded 将其包裹起来。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">Column(<br>  children: &lt;Widget&gt;[<br>    Expanded(<br>      child: ListView(...),<br>    )<br>  ],<br>)<br></code></pre></td></tr></table></figure><p>或者，可以使用 <code>SingleChildScrollView</code> 包裹 Row 或者 Column。</p><p>如果 <code>SingleChildScrollView</code> 之外还需要使用 Row 或 Column，则应该指定宽度或者高度，只有这样才能使列表滚动起来。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart">Column(<br>  children: [<br>    SizedBox(<br>      width: <span class="hljs-number">300</span>,<br>      SingleChildScrollView(<br>        scrollDirection: Axis.horizontal,<br>    child: Row(<br>      children: [<br>          widgets...<br>        ],<br>      )<br>    ),<br>    ),<br>  ],<br>)<br></code></pre></td></tr></table></figure><p>上面的例子中，Column 中包含一个可水平滚动的 Row，此时必须在 <code>SingleChildScrollView</code> 之外指定宽度，否则内部的宽度就会是 unbounded，结果就会造成无法滚动。</p><h4 id="如何让-Column-占满-Row-的最大高度？"><a href="#如何让-Column-占满-Row-的最大高度？" class="headerlink" title="如何让 Column 占满 Row 的最大高度？"></a>如何让 Column 占满 Row 的最大高度？</h4><p>借助 <a href="https://api.flutter.dev/flutter/widgets/IntrinsicHeight-class.html">IntrinsicHeight</a> 组件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">最终实现效果是：</span></span><br><span class="hljs-comment">/// <span class="markdown">1  </span></span><br><span class="hljs-comment">/// <span class="markdown"><span class="hljs-code">      3</span></span></span><br><span class="hljs-comment">/// <span class="markdown"><span class="hljs-code">2  </span></span></span><br>IntrinsicHeight(<br>  child: Row(<br>    mainAxisAlignment: MainAxisAlignment.spaceBetween,<br>    children: [<br>      Flexible(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.spaceBetween,<br>          crossAxisAlignment: CrossAxisAlignment.start,<br>          children: [<br>            Container(...), <span class="hljs-comment">// 组件1</span><br>            Container(...), <span class="hljs-comment">// 组件2</span><br>          ])<br>      ),<br>      Container(...), <span class="hljs-comment">// 组件3</span><br>    ])<br>)<br></code></pre></td></tr></table></figure><p>另外，IntrinsicHeight 还可以用于 Dialog 或者 BottomSheet 中，使得其中的元素<strong>显示内在元素的高度</strong>，从而避免元素因为约束的存在而不显示或者高度太高（比如在使用了 Column 或者 Row 的时候）。</p><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><h4 id="如何保证弹窗被关闭"><a href="#如何保证弹窗被关闭" class="headerlink" title="如何保证弹窗被关闭"></a>如何保证弹窗被关闭</h4><p>在 flutter 中，弹窗也是通过 <code>Navigator</code> 来管理路由的，所以关闭弹窗的时候也是通过调用 <code>Navigator.of(context).pop()</code> 方法，当我们需要同时展示多个弹窗的时候，如何确保被关闭的弹窗是我们想要关闭的那个弹窗？</p><p>我们知道 <code>showDialog</code> 会返回一个跳转结果 <code>Future</code>，因此，我们可以通过记录下这个值是否为空来判断某个弹窗是否已经被关闭，然后在调用关闭弹窗的方法之前先进行判断。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dart">Future? _loadingDialog;<br><br><span class="hljs-keyword">void</span> showLoadingDialog(BuildContext context) <span class="hljs-keyword">async</span> &#123;<br><span class="hljs-keyword">if</span> (_loadingDialog == <span class="hljs-keyword">null</span>) &#123;<br>    _loadingDialog = showDialog(<br>        context: context,<br>        barrierDismissible: <span class="hljs-keyword">false</span>,<br>        barrierColor: Colors.transparent,<br>        builder: (BuildContext context) &#123;<br>          <span class="hljs-keyword">return</span> LoadingDialog(<br>            showContent: <span class="hljs-keyword">false</span>,<br>            backgroundColor: Colors.transparent,<br>            loadingView: Padding(<br>              padding: <span class="hljs-keyword">const</span> EdgeInsets.only(bottom: <span class="hljs-number">200</span>),<br>              child: GradientProgressIndicator(),<br>            ),<br>          );<br>        &#125;);<br>    <span class="hljs-keyword">await</span> _loadingDialog;<br>    _loadingDialog = <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> dismissLoadingDialog(BuildContext context) &#123;<br>  <span class="hljs-keyword">if</span> (_loadingDialog != <span class="hljs-keyword">null</span>) &#123;<br>    Navigator.of(context, rootNavigator: <span class="hljs-keyword">true</span>).pop();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 LoadingDialog 是弹窗组件，我们定义了 <code>_loadingDialog</code> 变量用于保存弹窗显示后的结果 <code>Future</code>，并且在关闭后重新将其置为空值。这样，我们只要在展示其它弹窗之前先调用一下 <code>dismissLoadingDialog</code> 就可以确保加载弹窗已经关闭，而且也不用担心 <code>dismissLoadingDialog</code> 会把其它地方的路由给弹出了。</p><h4 id="使用原始类型的字符串"><a href="#使用原始类型的字符串" class="headerlink" title="使用原始类型的字符串"></a>使用原始类型的字符串</h4><p>在使用 String 字符串作为假数据时，有时候会遇到 <code>FormatException... Control character in string (at line...)</code> 的错误，可以通过在字符串前添加 <code>r</code> 来解决：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span> rawJson = <span class="hljs-string">r&#x27;&#x27;&#x27;&#123;&#125;&#x27;&#x27;&#x27;</span>;<br><br><span class="hljs-keyword">var</span> result = json.decode(rawJson);<br></code></pre></td></tr></table></figure><p>参考了 StackOverflow 上的<a href="https://stackoverflow.com/questions/55757489/n-gives-error-when-parsing-json-in-flutter/69269492#69269492">这个</a>回答。</p><h4 id="如何保存-tab-的状态"><a href="#如何保存-tab-的状态" class="headerlink" title="如何保存 tab 的状态"></a>如何保存 tab 的状态</h4><p>在使用 <code>IndexedStack</code> 或 <code>TabBarView</code> 的时候，由于切换视图后 widget 会被经历销毁重建的过程，为了防止这一现象，我们可以在组件上添加 <code>AutomaticKeepAliveClientMixin</code> 保存页面状态：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyTabViewState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyTabView</span>&gt; <span class="hljs-title">with</span> <span class="hljs-title">AutomaticKeepAliveClientMixin</span> </span>&#123;<br><span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> wantKeepAlive =&gt; <span class="hljs-keyword">true</span>;<br>  <br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// 必须调用父类 build 方法</span><br>    <span class="hljs-keyword">super</span>.build(context);<br>...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="访问-Uri-queryParameters-报错"><a href="#访问-Uri-queryParameters-报错" class="headerlink" title="访问 Uri.queryParameters 报错"></a>访问 <code>Uri.queryParameters</code> 报错</h4><p>在通过 Uri 的 <code>queryParameters</code> 获取 query 参数时，发现有些链接会抛出下面异常：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">Missing <span class="hljs-keyword">extension</span> byte (at offset <span class="hljs-number">1</span>)<br><br>When the exception was thrown, <span class="hljs-keyword">this</span> was the stack: <br>#<span class="hljs-number">0</span>      _Utf8Decoder.convertSingle (dart:convert-patch/convert_patch.dart:<span class="hljs-number">1787</span>:<span class="hljs-number">7</span>)<br>#<span class="hljs-number">1</span>      Utf8Decoder.convert (dart:convert/utf.dart:<span class="hljs-number">322</span>:<span class="hljs-number">42</span>)<br>#<span class="hljs-number">2</span>      Utf8Codec.decode (dart:convert/utf.dart:<span class="hljs-number">63</span>:<span class="hljs-number">20</span>)<br>#<span class="hljs-number">3</span>      _<span class="hljs-built_in">Uri</span>._uriDecode (dart:core/uri.dart:<span class="hljs-number">2858</span>:<span class="hljs-number">21</span>)<br>#<span class="hljs-number">4</span>      <span class="hljs-built_in">Uri</span>.decodeQueryComponent (dart:core/uri.dart:<span class="hljs-number">1059</span>:<span class="hljs-number">17</span>)  <br></code></pre></td></tr></table></figure><p>造成该异常的原因是 Uri 默认使用 utf-8 解码超链接字符串，如果链接中包含非 utf-8 字符，就会造成上面的错误，相关 issue 见：<a href="https://github.com/dart-lang/sdk/issues/31621">issue #31621</a>。目前该 issue 处于 open 的状态，暂时的解决办法是，在所有使用到 <code>queryParameter</code> 的地方用 <code>try..catch</code> 捕捉可能抛出的异常。</p><h2 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h2><p>Flutter 开发非常依赖各种官方或第三方的插件，在使用这些插件时多少都会遇到一些问题，虽然大部分问题都可以通过搜索引擎和查找 issues 来解决，但是对于那些比较常见的问题最好还是记录一下，这样下次再遇到的时候就可以节约重新寻找解决办法的时间。</p><h3 id="animations"><a href="#animations" class="headerlink" title="animations"></a>animations</h3><h4 id="OpenContainer"><a href="#OpenContainer" class="headerlink" title="OpenContainer"></a>OpenContainer</h4><p>在使用 <code>OpenContainer</code> 添加容器动效时，发现组件外部多了一圈空白以及边框，查看源码后发现，原来是组件的默认属性造成的，可以像下面这样去除：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">OpenContainer(<br>  closedColor: Colors.transparent,<br>  closedElevation: <span class="hljs-number">0</span>,<br>)<br></code></pre></td></tr></table></figure><h4 id="PageTransitionSwitcher"><a href="#PageTransitionSwitcher" class="headerlink" title="PageTransitionSwitcher"></a>PageTransitionSwitcher</h4><p>在使用 <code>PageTransitionSwitcher</code> 制作页面切换动画时，发现动画没有生效，发现原来是因为切换前后的两个页面使用了相同的组件 (Column) 作为根组件，这样 Switcher 就无法区分这两个组件，所以动画就失效了。解决办法是为这两个组件添加 key，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart">PageTransitionSwitcher(<br>  duration: <span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(milliseconds: <span class="hljs-number">600</span>),<br>  transitionBuilder: <span class="hljs-comment">/* ... */</span>,<br>  child: canSwitch<br>      ? Column(<br>          key: <span class="hljs-keyword">const</span> ValueKey&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">0</span>),<br>          children: [],<br>        )<br>      : Column(<br>          key: <span class="hljs-keyword">const</span> ValueKey&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">1</span>),<br>          children: [],<br>        )<br>)<br></code></pre></td></tr></table></figure><h3 id="cached-network-image"><a href="#cached-network-image" class="headerlink" title="cached_network_image"></a>cached_network_image</h3><h4 id="预加载网络图片"><a href="#预加载网络图片" class="headerlink" title="预加载网络图片"></a>预加载网络图片</h4><p>通过 <code>precacheImage</code> 和 <code>CachedNetworkImageProvider</code> 预加载网络图片：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">precacheImage(CachedNetworkImageProvider(urlString), context);<br></code></pre></td></tr></table></figure><h4 id="加载回调"><a href="#加载回调" class="headerlink" title="加载回调"></a>加载回调</h4><p>目前该库没有图片加载完成的回调（见 <a href="https://github.com/Baseflow/flutter_cached_network_image/issues/545">issue #545</a>），不过我们可以通过在 <code>imageBuilder</code> 中来添加回调：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">imageBuilder: (context, provider) &#123;<br>  <span class="hljs-keyword">if</span> (provider <span class="hljs-keyword">is</span> CachedNetworkImageProvider) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;provider.url&#125;</span> image is ready to be displayed&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> Image(<br>    image: provider,<br>  );<br>&#125;,<br></code></pre></td></tr></table></figure><h4 id="长图片重新加载问题"><a href="#长图片重新加载问题" class="headerlink" title="长图片重新加载问题"></a>长图片重新加载问题</h4><p>虽然使用了缓存，而且也是用 builder 加载图片的，但是发现一个现象：滑动屏幕后图片短暂消失并重新加载了。图片高度很高时这种现象更加明显，其原因是超出屏幕范围一定距离的组件被重新渲染了。解决方法是在 ListView 上设置 <code>cacheExtent</code> 参数:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">ListView.builder(<br>    cacheExtent: <span class="hljs-number">9999</span>,<br>    itemCount: state.length ?? <span class="hljs-number">10</span>,<br>    itemBuilder: ...)<br></code></pre></td></tr></table></figure><p>该参数的作用是改变超出屏幕高度后继续渲染的范围（以像素为单位），比如设置成 9999 后意味着超出屏幕 10000 像素以内的内容都会被保留下来。</p><h3 id="charts-flutter"><a href="#charts-flutter" class="headerlink" title="charts_flutter"></a>charts_flutter</h3><p>这是谷歌开发的一个<a href="https://pub.dev/packages/charts_flutter">图表库</a>，虽然官方已经 discontinuted，只剩<a href="https://pub.dev/packages/community_charts_flutter">社区</a>还在维护，但是好在大部分功能实现得比较完备，所以基本能用。不足之处是代码太过复杂，很多小问题很难马上找到解决方法，有时候需要去 so 或者 github 上搜各种各样的 workaround 来解决。</p><h3 id="flutter-inappwebview"><a href="#flutter-inappwebview" class="headerlink" title="flutter_inappwebview"></a>flutter_inappwebview</h3><p>目前功能最强大的 WebView 插件，基本能满足绝大部分移动端网页加载的需求，而且可定制化程度很高。</p><h4 id="修改-Cookie"><a href="#修改-Cookie" class="headerlink" title="修改 Cookie"></a>修改 Cookie</h4><p>如果想要修改 Cookie 一般通过 CookieManager，直接拦截请求并修改请求对象的 Header 不会生效。</p><h4 id="添加自定义-UserAgent"><a href="#添加自定义-UserAgent" class="headerlink" title="添加自定义 UserAgent"></a>添加自定义 UserAgent</h4><p><code>InAppWebViewOptions</code> 的 <code>userAgent</code> 只在 iOS 上生效，而 <code>applicationNameForUserAgent</code> 只在 Android 上生效，所以最好的做法是分平台设置 <code>InAppWebViewOptions</code>。</p><p>另外需要注意，由于设置 <code>userAgent</code> 后会覆盖默认的 UserAgent，所以如果需要在默认的 UserAgent 上添加其它参数，iOS 上需要通过 <code>InAppWebViewController.getDefaultUserAgent()</code> 获取默认 UserAgent 参数，而 Android 不需要添加。</p><h4 id="图片加载失败问题"><a href="#图片加载失败问题" class="headerlink" title="图片加载失败问题"></a>图片加载失败问题</h4><p>如果图片源或者请求是 http 的，为了在 Android 上正常加载请求，必须在 <code>AndroidInAppWebViewOptions</code> 中将 <code>mixedContentMode</code> 设置为 <code>AndroidMixedContentMode.MIXED_CONTENT_ALWAYS_ALLOW</code>。</p><h3 id="getx"><a href="#getx" class="headerlink" title="getx"></a><a href="https://pub.dev/packages/get">getx</a></h3><h4 id="管理状态"><a href="#管理状态" class="headerlink" title="管理状态"></a>管理状态</h4><p>在 controller 中，一般监听变量更新只需要在变量后家 <code>obs</code>，但是如果变量是对象则需要使用 <code>Rxn</code> 对象来包装：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> page = Rxn&lt;MyData&gt;();<br></code></pre></td></tr></table></figure><h4 id="管理依赖"><a href="#管理依赖" class="headerlink" title="管理依赖"></a>管理依赖</h4><p>一般注入 Controller 的方式有两种：</p><h5 id="直接注入"><a href="#直接注入" class="headerlink" title="直接注入"></a>直接注入</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">Get.put(Controller());<br></code></pre></td></tr></table></figure><h5 id="使用-Bindings"><a href="#使用-Bindings" class="headerlink" title="使用 Bindings"></a>使用 Bindings</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPageBinding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bindings</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dependencies() &#123;<br>    Get.put(MyPageController());<br>    Get.lazyPut(() =&gt; PayModuleController());<br>    Get.lazyPut(() =&gt; MediaModuleController());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义好 Binding 类后，有两种方式使用来使用它，一种是通过 GetPage，另一种是通过 Get.to()：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">GetPage(<br>  name: myPage,<br>  page: () =&gt; <span class="hljs-keyword">const</span> MyPage(),<br>  binding: MyPageBinding(),<br>)<br><br>Get.to(myPage, binding: MyPageBinding());<br></code></pre></td></tr></table></figure><h5 id="获取-Controller"><a href="#获取-Controller" class="headerlink" title="获取 Controller"></a>获取 Controller</h5><p>使用 Get.put() 可以直接获得 controller，而如果是使用 Bindings 注入的依赖，则需要使用 Get.find() 获取依赖。当然，也可以使用 GetView，不过本质上也是使用了 Get.find()。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// Use Get.find()</span><br>MyAwesomeController <span class="hljs-keyword">get</span> controller =&gt; Get.find&lt;MyAwesomeController&gt;();<br><br><span class="hljs-comment">// Use GetView</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GetView</span>&lt;<span class="hljs-title">MyAwesomeController</span>&gt; </span>&#123;<br><span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    controller.doSomething();<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，还有一个小技巧，对于一些轻量级的 view 的 controller，需要使用传入参数才能初始化，此时，可以将 controller 放到 build 方法中初始化：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <br>  MyView(&#123;Key? key, <span class="hljs-keyword">this</span>.someId&#125;) : <span class="hljs-keyword">super</span>(key: key);<br>  <br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> someId;<br>  <br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">var</span> controller = Get.put(MyAwesomeController(someId), tag: someId);<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 Get.put 注入的依赖只会被初始化一次，所以不用担心外部组件状态刷新后会重新创建 controller，而且 controller 所需的参数也能得到传递。不过，我们还应该使用 tag，这样就允许组件根据传入的不同的参数，创建多个各自独立的 controller 了。</p><h3 id="ota-update"><a href="#ota-update" class="headerlink" title="ota_update"></a>ota_update</h3><p>这是一个应用内更新插件，安卓 10 以上安装时需要在 manifest 中添加以下内容：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff">    &lt;application<br>        android:icon=&quot;@mipmap/ic_launcher&quot;<br>        android:label=&quot;@string/app_name&quot;<br>        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;<br><span class="hljs-addition">+       android:requestLegacyExternalStorage=&quot;true&quot;</span><br>        android:usesCleartextTraffic=&quot;true&quot;&gt;<br></code></pre></td></tr></table></figure><h4 id="selection-state-loss"><a href="#selection-state-loss" class="headerlink" title="selection state loss"></a>selection state loss</h4><p>以 <a href="https://google.github.io/charts/flutter/gallery.html#time-series-charts">Time Series Charts</a> 为例，假如我们需要监听选中状态，然后更新图表外的数据：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart">selectionModels: [<br>  SelectionModelConfig&lt;<span class="hljs-built_in">DateTime</span>&gt;(<br>    type: SelectionModelType.info,<br>    changedListener: (SelectionModel&lt;<span class="hljs-built_in">DateTime</span>&gt; model) &#123;<br>      <span class="hljs-keyword">var</span> data = model.selectedDatum.first;<br>      onSelected?.call(data.datum);<br>    &#125;,<br>  ),<br>],<br></code></pre></td></tr></table></figure><p>在设置了监听选中事件之后，如果我们在代码中更新了 State，比如使用了 <code>setState</code>，那么图表的选中状态就会丢失，这是因为外部的 state 更新之后使得 chart 也重新构建，导致 charts 内部维护的 state 发生刷新，原有的状态也就丢失了。</p><p>解决方法是，将 <code>setState</code> 放到图表视图之外，防止展示图表的过程中的重建图表视图，比如可以借助 GetX 实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">Obx(() =&gt; ViewThatUsesSelectedData()),<br>YourChartsGraph(<br>  DateDurationGraph.createDurationData(durations: durationList),<br>  onSelected: (DateDuration dateDuration) &#123;<br>    controller.selectedDateDuration.value = dateDuration;<br>  &#125;,<br>),<br></code></pre></td></tr></table></figure><h2 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h2><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><h4 id="CocoaPods-out-of-date"><a href="#CocoaPods-out-of-date" class="headerlink" title="CocoaPods out of date"></a>CocoaPods out of date</h4><p>如果你的 ruby 是通过 <code>brew</code> 命令安装的，则更新 CocoaPods 时同样需要通过 <code>brew</code> 命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">brew upgrade cocoapods --verbose<br></code></pre></td></tr></table></figure><h4 id="LauchSreen-storyboard"><a href="#LauchSreen-storyboard" class="headerlink" title="LauchSreen.storyboard"></a>LauchSreen.storyboard</h4><p>当我们想要设置全屏图片的时候，由于默认的 Constraint 会将图片居中显示，所以图片四周会留有空隙。为了去除这个限制，我们需要 Xcode 中打开 LaunchScreen.storyboard，然后在 View Controller 的 View 和 LaunchImage 上的 <strong>Safe Area</strong> 去掉。</p><p>具体设置方法：右侧 Inspector 面板 &gt; Show the Size inspector &gt; 解选 Layout Margins 中的 Safe Area Relative Margins，拖动图片占满全屏，然后根据 View Controller Scene 的 Warning 提示，更新 Constraint 就可以了。</p><h4 id="Xcode-‘architecture-arm64’-问题"><a href="#Xcode-‘architecture-arm64’-问题" class="headerlink" title="Xcode ‘architecture arm64’ 问题"></a>Xcode ‘architecture arm64’ 问题</h4><p>在集成某些三方库之后，在使用命令行运行 iOS 模拟器的时候可能会遇到下面这个报错：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">building </span>for iOS Simulator, <span class="hljs-keyword">but </span>linking in object file <span class="hljs-keyword">built </span>for iOS, for architecture arm64<br></code></pre></td></tr></table></figure><p>这是因为 iOS 模拟器未来将会兼容 arm64 架构，但是目前还不支持，所以我们需要修改 Build Setting 使得能够在 x86_64 的模拟器上运行，可以在  Architecture &gt; <strong>Build Active Architecture Only</strong> 设置为 Yes，具体操作步骤见<a href="https://stackoverflow.com/a/64591869">这里</a>。</p><h4 id="Missing-Push-Notification-Entitlement-issue"><a href="#Missing-Push-Notification-Entitlement-issue" class="headerlink" title="Missing Push Notification Entitlement issue"></a>Missing Push Notification Entitlement issue</h4><p>当上传新版本之后收到 Apple Store Connect 的邮件提醒 <code>ITMS-90078: Missing Push Notification Entitlement</code>，搜索之后发现是 Flutter 的问题，相关 issue 见：<a href="https://github.com/flutter/flutter/issues/9984">issue#9984</a>。暂时的解决办法是在 Capabilities 中开启 Push Notifications，该 issue 下有提到<a href="https://github.com/flutter/flutter/issues/9984#issuecomment-528649926">如何操作</a>。</p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><h4 id="插件中使用-context"><a href="#插件中使用-context" class="headerlink" title="插件中使用 context"></a>插件中使用 context</h4><p>参考 Flutter <a href="https://github.com/flutter/plugins/blob/master/packages/battery/battery/android/src/main/java/io/flutter/plugins/battery/BatteryPlugin.java">官方插件</a>的做法，需要实现 <code>MethodCallHandler</code> 和 <code>FlutterPlugin</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPlugin</span> : <span class="hljs-type">MethodChannel.MethodCallHandler</span>, <span class="hljs-type">FlutterPlugin &#123;</span></span><br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-comment">// 兼容老版本，见 https://docs.flutter.dev/development/packages-and-plugins/plugin-api-migration</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">registerWith</span><span class="hljs-params">(registry: <span class="hljs-type">PluginRegistry</span>.<span class="hljs-type">Registrar</span>)</span></span> &#123;<br>            <span class="hljs-keyword">val</span> myPlugin = MyPlugin()<br>            myPlugin.onAttachedToEngine(registry.context(), registry.messenger())<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> context: Context<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAttachedToEngine</span><span class="hljs-params">(binding: <span class="hljs-type">FlutterPlugin</span>.<span class="hljs-type">FlutterPluginBinding</span>)</span></span> &#123;<br>        onAttachedToEngine(binding.applicationContext, binding.binaryMessenger)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAttachedToEngine</span><span class="hljs-params">(applicationContext: <span class="hljs-type">Context</span>, messenger: <span class="hljs-type">BinaryMessenger</span>)</span></span> &#123;<br>        context = applicationContext<br><br>        <span class="hljs-keyword">val</span> channel = MethodChannel(messenger, <span class="hljs-string">&quot;my_plugin_name&quot;</span>)<br>        channel.setMethodCallHandler(<span class="hljs-keyword">this</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDetachedFromEngine</span><span class="hljs-params">(binding: <span class="hljs-type">FlutterPlugin</span>.<span class="hljs-type">FlutterPluginBinding</span>)</span></span> &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMethodCall</span><span class="hljs-params">(call: <span class="hljs-type">MethodCall</span>, result: <span class="hljs-type">MethodChannel</span>.<span class="hljs-type">Result</span>)</span></span> &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h2><h3 id="依赖引用-git-地址"><a href="#依赖引用-git-地址" class="headerlink" title="依赖引用 git 地址"></a>依赖引用 git 地址</h3><p>当使用 <a href="https://dart.dev/tools/pub/dependencies#git-packages">git package</a> 时，有时候会发现使用 pub get 无法获取最新的 package，这是因为只有在第一次的时候才会从 git 地址获取最新版本，之后会将 ref 写入 <code>pubspec.lock</code>，因此我们可以通过将 <code>pubspec.lock</code> 中的 dependency 信息整块删除，然后重新运行 pub get 就可以获取到最新的版本了。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs diff"># 当版本没有发生变化时，pubspec.lock 会将依赖锁定为某一个 ref 的版本<br>dependency: &quot;direct main&quot;<br>    description:<br>      path: &quot;.&quot;<br>      ref: HEAD<br><span class="hljs-addition">+     resolved-ref: &quot;83a1f768fca56902b3151931e8c0b59455b83aca&quot;</span><br>      url: &quot;repo_url&quot;<br>    source: git<br>    version: &quot;1.0.0&quot;<br></code></pre></td></tr></table></figure><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>当在命令行下使用 <code>flutter pub get</code> 下载依赖时提示连接超时，可以尝试去除命令行代理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 学习笔记</title>
      <link href="/flutter-notes/"/>
      <url>/flutter-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2019-08-23/flutter-and-dart.png"></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Flutter 采用 Dart 作为主要编程语言，所以应用的入口同样是顶层的 <code>main()</code> 方法，<code>main()</code> 方法中调用了 <code>runApp()</code> 方法，它接收一个 Widget 作为参数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&#x27;Demo&#x27;</span>),<br>      ),<br>      body: Center(<br>        child: Text(<span class="hljs-string">&#x27;Hello World&#x27;</span>),<br>      ),<br>    ),<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>Flutter 中的组件分为非容器类组件和容器类组件，非容器类组件一般直接或间接继承自 <code>LeafRenderObjectWidget</code>，而容器类组件则继承自 <code>SingleChildRenderObjectWidget</code> 和 <code>MultiChildRenderObjectWidget</code>，所以，所有组件的继承关系为 Widget &gt; RenderObjectWidget &gt; (Leaf/SingleChild/MultiChild)RenderObjectWidget，其中，<code>RenderObjectWidget</code> 类中定义了创建、更新 <code>RenderObject</code> 的方法，所有子类必须实现它。</p><h3 id="Layout-基础"><a href="#Layout-基础" class="headerlink" title="Layout 基础"></a>Layout 基础</h3><p>Flutter 中的 Widget 借鉴了 React 的思想。所有的 UI 都是基于 Widget 的，Widget 定义了视图如何显示（实际对应的是 Element）。如果使用的是 StatefulWidget，当 State 发生变化时 (通过 <code>setState()</code>) 会触发重绘，当然，这种重绘是经过框架计算的，框架会尽量减少重绘的范围。</p><p>Flutter 中布局模型有两种，一种是基于 RenderBox 的模型，其约束被称为 <a href="https://api.flutter.dev/flutter/rendering/BoxConstraints-class.html">BoxContraints</a>，另一种是基于 RenderSliver 的可滚动列表模型，其约束来自于 <a href="https://api.flutter.dev/flutter/rendering/SliverConstraints-class.html">SliverConstraints</a>。由于开发过程中涉及到的大部分约束相关的问题都来自于 Box 约束，因此这里主要介绍它。</p><h4 id="Box-约束"><a href="#Box-约束" class="headerlink" title="Box 约束"></a>Box 约束</h4><p>在 Flutter 中，组件是基于 <a href="https://api.flutter.dev/flutter/rendering/RenderBox-class.html">RenderBox</a> 被渲染出来的，而 RenderBox 的<em>约束 (constraints)</em> 来自于父组件，并且会根据约束来调整自身的*大小 (size)*。<strong>约束</strong>包含最大/最小的宽和高，<strong>大小</strong>则由具体的宽和高组成。</p><p>通常来说，依据组件如何处理它们的约束，Flutter 中可以分为三种 Boxes：</p><ul><li>想要尽可能大的 Box，比如 Center、ListView 和未指定大小的 Container</li><li>和子组件一样大的 Box，比如 Transform 和 Opacity</li><li>固定大小的 Box，比如 Image 和 Text</li></ul><h5 id="不受限的约束"><a href="#不受限的约束" class="headerlink" title="不受限的约束"></a>不受限的约束</h5><p>在某些场景下，Box 的约束可能是不受限制的，也就是 unbounded，它们的宽或高被设置为 double.INIFINITY。</p><p>一个尽可能大的 Box 如果被给予了不受限的约束的话，就会在运行时报错，比如如果你把一个垂直滚动的 ListView 嵌套进一个水平滚动的 ListView，那么，由于 ListView 会在它的交叉方向上寻求最大边界，内部的 ListView 会尝试尽可能填充自己的宽度，而此时宽度又是无限宽，所以会报异常。</p><h5 id="Flex-Boxes"><a href="#Flex-Boxes" class="headerlink" title="Flex Boxes"></a>Flex Boxes</h5><p>Flex boxes (比如 Row 或 Column) 在不同的约束下表现不同。在受限的约束下，Flex box 会在该方向上尽可能的大。在不受限的约束下，它们会将子组件尽可能合适地进行排列，但是前提是子组件不能使用大于 0 的 Flex，也就是说使用了 Flex 的 box 不能相互嵌套。比如对于 Column 来说，它的 width 不能是 unbounded；对于 Row 来说，它的高度也不能是 unbounded。</p><h4 id="理解约束"><a href="#理解约束" class="headerlink" title="理解约束"></a>理解约束</h4><p>Flutter 中有一个基本原则：<strong>约束向下传递，大小向上传递，父布局设置位置</strong>。</p><ul><li>组件的约束 (constraints) 来自父组件，约束由 4 个 double 组成：最小/最大宽度，最小/最大高度。</li><li>组件会依次测量子组件，得到子组件的大小，并且告诉每个子组件它们各自的约束。</li><li>组件会根据子组件的大小和排列方向依次放置子组件。</li><li>最后，组件告诉父组件它自身的大小。</li></ul><h5 id="约束的限制"><a href="#约束的限制" class="headerlink" title="约束的限制"></a>约束的限制</h5><ul><li>组件的大小必须在父组件的约束范围之内，也就是说<strong>子组件并不能拥有任何想要的大小</strong>。</li><li>组件<strong>无法知晓也决定不了自身在屏幕上的位置</strong>，因为它的位置是由父组件决定的。</li><li>因为所有组件都在一个组件树之中，所以<strong>任何组件都无法在脱离组件树的情况下知道自身的大小和尺寸</strong>。</li><li>当子组件需要一个不同的大小并且父组件没有足够的关于如何排列它的信息时，子组件的大小会被忽略。所以，<strong>定义对齐方式时必须足够明确</strong>。</li></ul><h5 id="严密约束和宽松约束"><a href="#严密约束和宽松约束" class="headerlink" title="严密约束和宽松约束"></a>严密约束和宽松约束</h5><p>约束也分为 <em>tight</em> 和 <em>loose</em> 的。宽松约束指组件的最大宽高确定，但是最小宽高为零。严密约束是指确定大小的约束，也可以理解为最大宽高和最小宽高相等。比如下面这个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 布局 A</span><br>Container(<br>  child: Container(<br>    color: Colors.red,<br>    width: <span class="hljs-number">100</span>,<br>    height: <span class="hljs-number">100</span>,<br>  ),<br>);<br><br><span class="hljs-comment">// 布局 B</span><br>Center(<br>  child: Container(<br>    color: Colors.red,<br>    width: <span class="hljs-number">100</span>,<br>    height: <span class="hljs-number">100</span>,<br>  ),<br>);<br></code></pre></td></tr></table></figure><p>同样作为根布局，布局 A 会占满整个屏幕，因为 Container 传递的是 tight 约束，它告诉同样为 Container 的子组件，它的大小是整个屏幕，所以，即使子组件 Container 设置了大小也不会有效果。</p><p>而布局 B 中的 Center 作为根布局，它传递的是 loose 约束，所以只要子组件 Contaienr 的大小不超过屏幕大小就可以了，最小多小并不会有限制，所以它设置的宽高可以传递到父布局并设置生效。</p><p>内部 Container 的约束分别可以表示为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 布局 A</span><br>BoxConstraints.expand(&#123;<br>  width = <span class="hljs-built_in">double</span>.infinity,<br>  height = <span class="hljs-built_in">double</span>.infinity,<br>&#125;)<br><span class="hljs-comment">// 等同于：</span><br>BoxConstraints(<br>  minWidth: <span class="hljs-built_in">double</span>.infinity,<br>  maxWidth: <span class="hljs-built_in">double</span>.infinity,<br>  minHeight: <span class="hljs-built_in">double</span>.infinity,<br>  maxHeight: <span class="hljs-built_in">double</span>.infinity,<br>);<br><br><span class="hljs-comment">// 布局 B</span><br>BoxConstraints.loose(Size(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>))<br><span class="hljs-comment">// 等同于：</span><br>BoxConstraints(<br>  minWidth: <span class="hljs-number">100</span>,<br>  maxWidth: <span class="hljs-built_in">double</span>.infinity,<br>  minHeight: <span class="hljs-number">100</span>,<br>  maxHeight: <span class="hljs-built_in">double</span>.infinity,<br>);<br></code></pre></td></tr></table></figure><p>因此，固定大小的组件 (比如 SizedBox) 也是严密约束的，其约束可以表示为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">BoxConstraints.tightFor(width: <span class="hljs-number">80.0</span>, height: <span class="hljs-number">80.0</span>)<br><span class="hljs-comment">// 等同于：</span><br>BoxConstraints(minHeight: <span class="hljs-number">80.0</span>, maxHeight: <span class="hljs-number">80.0</span>, minWidth: <span class="hljs-number">80.0</span>, maxWidth: <span class="hljs-number">80.0</span>)<br></code></pre></td></tr></table></figure><h5 id="「去除」父级约束"><a href="#「去除」父级约束" class="headerlink" title="「去除」父级约束"></a>「去除」父级约束</h5><p>既然布局约束是向下传递的，有没有什么办法可以去除掉父布局的约束呢？理论上是不可以的，但是实际使用中，我们可以使用 <code>UnconstraintedBox</code>，它可以使得子布局忽略父布局的约束：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart">ConstrainedBox(<br>  constraints: BoxConstraints(minWidth: <span class="hljs-number">60.0</span>, minHeight: <span class="hljs-number">100.0</span>),    <span class="hljs-comment">// A</span><br>  child: UnconstrainedBox( <span class="hljs-comment">// 「去除」父级约束</span><br>    child: ConstrainedBox(<br>      constraints: BoxConstraints(minWidth: <span class="hljs-number">90.0</span>, minHeight: <span class="hljs-number">20.0</span>), <span class="hljs-comment">// B</span><br>      child: redBox,<br>    ),<br>  )<br>)<br></code></pre></td></tr></table></figure><p>上面的例子中，最外层的约束 A 不会传递给 B，最终 redBox 的高度会是 20。但这只是表面现象，其实 <code>UnconstrainedBox</code> 只是阻断了约束的传递，自身还是会受到父级约束的限制，因此最终整体布局的高度还是 100。</p><p>实际使用中，我们可以利用 <code>UncontrainedBox</code> 去除父组件的约束，比如如果使用 <code>SizedBox</code> 时指定了宽度或者高度，子组件就会有相同的宽度或高度，而如果想要去除这种限制，我们就可以使用 <code>UnconstrainedBox</code> 来包裹子组件。</p><h4 id="如何学习组件的布局规则"><a href="#如何学习组件的布局规则" class="headerlink" title="如何学习组件的布局规则"></a>如何学习组件的布局规则</h4><p>Flutter 中组件众多，我们很难一下子记住所有的组件到底是如何布局的，所以最好的做法是阅读<strong>文档</strong>和<strong>源码</strong>。比如，如果你想阅读 <code>Column</code> 组件的源码，首先，我们通过 IDE 跳转到 <code>basic.dart</code> 文件，发现原来 <code>Column</code> 继承的是 <code>Flex</code> 类，在 <code>Flex</code> 的 <code>createRenderObject()</code> 方法中发现返回的是 <code>RenderFlex</code> 对象，最后在 <code>flex.dart</code> 文件中找到 <code>performLayout()</code> 方法，这里才是实际测量并计算子组件位置的地方。</p><h3 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h3><h4 id="Basic-Widget"><a href="#Basic-Widget" class="headerlink" title="Basic Widget"></a>Basic Widget</h4><p><a href="https://api.flutter.dev/flutter/material/MaterialApp-class.html">MaterialApp</a>, <a href="https://api.flutter.dev/flutter/material/Scaffold-class.html">Scaffold</a>, <a href="https://api.flutter.dev/flutter/material/AppBar-class.html">AppBar</a> (<a href="https://api.flutter.dev/flutter/material/material-library.html">material library</a>)</p><p><a href="https://api.flutter.dev/flutter/cupertino/CupertinoApp-class.html">CupertinoApp</a>, <a href="https://api.flutter.dev/flutter/cupertino/CupertinoPageScaffold-class.html">CupertinoPageScaffold</a>, <a href="https://api.flutter.dev/flutter/cupertino/CupertinoTabScaffold-class.html">CupertinoTabScaffold</a> (<a href="https://api.flutter.dev/flutter/cupertino/cupertino-library.html">cupertino library</a>)</p><p><a href="https://api.flutter.dev/flutter/widgets/Builder-class.html">Builder</a>, <a href="https://api.flutter.dev/flutter/widgets/StatefulBuilder-class.html">StatefulBuilder</a></p><p><a href="https://api.flutter.dev/flutter/widgets/Text-class.html">Text</a>, <a href="https://api.flutter.dev/flutter/widgets/Icon-class.html">Icon</a>, <a href="https://api.flutter.dev/flutter/widgets/Image-class.html">Image</a></p><p><a href="https://api.flutter.dev/flutter/material/TextButton-class.html">TextButton</a>, <a href="https://api.flutter.dev/flutter/material/ElevatedButton-class.html">ElevatedButton</a>, <a href="https://api.flutter.dev/flutter/material/OutlinedButton-class.html">OutlinedButton</a>, <a href="https://api.flutter.dev/flutter/material/IconButton-class.html">IconButton</a></p><p><a href="https://api.flutter.dev/flutter/widgets/GestureDetector-class.html">GestureDetector</a>, <a href="https://api.flutter.dev/flutter/material/InkWell-class.html">InkWell</a>/<a href="https://api.flutter.dev/flutter/material/InkResponse-class.html">InkResponse</a></p><h4 id="Layout-Widget"><a href="#Layout-Widget" class="headerlink" title="Layout Widget"></a>Layout Widget</h4><p><a href="https://api.flutter.dev/flutter/widgets/Row-class.html">Row</a>, <a href="https://api.flutter.dev/flutter/widgets/Column-class.html">Column</a>, <a href="https://api.flutter.dev/flutter/widgets/Stack-class.html">Stack</a>/<a href="https://api.flutter.dev/flutter/widgets/Positioned-class.html">Positioned</a>, <a href="https://api.flutter.dev/flutter/widgets/ListView-class.html">ListView</a>, <a href="https://api.flutter.dev/flutter/widgets/GridView-class.html">GridView</a>, <a href="https://api.flutter.dev/flutter/material/Scrollbar-class.html">Scrollbar</a></p><p><a href="https://api.flutter.dev/flutter/widgets/SingleChildScrollView-class.html">SingleChildScrollView</a>, <a href="https://api.flutter.dev/flutter/widgets/CustomScrollView-class.html">CustomScrollView</a>, <a href="https://api.flutter.dev/flutter/widgets/SliverList-class.html">SliverList</a>, <a href="https://api.flutter.dev/flutter/widgets/SliverGrid-class.html">SliverGrid</a></p><p><a href="https://api.flutter.dev/flutter/widgets/Container-class.html">Container</a>, <a href="https://api.flutter.dev/flutter/widgets/Center-class.html">Center</a>, <a href="https://api.flutter.dev/flutter/widgets/Padding-class.html">Padding</a></p><p><a href="https://api.flutter.dev/flutter/widgets/DecoratedBox-class.html">DecoratedBox</a>/<a href="https://api.flutter.dev/flutter/painting/BoxDecoration-class.html">BoxDecoration</a>, <a href="https://api.flutter.dev/flutter/widgets/ClipRect-class.html">ClipRect</a>, <a href="https://api.flutter.dev/flutter/widgets/ClipRRect-class.html">ClipRRect</a>, <a href="https://api.flutter.dev/flutter/widgets/Transform-class.html">Transform</a></p><p><a href="https://api.flutter.dev/flutter/widgets/Expanded-class.html">Expanded</a>, <a href="https://api.flutter.dev/flutter/widgets/Flexible-class.html">Flexible</a>, <a href="https://api.flutter.dev/flutter/widgets/ConstrainedBox-class.html">ConstrainedBox</a>, <a href="https://api.flutter.dev/flutter/widgets/SizedBox-class.html">SizedBox</a>, <a href="https://api.flutter.dev/flutter/widgets/Spacer-class.html">Spacer</a></p><p><a href="https://api.flutter.dev/flutter/widgets/Flex-class.html">Flex</a>, <a href="https://api.flutter.dev/flutter/widgets/Wrap-class.html">Wrap</a>, <a href="https://api.flutter.dev/flutter/dart-developer/Flow-class.html">Flow</a>, <a href="https://api.flutter.dev/flutter/widgets/Align-class.html">Align</a>/<a href="https://api.flutter.dev/flutter/painting/Alignment-class.html">Alignment</a>/<a href="https://api.flutter.dev/flutter/painting/FractionalOffset-class.html">FractionalOffset</a></p><h4 id="Animation-Widget"><a href="#Animation-Widget" class="headerlink" title="Animation Widget"></a><a href="https://flutter.dev/docs/development/ui/animations/overview">Animation</a> Widget</h4><p><a href="https://api.flutter.dev/flutter/animation/Animation-class.html">Animation</a>, <a href="https://api.flutter.dev/flutter/animation/Tween-class.html">Tween</a>, <a href="https://api.flutter.dev/flutter/animation/AnimationController-class.html">AnimationController</a>, <a href="https://api.flutter.dev/flutter/animation/Curve-class.html">Curves</a>, <a href="https://api.flutter.dev/flutter/widgets/AnimatedWidget-class.html">Transition</a>, <a href="https://api.flutter.dev/flutter/widgets/ImplicitlyAnimatedWidget-class.html">ImplicitlyAnimatedWidget</a></p><h4 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h4><p>其他组件的介绍见：<a href="https://flutter.dev/docs/development/ui/widgets">Widget Catalog</a>, <a href="https://www.youtube.com/playlist?list=PLjxrf2q8roU23XGwz3Km7sQZFTdB996iG">Widget of the Week</a></p><h3 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h3><p>大多数情况下，我们都可以通过组合创建出所需要的组件，但是对于一些特别复杂的组件，无法通过组合获得，此时就需要通过自定义的方式创造出我们想要的组件。</p><p>Flutter 中自定义组件的方式主要依赖于 <code>CustomPaint</code> 组件和自定义画笔 <code>CustomerPainter</code>。</p><h4 id="CustomPaint"><a href="#CustomPaint" class="headerlink" title="CustomPaint"></a>CustomPaint</h4><p>用于使用自定义的画笔，其构造方法如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart">CustomPaint(&#123;<br>  Key key,<br>  <span class="hljs-keyword">this</span>.painter, <br>  <span class="hljs-keyword">this</span>.foregroundPainter,<br>  <span class="hljs-keyword">this</span>.size = Size.zero, <br>  <span class="hljs-keyword">this</span>.isComplex = <span class="hljs-keyword">false</span>, <br>  <span class="hljs-keyword">this</span>.willChange = <span class="hljs-keyword">false</span>, <br>  Widget child,<br>&#125;)<br></code></pre></td></tr></table></figure><p>其中，<code>painter</code> 最先被绘制，然后是 <code>child</code>，最后是 <code>foregroudnPainter</code>。默认会以 <code>child</code> 作为可绘制区域，如果没有指定 <code>child</code> 则以 <code>size</code> 指定的大小作为可绘制区域，默认值为 <code>Size.zero</code>。<code>painter</code> 默认情况下是可以超出可绘制区域的，如果要改变这种行为，可以使用 <code>ClipRect</code> 组件包裹 <code>CustomerPaint</code> 组件。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>为了防止不必要的重绘，可以使用 <code>RepaintBoundary</code> 包裹 <code>CustomPaint</code> 组件。</p><h4 id="CustomPainter"><a href="#CustomPainter" class="headerlink" title="CustomPainter"></a>CustomPainter</h4><p>实现自定义画笔的内容。主要通过在 <code>Canvas</code> 上绘制一系列图形，通过 <code>Paint</code> 指定画笔风格。</p><p>比如画一些常见的几何图形和文字：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">canvas.drawPoints(PointMode.points, [p1, p2], paint);<br>canvas.drawLine(from, to, paint);<br>canvas.drawRect(rect, paint);<br>canvas.drawCircle(center, radius, paint);<br>canvas.drawArc(rect, startAngle, sweepAngle, userCenter, paint);<br>canvas.drawParagraph(textBuilder.build()..layout(ParagraphConstraints(width: <span class="hljs-number">100</span>)), offset);<br></code></pre></td></tr></table></figure><h4 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h4><p>画笔的使用与其它平台中类似，我们可以设置画笔风格（填充 or 描边）、描边宽度、颜色、反锯齿等。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> paint = Paint()<br>  ..color = Colors.red<br>  ..style = PaintingStyle.stroke<br>  ..isAntiAlias = <span class="hljs-keyword">true</span><br>  ..strokeWidth = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><p>Flutter 中对动画进行了抽象，主要涉及 Animation、Curve、Controller、Tween 四个部分。</p><h4 id="Animation-1"><a href="#Animation-1" class="headerlink" title="Animation"></a>Animation</h4><p><a href="https://api.flutter.dev/flutter/animation/Animation-class.html">Animation</a> 是一个抽象类，主要的功能是保存动画的<strong>插值</strong>和<strong>状态</strong>。在动画的每一帧中，我们可以通过 <code>Animation</code>对象的 <code>value</code> 属性获取动画的当前状态值，也可以在其上添加每一帧的监听器 (<em>addListener</em>) 和状态变化监听器 (<em>addStatusListener</em>)。</p><h4 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h4><p><code>AnimationController</code> 用于控制动画，它包含动画的启动 <code>forward()</code>、停止 <code>stop()</code> 、反向播放  <code>reverse()</code>、重复播放 <code>repeat()</code> 等方法。<code>AnimationController</code> 会在动画的每一帧生成一个新的值，范围默认是 [0, 1]，可以通过 <code>lowerBound</code> 和 <code>upperBound</code> 进行指定。</p><p>创建 <code>AnimationController</code> 时需要传入一个 <code>vsync</code> 参数，它接收一个 <code>TickerProvider</code> 对象，它负责创建 <code>Ticker</code>，用于在动画的每一帧提供回调。一般可以使用 mixin 类 <code>SingleTickerProviderStateMixin</code> 或者 <code>TickerProviderStateMixin</code> 来实现 <code>TickerProvider</code> 的功能。</p><h4 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h4><p>默认情况下，<code>AnimationController</code> 控制的值的范围是数字区间 [0.0, 1.0]，如果我们需要构建 UI 的动画值在不同的范围或者使用不同的数据类型，就可以通过 <code>Tween</code> 添加映射来生成不同范围或数据类型的值。</p><h4 id="Curve"><a href="#Curve" class="headerlink" title="Curve"></a>Curve</h4><p>我们通过 <code>Curve</code>（曲线）来描述动画过程，把匀速动画称为线性 (Curves.linear) 的，非匀速动画称为非线性的。</p><h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><h4 id="Widget-Element-RenderObject"><a href="#Widget-Element-RenderObject" class="headerlink" title="Widget/Element/RenderObject"></a>Widget/Element/RenderObject</h4><p>Flutter 中一切都是 Widget，但是所有 widget 最终的 layout 和渲染都是通过 <code>RenderObject</code> 来完成的，从创建到渲染大致的流程是：根据 Widget 树生成 Element 树，然后创建 <code>RenderObject</code> 并关联到 <code>Element.renderObject</code> 属性上，最后再通过 <code>RenderObject</code> 来完成布局和绘制。<a href="https://book.flutterchina.club/">^注1</a></p><p>Element 是 Widget 在 UI 树中对应的实例对象，大多数 Element 只有一个 <code>renderObject</code>，除了少部分有多个子节点。最终，所有 Element 的 <code>renderObject</code> 构成了一棵 Render Tree，即渲染树。</p><p>即在 Flutter 中主要有三棵树：Widget Tree =&gt; Element Tree =&gt; RenderObejct Tree（其实 Widget Tree 并不存在，只是我们看到的结果，只有 Element 和 RenderObject 才有上下级相互关联的关系）。</p><h5 id="RenderObejct-RenderBox"><a href="#RenderObejct-RenderBox" class="headerlink" title="RenderObejct/RenderBox"></a>RenderObejct/RenderBox</h5><p>每一个 Element 对应一个 RenderObject，它负责布局和绘制，但是它并没有定义子节点模型以及坐标系统，实际完成布局的（确定大小和位置）是通过 RenderBox。</p><h5 id="BuildContext-即-Element"><a href="#BuildContext-即-Element" class="headerlink" title="BuildContext 即 Element"></a><code>BuildContext</code> 即 Element</h5><p>创建这个接口是为了避免开发者直接操作 Element 对象。</p><h4 id="Flutter-应用是如何运行的"><a href="#Flutter-应用是如何运行的" class="headerlink" title="Flutter 应用是如何运行的"></a>Flutter 应用是如何运行的</h4><p>我们知道一个 Flutter 应用的入口是 main() 方法中的 runApp()，那么 runApp() 中主要做了哪些操作呢？</p><p>首先，通过 <code>WidgetsFlutterBinding</code> 绑定 Flutter 框架（widgets、services、gesture、painting 等）和 Flutter engine（sky_engine），<code>WidgetsFlutterBinding</code> 就像胶水一样，而绑定发生的位置是在 <code>BindingBase</code> 中的 <code>window</code>。<code>window</code> 实际是一个 <code>SingletonFlutterWindow</code> 对象，它作为应用的主窗口，继承自 <code>FlutterView</code>，并且提供了设备屏幕相关的信息以及设备设置的回调方法（比如语言、屏幕亮度等）。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">Inflate the given widget and attach it to the screen.</span></span><br><span class="hljs-keyword">void</span> runApp(Widget app) &#123;<br>  WidgetsFlutterBinding.ensureInitialized()<br>    ..scheduleAttachRootWidget(app)<br>    ..scheduleWarmUpFrame();<br>&#125;<br><br><span class="hljs-comment">/// <span class="markdown">This is the glue that binds the framework to the Flutter engine.</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetsFlutterBinding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BindingBase</span> <span class="hljs-title">with</span> <span class="hljs-title">GestureBinding</span>, <span class="hljs-title">SchedulerBinding</span>, ... </span>&#123;<br>  <span class="hljs-keyword">static</span> WidgetsBinding ensureInitialized() &#123;<br>    <span class="hljs-keyword">if</span> (WidgetsBinding.instance == <span class="hljs-keyword">null</span>)<br>      WidgetsFlutterBinding();<br>    <span class="hljs-keyword">return</span> WidgetsBinding.instance!;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/// <span class="markdown">Base class for mixins that provide singleton services (also known as &quot;bindings&quot;).</span></span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BindingBase</span> </span>&#123;<br>  ui.SingletonFlutterWindow <span class="hljs-keyword">get</span> <span class="hljs-built_in">window</span> =&gt; ui.<span class="hljs-built_in">window</span>;<br>&#125;<br><br><span class="hljs-comment">/// <span class="markdown">A [FlutterWindow] that includes access to setting callbacks and retrieving</span></span><br><span class="hljs-comment">/// <span class="markdown">properties that reside on the [PlatformDispatcher].</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonFlutterWindow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FlutterWindow</span> </span>&#123;<br>  VoidCallback? <span class="hljs-keyword">get</span> onXxxChanged =&gt; platformDispatcher.onXxxChanged;<br>  ...<br>&#125;<br><br><span class="hljs-comment">/// <span class="markdown">A top-level platform window displaying a Flutter layer tree drawn from a [Scene].</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlutterWindow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FlutterView</span> </span>&#123;<br>  ...<br>&#125;<br><br><span class="hljs-comment">/// <span class="markdown">A view into which a Flutter [Scene] is drawn.</span></span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlutterView</span> </span>&#123;<br>PlatformDispatcher <span class="hljs-keyword">get</span> platformDispatcher;<br>  ViewConfiguration <span class="hljs-keyword">get</span> viewConfiguration;<br>  <br>  <span class="hljs-built_in">double</span> <span class="hljs-keyword">get</span> devicePixelRatio =&gt; viewConfiguration.devicePixelRatio;<br>  Rect <span class="hljs-keyword">get</span> physicalGeometry =&gt; viewConfiguration.geometry;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>紧接着会调用 <code>WidgetsBinding</code> 中的 <code>attachRootWidget</code> 方法，将根 Widget 添加到 <code>renderViewElement</code> 上，这是一个 <code>RenderView</code> 对象，它作为整个 RenderObejct Tree 的根 <code>RenderObject</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> attachRootWidget(Widget rootWidget) &#123;<br>  _readyToProduceFrames = <span class="hljs-keyword">true</span>;<br>  _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(<br>    container: renderView,<br>    debugShortDescription: <span class="hljs-string">&#x27;[root]&#x27;</span>,<br>    child: rootWidget,<br>  ).attachToRenderTree(buildOwner!, renderViewElement <br>                       <span class="hljs-keyword">as</span> RenderObjectToWidgetElement&lt;RenderBox&gt;?);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>attachRootWidget</code> 之后，会继续调用 <code>scheduleWarmUpFrame</code> 方法，调用该方法之后会通知框架尽早进行一次绘制，而不是等待 flutter 引擎接收到一次 <code>Vsync</code> 信号之后（正常情况下，每次接受到一次信号会触发一次重绘，也就是一帧，此外还会调用 <code>FrameCallback</code>，Flutter 中一共有 3 种这样的帧回调）。另外，这个方法只会被调用一次，第二次调用无效。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">ScheduleBinding</span></span><br><span class="hljs-keyword">void</span> scheduleWarmUpFrame() &#123;<br>  ...<br>  Timer.run(() &#123;<br>    handleBeginFrame(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// 会执行 transientCallbacks</span><br>  &#125;);<br>  Timer.run(() &#123;<br>    handleDrawFrame(); <span class="hljs-comment">// 会执行 persistentCallbacks 和 postFrameCallbacks</span><br>    resetEpoch();<br>  &#125;);<br>  <span class="hljs-comment">// 锁定事件，在首帧绘制结束之前不会触发新的重绘，也不会响应任何事件输入</span><br>  lockEvents(() <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">await</span> endOfFrame;<br>    Timeline.finishSync();<br>  &#125;);<br> ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在创建完 <code>RenderObject</code> 以及首帧绘制任务之后，接下来真正执行渲染和绘制任务的地方是在 <code>RendererBinding</code> 中的 <code>drawFrame()</code> 方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> drawFrame() &#123;<br>  <span class="hljs-keyword">assert</span>(renderView != <span class="hljs-keyword">null</span>);<br>  pipelineOwner.flushLayout(); <span class="hljs-comment">// 布局</span><br>  pipelineOwner.flushCompositingBits(); <span class="hljs-comment">// 重绘之前的预处理操作</span><br>  pipelineOwner.flushPaint(); <span class="hljs-comment">// 重绘</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，在首帧绘制结束后，之后的绘制只有被标记为 dirty 的 Element 才会被重新绘制：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">framework.dart/BuildOwner</span></span><br><span class="hljs-keyword">void</span> buildScope(<span class="hljs-built_in">Element</span> context, [ VoidCallback? callback ]) &#123;<br><span class="hljs-built_in">int</span> dirtyCount = _dirtyElements.length;<br>  <span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (index &lt; dirtyCount) &#123;<br>    _dirtyElements[index].rebuild(); <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="State-Management"><a href="#State-Management" class="headerlink" title="State Management"></a>State Management</h2><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a><a href="https://github.com/rrousselGit/provider">Provider</a></h3><p>Provider 是基于 <a href="https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html">InheritedWidget</a> 的状态管理工具，它的优点是便于理解且使用简单，主要由三个部分组成：</p><ul><li>ChangeNotifier: 提供数据，更新数据并发送通知</li><li>ChangeNotifierProvider: 连接数据和组件</li><li>Consumer: 消费事件，监听数据变化</li></ul><h4 id="ChangeNotifier"><a href="#ChangeNotifier" class="headerlink" title="ChangeNotifier"></a>ChangeNotifier</h4><p>ChangeNotifier 封装了应用状态，使用观察者-被观察者模式，会通知注册处发生的变化。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChangeNotifier</span> </span>&#123;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;Item&gt; _items = [];<br><br>  <span class="hljs-keyword">void</span> add(Item item) &#123;<br>    _items.add(item);<br>    <br>    <span class="hljs-comment">// This call tells the widgets that are listening to this model to rebuild.</span><br>    notifyListeners();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ChangeNotifierProvider"><a href="#ChangeNotifierProvider" class="headerlink" title="ChangeNotifierProvider"></a>ChangeNotifierProvider</h4><p>ChangeNotifierProvider 用于给子组件提供一个 ChangeNotifier 实例。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart">ChangeNotifierProvider(<br>  create: (context) =&gt; CartModel(),<br>  child: MyApp(),<br>)<br><br><span class="hljs-comment">// 如果有多个 ChangeNotifier 则需要使用 MultiProvider</span><br>MultiProvider(<br>  providers: [<br>    Provider(create: (context) =&gt; SomeClass()),<br>    ChangeNotifierProvider(create: (context) =&gt; SomeModel()),<br>    ChangeNotifierProxyProvider&lt;DataProvider, SomeOtherModel&gt;(<br>      create: (context) =&gt; SomeOtherModel(),<br>      update: (context, newData, previousModel) =&gt; <br>          previousModel.updateModel(newData);<br>    ),<br>  ],<br>  child: MyApp(),<br>)<br></code></pre></td></tr></table></figure><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>我们通过 Consumer 组件来消费 ChangeNotifier 产生的事件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">return</span> Consumer&lt;CartModel&gt;(<br>  builder: (context, cart, child) &#123;<br>    <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&quot;Total price: <span class="hljs-subst">$&#123;cart.totalPrice&#125;</span>&quot;</span>);<br>  &#125;,<br>);<br></code></pre></td></tr></table></figure><p>Consumer 的 build 函数一共接收三个参数，第一个参数是 context，第二个参数是 ChangeNotifier 对象，也就是我们需要监听的目标对象，第三个是 child，它的作用是优化性能，比如当一个组件不是每次状态发生更新时都要更新 UI 时，此时就可以根据状态来决定是否需要重新创建。其次，最好的做法是将 Consumer 组件放在组件树底部，这样可以尽可能减少因状态发生变化而需要的组件更新。</p><p>另外，我们也可以使用 <code>Provider</code> 提供的扩展方法 <code>context.watch&lt;T&gt;()</code> 来获得 ChangeNotifier 并触发 rebuild，不过，该方法只能在 build 方法中使用。</p><h4 id="Provider-of-lt-T-gt"><a href="#Provider-of-lt-T-gt" class="headerlink" title="Provider.of&lt;T&gt;()"></a>Provider.of&lt;T&gt;()</h4><p>当你只需要访问 ChangeNotifier 中的方法或者属性而不需要更新 UI 时，可以使用 <code>Provider.of</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">Provider.of&lt;CartModel&gt;(context, listen: <span class="hljs-keyword">false</span>).removeAll();<br></code></pre></td></tr></table></figure><p>通过这种方式可以访问到 <code>CartModel</code> 中的方法，但是在数据发生变化时不会收到通知。</p><p>另外，也可以使用 <code>context.read&lt;T&gt;()</code>，它也能获取到 ChangeNotifier，不过只能在 build 方法之外才能被调用（比如在 onPressed 方法中），所以也不会触发 rebuild，而使用 <code>Provider.of&lt;T&gt;(context, listen: false)</code> 则没有这样的限制。</p><h4 id="select-lt-T-R-gt-R-Function-T-value-selector"><a href="#select-lt-T-R-gt-R-Function-T-value-selector" class="headerlink" title="select&lt;T, R&gt;(R Function(T value) selector)"></a>select&lt;T, R&gt;(R Function(T value) selector)</h4><p>当我们只需要监听 ChangeNotifier 中部分发生变化的内容时，就可以使用 select 方法。与 watch 方法类似，select 只有在 build 方法中才能被使用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> isInCart = context.select&lt;CartModel, <span class="hljs-built_in">bool</span>&gt;(<br>  (cart) =&gt; cart.items.contains(item),<br>);<br></code></pre></td></tr></table></figure><h4 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h4><p>使用 Provider 实现一个 Counter 的例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(CounterWithProvider());<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterWithProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ChangeNotifierProvider(<br>      create: (_) =&gt; Counter(),<br>      <span class="hljs-comment">// 不能直接使用 CounterWithProvider 的 context</span><br>      <span class="hljs-comment">// 因为它的 `BuildContext` 没有 Provider</span><br>      builder: (context, child) =&gt; MaterialApp(<br>        home: Scaffold(<br>            floatingActionButton: FloatingActionButton(<br>              onPressed: () &#123;<br>                <span class="hljs-comment">// 使用 builder 的 context 才是安全的</span><br>                <span class="hljs-keyword">var</span> counter = context.read&lt;Counter&gt;();<br>                <span class="hljs-comment">// 或者使用 Provider.of&lt;T&gt;</span><br>                <span class="hljs-comment">// var counter = Provider.of&lt;Counter&gt;(context, listen: false);</span><br>                counter.add();<br>              &#125;,<br>              tooltip: <span class="hljs-string">&#x27;Add&#x27;</span>,<br>              child: Icon(Icons.add),<br>            ),<br>            appBar: AppBar(<br>              title: Text(<span class="hljs-string">&#x27;Counter App&#x27;</span>),<br>            ),<br>            body: Container(<br>              child: Center(<br>                child: Consumer&lt;Counter&gt;(<br>                  builder: (_, counter, child) =&gt;<br>                      Text(<span class="hljs-string">&#x27;You\&#x27;ve clicked <span class="hljs-subst">$&#123;counter.count&#125;</span> times&#x27;</span>),<br>                ),<br>              ),<br>            )),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChangeNotifier</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">void</span> add() &#123;<br>    count++;<br>    notifyListeners();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Others-1"><a href="#Others-1" class="headerlink" title="Others"></a>Others</h2><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a><a href="https://flutter.dev/docs/testing/debugging">调试</a></h3><p>Flutter 提供了丰富的调试工具，比如 <a href="https://flutter.dev/docs/development/tools/devtools/inspector">Flutter Inspector</a>, Flutter Outline, <a href="https://flutter.dev/docs/development/tools/devtools/performance">Flutter Performance</a> 等。</p><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a><a href="https://book.flutterchina.club/chapter2/thread_model_and_error_report.html">异常捕获</a></h3><p>Flutter 中，发生异常时不会导致程序退出，只会导致当前任务的后续代码不再继续执行，也就是说一个任务中的异常是不会影响其它任务的执行的。下面是在 Flutter 中捕获异常的简单演示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">// 提供一个自定义的错误处理回调</span><br>  FlutterError.onError = (FlutterErrorDetails details) &#123;<br>    reportErrorAndLog(details); <span class="hljs-comment">// 上报错误和日志</span><br>  &#125;;<br><br>  <span class="hljs-comment">// 在指定配置的环境下运行项目</span><br>  runZonedGuarded(<br>    () =&gt; runApp(ErrorReportApp()),<br>    <span class="hljs-comment">// Zone 中未捕获到的异常处理回调</span><br>    (<span class="hljs-built_in">Object</span> obj, StackTrace stack) &#123;<br>      <span class="hljs-keyword">var</span> details = makeDetails(obj, stack);<br>      reportErrorAndLog(details);<br>    &#125;,<br>    zoneSpecification: ZoneSpecification(<br>      <span class="hljs-built_in">print</span>: (Zone self, ZoneDelegate parent, Zone zone, <span class="hljs-built_in">String</span> line) &#123;<br>        collectLog(line); <span class="hljs-comment">// 收集日志</span><br>      &#125;,<br>    ),<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的异常上报的例子见：<a href="https://flutter.dev/docs/cookbook/maintenance/error-reporting">Report errors to a service</a></p><h3 id="平台相关"><a href="#平台相关" class="headerlink" title="平台相关"></a>平台相关</h3><h4 id="Platform-Channel"><a href="#Platform-Channel" class="headerlink" title="Platform Channel"></a>Platform Channel</h4><p>当我们需要执行平台相关的代码时，就需要借助于 <a href="https://docs.flutter.dev/development/platform-integration/platform-channels">platform channels</a>。工作流程如下：</p><p>首先需要在项目中创建 <a href="https://api.flutter.dev/flutter/services/MethodChannel-class.html">MethodChannel</a>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> MethodChannel methodChannel = MethodChannel(<span class="hljs-string">&#x27;method_channel_name&#x27;</span>);<br></code></pre></td></tr></table></figure><p>接下来，在目标平台创建对应的 MethodChannel，并且对方法调用进行处理。以安卓平台为例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">methodChannel = MethodChannel(flutterPluginBinding.binaryMessenger, <span class="hljs-string">&quot;method_channel_name&quot;</span>)<br>methodChannel.setMethodCallHandler &#123; call, result -&gt;<br>    <span class="hljs-keyword">when</span> (call.method) &#123;<br>        <span class="hljs-string">&quot;someMethodCall&quot;</span> -&gt; &#123;<br>            result.success(<span class="hljs-literal">null</span>)<br>        &#125;<br>        <span class="hljs-keyword">else</span> -&gt; &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如我们需要监听方法调用结果，则需要通过 EventChannel 和 EventSink，前者用于注册事件监听，后者用于发送事件。</p><p>同样的，我们需要先在 dart 部分创建 EventChannel：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> EventChannel eventChannel = EventChannel(<span class="hljs-string">&#x27;event_channel_name&#x27;</span>);<br></code></pre></td></tr></table></figure><p> 然后在平台部分创建 EventChannel 并对事件流进行监听并处理，以安卓为例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> eventChannel: EventChannel<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> eventSink: EventSink? = <span class="hljs-literal">null</span><br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAttachedToEngine</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> flutterPluginBinding: <span class="hljs-type">FlutterPluginBinding</span>)</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    eventChannel = EventChannel(flutterPluginBinding.binaryMessenger, <br>                                <span class="hljs-string">&quot;flutter_nimplayer_event&quot;</span>)<br>    eventChannel.setStreamHandler(<span class="hljs-keyword">object</span> : StreamHandler &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onListen</span><span class="hljs-params">(arguments: <span class="hljs-type">Any</span>?, eventSink: <span class="hljs-type">EventSink</span>?)</span></span> &#123;<br>            <span class="hljs-keyword">this</span>.eventSink = eventSink<br>        &#125;<br>    <br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCancel</span><span class="hljs-params">(arguments: <span class="hljs-type">Any</span>?)</span></span> &#123;<br>        &#125;<br>    &#125;)<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>向 dart 端传递事件调用结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">eventSink?.success(<span class="hljs-keyword">data</span>)<br></code></pre></td></tr></table></figure><h4 id="安卓插件安装流程"><a href="#安卓插件安装流程" class="headerlink" title="安卓插件安装流程"></a>安卓插件安装流程</h4><p>安卓项目下的 <code>app/build.gradle</code> 中有一行：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">from:</span> <span class="hljs-string">&quot;$flutterRoot/packages/flutter_tools/gradle/flutter.gradle&quot;</span><br></code></pre></td></tr></table></figure><p>该文件的位置在：<code>$FLUTTER_HOME/packages/flutter_tools/gradle/flutter.gradle</code>，其中添加项目中的依赖的方法调用路径是：<code>apply() -&gt; addFlutterTasks() -&gt; configurePlugins() -&gt; getPluginList() -&gt; configurePluginProject() &#123; api pluginProject &#125;</code>。</p><p>关键的一步是在 <code>getPluginList()</code> 中，通过读取项目根目录下生成的 <code>.flutter-plugins</code> 文件获取插件列表，然后把它们添加到 android 项目中。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Dart 学习笔记</title>
      <link href="/effective-dart-notes/"/>
      <url>/effective-dart-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2021-05-15/cover.png" alt="cover"></p><blockquote><p>阅读 <a href="https://dart.dev/guides/language/effective-dart">Effective Dart</a> 时做的一些笔记。</p></blockquote><h2 id="Style-Guide"><a href="#Style-Guide" class="headerlink" title="Style Guide"></a>Style Guide</h2><p>好代码一定是遵循良好代码风格的代码。前后一致的命名、排序和格式化使得代码具有更高的可读性。在整个 Dart 生态中维持一个规范统一的代码风格，可以使得程序员之间分享彼此的代码时，更容易阅读和互相学习。</p><h3 id="Identifiers"><a href="#Identifiers" class="headerlink" title="Identifiers"></a>Identifiers</h3><p>Dart 中标识符有三种类型：</p><ul><li>UpperCamelCase：大驼峰命名法，每个单词首字母大写。</li><li>lowerCamelCase：小驼峰命名法，除了首个单词，其余每个单词首字母大写。</li><li>lowercase_with_underscores：带下划线的小写命名法，每个单词小写，用下划线分割单词。</li></ul><span id="more"></span><h4 id="DO-name-types-using-UpperCamelCase"><a href="#DO-name-types-using-UpperCamelCase" class="headerlink" title="DO name types using UpperCamelCase."></a>DO name types using <code>UpperCamelCase</code>.</h4><p>类名，枚举类，<code>typedef</code>，注解等的命名都应该采用大驼峰命名法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SliderMenu</span> </span>&#123; ... &#125;<br><br><span class="hljs-keyword">enum</span> Status &#123; ... &#125;<br><br><span class="hljs-keyword">typedef</span> Predicate&lt;T&gt; = <span class="hljs-built_in">bool</span> <span class="hljs-built_in">Function</span>(T value);<br><br><span class="hljs-meta">@Foo</span>(anArg)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; ... &#125;<br><br>#### DO name extensions using `UpperCamelCase`.<br><br>和类型命名一样，扩展方法也应该使用大驼峰命名法。<br><br>​```dart<br><span class="hljs-keyword">extension</span> MyFancyList&lt;T&gt; <span class="hljs-keyword">on</span> <span class="hljs-built_in">List</span>&lt;T&gt; &#123; ... &#125;<br></code></pre></td></tr></table></figure><h4 id="DO-name-libraries-packages-directories-and-source-files-using-lowercase-with-underscores"><a href="#DO-name-libraries-packages-directories-and-source-files-using-lowercase-with-underscores" class="headerlink" title="DO name libraries, packages, directories, and source files using lowercase_with_underscores."></a>DO name libraries, packages, directories, and source files using <code>lowercase_with_underscores</code>.</h4><p>库名，包名，文件和文件夹名，都应该使用小写+下划分隔符命名。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">library</span> my_library;<br><br><span class="hljs-keyword">export</span> <span class="hljs-string">&#x27;global_constants.dart&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-string">&#x27;src/common_util/screen_util.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="DO-name-import-prefixes-using-lowercase-with-underscores"><a href="#DO-name-import-prefixes-using-lowercase-with-underscores" class="headerlink" title="DO name import prefixes using lowercase_with_underscores."></a>DO name import prefixes using <code>lowercase_with_underscores</code>.</h4><p>导入包名使用别名时，用小写+下划分隔符。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:angular_components/angular_components&#x27;</span> <span class="hljs-keyword">as</span> angular_components;<br></code></pre></td></tr></table></figure><h4 id="DO-name-other-identifiers-using-lowerCamelCase"><a href="#DO-name-other-identifiers-using-lowerCamelCase" class="headerlink" title="DO name other identifiers using lowerCamelCase."></a>DO name other identifiers using <code>lowerCamelCase</code>.</h4><p>顶层方法，变量，类的成员，变量，参数等，都应该使用小驼峰命名法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> httpRequest;<br><br><span class="hljs-keyword">void</span> alignItems(<span class="hljs-built_in">bool</span> clearItems) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="PREFER-using-lowerCamelCase-for-constant-names"><a href="#PREFER-using-lowerCamelCase-for-constant-names" class="headerlink" title="PREFER using lowerCamelCase for constant names."></a>PREFER using <code>lowerCamelCase</code> for constant names.</h4><p>推荐使用小驼峰命名常量、枚举类。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> defaultTimeout = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">final</span> urlScheme = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;^([a-z]+):&#x27;</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dice</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> numberGenerator = Random();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DO-capitalize-acronyms-and-abbreviations-longer-than-two-letters-like-words"><a href="#DO-capitalize-acronyms-and-abbreviations-longer-than-two-letters-like-words" class="headerlink" title="DO capitalize acronyms and abbreviations longer than two letters like words."></a>DO capitalize acronyms and abbreviations longer than two letters like words.</h4><p>大于两个字符的缩写均当做普通单词使用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpConnection</span> </span>&#123;&#125; <span class="hljs-comment">// bad: HTTPConnection</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DBIOPort</span> </span>&#123;&#125; <span class="hljs-comment">// bad: DbIoPort</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TVVcr</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MrRogers</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">var</span> httpRequest = ...<br><span class="hljs-keyword">var</span> uiHandler = ...<br>Id id;<br></code></pre></td></tr></table></figure><h4 id="PREFER-using-etc-for-unused-callback-parameters"><a href="#PREFER-using-etc-for-unused-callback-parameters" class="headerlink" title="PREFER using _, __, etc. for unused callback parameters."></a>PREFER using <code>_</code>, <code>__</code>, etc. for unused callback parameters.</h4><p>推荐使用 <code>_</code> 命名未使用的回调参数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">futureOfVoid.then((_, __, ___) &#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Operation complete.&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="DON’T-use-a-leading-underscore-for-identifiers-that-aren’t-private"><a href="#DON’T-use-a-leading-underscore-for-identifiers-that-aren’t-private" class="headerlink" title="DON’T use a leading underscore for identifiers that aren’t private."></a>DON’T use a leading underscore for identifiers that aren’t private.</h4><p>不要使用下划线作为标识符的起始字符，只有私有变量和私有函数才可以使用下划线开头。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> _notVisible;<br><br>_initContentForCaseA() &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DON’T-use-prefix-letters"><a href="#DON’T-use-prefix-letters" class="headerlink" title="DON’T use prefix letters."></a>DON’T use prefix letters.</h4><p>不要使用前缀字符。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> defaultTimeout; <span class="hljs-comment">// bad: kDefaultTimeout</span><br></code></pre></td></tr></table></figure><h3 id="Ordering"><a href="#Ordering" class="headerlink" title="Ordering"></a>Ordering</h3><p>为了保持一个 Dart 文件的整洁性，我们应该保证每段代码都按照特定的顺序排列，并且每个区域都被空白行分割。</p><h4 id="DO-place-“dart-”-imports-before-other-imports"><a href="#DO-place-“dart-”-imports-before-other-imports" class="headerlink" title="DO place “dart:” imports before other imports."></a>DO place “dart:” imports before other imports.</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:async&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:html&#x27;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:bar/bar.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:foo/foo.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="DO-place-“package-”-imports-before-relative-imports"><a href="#DO-place-“package-”-imports-before-relative-imports" class="headerlink" title="DO place “package:” imports before relative imports."></a>DO place “package:” imports before relative imports.</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:bar/bar.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:foo/foo.dart&#x27;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;util.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="DO-specify-exports-in-a-separate-section-after-all-imports"><a href="#DO-specify-exports-in-a-separate-section-after-all-imports" class="headerlink" title="DO specify exports in a separate section after all imports."></a>DO specify exports in a separate section after all imports.</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;src/error.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;src/foo_bar.dart&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-string">&#x27;src/error.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="DO-sort-sections-alphabetically"><a href="#DO-sort-sections-alphabetically" class="headerlink" title="DO sort sections alphabetically."></a>DO sort sections alphabetically.</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:bar/bar.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:foo/foo.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:gold/gold.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="Formatting"><a href="#Formatting" class="headerlink" title="Formatting"></a>Formatting</h3><p>为了使得代码具有良好的可读性，我们需要格式化 Dart 代码。</p><h4 id="DO-format-your-code-using-dart-format"><a href="#DO-format-your-code-using-dart-format" class="headerlink" title="DO format your code using dart format."></a>DO format your code using <code>dart format</code>.</h4><p>Dart 为我们提供了 <a href="https://dart.dev/tools/dart-format">dart format</a> 工具格式化代码，具体见相关<a href="https://github.com/dart-lang/dart_style/wiki/Formatting-Rules">文档</a>。</p><h4 id="CONSIDER-changing-your-code-to-make-it-more-formatter-friendly"><a href="#CONSIDER-changing-your-code-to-make-it-more-formatter-friendly" class="headerlink" title="CONSIDER changing your code to make it more formatter-friendly."></a>CONSIDER changing your code to make it more formatter-friendly.</h4><p>在某些场景下，格式化可能会失效，比如很长的标识符、嵌套很深的表达式、多种操作符的混合使用等，我们应该考虑修改代码使得代码更加容易被格式化。</p><h4 id="AVOID-lines-longer-than-80-characters"><a href="#AVOID-lines-longer-than-80-characters" class="headerlink" title="AVOID lines longer than 80 characters."></a>AVOID lines longer than 80 characters.</h4><p>单行代码越长越难读，考虑换行，或者将一些特别长的标识符简写。</p><h4 id="DO-use-curly-braces-for-all-flow-control-statements"><a href="#DO-use-curly-braces-for-all-flow-control-statements" class="headerlink" title="DO use curly braces for all flow control statements."></a>DO use curly braces for all flow control statements.</h4><p>哪怕只有流程语句中只有一个表达式也应该使用花括号。</p><h2 id="Documentation-Guide"><a href="#Documentation-Guide" class="headerlink" title="Documentation Guide"></a>Documentation Guide</h2><p>良好的文档和注释可以使得阅读你的代码的人（包括未来的你）更容易理解你的代码。简洁、精确的注释可以节约一个人大量的时间和精力去理解看懂一段代码所需要的上下文。虽然好的代码是自解释的，但是大多数时候我们都应该写更多的注释而不是更少的注释。</p><h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><h4 id="DO-format-comments-like-sentences"><a href="#DO-format-comments-like-sentences" class="headerlink" title="DO format comments like sentences."></a>DO format comments like sentences.</h4><p>应该像写普通的句子一样写注释，注释尽量使用英文，首字符前加空格，首字母大写，每一句都应该使用标点。如果使用中文，则应该在中英文之间使用空格分割。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// Not if there is nothing before it.</span><br><span class="hljs-keyword">if</span> (_chunks.isEmpty) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 尽量减少使用中文注释，即使使用也要 use space 分割中英文字符。</span><br><span class="hljs-keyword">if</span> (_chunks.specialCases) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br></code></pre></td></tr></table></figure><h4 id="DON’T-use-block-comments-for-documentation"><a href="#DON’T-use-block-comments-for-documentation" class="headerlink" title="DON’T use block comments for documentation."></a>DON’T use block comments for documentation.</h4><p>Dart 中不推荐使用块注释。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">greet(name) &#123;<br>  <span class="hljs-comment">// Assume we have a valid name.</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hi, <span class="hljs-subst">$name</span>!&#x27;</span>);<br>  <span class="hljs-comment">// bad:</span><br>  <span class="hljs-comment">/* Assume we have a valid name. */</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hi, <span class="hljs-subst">$name</span>!&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Doc-comments"><a href="#Doc-comments" class="headerlink" title="Doc comments"></a>Doc comments</h3><p>文档注释 <code>///</code> 可以用于方便地生成文档页，主要通过 <a href="https://github.com/dart-lang/dartdoc">dartdoc</a> 生成。</p><h4 id="DO-use-doc-comments-to-document-members-and-types"><a href="#DO-use-doc-comments-to-document-members-and-types" class="headerlink" title="DO use /// doc comments to document members and types."></a>DO use <code>///</code> doc comments to document members and types.</h4><p>对于类和成员变量变量，使用 <code>///</code> 注释，这样 dartdoc 才能找到它们并解析成文档。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">The number of characters in this chunk when unsplit.</span></span><br><span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> length =&gt; ...<br></code></pre></td></tr></table></figure><h4 id="PREFER-writing-doc-comments-for-public-APIs"><a href="#PREFER-writing-doc-comments-for-public-APIs" class="headerlink" title="PREFER writing doc comments for public APIs."></a>PREFER writing doc comments for public APIs.</h4><p>不用给每个类，成员变量写注释，但是至少关键部分应该写文档注释。</p><h4 id="CONSIDER-writing-a-library-level-doc-comment"><a href="#CONSIDER-writing-a-library-level-doc-comment" class="headerlink" title="CONSIDER writing a library-level doc comment."></a>CONSIDER writing a library-level doc comment.</h4><p>最好在 Dart library 的入口提供文档注释，比如 library 的主要功能、术语解释、样本代码、常用类和方法的链接、外部引用资源等。</p><h4 id="CONSIDER-writing-doc-comments-for-private-APIs"><a href="#CONSIDER-writing-doc-comments-for-private-APIs" class="headerlink" title="CONSIDER writing doc comments for private APIs."></a>CONSIDER writing doc comments for private APIs.</h4><p>一些重要的私有方法也应该提供文档注释，方便库的使用者理解你的代码。</p><h4 id="DO-start-doc-comments-with-a-single-sentence-summary"><a href="#DO-start-doc-comments-with-a-single-sentence-summary" class="headerlink" title="DO start doc comments with a single-sentence summary."></a>DO start doc comments with a single-sentence summary.</h4><p>每个文档注释的开头应该使用简单、准确的一句话作为总结概括。</p><h4 id="DO-separate-the-first-sentence-of-a-doc-comment-into-its-own-paragraph"><a href="#DO-separate-the-first-sentence-of-a-doc-comment-into-its-own-paragraph" class="headerlink" title="DO separate the first sentence of a doc comment into its own paragraph."></a>DO separate the first sentence of a doc comment into its own paragraph.</h4><p>第一句总结之后使用空白行分割，可以使得文档注释更易读。</p><h4 id="AVOID-redundancy-with-the-surrounding-context"><a href="#AVOID-redundancy-with-the-surrounding-context" class="headerlink" title="AVOID redundancy with the surrounding context."></a>AVOID redundancy with the surrounding context.</h4><p>为类的成员和方法写注释时，避免写得太过啰嗦，因为读者对类的基本用途和上下文已经有了解了。</p><h4 id="PREFER-starting-function-or-method-comments-with-third-person-verbs"><a href="#PREFER-starting-function-or-method-comments-with-third-person-verbs" class="headerlink" title="PREFER starting function or method comments with third-person verbs."></a>PREFER starting function or method comments with third-person verbs.</h4><p>使用第三人称动词作为方法注释的开头，因为方法一般都是执行一项任务，这样可以让读者更快了解方法的用途。</p><h4 id="PREFER-starting-variable-getter-or-setter-comments-with-noun-phrases"><a href="#PREFER-starting-variable-getter-or-setter-comments-with-noun-phrases" class="headerlink" title="PREFER starting variable, getter, or setter comments with noun phrases."></a>PREFER starting variable, getter, or setter comments with noun phrases.</h4><p>使用名词作为变量注释的开头，因为变量一般代表一条数据。</p><h4 id="PREFER-starting-library-or-type-comments-with-noun-phrases"><a href="#PREFER-starting-library-or-type-comments-with-noun-phrases" class="headerlink" title="PREFER starting library or type comments with noun phrases."></a>PREFER starting library or type comments with noun phrases.</h4><p>使用名词作为库和类型注释的开头，同样库和类型是一种对象火种功能的抽象。</p><h4 id="CONSIDER-including-code-samples-in-doc-comments"><a href="#CONSIDER-including-code-samples-in-doc-comments" class="headerlink" title="CONSIDER including code samples in doc comments."></a>CONSIDER including code samples in doc comments.</h4><p>复杂的代码中如果包含示例代码有助于读者理解你的代码。</p><h4 id="DO-use-square-brackets-in-doc-comments-to-refer-to-in-scope-identifiers"><a href="#DO-use-square-brackets-in-doc-comments-to-refer-to-in-scope-identifiers" class="headerlink" title="DO use square brackets in doc comments to refer to in-scope identifiers."></a>DO use square brackets in doc comments to refer to in-scope identifiers.</h4><p>文档注释中使用中括号引用当前上下文中代码的链接。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">Throws a [StateError] if ...</span></span><br><span class="hljs-comment">/// <span class="markdown">similar to [anotherMethod()], but ...</span></span><br><span class="hljs-comment">/// <span class="markdown">Similar to [Duration.inDays], but handles fractional days.</span></span><br><span class="hljs-comment">/// <span class="markdown">To create a point from polar coordinates, use [Point.polar()].</span></span><br></code></pre></td></tr></table></figure><h4 id="DO-use-prose-to-explain-parameters-return-values-and-exceptions"><a href="#DO-use-prose-to-explain-parameters-return-values-and-exceptions" class="headerlink" title="DO use prose to explain parameters, return values, and exceptions."></a>DO use prose to explain parameters, return values, and exceptions.</h4><p>Java 中一般使用 <code>@param</code>, <code>@returns</code>, <code>@throws</code> 等注解来注释参数和返回值等，在 Dart 中不要这么做，推荐使用直白文字的叙述方法的功能，参数以及特殊的地方。</p><h4 id="DO-put-doc-comments-before-metadata-annotations"><a href="#DO-put-doc-comments-before-metadata-annotations" class="headerlink" title="DO put doc comments before metadata annotations."></a>DO put doc comments before metadata annotations.</h4><p>文档注释应该在注解之前。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">A button that can be flipped on and off.</span></span><br><span class="hljs-meta">@Component</span>(selector: <span class="hljs-string">&#x27;toggle&#x27;</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToggleComponent</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><p>Dart 中支持大多数常见的 <a href="https://daringfireball.net/projects/markdown/">markdown</a> 语法。</p><h4 id="AVOID-using-markdown-excessively"><a href="#AVOID-using-markdown-excessively" class="headerlink" title="AVOID using markdown excessively."></a>AVOID using markdown excessively.</h4><p>When in doubt, format less. Formatting exists to illuminate your content, not replace it. Words are what matter. (说得太经典了，拿小本本记下来(๑•͈ᴗ•͈))</p><h4 id="AVOID-using-HTML-for-formatting"><a href="#AVOID-using-HTML-for-formatting" class="headerlink" title="AVOID using HTML for formatting."></a>AVOID using HTML for formatting.</h4><p>大多数情况下，应该只使用 markdown 语法就够了。</p><h4 id="PREFER-backtick-fences-for-code-blocks"><a href="#PREFER-backtick-fences-for-code-blocks" class="headerlink" title="PREFER backtick fences for code blocks."></a>PREFER backtick fences for code blocks.</h4><p>我们可以使用 <code>inline code</code> 或者 code blocks，如果是小段的代码可以使用前者，如果是大段的代码块，推荐使用后者。</p><h3 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h3><p>作为程序员，虽然我们每天主要和计算机打交道，但是我们写得绝大多数代码都是给人读的，写代码需要练习，写作也同样需要练习。</p><p>这里介绍一些写作技巧，更多关于技术写作的技巧，推荐阅读：<a href="https://en.wikiversity.org/wiki/Technical_writing_style">Technical writing style</a>.</p><h4 id="PREFER-brevity"><a href="#PREFER-brevity" class="headerlink" title="PREFER brevity."></a>PREFER brevity.</h4><p>保证你的文字是清晰和精准的，同时保持简洁。</p><h4 id="AVOID-abbreviations-and-acronyms-unless-they-are-obvious"><a href="#AVOID-abbreviations-and-acronyms-unless-they-are-obvious" class="headerlink" title="AVOID abbreviations and acronyms unless they are obvious."></a>AVOID abbreviations and acronyms unless they are obvious.</h4><p>尽可能少使用缩写，除非是那种人人都知道的，比如 “i.e.”, “e.g.”, “etc”。</p><h4 id="PREFER-using-“this”-instead-of-“the”-to-refer-to-a-member’s-instance"><a href="#PREFER-using-“this”-instead-of-“the”-to-refer-to-a-member’s-instance" class="headerlink" title="PREFER using “this” instead of “the” to refer to a member’s instance."></a>PREFER using “this” instead of “the” to refer to a member’s instance.</h4><p>当需要代指当前类的实例是时候，使用 this 代替 the。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span> </span>&#123;<br>  <span class="hljs-comment">/// <span class="markdown">True if this box contains a value.</span></span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> hasValue =&gt; _value != <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Usage-Guide"><a href="#Usage-Guide" class="headerlink" title="Usage Guide"></a>Usage Guide</h2><h3 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h3><h4 id="DO-use-strings-in-part-of-directives"><a href="#DO-use-strings-in-part-of-directives" class="headerlink" title="DO use strings in part of directives."></a>DO use strings in <code>part of</code> directives.</h4><p>在 Dart 中，我们可以使用 <code>part of</code> 将代码分离到另一个文件中，然后使用 <code>part</code> 引用这部分分离出去的代码，推荐的做法是，直接使用 URI 链接到指定的文件，而不是只指定库的名字。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">part</span> of <span class="hljs-string">&#x27;../../my_library.dart&#x27;</span>;<br><br><span class="hljs-comment">// bad:</span><br><span class="hljs-keyword">part</span> of my_library;<br></code></pre></td></tr></table></figure><h4 id="DON’T-import-libraries-that-are-inside-the-src-directory-of-another-package"><a href="#DON’T-import-libraries-that-are-inside-the-src-directory-of-another-package" class="headerlink" title="DON’T import libraries that are inside the src directory of another package."></a>DON’T import libraries that are inside the <code>src</code> directory of another package.</h4><p>我们应该直接导入库，而不是导入库中的某个文件或者目录，因为库作者可能对目录结构做修改。</p><h4 id="DON’T-allow-an-import-path-to-reach-into-or-out-of-lib"><a href="#DON’T-allow-an-import-path-to-reach-into-or-out-of-lib" class="headerlink" title="DON’T allow an import path to reach into or out of lib."></a>DON’T allow an import path to reach into or out of <code>lib</code>.</h4><p>比如使用相对路径引用 lib 之外的某个文件，或者 lib 之外的某个文件（比如 test 文件夹）导入 lib 内的文件，这两种情况都应该避免，应该只使用包导入的方式导入依赖。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:my_package/api.dart&#x27;</span>;<br><br><span class="hljs-comment">// bad:</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../lib/api.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="PREFER-relative-import-paths"><a href="#PREFER-relative-import-paths" class="headerlink" title="PREFER relative import paths."></a>PREFER relative import paths.</h4><p>如果无法使用包导入，才使用相对路径的方式导入。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">test/api_test.dart:<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;test_utils.dart&#x27;</span>; <span class="hljs-comment">// 在当前同一个目录结构下，可以使用相对路径</span><br></code></pre></td></tr></table></figure><h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><h4 id="DON’T-explicitly-initialize-variables-to-null"><a href="#DON’T-explicitly-initialize-variables-to-null" class="headerlink" title="DON’T explicitly initialize variables to null."></a>DON’T explicitly initialize variables to <code>null</code>.</h4><p>Dart 会自动为可为空的变量赋值为 null，而不可为空的变量在初始化之前被使用的话会报错。所以没必要为变量赋空值。</p><h4 id="DON’T-use-an-explicit-default-value-of-null"><a href="#DON’T-use-an-explicit-default-value-of-null" class="headerlink" title="DON’T use an explicit default value of null."></a>DON’T use an explicit default value of <code>null</code>.</h4><p>与上一条类似，如果你为一个可选位置参数的值可为空，那么 Dart 会为它自动赋值为空值，没必要手动赋值为空。</p><h4 id="PREFER-using-to-convert-null-to-a-boolean-value"><a href="#PREFER-using-to-convert-null-to-a-boolean-value" class="headerlink" title="PREFER using ?? to convert null to a boolean value."></a>PREFER using <code>??</code> to convert <code>null</code> to a boolean value.</h4><p>使用 <code>??</code> 将空值转换为布尔值，好处更简洁易懂。看例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// If you want null to be false:</span><br><span class="hljs-keyword">if</span> (optionalThing?.isEnabled ?? <span class="hljs-keyword">false</span>) &#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Have enabled thing.&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// If you want null to be true:</span><br><span class="hljs-keyword">if</span> (optionalThing?.isEnabled ?? <span class="hljs-keyword">true</span>) &#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Have enabled thing or nothing.&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 第二种情况等同于下面这种写法，所以使用 ?? 明显可以简化写法</span><br><span class="hljs-keyword">if</span> (optionalThing?.isEnabled == <span class="hljs-keyword">null</span> || optionalThing!.isEnabled!) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Have enabled thing or nothing.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AVOID-late-variables-if-you-need-to-check-whether-they-are-initialized"><a href="#AVOID-late-variables-if-you-need-to-check-whether-they-are-initialized" class="headerlink" title="AVOID late variables if you need to check whether they are initialized."></a>AVOID <code>late</code> variables if you need to check whether they are initialized.</h4><p>使用 <code>late</code> 关键字可以让我们延迟初始化某些变量，但是这样我们就没法判断某个变量是否初始化了，当需要做这样的判断时候，最好的做法是不要使用 <code>late</code> 关键字，而是使用 nullable 变量。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 使用 late 关键字</span><br><span class="hljs-keyword">late</span> <span class="hljs-built_in">Type</span> a;<br><span class="hljs-built_in">bool</span> initialized = <span class="hljs-keyword">false</span>;<br><br>initialize() &#123;<br>  a = <span class="hljs-built_in">Type</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br>  initialized = <span class="hljs-keyword">true</span>;<br>&#125;<br><br>doSomeWorkEnsureInitialized() &#123;<br>  <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!initialized) &#123;<br>      intialize();<br>    &#125;<br>  &#125;<br>  doWork();<br>&#125;<br><br><span class="hljs-comment">// 不使用 late 关键字</span><br><span class="hljs-built_in">Type?</span> a;<br><br>doSomeWorkEnsureInitialized() &#123;<br>  <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span>) &#123;<br>    initialize();<br>  &#125;<br>  doWork();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="CONSIDER-copying-a-nullable-field-to-a-local-variable-to-enable-type-promotion"><a href="#CONSIDER-copying-a-nullable-field-to-a-local-variable-to-enable-type-promotion" class="headerlink" title="CONSIDER copying a nullable field to a local variable to enable type promotion."></a>CONSIDER copying a nullable field to a local variable to enable type promotion.</h4><p>Dart 中有类型提升的机制，但是只适用于本地变量，因此，对于可为空的成员变量我们应该先将其拷贝成本地变量，然后再使用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> Response? response;<br><br><span class="hljs-meta">@override</span><br><span class="hljs-built_in">String</span> toString() &#123;<br>  <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">this</span>.response;<br>  <span class="hljs-keyword">if</span> (response != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Could not complete upload to <span class="hljs-subst">$&#123;response.url&#125;</span> &quot;</span><br>        <span class="hljs-string">&quot;(error code <span class="hljs-subst">$&#123;response.errorCode&#125;</span>): <span class="hljs-subst">$&#123;response.reason&#125;</span>.&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Could not upload (no response).&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是要注意如果本地变量发生变化，要将其重新赋值到成员变量上。而且成员变量有可能在被拷贝之后发生了变化，则拷贝的本地变量已经「过时」了。</p><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><h4 id="DO-use-adjacent-strings-to-concatenate-string-literals"><a href="#DO-use-adjacent-strings-to-concatenate-string-literals" class="headerlink" title="DO use adjacent strings to concatenate string literals."></a>DO use adjacent strings to concatenate string literals.</h4><p>Dart 中不需要使用 + 来连接两个字符，像 C 和 C++ 中一样，相邻的字符串会自动被拼接成同一个字符串。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;content1,&#x27;</span><span class="hljs-string">&#x27;content2,&#x27;</span>);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Some very very long string text which cannot be put into one line, &#x27;</span><br>      <span class="hljs-string">&#x27;but can be put into adjacent line to be concatenated together without +&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="PREFER-using-interpolation-to-compose-strings-and-values"><a href="#PREFER-using-interpolation-to-compose-strings-and-values" class="headerlink" title="PREFER using interpolation to compose strings and values."></a>PREFER using interpolation to compose strings and values.</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-string">&#x27;Hello, <span class="hljs-subst">$name</span>! You are <span class="hljs-subst">$&#123;year - birth&#125;</span> years old.&#x27;</span>; <span class="hljs-comment">// good</span><br><span class="hljs-string">&#x27;Hello, &#x27;</span> + name + <span class="hljs-string">&#x27;! You are &#x27;</span> + (year - birth).toString(); <span class="hljs-comment">// bad!</span><br></code></pre></td></tr></table></figure><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><h4 id="DO-use-collection-literals-when-possible"><a href="#DO-use-collection-literals-when-possible" class="headerlink" title="DO use collection literals when possible."></a>DO use collection literals when possible.</h4><p>创建集合的时候使用字面量表达式，而不是默认构造器，因为字面量表达式还支持扩展表达式和集合 if 和集合 for 的操作。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// good:</span><br><span class="hljs-keyword">var</span> points = &lt;Point&gt;[];<br><span class="hljs-keyword">var</span> addresses = &lt;<span class="hljs-built_in">String</span>, Address&gt;&#123;&#125;;<br><span class="hljs-keyword">var</span> counts = &lt;<span class="hljs-built_in">int</span>&gt;&#123;&#125;;<br><br><span class="hljs-comment">// bad:</span><br><span class="hljs-keyword">var</span> points = <span class="hljs-built_in">List</span>&lt;Point&gt;.empty(growable: <span class="hljs-keyword">true</span>);<br><span class="hljs-keyword">var</span> addresses = <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Address&gt;();<br><span class="hljs-keyword">var</span> counts = <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">int</span>&gt;();<br></code></pre></td></tr></table></figure><h4 id="DON’T-use-length-to-see-if-a-collection-is-empty"><a href="#DON’T-use-length-to-see-if-a-collection-is-empty" class="headerlink" title="DON’T use .length to see if a collection is empty."></a>DON’T use <code>.length</code> to see if a collection is empty.</h4><p>使用 <code>isEmpty</code> 和 <code>isNotEmpty</code> 代替 <code>.length</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (lunchBox.isEmpty) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;so hungry...&#x27;</span>;<br><span class="hljs-keyword">if</span> (words.isNotEmpty) <span class="hljs-keyword">return</span> words.join(<span class="hljs-string">&#x27; &#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="AVOID-using-Iterable-forEach-with-a-function-literal"><a href="#AVOID-using-Iterable-forEach-with-a-function-literal" class="headerlink" title="AVOID using Iterable.forEach() with a function literal."></a>AVOID using <code>Iterable.forEach()</code> with a function literal.</h4><p>使用 for..in 代替 forEach()。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// good:</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> person <span class="hljs-keyword">in</span> people) &#123;<br>  ...<br>&#125;<br><br><span class="hljs-comment">// bad:</span><br>people.forEach((person) &#123;<br>  ...<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="DON’T-use-List-from-unless-you-intend-to-change-the-type-of-the-result"><a href="#DON’T-use-List-from-unless-you-intend-to-change-the-type-of-the-result" class="headerlink" title="DON’T use List.from() unless you intend to change the type of the result."></a>DON’T use <code>List.from()</code> unless you intend to change the type of the result.</h4><p>使用 <code>iterable.toList()</code> 代替 <code>List.from(iterable)</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> copy1 = iterable.toList();<br><span class="hljs-keyword">var</span> copy2 = <span class="hljs-built_in">List</span>.from(iterable);<br></code></pre></td></tr></table></figure><p>只有在需要修改集合类型的时候才使用 <code>List.from()</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2.33</span>, <span class="hljs-number">4</span>]; <span class="hljs-comment">// List&lt;num&gt;.</span><br>numbers.removeAt(<span class="hljs-number">1</span>); <span class="hljs-comment">// Now it only contains integers.</span><br><span class="hljs-keyword">var</span> ints = <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt;.from(numbers);<br></code></pre></td></tr></table></figure><h4 id="DO-use-whereType-to-filter-a-collection-by-type"><a href="#DO-use-whereType-to-filter-a-collection-by-type" class="headerlink" title="DO use whereType() to filter a collection by type."></a>DO use <code>whereType()</code> to filter a collection by type.</h4><p>使用 <code>whereType()</code> 根据类型筛选集合。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> objects = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> ints = objects.whereType&lt;<span class="hljs-built_in">int</span>&gt;();<br></code></pre></td></tr></table></figure><h4 id="DON’T-use-cast-when-a-nearby-operation-will-do"><a href="#DON’T-use-cast-when-a-nearby-operation-will-do" class="headerlink" title="DON’T use cast() when a nearby operation will do."></a>DON’T use <code>cast()</code> when a nearby operation will do.</h4><p>集合方法很多都支持泛型，所以除非必要，不要使用 <code>cast()</code> 进行类型转换。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> stuff = &lt;<span class="hljs-built_in">dynamic</span>&gt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">var</span> ints = <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt;.from(stuff);<br><span class="hljs-comment">// var ints = stuff.toList().cast&lt;int&gt;();</span><br><br><span class="hljs-keyword">var</span> reciprocals = stuff.map&lt;<span class="hljs-built_in">double</span>&gt;((n) =&gt; <span class="hljs-number">1</span> / n);<br><span class="hljs-comment">// var reciprocals = stuff.map((n) =&gt; 1 / n).cast&lt;double&gt;();</span><br></code></pre></td></tr></table></figure><h4 id="AVOID-using-cast"><a href="#AVOID-using-cast" class="headerlink" title="AVOID using cast()."></a>AVOID using <code>cast()</code>.</h4><p>如非必要，尽量减少使用 <code>cast()</code> 转换集合类型，考虑使用以下方法代替：</p><ul><li><p>直接用目标类型创建集合。</p></li><li><p>遍历元素，对单个元素使用 <code>cast()</code>（使用时才转换）。</p></li><li><p>尽量使用 <strong><code>List.from()</code></strong> 代替 <code>cast()</code>。</p></li></ul><p><code>cast()</code> 方法会返回一个集合并且在每次操作时检查元素类型，如果你只在集合的少量元素上做操作则适合使用 <code>cast()</code> 方法，其它情况下，这种转换的性能开销都比较大。</p><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><h4 id="DO-use-a-function-declaration-to-bind-a-function-to-a-name"><a href="#DO-use-a-function-declaration-to-bind-a-function-to-a-name" class="headerlink" title="DO use a function declaration to bind a function to a name."></a>DO use a function declaration to bind a function to a name.</h4><p>当使用局部方法的时候，如果需要有方法名，尽量直接使用方法声明，避免使用 lambd 表达式+变量给方法命名。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">// good:</span><br>  localFunction() &#123;<br>    ...<br>  &#125;<br>  <br>  <span class="hljs-comment">// bad:</span><br>  <span class="hljs-keyword">var</span> localFunction = () &#123;<br>    ...<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DON’T-create-a-lambda-when-a-tear-off-will-do"><a href="#DON’T-create-a-lambda-when-a-tear-off-will-do" class="headerlink" title="DON’T create a lambda when a tear-off will do."></a>DON’T create a lambda when a tear-off will do.</h4><p>当使用匿名函数的时候，如果函数调用的方法所需的参数和函数的参数一致，则可以使用 tear-off 的语法，类似于 Java 中的方法引用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// good:</span><br>names.forEach(<span class="hljs-built_in">print</span>);<br><br><span class="hljs-comment">// bad:</span><br>names.forEach((name) &#123;<br>  <span class="hljs-built_in">print</span>(name);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="DO-use-to-separate-a-named-parameter-from-its-default-value"><a href="#DO-use-to-separate-a-named-parameter-from-its-default-value" class="headerlink" title="DO use = to separate a named parameter from its default value."></a>DO use <code>=</code> to separate a named parameter from its default value.</h4><p>由于历史遗留问题，Dart 中允许使用 <code>:</code> 为参数设置默认值，最好的做法是用 <code>=</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// good:</span><br><span class="hljs-keyword">void</span> insert(<span class="hljs-built_in">Object</span> item, &#123;<span class="hljs-built_in">int</span> at = <span class="hljs-number">0</span>&#125;) &#123; ... &#125;<br><br><span class="hljs-comment">// bad:</span><br><span class="hljs-keyword">void</span> insert(<span class="hljs-built_in">Object</span> item, &#123;<span class="hljs-built_in">int</span> at: <span class="hljs-number">0</span>&#125;) &#123; ... &#125;<br></code></pre></td></tr></table></figure><h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><h4 id="DO-follow-a-consistent-rule-for-var-and-final-on-local-variables"><a href="#DO-follow-a-consistent-rule-for-var-and-final-on-local-variables" class="headerlink" title="DO follow a consistent rule for var and final on local variables."></a>DO follow a consistent rule for <code>var</code> and <code>final</code> on local variables.</h4><p>绝大多数局部变量都不需要有类型标注，而是直接使用 <code>var</code> 或者 <code>final</code> 关键字声明。我们可以选择以下两个原则的其中一个，不要同时使用两种方式：</p><ul><li>原则 A：如果是不会被重新赋值的变量，则使用 <code>final</code> 关键字，会被重新赋值的则使用 <code>var</code> 关键字。</li><li>原则 B：所有的局部变量一律都使用 <code>var</code> 关键字，只有顶层变量和成员变量才使用 <code>final</code> 关键字。</li></ul><p>推荐原则 B，更简单，且容易遵循。</p><h4 id="AVOID-storing-what-you-can-calculate"><a href="#AVOID-storing-what-you-can-calculate" class="headerlink" title="AVOID storing what you can calculate."></a>AVOID storing what you can calculate.</h4><p>原因是浪费内存，推荐使用 getters 代替。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>  <span class="hljs-built_in">double</span> radius;<br><br>  Circle(<span class="hljs-keyword">this</span>.radius);<br><br>  <span class="hljs-comment">// 不要使用成员变量来保存需要计算得到的值，使用 getters</span><br>  <span class="hljs-built_in">double</span> <span class="hljs-keyword">get</span> area =&gt; pi * radius * radius;<br>  <span class="hljs-built_in">double</span> <span class="hljs-keyword">get</span> circumference =&gt; pi * <span class="hljs-number">2.0</span> * radius;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Members"><a href="#Members" class="headerlink" title="Members"></a>Members</h3><p>Dart 中，对象的成员可以是方法或者变量。</p><h4 id="DON’T-wrap-a-field-in-a-getter-and-setter-unnecessarily"><a href="#DON’T-wrap-a-field-in-a-getter-and-setter-unnecessarily" class="headerlink" title="DON’T wrap a field in a getter and setter unnecessarily."></a>DON’T wrap a field in a getter and setter unnecessarily.</h4><p>Dart 中访问属性和访问 getters/setters 的效果是一样的，每个属性默认会自动生成 getters/setters，所以没必要手动去写 getters/setters，如果是为了使属性不可访问，则应该使用私有属性。</p><h4 id="PREFER-using-a-final-field-to-make-a-read-only-property"><a href="#PREFER-using-a-final-field-to-make-a-read-only-property" class="headerlink" title="PREFER using a final field to make a read-only property."></a>PREFER using a <code>final</code> field to make a read-only property.</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// good:</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> contents = [];<br>&#125;<br><br><span class="hljs-comment">// bad:</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> _contents;<br>  <span class="hljs-keyword">get</span> contents =&gt; _contents;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="CONSIDER-using-gt-for-simple-members"><a href="#CONSIDER-using-gt-for-simple-members" class="headerlink" title="CONSIDER using =&gt; for simple members."></a>CONSIDER using <code>=&gt;</code> for simple members.</h4><p>使用箭头表达式定义成员变量，最常见的用法是用于创建 getters。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">double</span> <span class="hljs-keyword">get</span> right =&gt; left + width;<br><span class="hljs-keyword">set</span> right(<span class="hljs-built_in">double</span> value) =&gt; left = value - width;<br><br><span class="hljs-built_in">String</span> capitalize(<span class="hljs-built_in">String</span> name) =&gt;<br>    <span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;name[<span class="hljs-number">0</span>].toUpperCase()&#125;</span><span class="hljs-subst">$&#123;name.substring(<span class="hljs-number">1</span>)&#125;</span>&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="DON’T-use-this-except-to-redirect-to-a-named-constructor-or-to-avoid-shadowing"><a href="#DON’T-use-this-except-to-redirect-to-a-named-constructor-or-to-avoid-shadowing" class="headerlink" title="DON’T use this. except to redirect to a named constructor or to avoid shadowing."></a>DON’T use <code>this.</code> except to redirect to a named constructor or to avoid shadowing.</h4><p>只有以下几种情况下才使用 <code>this</code> 关键字：</p><ul><li>构造器中引用成员变量；</li><li>构造器重定向到某个具名构造器时；</li><li>成员变量与局部变量或者参数同名时；</li></ul><p>有趣的是，在构造器初始化列表中，可以区分出同名参数，所以不需要使用 <code>this</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseBox</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> value;<br><br>  Box(value)<br>      : value = value,<br>        <span class="hljs-keyword">super</span>(value);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DO-initialize-fields-at-their-declaration-when-possible"><a href="#DO-initialize-fields-at-their-declaration-when-possible" class="headerlink" title="DO initialize fields at their declaration when possible."></a>DO initialize fields at their declaration when possible.</h4><p>如果成员属性不依赖构造器初始化，则应该尽量在声明处进行初始化。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileMark</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> name;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">DateTime</span> start = <span class="hljs-built_in">DateTime</span>.now();<br><br>  ProfileMark(<span class="hljs-keyword">this</span>.name);<br>  ProfileMark.unnamed() : name = <span class="hljs-string">&#x27;&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h3><h4 id="DO-use-initializing-formals-when-possible"><a href="#DO-use-initializing-formals-when-possible" class="headerlink" title="DO use initializing formals when possible."></a>DO use initializing formals when possible.</h4><p>在构造器参数前使用 <code>this.</code> 叫做 <em>initializing formal</em>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-built_in">double</span> x, y;<br>  Point(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DON’T-use-late-when-a-constructor-initializer-list-will-do"><a href="#DON’T-use-late-when-a-constructor-initializer-list-will-do" class="headerlink" title="DON’T use late when a constructor initializer list will do."></a>DON’T use <code>late</code> when a constructor initializer list will do.</h4><p>如果成员变量会在构造器中进行初始化，就应该避免将其标记为 <code>late</code>。</p><h4 id="DO-use-instead-of-for-empty-constructor-bodies"><a href="#DO-use-instead-of-for-empty-constructor-bodies" class="headerlink" title="DO use ; instead of {} for empty constructor bodies."></a>DO use <code>;</code> instead of <code>&#123;&#125;</code> for empty constructor bodies.</h4><p>构造器方法体为空时使用 <code>;</code> 结束构造器，避免使用空方法体。</p><h4 id="DON’T-use-new"><a href="#DON’T-use-new" class="headerlink" title="DON’T use new."></a>DON’T use <code>new</code>.</h4><p>避免使用 <code>new</code> 关键字，同样是 Dart 的历史遗留问题。</p><h4 id="DON’T-use-const-redundantly"><a href="#DON’T-use-const-redundantly" class="headerlink" title="DON’T use const redundantly."></a>DON’T use <code>const</code> redundantly.</h4><p>以下几种情况下，不需要使用 <code>const</code> 关键字：</p><ul><li>在一个 <code>const</code> 的集合中；</li><li>在一个 <code>const</code> 构造器中，其中每个参数都是 const 的；</li><li>在元数据注解中；</li><li><code>const</code> 常量的初始化器；</li><li>在 switch..case 表达式中，case 之后 : 之前的值默认也是 <code>const</code> 的；</li></ul><h3 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a>Error handling</h3><h4 id="AVOID-catches-without-on-clauses"><a href="#AVOID-catches-without-on-clauses" class="headerlink" title="AVOID catches without on clauses."></a>AVOID catches without <code>on</code> clauses.</h4><p>如果 catch 子句没有使用 <code>on</code> 关键字限定捕捉的异常类型，则会捕捉所有类型的异常，这样我们就没法得到程序出错的具体原因了，到底是 stackoverflow 还是参数异常，又或者是断言条件未满足？所以，哪怕是只捕捉 <a href="https://api.dart.dev/stable/dart-core/Exception-class.html"><code>Exception</code></a> 也比捕捉全部异常好，Exception 代表程序运行时异常，排除了编码错误造成的异常。</p><h4 id="DON’T-discard-errors-from-catches-without-on-clauses"><a href="#DON’T-discard-errors-from-catches-without-on-clauses" class="headerlink" title="DON’T discard errors from catches without on clauses."></a>DON’T discard errors from catches without <code>on</code> clauses.</h4><p>如果你执意捕捉所有异常，请不要丢弃异常内容，至少打印一下好吗？</p><h4 id="DO-throw-objects-that-implement-Error-only-for-programmatic-errors"><a href="#DO-throw-objects-that-implement-Error-only-for-programmatic-errors" class="headerlink" title="DO throw objects that implement Error only for programmatic errors."></a>DO throw objects that implement <code>Error</code> only for programmatic errors.</h4><p>所有的编码异常都继承自 <a href="https://api.dart.dev/stable/dart-core/Error-class.html"><code>Error</code></a> 类，如果是运行时异常造成的错误，则应该抛出运行时异常，尽量在编码异常中排除掉运行时异常。</p><h4 id="DON’T-explicitly-catch-Error-or-types-that-implement-it"><a href="#DON’T-explicitly-catch-Error-or-types-that-implement-it" class="headerlink" title="DON’T explicitly catch Error or types that implement it."></a>DON’T explicitly catch <code>Error</code> or types that implement it.</h4><p>实现了 Error 类的大多是编码异常，这类异常可以告诉我们程序出错的信息，通常不应该捕捉这类异常。</p><h4 id="DO-use-rethrow-to-rethrow-a-caught-exception"><a href="#DO-use-rethrow-to-rethrow-a-caught-exception" class="headerlink" title="DO use rethrow to rethrow a caught exception."></a>DO use <code>rethrow</code> to rethrow a caught exception.</h4><p><code>throw</code> 会重置错误栈信息，而 <code>rethrow</code> 则不会。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">try</span> &#123;<br>  somethingRisky();<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-keyword">if</span> (!canHandle(e)) <span class="hljs-keyword">rethrow</span>;<br>  handle(e);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Asynchrony"><a href="#Asynchrony" class="headerlink" title="Asynchrony"></a>Asynchrony</h3><h4 id="PREFER-async-await-over-using-raw-futures"><a href="#PREFER-async-await-over-using-raw-futures" class="headerlink" title="PREFER async/await over using raw futures."></a>PREFER async/await over using raw futures.</h4><p><code>async</code> / <code>await</code> 语法可以提升代码的可读性，并且是的程序更容易 debug。</p><h4 id="DON’T-use-async-when-it-has-no-useful-effect"><a href="#DON’T-use-async-when-it-has-no-useful-effect" class="headerlink" title="DON’T use async when it has no useful effect."></a>DON’T use <code>async</code> when it has no useful effect.</h4><p>虽然异步场景下优先推荐使用 <code>async</code>，但是注意不要滥用 <code>async</code>。满足以下条件时才推荐使用 <code>async</code>：</p><ul><li>使用了 <code>await</code>.（废话）</li><li>需要异步返回异常，使用 <code>async</code> 比使用 Future.error() 更简洁。</li><li>需要返回一个 Future 对象，使用 <code>async</code> 比使用 Future.value() 更简洁。</li></ul><h4 id="CONSIDER-using-higher-order-methods-to-transform-a-stream"><a href="#CONSIDER-using-higher-order-methods-to-transform-a-stream" class="headerlink" title="CONSIDER using higher-order methods to transform a stream."></a>CONSIDER using higher-order methods to transform a stream.</h4><p><a href="https://dart.dev/tutorials/language/streams"><code>Stream</code></a> 和集合类似，包含一些诸如 every, any, distinct 等便捷的转换操作，避免手动转换。</p><h4 id="AVOID-using-Completer-directly"><a href="#AVOID-using-Completer-directly" class="headerlink" title="AVOID using Completer directly."></a>AVOID using Completer directly.</h4><p>Completer 是比较底层的类，应该避免使用，大多数场景下用 <code>async</code>/<code>await</code> 就足够了。</p><h4 id="DO-test-for-Future-lt-T-gt-when-disambiguating-a-FutureOr-lt-T-gt-whose-type-argument-could-be-Object"><a href="#DO-test-for-Future-lt-T-gt-when-disambiguating-a-FutureOr-lt-T-gt-whose-type-argument-could-be-Object" class="headerlink" title="DO test for Future&lt;T&gt; when disambiguating a FutureOr&lt;T&gt; whose type argument could be Object."></a>DO test for <code>Future&lt;T&gt;</code> when disambiguating a <code>FutureOr&lt;T&gt;</code> whose type argument could be <code>Object</code>.</h4><p>在使用 <a href="https://api.dart.dev/stable/2.13.0/dart-async/FutureOr-class.html"><code>FutureOr&lt;T&gt;</code></a> 之前，你通常需要先用 <code>is</code> 关键字判断其类型。因为 T 有可能是 Object，而 FutureOr&lt;&gt; 本身也是 Object，所以要用 <code>Future&lt;T&gt;</code> 作为判断依据。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">Future&lt;T&gt; logValue&lt;T&gt;(FutureOr&lt;T&gt; value) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">is</span> Future&lt;T&gt;) &#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> value;<br>    <span class="hljs-built_in">print</span>(result);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">print</span>(value);<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Design-Guide"><a href="#Design-Guide" class="headerlink" title="Design Guide"></a>Design Guide</h2><h3 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h3><h4 id="DO-use-terms-consistently"><a href="#DO-use-terms-consistently" class="headerlink" title="DO use terms consistently."></a>DO use terms consistently.</h4><p>在整个代码库中保持用相同的名称命名相同的物体，尽量使用被大众接受或者共同认可的方式命名。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">pageCount         <span class="hljs-comment">// A field.</span><br>updatePageCount() <span class="hljs-comment">// Consistent with pageCount.</span><br>toSomething()     <span class="hljs-comment">// Consistent with Iterable&#x27;s toList().</span><br>asSomething()     <span class="hljs-comment">// Consistent with List&#x27;s asMap().</span><br>Point             <span class="hljs-comment">// A familiar concept.</span><br></code></pre></td></tr></table></figure><h4 id="AVOID-abbreviations"><a href="#AVOID-abbreviations" class="headerlink" title="AVOID abbreviations."></a>AVOID abbreviations.</h4><p>尽量避免使用缩写，除非是非常常见的缩写。</p><h4 id="PREFER-putting-the-most-descriptive-noun-last"><a href="#PREFER-putting-the-most-descriptive-noun-last" class="headerlink" title="PREFER putting the most descriptive noun last."></a>PREFER putting the most descriptive noun last.</h4><p>最后一个单词一定是最具描述性、最能总结该类用途的名词。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">StatelessWidget<br>DownloadPage<br>AnimationController<br>OutlineInputBorder<br></code></pre></td></tr></table></figure><h4 id="CONSIDER-making-the-code-read-like-a-sentence"><a href="#CONSIDER-making-the-code-read-like-a-sentence" class="headerlink" title="CONSIDER making the code read like a sentence."></a>CONSIDER making the code read like a sentence.</h4><p>尽量使你的代码读起来可以像读文章一样易懂。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (serviceTable.isEmpty) &#123;<br>  serviceTable.addAll(waitingList.where(<br>          (customer) =&gt; customer.waitingMinutes &gt; <span class="hljs-number">30</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="PREFER-a-noun-phrase-for-a-non-boolean-property-or-variable"><a href="#PREFER-a-noun-phrase-for-a-non-boolean-property-or-variable" class="headerlink" title="PREFER a noun phrase for a non-boolean property or variable."></a>PREFER a noun phrase for a non-boolean property or variable.</h4><p>尽量使用名词命名非布尔类型的属性或变量。</p><h4 id="PREFER-a-non-imperative-verb-phrase-for-a-boolean-property-or-variable"><a href="#PREFER-a-non-imperative-verb-phrase-for-a-boolean-property-or-variable" class="headerlink" title="PREFER a non-imperative verb phrase for a boolean property or variable."></a>PREFER a non-imperative verb phrase for a boolean property or variable.</h4><p>使用非祈使<strong>动词</strong>命名布尔类型的属性或变量。布尔类型的变量一般代表某种状态或者能力。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">isEmpty<br>hasElements<br>canClose<br>closesWindow<br>canShowPopup<br>hasShownPopup<br></code></pre></td></tr></table></figure><h4 id="CONSIDER-omitting-the-verb-for-a-named-boolean-parameter"><a href="#CONSIDER-omitting-the-verb-for-a-named-boolean-parameter" class="headerlink" title="CONSIDER omitting the verb for a named boolean parameter."></a>CONSIDER omitting the verb for a named boolean <em>parameter</em>.</h4><p>具名参数一般可以省略动词，使用形容词。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> copy = <span class="hljs-built_in">List</span>.from(elements, growable: <span class="hljs-keyword">true</span>);<br><span class="hljs-keyword">var</span> copy = <span class="hljs-built_in">List</span>.from(elements, canGrow: <span class="hljs-keyword">true</span>); <span class="hljs-comment">// 哪一种更好？</span><br></code></pre></td></tr></table></figure><h4 id="PREFER-the-“positive”-name-for-a-boolean-property-or-variable"><a href="#PREFER-the-“positive”-name-for-a-boolean-property-or-variable" class="headerlink" title="PREFER the “positive” name for a boolean property or variable."></a>PREFER the “positive” name for a boolean property or variable.</h4><p>对于布尔值，尽量使用有价值、有意义、有用的值作为 true 值等。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (socket.isConnected &amp;&amp; database.hasData) &#123;<br>  socket.write(database.read());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="PREFER-an-imperative-verb-phrase-for-a-function-or-method-whose-main-purpose-is-a-side-effect"><a href="#PREFER-an-imperative-verb-phrase-for-a-function-or-method-whose-main-purpose-is-a-side-effect" class="headerlink" title="PREFER an imperative verb phrase for a function or method whose main purpose is a side effect."></a>PREFER an imperative verb phrase for a function or method whose main purpose is a side effect.</h4><p>使用祈使动词短语命名那些具有 “side effect” 的方法名，side effect 即会改变对象的内部状态，比如属性等，或者产生一些新数据，或者会引起外部其它对象发生变化等等。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">queue.removeFirst();<br><span class="hljs-built_in">window</span>.refresh();<br></code></pre></td></tr></table></figure><h4 id="PREFER-a-noun-phrase-or-non-imperative-verb-phrase-for-a-function-or-method-if-returning-a-value-is-its-primary-purpose"><a href="#PREFER-a-noun-phrase-or-non-imperative-verb-phrase-for-a-function-or-method-if-returning-a-value-is-its-primary-purpose" class="headerlink" title="PREFER a noun phrase or non-imperative verb phrase for a function or method if returning a value is its primary purpose."></a>PREFER a noun phrase or non-imperative verb phrase for a function or method if returning a value is its primary purpose.</h4><p>如果方法的主要用途是返回值，那么应该使用名词短语或者非祈使动词短语作为方法名。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> element = list.elementAt(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> first = list.firstWhere(condition);<br><span class="hljs-keyword">var</span> char = string.codeUnitAt(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><h4 id="CONSIDER-an-imperative-verb-phrase-for-a-function-or-method-if-you-want-to-draw-attention-to-the-work-it-performs"><a href="#CONSIDER-an-imperative-verb-phrase-for-a-function-or-method-if-you-want-to-draw-attention-to-the-work-it-performs" class="headerlink" title="CONSIDER an imperative verb phrase for a function or method if you want to draw attention to the work it performs."></a>CONSIDER an imperative verb phrase for a function or method if you want to draw attention to the work it performs.</h4><p>当方法不产生任何 side effect 但是会比较消耗资源或者做一些有可能出错的操作时，也要使用祈使动词短语命名。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> table = database.downloadData();<br><span class="hljs-keyword">var</span> packageVersions = packageGraph.solveConstraints();<br></code></pre></td></tr></table></figure><h4 id="AVOID-starting-a-method-name-with-get"><a href="#AVOID-starting-a-method-name-with-get" class="headerlink" title="AVOID starting a method name with get."></a>AVOID starting a method name with <code>get</code>.</h4><p>大多数方法都应该直接省略 get 直接描述方法作用，比如使用 <code>packageSortOrder()</code> 而不是 <code>getPackageSortOrder()</code>。</p><h4 id="PREFER-naming-a-method-toXxx-if-it-copies-the-object’s-state-to-a-new-object"><a href="#PREFER-naming-a-method-toXxx-if-it-copies-the-object’s-state-to-a-new-object" class="headerlink" title="PREFER naming a method toXxx() if it copies the object’s state to a new object."></a>PREFER naming a method <code>toXxx()</code> if it copies the object’s state to a new object.</h4><p>如果方法的主要用途是将一个对象复制并转换为另一个对象时，尽量使用 toXxx() 命名。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">list.toSet();<br>stackTrace.toString();<br>dateTime.toLocal();<br></code></pre></td></tr></table></figure><h4 id="PREFER-naming-a-method-asXxx-if-it-returns-a-different-representation-backed-by-the-original-object"><a href="#PREFER-naming-a-method-asXxx-if-it-returns-a-different-representation-backed-by-the-original-object" class="headerlink" title="PREFER naming a method asXxx() if it returns a different representation backed by the original object."></a>PREFER naming a method <code>asXxx()</code> if it returns a different representation backed by the original object.</h4><p>如果方法的主要用途是基于一个对象包装转换成另一个对象时，尽量使用 asXxx() 命名。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> map = table.asMap();<br><span class="hljs-keyword">var</span> list = bytes.asFloat32List();<br><span class="hljs-keyword">var</span> future = subscription.asFuture();<br></code></pre></td></tr></table></figure><h4 id="AVOID-describing-the-parameters-in-the-function’s-or-method’s-name"><a href="#AVOID-describing-the-parameters-in-the-function’s-or-method’s-name" class="headerlink" title="AVOID describing the parameters in the function’s or method’s name."></a>AVOID describing the parameters in the function’s or method’s name.</h4><p>方法名中不要带有参数相关的信息。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// good:</span><br>list.add(element);<br>map.remove(key);<br><br><span class="hljs-comment">// bad:</span><br>list.addElement(element);<br>map.removeKey(key);<br></code></pre></td></tr></table></figure><p>只有在为了区分多种功能类似的方法时才可以忽略该原则：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">map.containsKey(key);<br>map.containsValue(value);<br></code></pre></td></tr></table></figure><h4 id="DO-follow-existing-mnemonic-conventions-when-naming-type-parameters"><a href="#DO-follow-existing-mnemonic-conventions-when-naming-type-parameters" class="headerlink" title="DO follow existing mnemonic conventions when naming type parameters."></a>DO follow existing mnemonic conventions when naming type parameters.</h4><p>使用现有的助记规则命名类型参数，比如 E 代表集合中的 Element，K/V 代表 Map 的 key/value，R 代表类或方法的 return 值，其它情况使用 T/S/U/N/E 等。</p><h3 id="Libraries-1"><a href="#Libraries-1" class="headerlink" title="Libraries"></a>Libraries</h3><p>Dart 中使用下划线 __ 代表成员是库私有的，这不仅仅是约定俗成的，更是在语法层面做出的规定。</p><h4 id="PREFER-making-declarations-private"><a href="#PREFER-making-declarations-private" class="headerlink" title="PREFER making declarations private."></a>PREFER making declarations private.</h4><p>对于库的作者而言，这点尤为重要，要尽可能减少暴露接口给库的使用者，只暴露必须使用到的接口。</p><h4 id="CONSIDER-declaring-multiple-classes-in-the-same-library"><a href="#CONSIDER-declaring-multiple-classes-in-the-same-library" class="headerlink" title="CONSIDER declaring multiple classes in the same library."></a>CONSIDER declaring multiple classes in the same library.</h4><p>Dart 中每个文件都是一个 library，但是不像 Java 等语言一个文件通常只能代表一个类，Dart 中可以在相同的 library 中包含多个类、顶层变量和方法，只要这些类、变量和方法的确相互联系并且构成一个功能模块就可以了。</p><p>将多个类放在一起有诸多好处。因为私有访问权限仅限于库层级，而不是类层级，所以在同一个库中是可以访问其它类中的私有属性和方法的。</p><h3 id="Classes-and-mixins"><a href="#Classes-and-mixins" class="headerlink" title="Classes and mixins"></a>Classes and mixins</h3><p>Dart 是一个纯面向对象的语言，这意味这所有对象都是类的实例。但是另一方面，Dart 有可以像面向过程或者函数式编程一样拥有顶层方法和变量。</p><h4 id="AVOID-defining-a-one-member-abstract-class-when-a-simple-function-will-do"><a href="#AVOID-defining-a-one-member-abstract-class-when-a-simple-function-will-do" class="headerlink" title="AVOID defining a one-member abstract class when a simple function will do."></a>AVOID defining a one-member abstract class when a simple function will do.</h4><p>当类中只有一个方法或者变量的时候，考虑使用顶层变量或者方法代替。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// good:</span><br><span class="hljs-keyword">typedef</span> Predicate&lt;E&gt; = <span class="hljs-built_in">bool</span> <span class="hljs-built_in">Function</span>(E element);<br><br><span class="hljs-comment">// bad:</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">bool</span> test(E element);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AVOID-defining-a-class-that-contains-only-static-members"><a href="#AVOID-defining-a-class-that-contains-only-static-members" class="headerlink" title="AVOID defining a class that contains only static members."></a>AVOID defining a class that contains only static members.</h4><p>Java C# 等语言必须将方法、变量和常量定义在类之中，比如 Java 中，我们常常会用一个 Constants 类来保存全局使用到的一些静态常量。而且为了避免命名冲突，我们常常会使用类名区分相同名字的方法。Dart 中没有这样的限制，相反，Dart 使用 library 作为命名空间，并且在导入包的时候可以使用 <code>as</code>/<code>show</code>/<code>hide</code> 等关键字避免冲突的命名。</p><p>我们可以将静态方法或静态成员变量转换成顶层方法或常量，然后以合适的方式命名或者整理进同一个库中。当然，这个规则不一定必须要遵循，一些场合下可能还是使用类和静态成员变量更合适：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> red = <span class="hljs-string">&#x27;#f00&#x27;</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> green = <span class="hljs-string">&#x27;#0f0&#x27;</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> blue = <span class="hljs-string">&#x27;#00f&#x27;</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> black = <span class="hljs-string">&#x27;#000&#x27;</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> white = <span class="hljs-string">&#x27;#fff&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AVOID-extending-a-class-that-isn’t-intended-to-be-subclassed"><a href="#AVOID-extending-a-class-that-isn’t-intended-to-be-subclassed" class="headerlink" title="AVOID extending a class that isn’t intended to be subclassed."></a>AVOID extending a class that isn’t intended to be subclassed.</h4><p>有些类可能本意就不是为了被继承而设计的，所以尽量用合适的命名告诉库的使用者哪些类可以被继承而哪些类不行。</p><h4 id="DO-document-if-your-class-supports-being-extended"><a href="#DO-document-if-your-class-supports-being-extended" class="headerlink" title="DO document if your class supports being extended."></a>DO document if your class supports being extended.</h4><p>同上，如果一个类可以被继承，至少用注释说明一些需要注意的地方。</p><h4 id="AVOID-implementing-a-class-that-isn’t-intended-to-be-an-interface"><a href="#AVOID-implementing-a-class-that-isn’t-intended-to-be-an-interface" class="headerlink" title="AVOID implementing a class that isn’t intended to be an interface."></a>AVOID implementing a class that isn’t intended to be an interface.</h4><p>同样的，如果一个接口不应该被实现，而使用者却实现了这个接口，那么当未来库的作者对这个接口做任何改动，都会影响到使用者的原有的实现。</p><h4 id="DO-document-if-your-class-supports-being-used-as-an-interface"><a href="#DO-document-if-your-class-supports-being-used-as-an-interface" class="headerlink" title="DO document if your class supports being used as an interface."></a>DO document if your class supports being used as an interface.</h4><p>如果一个接口可以被实现，需要在文档注释中说明。</p><h4 id="DO-use-mixin-to-define-a-mixin-type"><a href="#DO-use-mixin-to-define-a-mixin-type" class="headerlink" title="DO use mixin to define a mixin type."></a>DO use <code>mixin</code> to define a mixin type.</h4><p>Dart 从版本 2.1.0 之后才添加了 <code>mixin</code> 关键字，在这之前，任何没有默认构造器、没有父类的类都可以被用做 mixin，这带来了一个问题，有些类可能并不适合用做 mixin，误用它们可能会带来一些问题。而使用了 <code>mixin</code> 关键字之后，<code>mixin</code> 类只能被用做 mixins，而不能用做其它用途。</p><h4 id="AVOID-mixing-in-a-type-that-isn’t-intended-to-be-a-mixin"><a href="#AVOID-mixing-in-a-type-that-isn’t-intended-to-be-a-mixin" class="headerlink" title="AVOID mixing in a type that isn’t intended to be a mixin."></a>AVOID mixing in a type that isn’t intended to be a mixin.</h4><p>同上。</p><h3 id="Constructors-1"><a href="#Constructors-1" class="headerlink" title="Constructors"></a>Constructors</h3><p>Dart 中构造器是一类特殊的方法，用于创建类的实例，它的方法名和类名相同，没有返回值，并且除此之外还可以用 <code>.</code> 分割，后面加标识符，这类构造器叫具名构造器。</p><h4 id="CONSIDER-making-your-constructor-const-if-the-class-supports-it"><a href="#CONSIDER-making-your-constructor-const-if-the-class-supports-it" class="headerlink" title="CONSIDER making your constructor const if the class supports it."></a>CONSIDER making your constructor <code>const</code> if the class supports it.</h4><p>如果类中的成员变量都是 final 的，而且构造器只是初始化了这些成员变量，那么可以用 <code>const</code> 修饰构造器。这样，使用该类的开发者就可以在需要使用常量的地方使用该类的对象了，比如在其它常量容器中，switch..case 中，默认参数值等等。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> name;<br>  <br>  <span class="hljs-keyword">const</span> Pet(<span class="hljs-keyword">this</span>.name);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PetShop</span> </span>&#123;<br>  Pet pet;<br><br>  <span class="hljs-comment">// Error: The default value of an optional parameter must be constant.</span><br>  <span class="hljs-comment">// PetShop(&#123;this.pet = Pet(&#x27;Cat&#x27;)&#125;); </span><br>  <br>  PetShop([<span class="hljs-keyword">this</span>.pet = <span class="hljs-keyword">const</span> Pet(<span class="hljs-string">&#x27;Cat&#x27;</span>)]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Members-1"><a href="#Members-1" class="headerlink" title="Members"></a>Members</h3><h4 id="PREFER-making-fields-and-top-level-variables-final"><a href="#PREFER-making-fields-and-top-level-variables-final" class="headerlink" title="PREFER making fields and top-level variables final."></a>PREFER making fields and top-level variables <code>final</code>.</h4><p>尽量将成员变量和顶层变量设为 <code>final</code> 的。</p><h4 id="DO-use-getters-for-operations-that-conceptually-access-properties"><a href="#DO-use-getters-for-operations-that-conceptually-access-properties" class="headerlink" title="DO use getters for operations that conceptually access properties."></a>DO use getters for operations that conceptually access properties.</h4><p>在 API 设计中，使用 getters 还是使用方法作为访问某个数据的方式是个微妙但重要的部分。Dart 中成员变量会自动生成 getters，所以访问成员变量和访问 getters，其本质是一样的。所以，通常来说，访问 getters 给人的感觉就像是访问成员变量，它意味着：</p><ul><li>这种操作不需要接受参数，但是有返回值；</li><li>调用者只关心返回值；</li><li>这种操作并不会造成任何用户可见的 side effects；</li><li>这种操作具有幂等性，即无论调用多少次，结果相同；</li><li>返回的结果对象不会暴露原始对象的所有状态；</li></ul><p>如果你的目标操作符合以上所有特点，则可以将这种操作定义成一个 getter 而不是方法。</p><h4 id="DO-use-setters-for-operations-that-conceptually-change-properties"><a href="#DO-use-setters-for-operations-that-conceptually-change-properties" class="headerlink" title="DO use setters for operations that conceptually change properties."></a>DO use setters for operations that conceptually change properties.</h4><p>与 getters 类似，使用 setters 也会遇到类似的困境，不同的是 setters 需要满足 filed-like 特质：</p><ul><li>操作只接受一个参数，且不会产生返回值；</li><li>操作只会改变对象的某些状态；</li><li>操作具有等幂性；</li></ul><h4 id="DON’T-define-a-setter-without-a-corresponding-getter"><a href="#DON’T-define-a-setter-without-a-corresponding-getter" class="headerlink" title="DON’T define a setter without a corresponding getter."></a>DON’T define a setter without a corresponding getter.</h4><p>一个可被修改的 setter 往往对应着一个供访问的 getter。</p><h4 id="AVOID-using-runtime-type-tests-to-fake-overloading"><a href="#AVOID-using-runtime-type-tests-to-fake-overloading" class="headerlink" title="AVOID using runtime type tests to fake overloading."></a>AVOID using runtime type tests to fake overloading.</h4><p>Dart 中没有重载机制，有的人会定义一个方法，在方法中用 <code>is</code> 判断类型然后根据具体的类型做一些操作。这种操作虽然能达到目的，但是最好的做法还是使用一系列独立的方法，让用户根据不同的类型调用不同的方法。只有当一个对象具体类型不确定，需要在运行时根据不同的类型来调用特定的子类方法的时候，才可以把它们定义在一个方法内。</p><h4 id="AVOID-public-late-final-fields-without-initializers"><a href="#AVOID-public-late-final-fields-without-initializers" class="headerlink" title="AVOID public late final fields without initializers."></a>AVOID public <code>late final</code> fields without initializers.</h4><p>不像其它 <code>final</code> 成员变量，<code>late final</code> 的成员变量如果没有初始化器的话，Dart 会为它们生成 setters 函数，如果成员变量是 public 的，则意味着 setters 也是 public 的。我们将成员变量设置为 late 通常是希望稍后再去初始化它，比如在构造器中，而 <code>late final</code> 使得成员变量可能在被初始化之前就在外部被初始化了一遍。所以，最好的做法是：</p><ul><li>不要使用 <code>late</code>；</li><li>使用 <code>late</code> 但是在声明时为其初始化；</li><li>使用 <code>late</code> 但是将它标记为 private 的，同时为其提供一个 getter；</li></ul><h4 id="AVOID-returning-nullable-Future-Stream-and-collection-types"><a href="#AVOID-returning-nullable-Future-Stream-and-collection-types" class="headerlink" title="AVOID returning nullable Future, Stream, and collection types."></a>AVOID returning nullable <code>Future</code>, <code>Stream</code>, and collection types.</h4><p>如果返回的是容器类型，尽量避免返回空的容器类型，一般使用返回空的容器或者直接返回 null。</p><h4 id="AVOID-returning-this-from-methods-just-to-enable-a-fluent-interface"><a href="#AVOID-returning-this-from-methods-just-to-enable-a-fluent-interface" class="headerlink" title="AVOID returning this from methods just to enable a fluent interface."></a>AVOID returning <code>this</code> from methods just to enable a fluent interface.</h4><p>使用级联表达式而不是在方法中返回 <code>this</code> 实现链式调用。</p><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>我们使用类型标注限制某部分代码能够使用什么样的值。类型通常出现在两个地方：变量声明处的类型标注 (<em>type annotations</em>) 和使用泛型时的类型参数 (<em>generic invocations</em>)。</p><p>类型标注通常就是我们所认为的静态类型，我们可以对变量、参数、属性、返回值使用类型标注，就像下面这个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">bool</span> isEmpty(<span class="hljs-built_in">String</span> parameter) &#123; <span class="hljs-comment">// 返回值和参数的类型标注</span><br>  <span class="hljs-built_in">bool</span> result = parameter.isEmpty; <span class="hljs-comment">// 变量的类型标注</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>泛型调用时的类型参数可以是创建集合字面量，或者是调用泛型类的构造方法，或者是调用泛型方法。比如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> lists = &lt;<span class="hljs-built_in">num</span>&gt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]; <span class="hljs-comment">// 创建集合时指定类型</span><br>lists.addAll(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">num</span>&gt;.filled(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 调用泛型类的构造器并指定类型</span><br>lists.cast&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">// 调用泛型方法</span><br></code></pre></td></tr></table></figure><h4 id="Type-inference"><a href="#Type-inference" class="headerlink" title="Type inference"></a>Type inference</h4><p>类型标注是可选的，因为 Dart 会根据当前上下文推断出具体类型。当缺乏足够的信息推断出类型的时候，Dart 默认会使用 <code>dynamic</code> 类型。这种机制让类型推断看起来是安全的，但实际上使得类型检查完全失效了。</p><p>同时拥有类型推断和 <code>dynamic</code> 类型，使得我们在说代码是无类型的 (untyped) 时产生歧义，一个变量到底是动态类型还是没有写类型参数？所以，我们一般不说代码是无类型的，而是使用以下术语代替：</p><ul><li>如果代码拥有类型标注，则它的类型即所标注的类型（废话）。</li><li>如果代码是推断类型，则说明 Dart 已经确定其类型。而如果类型推断失败，那么我们不把称它为 <em>inferred</em>。</li><li>如果代码是动态类型的，那么它的静态类型就是 <code>dynamic</code>。这种情况下，代码既可以是主动被标注为 <code>dynamic</code> 也可以是推断类型（使用 <code>var</code> 关键字）。</li></ul><p>换句话说，代码是标注类型还是推断类型，与它是否被标注为 <code>dynamic</code> 或者其它类型无关。</p><p>类型推断是个强有力的工具，可以帮助我们编码或阅读代码时跳过一些显而易见的部分（代码类型），让我们关注真正重要的代码逻辑。但是，显式的代码类型也同样重要，它可以帮助我们写出健壮、可维护的代码。</p><p>当然，类型推断也不是万能药，一些情况下还是应该使用类型标注。有时候类型推断提前确定了变量类型，但是该类型不是你想要的，比如变量在初始化后推断出了类型，但是你实际却想要使用另一个类型，这种情况下就只能使用显式的类型标注了。</p><p>理解上面这些概念之后，方便我们在解释接下来的这些原则时，不会造成歧义。首先，我们可以将大致的原则总结为以下几点：</p><ul><li>当上下文不足以推断出类型的时候，请使用类型标注，即使你想要的是 <code>dynamic</code> 类型；</li><li>不要标注局部变量或者泛型调用；</li><li>对于顶层变量和属性，尽量显式标注其类型，除非初始化器使得它们的类型显而易见；</li></ul><h4 id="DO-type-annotate-variables-without-initializers"><a href="#DO-type-annotate-variables-without-initializers" class="headerlink" title="DO type annotate variables without initializers."></a>DO type annotate variables without initializers.</h4><p>如果没有变量没有立即被初始化，请使用类型标注。</p><h4 id="DO-type-annotate-fields-and-top-level-variables-if-the-type-isn’t-obvious"><a href="#DO-type-annotate-fields-and-top-level-variables-if-the-type-isn’t-obvious" class="headerlink" title="DO type annotate fields and top-level variables if the type isn’t obvious."></a>DO type annotate fields and top-level variables if the type isn’t obvious.</h4><p>如果变量类型不是显而易见的，也要使用类型标注。</p><p>显而易见包括以下这些情况：</p><ul><li>字面量，如基本数据类型等</li><li>构造器中的参数</li><li>引用其它变量或者常量</li><li>简单的表达式，比如 isEmpty, ==, &gt; 等等</li><li>工厂方法，比如 int.parse(), Future.wait() 等</li></ul><p>另外，当你觉得类型标注可以使你的代码更清晰时，那就请使用类型标注。</p><p>When in doubt, add a type annotation.</p><h4 id="DON’T-redundantly-type-annotate-initialized-local-variables"><a href="#DON’T-redundantly-type-annotate-initialized-local-variables" class="headerlink" title="DON’T redundantly type annotate initialized local variables."></a>DON’T redundantly type annotate initialized local variables.</h4><p>有初始化器的局部变量不要使用类型标注。只有当你确定推断类型不是你想要的类型的时候才使用类型标注。</p><h4 id="DO-annotate-return-types-on-function-declarations"><a href="#DO-annotate-return-types-on-function-declarations" class="headerlink" title="DO annotate return types on function declarations."></a>DO annotate return types on function declarations.</h4><p>给方法返回值添加类型标注可以方便方法的调用者。当然，匿名方法就没必要了。</p><h4 id="DO-annotate-parameter-types-on-function-declarations"><a href="#DO-annotate-parameter-types-on-function-declarations" class="headerlink" title="DO annotate parameter types on function declarations."></a>DO annotate parameter types on function declarations.</h4><p>给方法的参数添加类型标注，同样很有必要，可以帮助方法的调用者确定参数的边界。</p><p>需要注意的是，Dart 不会对可选的参数做类型推断，<a href="https://dart.dev/guides/language/effective-dart/design#do-annotate-parameter-types-on-function-declarations">来源</a>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> sayRepeatedly(<span class="hljs-built_in">String</span> message, &#123;<span class="hljs-built_in">int</span> count = <span class="hljs-number">2</span>&#125;) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>    <span class="hljs-built_in">print</span>(message);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DON’T-annotate-inferred-parameter-types-on-function-expressions"><a href="#DON’T-annotate-inferred-parameter-types-on-function-expressions" class="headerlink" title="DON’T annotate inferred parameter types on function expressions."></a>DON’T annotate inferred parameter types on function expressions.</h4><p>Dart 通常可以根据上下文确定匿名方法接收的参数是什么，所以匿名方法一般不需要添加类型标注。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> names = people.map((person) =&gt; person.name);<br></code></pre></td></tr></table></figure><h4 id="DON’T-type-annotate-initializing-formals"><a href="#DON’T-type-annotate-initializing-formals" class="headerlink" title="DON’T type annotate initializing formals."></a>DON’T type annotate initializing formals.</h4><p>之前说过构造器中使用 <code>this.</code> 给属性赋值的形式叫做 <code>initializing formals</code>，这种情况下也不要使用类型标注。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-built_in">double</span> x, y;<br>  Point(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DO-write-type-arguments-on-generic-invocations-that-aren’t-inferred"><a href="#DO-write-type-arguments-on-generic-invocations-that-aren’t-inferred" class="headerlink" title="DO write type arguments on generic invocations that aren’t inferred."></a>DO write type arguments on generic invocations that aren’t inferred.</h4><p>一些情况下，泛型的类型无法被确定，比如空的集合，所以我们需要为它们标注类型。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> playerScores = &lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">int</span>&gt;&#123;&#125;;<br><span class="hljs-keyword">final</span> events = StreamController&lt;Event&gt;();<br><br><span class="hljs-comment">// 对于成员变量来说，如果类型同样无法推断出，则需要在声明处标注类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Downloader</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> Completer&lt;<span class="hljs-built_in">String</span>&gt; response = Completer();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DON’T-write-type-arguments-on-generic-invocations-that-are-inferred"><a href="#DON’T-write-type-arguments-on-generic-invocations-that-are-inferred" class="headerlink" title="DON’T write type arguments on generic invocations that are inferred."></a>DON’T write type arguments on generic invocations that are inferred.</h4><p>如果泛型类的类型已经推断出来，就不要在写类型了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Downloader</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> Completer&lt;<span class="hljs-built_in">String</span>&gt; response = Completer&lt;<span class="hljs-built_in">String</span>&gt;(); <span class="hljs-comment">// 错误示例</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AVOID-writing-incomplete-generic-types"><a href="#AVOID-writing-incomplete-generic-types" class="headerlink" title="AVOID writing incomplete generic types."></a>AVOID writing incomplete generic types.</h4><p>也就是不要使用 raw 泛型。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// bad:</span><br><span class="hljs-built_in">List</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> completer = Completer&lt;<span class="hljs-built_in">Map</span>&gt;();<br><br><span class="hljs-comment">// good:</span><br><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">num</span>&gt; numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> completer = Completer&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">int</span>&gt;&gt;();<br></code></pre></td></tr></table></figure><h4 id="DO-annotate-with-dynamic-instead-of-letting-inference-fail"><a href="#DO-annotate-with-dynamic-instead-of-letting-inference-fail" class="headerlink" title="DO annotate with dynamic instead of letting inference fail."></a>DO annotate with <code>dynamic</code> instead of letting inference fail.</h4><p>显式标明 <code>dynamic</code> 永远要比不写类型标注要好。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// good:</span><br><span class="hljs-built_in">dynamic</span> mergeJson(<span class="hljs-built_in">dynamic</span> original, <span class="hljs-built_in">dynamic</span> changes) =&gt; ...<br><span class="hljs-comment">// bad:</span><br>mergeJson(original, changes) =&gt; ...<br></code></pre></td></tr></table></figure><p>当然，有些情况下，Dart 也能推断出 <code>dyanmic</code> 类型的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; readJson() =&gt; ...<br><br><span class="hljs-keyword">void</span> printUsers() &#123;<br>  <span class="hljs-keyword">var</span> json = readJson();<br>  <span class="hljs-keyword">var</span> users = json[<span class="hljs-string">&#x27;users&#x27;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="PREFER-signatures-in-function-type-annotations"><a href="#PREFER-signatures-in-function-type-annotations" class="headerlink" title="PREFER signatures in function type annotations."></a>PREFER signatures in function type annotations.</h4><p>默认的 Function 允许任何类型的返回值和参数，如果不带签名使用，在有些情况下会导致错误。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// good:</span><br><span class="hljs-built_in">bool</span> isValid(<span class="hljs-built_in">String</span> value, <span class="hljs-built_in">bool</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">String</span>) test) =&gt; ...<br><span class="hljs-comment">// bad:</span><br><span class="hljs-built_in">bool</span> isValid(<span class="hljs-built_in">String</span> value, <span class="hljs-built_in">Function</span> test) =&gt; ...<br></code></pre></td></tr></table></figure><h4 id="DON’T-specify-a-return-type-for-a-setter"><a href="#DON’T-specify-a-return-type-for-a-setter" class="headerlink" title="DON’T specify a return type for a setter."></a>DON’T specify a return type for a setter.</h4><p>Dart 中 setters 只会返回 void，所以不需要写返回值。</p><h4 id="DON’T-use-the-legacy-typedef-syntax"><a href="#DON’T-use-the-legacy-typedef-syntax" class="headerlink" title="DON’T use the legacy typedef syntax."></a>DON’T use the legacy typedef syntax.</h4><p>又是一个历史遗留问题，Dart 中有两种方式定义 typedef，推荐使用新的写法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// bad:</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">int</span> Comparison&lt;T&gt;(T a, T b);<br><span class="hljs-comment">// good:</span><br><span class="hljs-keyword">typedef</span> Comparison&lt;T&gt; = <span class="hljs-built_in">int</span> <span class="hljs-built_in">Function</span>(T a, T b);<br></code></pre></td></tr></table></figure><h4 id="PREFER-inline-function-types-over-typedefs"><a href="#PREFER-inline-function-types-over-typedefs" class="headerlink" title="PREFER inline function types over typedefs."></a>PREFER inline function types over typedefs.</h4><p>Dart 2 开始支持 inline function，我们可以直接定义方法作为类型签名。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilteredObservable</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> <span class="hljs-built_in">Function</span>(Event) _predicate;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>(Event)&gt; _observers;<br><br>  FilteredObservable(<span class="hljs-keyword">this</span>._predicate, <span class="hljs-keyword">this</span>._observers);<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>(Event)? notify(Event event) &#123;<br>    <span class="hljs-keyword">if</span> (!_predicate(event)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>(Event)? last;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> observer <span class="hljs-keyword">in</span> _observers) &#123;<br>      observer(event);<br>      last = observer;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> last;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果方法很复杂或者多次使用的情况下，推荐使用 typedef 代替。</p><h4 id="PREFER-using-function-type-syntax-for-parameters"><a href="#PREFER-using-function-type-syntax-for-parameters" class="headerlink" title="PREFER using function type syntax for parameters."></a>PREFER using function type syntax for parameters.</h4><p>就像方法可以作为类型标注一样，方法也可以作为参数，并且有特殊的语法支持：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 函数形式的参数：返回值 Function(参数类型) 参数名</span><br><span class="hljs-built_in">Iterable</span>&lt;T&gt; where(<span class="hljs-built_in">bool</span> <span class="hljs-built_in">Function</span>(T) predicate) =&gt; ...<br></code></pre></td></tr></table></figure><h4 id="AVOID-using-dynamic-unless-you-want-to-disable-static-checking"><a href="#AVOID-using-dynamic-unless-you-want-to-disable-static-checking" class="headerlink" title="AVOID using dynamic unless you want to disable static checking."></a>AVOID using <code>dynamic</code> unless you want to disable static checking.</h4><p>Dart 中 <code>dynamic</code> 是一个非常特殊的类型，它的作用和 <code>Object?</code> 类似，都允许任何对象，包括 null，但是 <code>dynamic</code> 还有额外的功能，那就是默认允许任何操作，包括对任何成员的访问，无论这种访问是否有效或者合法，Dart 不会在编译期对其进行检查，如果有异常只会在运行期才会被抛出。除非你确认想要这种效果，否则还是使用 <code>Obejct?</code> 或者 <code>Object</code> 代替 <code>dynamic</code>，然后用 <code>is</code> 对类型进行进行检查和类型提升。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">Returns a Boolean representation for [arg], which must</span></span><br><span class="hljs-comment">/// <span class="markdown">be a String or bool.</span></span><br><span class="hljs-built_in">bool</span> convertToBool(<span class="hljs-built_in">Object</span> arg) &#123;<br>  <span class="hljs-keyword">if</span> (arg <span class="hljs-keyword">is</span> <span class="hljs-built_in">bool</span>) <span class="hljs-keyword">return</span> arg;<br>  <span class="hljs-keyword">if</span> (arg <span class="hljs-keyword">is</span> <span class="hljs-built_in">String</span>) <span class="hljs-keyword">return</span> arg.toLowerCase() == <span class="hljs-string">&#x27;true&#x27;</span>;<br>  <span class="hljs-keyword">throw</span> ArgumentError(<span class="hljs-string">&#x27;Cannot convert <span class="hljs-subst">$arg</span> to a bool.&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DO-use-Future-lt-void-gt-as-the-return-type-of-asynchronous-members-that-do-not-produce-values"><a href="#DO-use-Future-lt-void-gt-as-the-return-type-of-asynchronous-members-that-do-not-produce-values" class="headerlink" title="DO use Future&lt;void&gt; as the return type of asynchronous members that do not produce values."></a>DO use <code>Future&lt;void&gt;</code> as the return type of asynchronous members that do not produce values.</h4><p>如果异步方法没有值需要返回，请使用 Future<void> 作为返回值。这样可以保证后续的操作，还有支持 await 等。</p><h4 id="AVOID-using-FutureOr-lt-T-gt-as-a-return-type"><a href="#AVOID-using-FutureOr-lt-T-gt-as-a-return-type" class="headerlink" title="AVOID using FutureOr&lt;T&gt; as a return type."></a>AVOID using <code>FutureOr&lt;T&gt;</code> as a return type.</h4><p>如果方法接受 <code>FutureOr&lt;int&gt;</code> 作为参数，那么它可以接收 int 或者 <code>Future&lt;int&gt;</code> 作为参数，这样可以方便调用者用 Future 包装 int 后再调用你的方法。但是，如果你返回 <code>FutureOr&lt;T&gt;</code>，方法的调用者就需要检查返回值到底是 int 还是 <code>Future&lt;int&gt;</code>。推荐的做法是直接返回 <code>Future&lt;T&gt;</code>，这样调用者可以直接使用 <code>await</code> 获取异步结果值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">Future&lt;<span class="hljs-built_in">int</span>&gt; triple(FutureOr&lt;<span class="hljs-built_in">int</span>&gt; value) <span class="hljs-keyword">async</span> =&gt; (<span class="hljs-keyword">await</span> value) * <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><h4 id="AVOID-positional-boolean-parameters"><a href="#AVOID-positional-boolean-parameters" class="headerlink" title="AVOID positional boolean parameters."></a>AVOID positional boolean parameters.</h4><p>可选布尔值不但容易让调用着分不清参数的含义，而且容易出错。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// bad:</span><br><span class="hljs-keyword">new</span> ListBox(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);<br><span class="hljs-comment">// good:</span><br>ListBox(scroll: <span class="hljs-keyword">true</span>, showScrollbars: <span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><h4 id="AVOID-optional-positional-parameters-if-the-user-may-want-to-omit-earlier-parameters"><a href="#AVOID-optional-positional-parameters-if-the-user-may-want-to-omit-earlier-parameters" class="headerlink" title="AVOID optional positional parameters if the user may want to omit earlier parameters."></a>AVOID optional positional parameters if the user may want to omit earlier parameters.</h4><p>对于可选位置参数，调用者可能省略中间或者后面部分，尽量把关键部分写在前面，或者使用具名位置参数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 调用方可能省略一部分可选位置参数，因此，最重要的写在前面</span><br><span class="hljs-built_in">String</span>.fromCharCodes(<span class="hljs-built_in">Iterable</span>&lt;<span class="hljs-built_in">int</span>&gt; charCodes, [<span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>, <span class="hljs-built_in">int?</span> end]);<br><br><span class="hljs-comment">// 使用具名位置参数就没有这个烦恼了</span><br><span class="hljs-built_in">Duration</span>(<br>    &#123;<span class="hljs-built_in">int</span> days = <span class="hljs-number">0</span>,<br>    <span class="hljs-built_in">int</span> hours = <span class="hljs-number">0</span>,<br>    <span class="hljs-built_in">int</span> minutes = <span class="hljs-number">0</span>,<br>    <span class="hljs-built_in">int</span> seconds = <span class="hljs-number">0</span>,<br>    <span class="hljs-built_in">int</span> milliseconds = <span class="hljs-number">0</span>,<br>    <span class="hljs-built_in">int</span> microseconds = <span class="hljs-number">0</span>&#125;);<br></code></pre></td></tr></table></figure><h4 id="AVOID-mandatory-parameters-that-accept-a-special-“no-argument”-value"><a href="#AVOID-mandatory-parameters-that-accept-a-special-“no-argument”-value" class="headerlink" title="AVOID mandatory parameters that accept a special “no argument” value."></a>AVOID mandatory parameters that accept a special “no argument” value.</h4><p>不要强制用户传 null，使用可选参数代替。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// bad:</span><br><span class="hljs-keyword">var</span> rest = string.substring(start, <span class="hljs-keyword">null</span>);<br><span class="hljs-comment">// good:</span><br><span class="hljs-keyword">var</span> rest = string.substring(start);<br></code></pre></td></tr></table></figure><h4 id="DO-use-inclusive-start-and-exclusive-end-parameters-to-accept-a-range"><a href="#DO-use-inclusive-start-and-exclusive-end-parameters-to-accept-a-range" class="headerlink" title="DO use inclusive start and exclusive end parameters to accept a range."></a>DO use inclusive start and exclusive end parameters to accept a range.</h4><p>当方法接收的参数用数字下标表示范围时，尽量采用前闭后开的习俗，包括开头下标但是不包括结尾的下标。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].sublist(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// [1, 2]</span><br><span class="hljs-string">&#x27;abcd&#x27;</span>.substring(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// &#x27;bc&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="Equality"><a href="#Equality" class="headerlink" title="Equality"></a>Equality</h3><h4 id="DO-override-hashCode-if-you-override"><a href="#DO-override-hashCode-if-you-override" class="headerlink" title="DO override hashCode if you override ==."></a>DO override <code>hashCode</code> if you override <code>==</code>.</h4><p>这是约定俗成的。两个对象相同则说明它们的哈希值一致，否则类似于 Map 等基于哈希值的集合就无法使用了。</p><h4 id="DO-make-your-operator-obey-the-mathematical-rules-of-equality"><a href="#DO-make-your-operator-obey-the-mathematical-rules-of-equality" class="headerlink" title="DO make your == operator obey the mathematical rules of equality."></a>DO make your <code>==</code> operator obey the mathematical rules of equality.</h4><ul><li>自反性：<code>a == a</code> 永远返回 true；</li><li>对称性：<code>a == b</code> 为 true 时 <code>b == a</code> 也必定为 true；</li><li>传递性：<code>a == b</code> 和 <code>b == c</code> 都为 true，则 <code>a == c</code> 也为 true；</li></ul><h4 id="AVOID-defining-custom-equality-for-mutable-classes"><a href="#AVOID-defining-custom-equality-for-mutable-classes" class="headerlink" title="AVOID defining custom equality for mutable classes."></a>AVOID defining custom equality for mutable classes.</h4><p>如果是可变的对象，比如拥有可变属性的对象，他们的哈希值会随着属性的变化而变化，但是大多数基于哈希的集合没有考虑到这一点，因此，最好不要自定义可变对象的相等性。</p><h4 id="DON’T-make-the-parameter-to-nullable"><a href="#DON’T-make-the-parameter-to-nullable" class="headerlink" title="DON’T make the parameter to == nullable."></a>DON’T make the parameter to <code>==</code> nullable.</h4><p>Dart 语言中 null 只能等于 null，因此，使用 <code>==</code> 比较对象时，右边的对象不能是 null。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> name;<br><br>  <span class="hljs-comment">// bad:</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span> ==(<span class="hljs-built_in">Object?</span> other) =&gt;<br>      other != <span class="hljs-keyword">null</span> &amp;&amp; other <span class="hljs-keyword">is</span> Person &amp;&amp; name == other.name;<br>  <br>  <span class="hljs-comment">// good:</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span> ==(<span class="hljs-built_in">Object</span> other) =&gt; other <span class="hljs-keyword">is</span> Person &amp;&amp; name == other.name;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart 学习笔记</title>
      <link href="/dart-notes/"/>
      <url>/dart-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="https://dart.dev/assets/shared/dart-logo-for-shares.png" alt="dart-logo"></p><blockquote><p>阅读 <a href="https://dart.dev/guides/language/language-tour">language-tour</a> 时做的一些笔记。</p></blockquote><h3 id="Important-concepts"><a href="#Important-concepts" class="headerlink" title="Important concepts"></a>Important concepts</h3><ul><li>Dart 中一切皆对象，除了 null 之外，所有对象都继承自 <a href="https://api.dart.dev/stable/dart-core/Object-class.html">Object</a></li><li>Dart 是强类型语言，但是类型标注是可选的，因为 Dart 中存在类型推断的机制，使用 <code>var</code> 关键字后编译器可以推断出具体的类型</li><li>当开启了空安全（dart ≧ v2.12）之后，对于可为空的值必须明确指出（用 <code>?</code>），可为空的值转换成不为空的值时使用 <code>!</code></li><li>当需要接收任意对象时使用 <code>Object?</code></li><li>Dart 支持泛型，比如 <code>List&lt;int&gt;</code></li><li>Dart 支持顶层函数和局部函数，同样也支持顶层变量</li><li>标识符可以以字母或者 <code>_</code> 开头，Dart 中 <code>_</code> 开头的方法表示私有方法</li><li>Dart 中也分为表达式 <em>expressions</em> 和声明 <em>statements</em>，表达式有返回值而声明无返回值</li><li>Dart 工具提供了两种类型的问题：警告和错误。警告表示代码可能无法正确执行，错误分为编译期错误和运行时错误，编译期错误会导致程序无法执行，而运行时错误是代码执行过程中抛出的异常。</li></ul><span id="more"></span><h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Bob&#x27;</span>;<br></code></pre></td></tr></table></figure><p>变量保存了引用，上面的例子中，name 变量包含了一个引用，该引用指向了一个值为 Bob 的 String 对象。</p><p>当使用 <code>var</code> 关键字时，变量的类型可以自动被推断出来，当然你也可以显式指出对象的类型。除此之外，如果你不想限定变量的类型，则可以使用 <code>Obejct</code> 或者 <code>dynamic</code>。</p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>如果没有开启空安全 (dart ≧ v2.12)，则所有未被初始化的变量都会被初始化为 null，哪怕是数字型的变量，因为 Dart 中一切都是对象。但是，如果开启了空安全，则所有不可为空的变量会被要求先初始化才能使用。</p><h4 id="Late-变量"><a href="#Late-变量" class="headerlink" title="Late 变量"></a>Late 变量</h4><p>Dart 2.12 之后添加了 <code>late</code> 修饰符，主要有两种用途：</p><ul><li>声明不可为空的顶层变量或者成员变量而不直接初始化值</li><li>延迟初始化变量（使用到时才初始化）</li></ul><p>第一种情况很好理解，因为如果开启了空安全，则顶层变量和成员变量必须要在声明的同时进行初始化，否则编译期无法保证空安全，所以引进 <code>late</code> 之后表明我们不想立马初始化该变量，但是它会在稍后被初始化。</p><p>第二种情况则适用于，一个变量对于程序来说是非必须的，或者性能消耗比较大，则可以用 <code>late</code> 修饰，这样，只有在使用到该变量时程序才会初始化它。比如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 如果该变量未被使用，则 _readThermometer() 不会被调用</span><br><span class="hljs-keyword">late</span> <span class="hljs-built_in">String</span> temperature = _readThermometer(); <span class="hljs-comment">// 延迟初始化</span><br></code></pre></td></tr></table></figure><h4 id="final-和-const"><a href="#final-和-const" class="headerlink" title="final 和 const"></a>final 和 const</h4><p><code>final</code> 修饰的变量只能被赋值一次，并且 <code>final</code> 修饰的顶层变量会在第一次被使用时初始化。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> name = <span class="hljs-string">&#x27;Bob&#x27;</span>; <span class="hljs-comment">// final 修饰的变量可以没有类型标注</span><br><span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> nickname = <span class="hljs-string">&#x27;Bobby&#x27;</span>;<br><br>name = <span class="hljs-string">&#x27;Alice&#x27;</span>; <span class="hljs-comment">// Error: a final variable can only be set once.</span><br></code></pre></td></tr></table></figure><p><code>const</code> 变量是编译期常量（同时也是 final 的）。如果 <code>const</code> 修饰的是成员变量，则需要用 <code>static const</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> bar = <span class="hljs-number">1000000</span>; <span class="hljs-comment">// Unit of pressure (dynes/cm2)</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> atm = <span class="hljs-number">1.01325</span> * bar; <span class="hljs-comment">// Standard atmosphere</span><br></code></pre></td></tr></table></figure><p><code>final</code> 和 <code>const</code> 的不同之处在于，<code>final</code> 修饰的对象不能被修改，但是其属性可以被修改；而 <code>const</code> 修饰的对象和属性都不能被修改，它们是<em>不可变的</em>。</p><h3 id="Build-in-types"><a href="#Build-in-types" class="headerlink" title="Build-in types"></a>Build-in types</h3><h4 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h4><ul><li><a href="https://api.dart.dev/stable/dart-core/int-class.html">int</a>, 不大于 64 位</li><li><a href="https://api.dart.dev/stable/dart-core/double-class.html">double</a>, 64 位浮点数</li></ul><p>int 和 double 都是 <a href="https://api.dart.dev/stable/dart-core/num-class.html">num</a> 的子类，num 类型的数据包含了基本的操作符，比如加减乘以及 abs(), ceil(), floor(), 位运算等。</p><h4 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h4><ul><li>Dart 中使用 String 可以用单引号或者双引号。不过，在单引号中的 String 对象中需要对 <code>&#39;</code> 进行转义。</li><li>我们可以使用 <code>$&#123;expression&#125;</code> 在 String 中引用变量或者表达式。</li><li>我们可以用 <code>==</code> 比较两个 String 的值是否一致。</li><li>我们可以在 String 值之前加 <code>r</code> 来表示原始类型 (raw) 的 String，这样就不需要转义。</li><li>我们可以使用三个单引号或者双引号来创建多行 String，同样不需要在其中使用转义符。</li><li>我们可以使用字符相乘，但是字符必须在乘数系数的左边，如 <code>🔥 * 3</code>。</li><li>我们可以使用字符填充方法，比如 <code>paddingLeft</code> 和 <code>paddingRight</code>。</li></ul><h4 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h4><p>Dart 中使用 <code>bool</code> 表示布尔类型的值。</p><h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><p>Dart 中数组是用 <code>List</code> 表示的。可以用如下的方式创建数组：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> list = [<br>  <span class="hljs-string">&#x27;Car&#x27;</span>,<br>  <span class="hljs-string">&#x27;Boat&#x27;</span>,<br>  <span class="hljs-string">&#x27;Plane&#x27;</span>, <span class="hljs-comment">// Dart 中允许添加 trailing comma，这样可以防止复制粘贴出错</span><br>];<br></code></pre></td></tr></table></figure><p>Dart 2.3 之后添加了扩展运算符 (<code>...</code>) 和空值敏感的扩展运算符 (<code>...?</code>)：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> list2 = [<span class="hljs-number">0</span>, ...list];<br><span class="hljs-keyword">assert</span>(list2.length == <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>Dart 中还有提供了<em>集合 if</em> 和<em>集合 for</em> 的操作：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> nav = [<br>  <span class="hljs-string">&#x27;Home&#x27;</span>,<br>  <span class="hljs-string">&#x27;Mall&#x27;</span>,<br>  <span class="hljs-string">&#x27;Mine&#x27;</span>,<br>  <span class="hljs-keyword">if</span> (promoActive) <span class="hljs-string">&#x27;Outlet&#x27;</span><br>];<br><br><span class="hljs-keyword">var</span> listOfInts = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> listOfStrings = [<br>  <span class="hljs-string">&#x27;#0&#x27;</span>,<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> listOfInts) <span class="hljs-string">&#x27;#<span class="hljs-subst">$i</span>&#x27;</span><br>];<br></code></pre></td></tr></table></figure><p>关于其它常见的 API 见 <a href="https://dart.dev/guides/libraries/library-tour#collections">collections</a>。</p><h4 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h4><p>Dart 中同样用 <a href="https://api.dart.dev/stable/dart-core/Set-class.html"><code>Set</code></a> 类型表示无序且唯一的集合。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> halogens = &#123;<span class="hljs-string">&#x27;fluorine&#x27;</span>, <span class="hljs-string">&#x27;chlorine&#x27;</span>, <span class="hljs-string">&#x27;bromine&#x27;</span>, <span class="hljs-string">&#x27;iodine&#x27;</span>, <span class="hljs-string">&#x27;astatine&#x27;</span>&#125;;<br></code></pre></td></tr></table></figure><p>Set 和 List 一样，支持扩展运算符、集合 if 和集合 for 的操作。</p><h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><p><a href="https://api.dart.dev/stable/dart-core/Map-class.html">Map</a> 是包含了 key 和 value 集合，其中 key 必须唯一。Dar 中的 Map 同样使用花括号 <code>&#123;&#125;</code> 表示，而且优先级比集合 Set 更高：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> gifts = &#123;<br>  <span class="hljs-comment">// Key:    Value</span><br>  <span class="hljs-string">&#x27;first&#x27;</span>: <span class="hljs-string">&#x27;partridge&#x27;</span>,<br>  <span class="hljs-string">&#x27;second&#x27;</span>: <span class="hljs-string">&#x27;turtledoves&#x27;</span>,<br>  <span class="hljs-string">&#x27;fifth&#x27;</span>: <span class="hljs-string">&#x27;golden rings&#x27;</span><br>&#125;; <span class="hljs-comment">// 自动推断出 map 的类型为 Map&lt;String, String&gt;</span><br><br><span class="hljs-comment">// 也可以通过这种方式创建</span><br><span class="hljs-keyword">var</span> gifts = <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt;();<br>gifts[<span class="hljs-string">&#x27;first&#x27;</span>] = <span class="hljs-string">&#x27;partridge&#x27;</span>;<br>gifts[<span class="hljs-string">&#x27;second&#x27;</span>] = <span class="hljs-string">&#x27;turtledoves&#x27;</span>;<br>gifts[<span class="hljs-string">&#x27;fifth&#x27;</span>] = <span class="hljs-string">&#x27;golden rings&#x27;</span>;<br><br><span class="hljs-keyword">var</span> names = &#123;&#125;; <span class="hljs-comment">// 这种方式创建的是 map 而不是 set</span><br><br><span class="hljs-comment">// 访问 map 的语法 []，其实类似调用方法，具体获取到的值是不确定的</span><br><span class="hljs-comment">// 报错：Const variables must be initialized with a constant value</span><br><span class="hljs-keyword">const</span> lightRed = Colors.red[<span class="hljs-number">200</span>];<br></code></pre></td></tr></table></figure><h4 id="Runes-and-grapheme-clusters"><a href="#Runes-and-grapheme-clusters" class="headerlink" title="Runes and grapheme clusters"></a>Runes and grapheme clusters</h4><p>Dart 中，使用 <a href="https://api.dart.dev/stable/dart-core/Runes-class.html">Runes</a> 表示字符串的 Unicode 字符集。我们可以使用 <a href="https://pub.dev/packages/characters">characters</a> 包下的类来操作字符。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:characters/characters.dart&#x27;</span>;<br>...<br><span class="hljs-keyword">var</span> hi = <span class="hljs-string">&#x27;Hi ✡️&#x27;</span>;<br><span class="hljs-built_in">print</span>(hi);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The end of the string: <span class="hljs-subst">$&#123;hi.substring(hi.length - <span class="hljs-number">1</span>)&#125;</span>&#x27;</span>);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The last character: <span class="hljs-subst">$&#123;hi.characters.last&#125;</span>\n&#x27;</span>); <span class="hljs-comment">// 使用 characters 才能正常打印 emoji</span><br></code></pre></td></tr></table></figure><p>Dart 中的字符串使用 UTF-16 编码，如果要用字符串表示 Unicode 字符则需要使用 <code>\uXXXX</code> 的语法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\u&#123;1f606&#125;&#x27;</span>); <span class="hljs-comment">// 😆</span><br></code></pre></td></tr></table></figure><h4 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h4><p>Dart 中使用 <a href="https://api.dart.dev/stable/dart-core/Symbol-class.html">Symbol</a> 对象表示操作符或者标识符，用 <code>#</code> + 修饰符表示。</p><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Dart 中一切都是对象，函数的类型用 <a href="https://api.dart.dev/stable/dart-core/Function-class.html">Function</a> 表示，而且函数也可以作为变量或者作为方法的参数进行传递。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> say(<span class="hljs-built_in">String</span> content) &#123;<br>  <span class="hljs-built_in">print</span>(content);<br>&#125;<br><br><span class="hljs-comment">// Dart 中只有单个表达式的函数可以使用缩写，用 =&gt; 代替 &#123; &#125;</span><br><span class="hljs-built_in">bool</span> isEvenNumber(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>) =&gt; <span class="hljs-built_in">num</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">num</span> % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 这里的参数 body 表示一个返回类型为 Future&lt;T&gt; 的函数</span><br><span class="hljs-keyword">void</span> calculate&lt;T&gt;(Future&lt;T&gt; <span class="hljs-built_in">Function</span>() body) &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>Dart 中的函数除了可以有普通的参数，还可以是<em>具名参数</em>或者<em>可选位置参数</em>。如果使用了 Sound null safety (sdk ≧ 2.12)，且没有指明默认值，则这两种类型参数都必须是可为空的，即参数后跟 <code>?</code>。</p><h5 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h5><p>具名参数 (Named parameters) 是必须写出名字的参数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 函数中使用 &#123;&#125; 圈起来的参数即具名参数</span><br><span class="hljs-keyword">void</span> enableFlags(&#123;<span class="hljs-built_in">bool?</span> bold, <span class="hljs-built_in">int?</span> index&#125;) &#123;&#125;<br><br><span class="hljs-comment">// 可以给具名参数添加默认值</span><br><span class="hljs-keyword">void</span> enableFlags(&#123;<span class="hljs-built_in">bool?</span> bold = <span class="hljs-keyword">true</span>&#125;) &#123;&#125;<br><br><span class="hljs-comment">// 用 required 标记具名参数中必须有的参数</span><br><span class="hljs-keyword">void</span> enableFlags(&#123;<span class="hljs-keyword">required</span> <span class="hljs-built_in">bool?</span> bold&#125;) &#123;&#125;<br><br><span class="hljs-comment">// 调用函数，无参数</span><br>enableFlags()<br><br><span class="hljs-comment">// 调用时如果有参数名则必须写参数名称</span><br>enableFlags(<br>  bold: <span class="hljs-keyword">true</span>,<br>  hidden: <span class="hljs-keyword">false</span><br>);<br></code></pre></td></tr></table></figure><p>Dart 2.17 之后，可选具名参数的位置可以在普通参数之前：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// Dart 2.17 之前</span><br><span class="hljs-built_in">List</span>.generate(<span class="hljs-number">5</span>, (index) =&gt; index, growable: <span class="hljs-keyword">true</span>);<br><br><span class="hljs-comment">// Dart 2.17 之后</span><br><span class="hljs-built_in">List</span>.generate(<span class="hljs-number">5</span>, growable: <span class="hljs-keyword">true</span>, (index) =&gt; index);<br></code></pre></td></tr></table></figure><h5 id="可选位置参数"><a href="#可选位置参数" class="headerlink" title="可选位置参数"></a>可选位置参数</h5><p>可选位置参数 (Optional positional parameters) 和普通的参数唯一的不同之处是它是可选的😅。用 <code>[]</code> 圈起来的参数即可选位置参数。比如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// title 是必须的位置参数，而 subtitle 是可选的</span><br><span class="hljs-keyword">void</span> say(<span class="hljs-built_in">String</span> title, [<span class="hljs-built_in">String?</span> subtitle]) &#123;<br>  <span class="hljs-built_in">print</span>(title);<br>  <span class="hljs-keyword">if</span> (subtitle != <span class="hljs-keyword">null</span>) <span class="hljs-built_in">print</span>(subtitle);<br>&#125;<br><br><span class="hljs-comment">// 可选位置参数也可以有默认值</span><br><span class="hljs-keyword">void</span> sing(<span class="hljs-built_in">String</span> song, [<span class="hljs-built_in">String?</span> instrument = <span class="hljs-string">&#x27;Piano&#x27;</span>]) &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main() 函数"></a>main() 函数</h4><p>每个应用都有一个 main() 函数作为应用的入口。main() 函数通常返回空，并且可以有数组作为参数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; arguments) &#123;<br>  <span class="hljs-built_in">print</span>(arguments);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>Dart 中的匿名函数和其它语言中类似，可以有多个参数或者没有参数，后跟方法体，形式如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">([[<span class="hljs-built_in">Type</span>] param1[, …]]) &#123;<br>  codeBlock;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果只有单个的表达式或者只有返回值，可以使用箭头表达式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">([[<span class="hljs-built_in">Type</span>] param1[, …]]) =&gt; expression; <span class="hljs-comment">// 如果是赋值表达式，则该值就是返回值</span><br></code></pre></td></tr></table></figure><h4 id="Lexical-scope"><a href="#Lexical-scope" class="headerlink" title="Lexical scope"></a>Lexical scope</h4><p>Dart 同样是具有<strong>词法作用域</strong>或静态作用域的语言，即只要还在代码作用域内的值，都能访问到。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">bool</span> topLevel = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> insideMain = <span class="hljs-keyword">true</span>;<br><br>  <span class="hljs-keyword">void</span> myFunction() &#123;<br>    <span class="hljs-keyword">var</span> insideFunction = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">void</span> nestedFunction() &#123;<br>      <span class="hljs-keyword">var</span> insideNestedFunction = <span class="hljs-keyword">true</span>;<br><br>      <span class="hljs-keyword">assert</span>(topLevel);<br>      <span class="hljs-keyword">assert</span>(insideMain);<br>      <span class="hljs-keyword">assert</span>(insideFunction);<br>      <span class="hljs-keyword">assert</span>(insideNestedFunction);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Lexical-closures"><a href="#Lexical-closures" class="headerlink" title="Lexical closures"></a>Lexical closures</h4><p>词法闭包也叫<strong>函数闭包</strong>，和 JS 中的闭包概念类似，即定义在函数中的函数，同时使得该函数能够访问其它函数作用域中的变量。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Function</span> makeAdder(<span class="hljs-built_in">int</span> addBy) &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span> i) =&gt; addBy + i;<br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> add2 = makeAdder(<span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">print</span>(add2(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 这里 add2 访问了 makeAdder 中定义的值，也即把 2 保存了下来</span><br>  <span class="hljs-built_in">print</span>(makeAdder(<span class="hljs-number">10</span>)(<span class="hljs-number">3</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><p>Dart 中支持的操作符表，见 <a href="https://dart.dev/guides/language/language-tour#operators">Operators</a>。</p><h4 id="Cascade-notation"><a href="#Cascade-notation" class="headerlink" title="Cascade notation"></a>Cascade notation</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// cascade notation，可以在赋值的基础上对属性和方法进行调用</span><br><span class="hljs-comment">// 使得创建对象和属性赋值变得更简单，省去创建临时对象的步骤</span><br><span class="hljs-keyword">var</span> paint = Paint()<br>  ..color = <span class="hljs-string">&#x27;Black&#x27;</span><br>  ..strokeCap = <span class="hljs-string">&#x27;Round&#x27;</span><br>  ..strokeWidth = <span class="hljs-number">5.0</span>;<br><span class="hljs-built_in">print</span>(paint);<br></code></pre></td></tr></table></figure><h3 id="Control-flow-statements"><a href="#Control-flow-statements" class="headerlink" title="Control flow statements"></a>Control flow statements</h3><h4 id="switch-and-case"><a href="#switch-and-case" class="headerlink" title="switch and case"></a>switch and case</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// Dart 中的 case 语法有 fall through 机制</span><br><span class="hljs-comment">// 但是如果定义了 case 内容而没有 break 则会报错</span><br><span class="hljs-keyword">var</span> command = <span class="hljs-string">&#x27;CLOSED&#x27;</span>;<br><span class="hljs-keyword">switch</span> (command) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EARLY_CLOSE&#x27;</span>: <span class="hljs-comment">// fall through to &#x27;CLOSED&#x27;</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;CLOSED&#x27;</span>:<br>    <span class="hljs-keyword">var</span> youCantAccess = <span class="hljs-number">1</span>; <span class="hljs-comment">// Dart 中的 case 自带作用域</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;bye bye&#x27;</span>);<br>    <span class="hljs-keyword">continue</span> afterClosed; <span class="hljs-comment">// 可以使用 label 绕过无 break 的限制</span><br><br>  afterClosed:<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;CLOSED_AFTER&#x27;</span>:<br>    <span class="hljs-comment">// print(youCantAccess); // undefined</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;see you tomorrow&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p>Dart 中所有异常都是 unchecked exceptions，意味着 Dart 不会强制你去捕捉异常。</p><h4 id="Catch"><a href="#Catch" class="headerlink" title="Catch"></a>Catch</h4><p>Dart 中的 try catch 语法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">try</span> &#123;<br>  breedMoreLlamas();<br>&#125; <span class="hljs-keyword">on</span> OutOfLlamasException &#123;<br>  <span class="hljs-comment">// 特定类型的异常</span><br>  buyMoreLlamas();<br>&#125; <span class="hljs-keyword">on</span> Exception <span class="hljs-keyword">catch</span> (e, s) &#123; <span class="hljs-comment">// 第二个参数为错误栈</span><br>  <span class="hljs-comment">// 其它类型的异常</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Unknown exception: <span class="hljs-subst">$e</span>&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-comment">// 所有其它未指定的错误</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Something really unknown: <span class="hljs-subst">$e</span>&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>Dart 中一切皆对象，除了 null 之外，所有对象都是某个类的实例。除了可以继承类之外，Dart 还提供了一种基于 mixin 的继承，也就是说可以通过 with 关键字继承某个没有构造器的类来扩展功能，还可以使用<a href="https://dart.dev/guides/language/extension-methods">扩展函数</a>。</p><h4 id="Using-class-members"><a href="#Using-class-members" class="headerlink" title="Using class members"></a>Using class members</h4><p>所有对象都由成员变量和方法构成，使用 <code>.</code> 的语法访问对象的属性或者方法，使用 <code>?.</code> 访问可为空对象的属性和方法。</p><h4 id="Using-constructors"><a href="#Using-constructors" class="headerlink" title="Using constructors"></a>Using constructors</h4><p>Dart 中创建构造器除了可以使用类名，也可以使用 <code>类名.构造器名()</code> 的形式。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DummyClass</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">// 默认构造函数</span><br>  DummyClass(<span class="hljs-keyword">this</span>.i);<br>  <br>  <span class="hljs-comment">// 我们可以为构造函数定义名称，这种构造器被称为「具名构造器」</span><br>  DummyClass.create(<span class="hljs-built_in">int</span> i, <span class="hljs-built_in">String</span> message) &#123;<br>    <span class="hljs-built_in">print</span>(message);<br>    <span class="hljs-keyword">this</span>.i = i;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 在「具名构造器」后为成员变量赋值</span><br>  DummyClass.ten() : i = <span class="hljs-number">10</span> &#123; <span class="hljs-comment">// :后的部分称为 initializer list</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Ten <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.i&#125;</span>&#x27;</span>); <span class="hljs-comment">// print: Ten 10</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Getting-an-object’s-type"><a href="#Getting-an-object’s-type" class="headerlink" title="Getting an object’s type"></a>Getting an object’s type</h4><p>我们可以使用 <code>runtimeType</code> 获得对象的类型 <a href="https://api.dart.dev/stable/dart-core/Type-class.html">Type</a>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> dummy = DummyClass.create(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The type of a is <span class="hljs-subst">$&#123;dummy.runtimeType&#125;</span>&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="Instance-variables"><a href="#Instance-variables" class="headerlink" title="Instance variables"></a>Instance variables</h4><ul><li>所有未初始化可为空的实例变量都会被初始化为 null。</li><li>所有实例变量都会默认自带 getter 函数，非 final 的实例变量和不带初始化器的 late final 实例变量会自动生成 setter 函数。</li><li>非延迟初始化的实例变量的值会在对象创建之后，构造器和初始化器列表执行之前，就被赋值。可为空的赋值为 null，不可为空的赋值为初始值。</li><li>实例变量可以是 final 的，但是必须在构造器或者初始化列表中进行赋值。</li></ul><h4 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h4><p>Dart 中类的构造器和其它语言类似：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-built_in">double</span> x = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">double</span> y = <span class="hljs-number">0</span>;<br><br>  Point(<span class="hljs-built_in">double</span> x, <span class="hljs-built_in">double</span> y) &#123;<br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，Dart 提供了一种语法糖的写法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-built_in">double</span> x = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">double</span> y = <span class="hljs-number">0</span>;<br><br>  Point(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="具名构造器"><a href="#具名构造器" class="headerlink" title="具名构造器"></a>具名构造器</h5><p>我们可以通过具名构造器 (Named constructors) 为一个类实现多个构造器。不过具名构造器不能被继承，如果想在子类中使用和父类相同的构造器，只能为子类单独实现。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weather</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> humidity = <span class="hljs-string">&#x27;&#x27;</span>;<br><br>  Weather.display(<span class="hljs-keyword">this</span>.humidity);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shower</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Weather</span></span>&#123;<br>  Shower.display(<span class="hljs-built_in">String</span> humidity) : <span class="hljs-keyword">super</span>.display(humidity);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="构造器初始化列表"><a href="#构造器初始化列表" class="headerlink" title="构造器初始化列表"></a>构造器初始化列表</h5><p>除了调用父类构造器之外，我们还可以在构造器方法体执行之前初始化成员变量，称为 <em>Initializer list</em>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">Point.fromJson(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">double</span>&gt; json)<br>    : x = json[<span class="hljs-string">&#x27;x&#x27;</span>]!,<br>      y = json[<span class="hljs-string">&#x27;y&#x27;</span>]!,<br><span class="hljs-keyword">super</span>(x) &#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;In Point.fromJson(): (<span class="hljs-subst">$x</span>, <span class="hljs-subst">$y</span>)&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化起列表中，调用父类构造器必须放到最后。</p><h5 id="构造器初始化顺序"><a href="#构造器初始化顺序" class="headerlink" title="构造器初始化顺序"></a>构造器初始化顺序</h5><p>默认情况下，子类会先调用父类中的默认构造函数（未定义的话会生成一个无参构造器），如果存在构造器初始化列表 (Initializer list) 则会先调用它们。所以，当使用默认构造函数创建对象时，构造器的初始化顺序为：</p><ol><li>构造器初始化列表</li><li>父类无参构造器</li><li>子类无参构造器</li></ol><p>另外，如果父类未定义默认构造器，则子类实现构造器时必须先调用父类的某个具名构造器。</p><h5 id="重定向构造器"><a href="#重定向构造器" class="headerlink" title="重定向构造器"></a>重定向构造器</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-built_in">double</span> x, y;<br><br>  Point(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);<br><br>  <span class="hljs-comment">// 使用 this 关键字重定向到默认构造器</span><br>  Point.alongXAxis(<span class="hljs-built_in">double</span> x) : <span class="hljs-keyword">this</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="常量构造器"><a href="#常量构造器" class="headerlink" title="常量构造器"></a>常量构造器</h5><p>当你想要创建的对象是编译期常量时（比如用于创建注解），可以使用 <code>const</code> 修饰构造器：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImmutablePoint</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> ImmutablePoint origin = ImmutablePoint(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> x, y; <span class="hljs-comment">// 记得所有的变量都要是 final 的</span><br><br>  <span class="hljs-keyword">const</span> ImmutablePoint(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用常量构造器 (Constant Constructors) 初始化对象时，使用相同的值的对象只会在第一次创建时被初始化，也就是说<strong>相同值的对象只会初始化一次</strong>。</p><h5 id="工厂构造器"><a href="#工厂构造器" class="headerlink" title="工厂构造器"></a>工厂构造器</h5><p>使用 <code>factory</code> 关键字的构造器，适用于不需要每次创建新对象的情况，比如使用了缓存。另一个使用场景是通过 JSON 数据初始化对象。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> name;<br>  <span class="hljs-built_in">bool</span> mute = <span class="hljs-keyword">false</span>;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Logger&gt; _cache = &lt;<span class="hljs-built_in">String</span>, Logger&gt;&#123;&#125;;<br><br>  <span class="hljs-keyword">factory</span> Logger(<span class="hljs-built_in">String</span> name) &#123;<br>    <span class="hljs-keyword">return</span> _cache.putIfAbsent(name, () =&gt; Logger._internal(name));<br>  &#125;<br><br>  <span class="hljs-keyword">factory</span> Logger.fromJson(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; json) &#123;<br>    <span class="hljs-keyword">return</span> Logger(json[<span class="hljs-string">&#x27;name&#x27;</span>].toString());<br>  &#125;<br><br>  Logger._internal(<span class="hljs-keyword">this</span>.name);<br><br>  <span class="hljs-keyword">void</span> log(<span class="hljs-built_in">String</span> msg) &#123;<br>    <span class="hljs-keyword">if</span> (!mute) <span class="hljs-built_in">print</span>(msg);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Getters-and-setters"><a href="#Getters-and-setters" class="headerlink" title="Getters and setters"></a>Getters and setters</h4><p>使用 getters 和 setters 方法定义一些需要通过计算得到的值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>&#123;<br>  <span class="hljs-built_in">double</span> left, top, width, height;<br><br>  Rectangle(<span class="hljs-keyword">this</span>.left, <span class="hljs-keyword">this</span>.top, <span class="hljs-keyword">this</span>.width, <span class="hljs-keyword">this</span>.height);<br><br>  <span class="hljs-comment">// Define two calculated properties: right and bottom.</span><br>  <span class="hljs-built_in">double</span> <span class="hljs-keyword">get</span> right =&gt; left + width;<br>  <span class="hljs-keyword">set</span> right(<span class="hljs-built_in">double</span> value) =&gt; left = value - width;<br><br>  <span class="hljs-built_in">double</span> <span class="hljs-keyword">get</span> bottom =&gt; top + height;<br>  <span class="hljs-keyword">set</span> bottom(<span class="hljs-built_in">double</span> value) =&gt; top = value - height;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Abstract-classes"><a href="#Abstract-classes" class="headerlink" title="Abstract classes"></a>Abstract classes</h4><p>Dart 中的抽象类同样无法被直接实例化，如果需要实例化可以通过<a href="#%E5%B7%A5%E5%8E%82%E6%9E%84%E9%80%A0%E5%99%A8">工厂构造器</a>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractContainer</span> </span>&#123;<br>  <span class="hljs-comment">// Define constructors, fields, methods...</span><br><br>  <span class="hljs-keyword">void</span> updateChildren(); <span class="hljs-comment">// Abstract method.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，在一个非 abstract 类中，我们可以使用 <code>external</code> 关键字修饰一个需要由子类去实现的抽象方法，例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> </span>&#123;<br>  <span class="hljs-keyword">external</span> <span class="hljs-keyword">void</span> doSomething();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Implicit-interfaces"><a href="#Implicit-interfaces" class="headerlink" title="Implicit interfaces"></a>Implicit interfaces</h4><p>Dart 中所有的类都可以作为接口被实现。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 使用 implement 关键字实现一个或多个接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>, <span class="hljs-title">Location</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用直接继承获得所有父类的实现，也可以使用 <code>implements</code> 将类作为接口实现，此时子类必须提供所有父类的属性和方法的实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">String</span> name;<br><br>  <span class="hljs-built_in">int</span> age;<br>  <br>  Animal(<span class="hljs-keyword">this</span>.age);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">String</span> name = <span class="hljs-string">&quot;Dog&quot;</span>;<br>  <br>  Dog() : <span class="hljs-keyword">super</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">// 如果使用 implements 则必须实现所有类属性</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animal</span> </span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">String</span> name = <span class="hljs-string">&quot;Cat&quot;</span>; <br>  <br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">int</span> age = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Extending-a-class"><a href="#Extending-a-class" class="headerlink" title="Extending a class"></a>Extending a class</h4><p>Dart 中所有类都可以被继承，使用 <code>extends</code> 关键字继承父类，使用 <code>super</code> 引用父类。</p><p>Dart 2.17 之后允许在构造器中使用 super 语法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OutlinedButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Button</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> OutlinedButton(&#123;<br>    <span class="hljs-keyword">super</span>.key,<br>    <span class="hljs-keyword">super</span>.onPress = () &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Pressed OutlinedButton&#x27;</span>);<br>    &#125;,<br>    <span class="hljs-keyword">super</span>.onLongPress,<br>    <span class="hljs-keyword">required</span> Widget <span class="hljs-keyword">super</span>.child<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就不需要调用父类构造器，写出 super(…) 这样的模板代码了。</p><h4 id="Extension-methods"><a href="#Extension-methods" class="headerlink" title="Extension methods"></a>Extension methods</h4><p>和 Kotlin 类似，在 Dart 中我们同样可以通过<a href="https://dart.dev/guides/language/extension-methods">扩展函数</a>扩充函数库。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">extension</span> NumberParsing <span class="hljs-keyword">on</span> <span class="hljs-built_in">String</span> &#123;<br>  <span class="hljs-built_in">int</span> parseInt() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>.parse(<span class="hljs-keyword">this</span>);<br>  &#125;<br>  <br>  <span class="hljs-built_in">double</span> parseDouble() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>.parse(<span class="hljs-keyword">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Enumerated-types"><a href="#Enumerated-types" class="headerlink" title="Enumerated types"></a>Enumerated types</h4><p>Dart 中的枚举类和 Java 中类似。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">enum</span> Color &#123; red, green, blue &#125;<br></code></pre></td></tr></table></figure><p>Dart 2.17 之后允许在 enum 类中使用成员变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">enum</span> Water &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> temperature;<br>  <span class="hljs-keyword">const</span> Water(<span class="hljs-keyword">this</span>.temperature);<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举类有以下限制：</p><ul><li>无法继承、实现或者混用 (mixin) 枚举类</li><li>无法直接实例化</li></ul><h4 id="Adding-features-to-a-class-mixins"><a href="#Adding-features-to-a-class-mixins" class="headerlink" title="Adding features to a class: mixins"></a>Adding features to a class: mixins</h4><p>Dart 中还提供了另外一种复用代码的方式 mixin，我们可以把可复用的代码放到 mixin 类中。子类使用 <code>with</code> 关键字进行关联。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">mixin</span> Musical &#123;<br>  <span class="hljs-built_in">bool</span> canPlayPiano = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-built_in">bool</span> canCompose = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-built_in">bool</span> canConduct = <span class="hljs-keyword">false</span>;<br><br>  <span class="hljs-keyword">void</span> entertainMe() &#123;<br>    <span class="hljs-keyword">if</span> (canPlayPiano) &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Playing piano&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (canConduct) &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Waving hands&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Humming to self&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Musician</span> <span class="hljs-title">with</span> <span class="hljs-title">Musical</span> </span>&#123;<br>  <span class="hljs-comment">// ···</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Maestro</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> <span class="hljs-title">with</span> <span class="hljs-title">Musical</span> </span>&#123;<br>  Maestro(<span class="hljs-built_in">String</span> maestroName) : <span class="hljs-keyword">super</span>(maestroName) &#123;<br>    canPlayPiano = <span class="hljs-keyword">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，我们还可以限制 mixin 的使用范围 (<code>on</code>)，以及像接口一样使用逗号 (<code>,</code>) 分割继承多个 mixin：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Musician</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">mixin</span> MusicalPerformer <span class="hljs-keyword">on</span> Musician &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingerDancer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Musician</span> <span class="hljs-title">with</span> <span class="hljs-title">MusicalPerformer</span>, <span class="hljs-title">DancerPerformer</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Class-variables-and-methods"><a href="#Class-variables-and-methods" class="headerlink" title="Class variables and methods"></a>Class variables and methods</h4><p>Dart 中的类同样可以使用静态变量和常量，以及静态方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DummyClass</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> f() &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><p>Dart 中的泛型（参数化类型）和 Java 以及 Kotlin 等语言非常相似，使用 <code>&lt;&gt;</code> 表示泛型。</p><h4 id="为什么使用泛型"><a href="#为什么使用泛型" class="headerlink" title="为什么使用泛型"></a>为什么使用泛型</h4><p>使用泛型一般有两个目的：</p><ul><li>指明泛型类型之后，减少代码出错。比如在集合中加入不该加入的值。</li><li>使用泛型减少复制粘贴的代码。比如持有某个对象的类，当需要改变持有的对象而其它部分不发生变化时，如果使用了泛型就不用重新复制一个新的类。</li></ul><h4 id="Using-collection-literals"><a href="#Using-collection-literals" class="headerlink" title="Using collection literals"></a>Using collection literals</h4><p>即在使用集合时定义集合类型，形式如 <code>&lt;type&gt;[]</code> or <code>&lt;type&gt;&#123;&#125;</code> or <code>&lt;keyType, valueType&gt;&#123;&#125;</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> names = &lt;<span class="hljs-built_in">String</span>&gt;[<span class="hljs-string">&#x27;Seth&#x27;</span>, <span class="hljs-string">&#x27;Kathy&#x27;</span>, <span class="hljs-string">&#x27;Lars&#x27;</span>];<br><span class="hljs-keyword">var</span> uniqueNames = &lt;<span class="hljs-built_in">String</span>&gt;&#123;<span class="hljs-string">&#x27;Seth&#x27;</span>, <span class="hljs-string">&#x27;Kathy&#x27;</span>, <span class="hljs-string">&#x27;Lars&#x27;</span>&#125;;<br></code></pre></td></tr></table></figure><h4 id="泛型集合及其类型"><a href="#泛型集合及其类型" class="headerlink" title="泛型集合及其类型"></a>泛型集合及其类型</h4><p>Java 中，由于泛型存在<a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">类型擦除</a>，所以是无法确定集合的确切类型的。但是，Dart 中的泛型是 <em>reified</em> 的，也就是说在运行时也能得到集合的类型信息。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> names = &lt;<span class="hljs-built_in">String</span>&gt;[];<br>names.addAll([<span class="hljs-string">&#x27;Seth&#x27;</span>, <span class="hljs-string">&#x27;Kathy&#x27;</span>, <span class="hljs-string">&#x27;Lars&#x27;</span>]);<br><span class="hljs-built_in">print</span>(names <span class="hljs-keyword">is</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="泛型参数类型的限制"><a href="#泛型参数类型的限制" class="headerlink" title="泛型参数类型的限制"></a>泛型参数类型的限制</h4><p>Dart 中限制泛型参数边界同样使用 <code>extends</code> 关键字。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SomeBaseClass</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// Implementation goes here...</span><br>  <span class="hljs-built_in">String</span> toString() =&gt; <span class="hljs-string">&quot;Instance of &#x27;Foo&lt;<span class="hljs-subst">$T</span>&gt;&#x27;&quot;</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Extender</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SomeBaseClass</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><h3 id="Libraries-and-visibility"><a href="#Libraries-and-visibility" class="headerlink" title="Libraries and visibility"></a>Libraries and visibility</h3><p>Dart 中，我们可以通过 <code>import </code> 和 <code>library</code> 指示符创建模块化的、可共享的代码库。另外，即使不使用 <code>library</code> 指示符，每个 dart app 都是一个 library。</p><p>导入一个 library 的语法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:html&#x27;</span>; <span class="hljs-comment">// html 是 dart 内建的库，所以使用 dart 作为命名空间</span><br></code></pre></td></tr></table></figure><p>其它库可以使用文件路径或者 <code>package:</code> 命名空间：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:test/test.dart&#x27;</span>; <span class="hljs-comment">// 导入一些三方库，比如通过 pub 包管理工具发布的三方库</span><br></code></pre></td></tr></table></figure><h4 id="指定库的前缀"><a href="#指定库的前缀" class="headerlink" title="指定库的前缀"></a>指定库的前缀</h4><p>如果两个库有相同的名称，可以通过 <code>as</code> 指定前缀解决冲突。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:lib1/lib1.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="hljs-keyword">as</span> lib2;<br><br><span class="hljs-comment">// Uses Element from lib1.</span><br><span class="hljs-built_in">Element</span> element1 = <span class="hljs-built_in">Element</span>();<br><br><span class="hljs-comment">// Uses Element from lib2.</span><br>lib2.<span class="hljs-built_in">Element</span> element2 = lib2.<span class="hljs-built_in">Element</span>();<br></code></pre></td></tr></table></figure><h4 id="部分导入"><a href="#部分导入" class="headerlink" title="部分导入"></a>部分导入</h4><p>如果只使用到库的一部分，可以使用部分导入的语法，通过 <code>show</code> 和 <code>hide</code> 做到。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 只导入 foo</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:lib1/lib1.dart&#x27;</span> <span class="hljs-keyword">show</span> foo;<br><br><span class="hljs-comment">// 导入除了 foo 意外的部分</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="hljs-keyword">hide</span> foo;<br></code></pre></td></tr></table></figure><h4 id="实现-libraries"><a href="#实现-libraries" class="headerlink" title="实现 libraries"></a>实现 libraries</h4><p>见 <a href="https://dart.dev/guides/libraries/create-library-packages">Create Library Packages</a></p><h3 id="Asynchrony-support"><a href="#Asynchrony-support" class="headerlink" title="Asynchrony support"></a>Asynchrony support</h3><p>Dart 中有很多返回 <a href="https://api.dart.dev/stable/dart-async/Future-class.html">Future</a> 和 <a href="https://api.dart.dev/stable/dart-async/Stream-class.html">Stream</a> 对象的函数，我们可以使用它们编写出异步的代码。除此之外，Dart 还提供了 <code>async</code> 和 <code>await</code> 关键字，让你可以像 JS 一样，更方便地写出一些更具易读性的异步代码。</p><p>常见的用法如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart">Future&lt;<span class="hljs-built_in">String</span>&gt; lookUpVersion() <span class="hljs-keyword">async</span> =&gt; <span class="hljs-string">&#x27;1.0.0&#x27;</span>;<br><br><span class="hljs-comment">// 在方法末尾添加 async 关键字，说明方法执行耗时操作，返回值通常是 Future</span><br><span class="hljs-comment">// 如果 async 方法无有意义的返回值，可以返回 Future&lt;void&gt;</span><br>Future&lt;<span class="hljs-built_in">String</span>&gt; checkVersion() <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">var</span> version = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    version = <span class="hljs-keyword">await</span> lookUpVersion();<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">// React to inability to look up the version</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> verion;<br>&#125;<br></code></pre></td></tr></table></figure><p>Stream 和 Future 的不同之处在于，它可以连续接收多个异步事件。我们可以通过 StreamBuilder 对持续发生变化的数据流进行监听，比如通过 WebSocket 获取数据：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart">StreamBuilder(<br>    stream: webSocketChannel.stream,<br>    builder: (context, snapshot) &#123;<br>      <span class="hljs-built_in">String</span> message = <span class="hljs-string">&#x27;&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (snapshot.connectionState != ConnectionState.active ||<br>          snapshot.hasError) &#123;<br>        message = <span class="hljs-string">&#x27;has error&#x27;</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (snapshot.hasData) &#123;<br>        message = snapshot.data.toString();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        message = <span class="hljs-string">&#x27;no data&#x27;</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> Container(<br>        padding: EdgeInsets.symmetric(vertical: <span class="hljs-number">10</span>),<br>        child: Text(<span class="hljs-string">&#x27;<span class="hljs-subst">$message</span>&#x27;</span>,<br>            style: Theme.of(context).textTheme.headline6),<br>      );<br>    &#125;,<br>  ),<br>)<br></code></pre></td></tr></table></figure><p>另外，我们还可以通过 Stream 实现事件总线的功能，比如 <a href="https://github.com/marcojakob/dart-event-bus">event_bus</a> 就是基于 Stream 实现的。</p><h3 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h3><p>Dart 中的 Generator 函数和 ES6 中相似，如果你想要延迟生成一系列值，可以考虑使用生成器。Dart 中的 Generator 函数分为两种：</p><ul><li>同步生成器：返回 <a href="https://api.dart.dev/stable/dart-core/Iterable-class.html">Iterable</a> 对象</li><li>异步生成器：返回 <a href="https://api.dart.dev/stable/dart-async/Stream-class.html">Stream</a> 对象</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 同步生成器</span><br><span class="hljs-built_in">Iterable</span>&lt;<span class="hljs-built_in">int</span>&gt; naturalsTo(<span class="hljs-built_in">int</span> n) <span class="hljs-keyword">sync</span>* &#123;<br>  <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (k &lt; n) <span class="hljs-keyword">yield</span> k++;<br>&#125;<br><br><span class="hljs-comment">// 异步生成器</span><br>Stream&lt;<span class="hljs-built_in">int</span>&gt; asynchronousNaturalsTo(<span class="hljs-built_in">int</span> n) <span class="hljs-keyword">async</span>* &#123;<br>  <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (k &lt; n) <span class="hljs-keyword">yield</span> k++;<br>&#125;<br><br><span class="hljs-comment">// 递归的生成器，使用 yield* 提高性能</span><br><span class="hljs-built_in">Iterable</span>&lt;<span class="hljs-built_in">int</span>&gt; naturalsDownFrom(<span class="hljs-built_in">int</span> n) <span class="hljs-keyword">sync</span>* &#123;<br>  <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">yield</span> n;<br>    <span class="hljs-keyword">yield</span>* naturalsDownFrom(n - <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Callable-classes"><a href="#Callable-classes" class="headerlink" title="Callable classes"></a>Callable classes</h3><p>我们可以通过给某个类实现 <code>call()</code> 方法，使得该类可以像方法一样被调用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WannabeFunction</span> </span>&#123;<br>  <span class="hljs-built_in">String</span> call(<span class="hljs-built_in">String</span> a, <span class="hljs-built_in">String</span> b, <span class="hljs-built_in">String</span> c) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;WannabeFunction.call()&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;<span class="hljs-subst">$a</span> <span class="hljs-subst">$b</span> <span class="hljs-subst">$c</span>!&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> wf = WannabeFunction(); <span class="hljs-comment">// 初始化该类对象，然后可以像方法一样调用它们</span><br>wf(<span class="hljs-string">&#x27;Hi&#x27;</span>, <span class="hljs-string">&#x27;there,&#x27;</span>, <span class="hljs-string">&#x27;gang&#x27;</span>) <span class="hljs-comment">// 实际调用的是 call() 方法</span><br></code></pre></td></tr></table></figure><h3 id="Isolates"><a href="#Isolates" class="headerlink" title="Isolates"></a>Isolates</h3><p>与其它语言的并发机制不同，Dart 中并没有采用共享状态的并发机制 (shared-state concurrency)，而是使用了 <em>isolates</em>。所有的代码都运行在自己的 <code>isolate</code> 中，每个 <code>isolate</code> 都有自己的内存堆，保证了相互独立性。</p><p>更多资料见：<a href="https://dart.dev/guides/language/language-tour#isolates">Isolates</a>。</p><h3 id="Typedefs"><a href="#Typedefs" class="headerlink" title="Typedefs"></a>Typedefs</h3><p>Dart 中，一切皆是对象，函数也是对象，但是函数对象的信息在运行时往往会被丢失，比如下面这个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedCollection</span> </span>&#123;<br>  <span class="hljs-built_in">Function</span> compare;<br><br>  SortedCollection(<span class="hljs-built_in">int</span> f(<span class="hljs-built_in">Object</span> a, <span class="hljs-built_in">Object</span> b)) : compare = f;<br>&#125;<br><br><span class="hljs-built_in">int</span> sort(<span class="hljs-built_in">Object</span> a, <span class="hljs-built_in">Object</span> b) =&gt; <span class="hljs-number">0</span>;<br><br>SortedCollection sc = SortedCollection(sort);<br><br><span class="hljs-comment">// 只知道 compare 是 Function，但是其具体类型被丢失了</span><br><span class="hljs-keyword">assert</span>(sc.compare <span class="hljs-keyword">is</span> <span class="hljs-built_in">Function</span>);<br></code></pre></td></tr></table></figure><p><code>typedef</code> 就是为了解决上面这个问题而出现的，我们可以给方法类型一个别名，这样，当方法被赋值到一个变量上时就能保留其类型信息：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 函数的信息被保存在 Compare 中</span><br><span class="hljs-keyword">typedef</span> Compare = <span class="hljs-built_in">int</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">Object</span> a, <span class="hljs-built_in">Object</span> b);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedCollection</span> </span>&#123;<br>  Compare compare; <span class="hljs-comment">// 用于接收我们定义的函数</span><br><br>  SortedCollection(<span class="hljs-keyword">this</span>.compare);<br>&#125;<br><br><span class="hljs-built_in">int</span> sort(<span class="hljs-built_in">Object</span> a, <span class="hljs-built_in">Object</span> b) =&gt; <span class="hljs-number">0</span>;<br><br>SortedCollection sc = SortedCollection(sort);<br><span class="hljs-keyword">assert</span>(sc.compare <span class="hljs-keyword">is</span> Compare); <span class="hljs-comment">// 现在可以确定函数的具体类型了</span><br></code></pre></td></tr></table></figure><p><code>typedef</code> 也可以使用泛型：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">typedef</span> Compare&lt;T&gt; = <span class="hljs-built_in">int</span> <span class="hljs-built_in">Function</span>(T a, T b);<br><br><span class="hljs-built_in">int</span> sort(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) =&gt; a - b;<br><br><span class="hljs-keyword">assert</span>(sort <span class="hljs-keyword">is</span> Compare&lt;<span class="hljs-built_in">int</span>&gt;); <span class="hljs-comment">// True!</span><br></code></pre></td></tr></table></figure><h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>通过元信息注解，我们可以为类和方法提供额外的信息。Dart 中自带的注解有 <code>@deprecated</code> 和 <code>@override</code>，除此之外，你也可以自定义注解，只要在类的构造器上使用 <code>const</code> 关键字就可以了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> who;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> what;<br><br>  <span class="hljs-keyword">const</span> Todo(<span class="hljs-keyword">this</span>.who, <span class="hljs-keyword">this</span>.what);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h3><p>Dart 支持三种类型的注释：单行注释、多行注释和文档注释。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">文档注释，使用 [] 给成员属性或者方法添加链接，比如查看 [main] 方法</span></span><br><span class="hljs-comment">/// <span class="markdown">虽然 Dart 中也能用 /<span class="hljs-strong">** <span class="hljs-emphasis">*/ 作为文档注释，但是编辑器会提醒你用 /// 代替</span></span></span></span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">// 单行注释</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Howdy!&#x27;</span>);<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * 多行注释</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hola!&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真实的自己</title>
      <link href="/2021-3/"/>
      <url>/2021-3/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/rNPQkauSr3w" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>读自己过去写的文字，就像是在听一个陌生人聊天。很多想法都是只有在特定的心境和环境下才能产生的，而写下的文字又经过了大脑的一层处理，所以，重新再读的时候会感到陌生，因为当时的那些情感和记忆离此刻的自己有点遥远，已经变得陌生了。不过，这些文字多少能反映出我们在那段时间所做出的思考。我们都是在反复尝试理解自己以及周围的世界。很多感悟其实在很多年前已经发出过，只不过当时没有记录下来。但是，我相信这些想法和感悟是会随着你的成长、境遇的不同而发生变化的。这也是写作的目的之一——见证自己的变化。还有就是，一步步发现真实的自己。</p></blockquote><span id="more"></span><h4 id="3-月-1-日-下定决心之后就立马行动"><a href="#3-月-1-日-下定决心之后就立马行动" class="headerlink" title="3 月 1 日 - 下定决心之后就立马行动"></a>3 月 1 日 - 下定决心之后就立马行动</h4><p>Once you make a decision, the universe conspires to make it happen.</p><p>当你下定决心做一件事的时候，你做事的心态会完全不同，你会认真考虑事情的来龙去脉，预想可能的结果，思考怎样才能做到最好等等。而且随着你花的时间越多，完成目标的信心也会逐渐增加，很多过去在你眼里被视为困难的事情都不再是困难了，仿佛问题在你的决心面前也失势了。困难就像弹簧，你强它就弱，你弱它就强，你越是害怕，它越是显得可怕。所以，当感到犹豫不决的时候，不要急忙动手去做事，而是要先给自己做好心理建设；当你确定某件事值得做的时候，就不要再想太多，尽管去做，很多困难只有在你的大脑里才显得无法克服。拖延越久，失败的可能性就越高；行动越果断，遇到的麻烦反而会少很多。</p><h4 id="3-月-2-日-向强者学习"><a href="#3-月-2-日-向强者学习" class="headerlink" title="3 月 2 日 - 向强者学习"></a>3 月 2 日 - 向强者学习</h4><p>发现自己有个奇怪的心理，那就是喜欢和人唱反调，尤其是那些地位比我高一点或者有一些权威的人。比如对我自己的小领导，明明一个功能可以用 A 方案实现，但是因为是小领导提出的，于是我就觉得 A 不好，应该用 B 方案。我不知道自己的这种心理是从什么时候培养起来的，但是可以肯定的是一定和我爸有关系。小时候老爸总是喜欢用他的权威打压我，驱使我服从，所以等我到了青春期之后，我的这种逆反心理就特别强。但是，青春期都过去这么久了，为什么我到现在还是会和人以这种方式斗气？毕竟这么做对我来说完全没有任何的好处。所以，还是要多多反省自己吧，为人处世尽量圆滑一点。不要觉得自己很厉害或者很差劲，实事求是地对待身边的所有人，承认他人身上比我好的部分，向他学习；对于自己做的不好的地方，及时改正；做的好的地方，也不要太得意或者想要炫耀，应该想办法加强它。只有这样，你才能变得越来越好。</p><h4 id="3-月-3-日-感受身体器官的状态"><a href="#3-月-3-日-感受身体器官的状态" class="headerlink" title="3 月 3 日 - 感受身体器官的状态"></a>3 月 3 日 - 感受身体器官的状态</h4><p>发现一个让心情平静下来的好方法：感受自己身体各个器官的状态。我一般会从头到脚逐个确认各个器官的状态：眼睛（转动眼球、从看近处到看远处），鼻子（深呼吸几口气，感受空气中的味道），嘴巴（搅动舌头，感受嘴里的味道；咽一口口水，感受喉咙上下滑动的感觉），耳朵（仔细听当下你听到的各种声音，无论你是在嘈杂的环境下，还是在安静的环境下，听近处和远处你能分辨的最强烈、最微弱和最难以分辨的声音），脖子（上下、左右、向两侧转动，前后移动，转动脖子画圆弧），肩膀（感受肩膀的状态，肌肉从紧张到完全放松），手臂（向上张开做个大力士的姿势然后收拢、伸个懒腰），手腕、手掌、手指（向各个方向转动手腕，活动手指），背部（感受背部肌肉的状态），胸腔（深吸一口气，屏住呼吸几秒，然后吐气；快速呼吸几次；急促连续吸气然后吐气），腹部（感受正常呼吸时肚子慢慢升高的状态），腰部（向各个方向伸展，感受腰部肌肉的状态），臀部（肌肉状态，提肛 10 次），胯部（感受器官状态），大腿和小腿（肌肉状态），脚踝、脚掌、脚趾（前后左右转动脚踝，活动脚趾）。如果条件允许，闭上眼睛，然后在大脑中重建你刚刚看到的四周的环境。然后，尽量什么都不想，集中注意力在呼吸上，进入冥想状态。一段时间之后，睁开眼睛，回到现实世界，你会发现自己此刻的心情已经平静许多。</p><h4 id="3-月-4-日-选择有吸引力的目标"><a href="#3-月-4-日-选择有吸引力的目标" class="headerlink" title="3 月 4 日 - 选择有吸引力的目标"></a>3 月 4 日 - 选择有吸引力的目标</h4><p>成功的人往往有很强的目标感，这种目标感要么来自于想要得到某些东西的强烈欲望（比如对金钱的渴望），要么来自于想要摆脱某种状态（贫穷、匮乏、无知、被轻视、不平等、受压迫等等）。无论是出于哪种情况，都能制造出足够的动机，促使一个人去完成自己的目标。我觉得自己就缺乏这种强烈的动机，所以做很多事的时候都容易中途放弃。那么，怎样才能为自己制造出足够强烈的动机呢？我觉得最关键的一点是，要让它<strong>足够有吸引力</strong>。这就需要我们在选择目标的时候，选择那些自己真正感兴趣的目标，而且确保它始终对自己有足够的诱惑力。</p><h4 id="3-月-5-日-孤独、独处和寿司店小哥"><a href="#3-月-5-日-孤独、独处和寿司店小哥" class="headerlink" title="3 月 5 日 - 孤独、独处和寿司店小哥"></a>3 月 5 日 - 孤独、独处和寿司店小哥</h4><p>为什么生活在都市里的很多人都会感到孤独？明明身边有很多人，也并不缺少沟通的人，但是我们往往更习惯一个人的生活。我觉得这一方面和都市提供的各种便利有关，我们不再需要彼此依赖，再加上发达的网络，几乎做任何事都可以通过一部手机解决。另外，这也和我们有了更多的空闲时间有关，而我们选择如何度过这些空闲时间是关键。如果你用一些有意义的活动去填充时间，那就不会感到孤独，但如果你纯粹是为了消磨时间而去做一些事，那么孤独感就会愈加强烈。最好的状态是，既能主动去拓展自己的社交，又能独处做自己喜欢做的事，两者之间达到平衡。这大概需要我们有一颗<strong>强大的内心</strong>以及<strong>足够的自控能力</strong>。</p><p>晚上去镇上一个寿司店买晚餐，老板是一个年轻小哥。和小哥聊了一会儿，发现他年纪和我差不多，但是经历比我丰富得多：做过销售，在全国各地跑过，去年受疫情影响，销售不好做，于是开始做寿司，因为他高中毕业后去山东学做过餐饮。而且他一边开店，一边还想考中医药资格证，这样可以靠挂靠证书多拿一份收入。真的是非常努力上进的一个人，我都有点想认识他一下了。然后想到，其实生活中有无数像他这样的人，我们身边的每个人都有自己的故事，我们要<strong>向其中那些努力的人靠近</strong>。尤其是像我们这样家庭环境一般的人，想要拥有美好的生活，只能靠自己。不停思考自己的未来，努力创造，总会慢慢一点点接近自己的理想生活的。</p><h4 id="3-月-6-日-警惕知识诅咒，习惯性确认你以为的「常识」"><a href="#3-月-6-日-警惕知识诅咒，习惯性确认你以为的「常识」" class="headerlink" title="3 月 6 日 - 警惕知识诅咒，习惯性确认你以为的「常识」"></a>3 月 6 日 - 警惕知识诅咒，习惯性确认你以为的「常识」</h4><p>和他人沟通的时候，很重要的一点是要意识到，你以为的「常识」在别人那里不一定是「常识」。有一个名词叫知识诅咒（Curse of knowledge），即下意识地以为对方拥有和你相同的知识背景。这种认知偏差一方面会让我们的沟通显得更自然，但是另一方面，当我们发现对方并不理解我们所说的东西的时候，会感到非常困惑和无法理解，觉得为什么对方没能听懂我们的表达。所以，一定要在心中记住这句话：不要觉得一切都是理所当然的。当发现对方没听懂或者不具备我们以为的某些「常识」的时候，不要立即感到厌倦或者不耐烦，要有耐心，好好解释，扫除障碍后才能继续有效沟通。这种情况适用于每个人，很多时候可能在对方眼里你也是一样的「没有常识」，毕竟，我们的兴趣不同，覆盖的知识面也不同。即使是长时间一起生活的人，也不一定能完全理解彼此。所以，沟通的时候要<strong>习惯性确认</strong>，变得更<strong>有耐心</strong>一点。沟通的目的是加深对彼此的了解，而不是造成更多的隔阂。</p><h4 id="3-月-7-日-能团结人类的就是好的"><a href="#3-月-7-日-能团结人类的就是好的" class="headerlink" title="3 月 7 日 - 能团结人类的就是好的"></a>3 月 7 日 - 能团结人类的就是好的</h4><p>什么是好的文化？我觉得在不强迫他人意志的前提下，能把人团结在一块儿的就是好的。以此为标准，好的教育让人学会合作和分享，学会帮助他人、宽慰他人。好的政治会把人聚拢在一起，让大家朝着共同的目标努力，且能改善绝大多数人的生存状况；而坏的政治则会把人群分割，让人追求各自的利益而忽视他人的利益。至于宗教，情况就更复杂了。有的宗教，从内部看是把人团结在一起的，但是从外部看，又是鼓励敌视其它非信仰此宗教的人群的，所以很难说是好是坏。不过，有的宗教就相对比较温和，比如佛教和道教。形成这种差异的可能原因有很多，比如人口、地理、环境因素等等。</p><p>把视角再缩小一点，其实小到一家公司、一个家庭，也是可以用这种标准作为评判的。好的公司内部一定是齐心协力、团结一致的，即使有分歧，一般也会以整体的利益为重。而差的公司往往派系林立，每个部门各自为政，甚至每个人都有自己的利益出发点。所以，创立一家伟大的公司的前提是，<strong>让每个员工都能视自己为最佳合作者，认同公司的理念，和公司有着一致的目标</strong>。好的家庭也一样，每一位家庭成员，都视自己为这个家的一部分，都想着为家庭做贡献，而不是一味地索取；当其它家庭成员需要帮助的时候，要及时伸出援手；亲密关系更需要彼此通力合作才能维持下去。</p><h4 id="3-月-8-日-和你完全契合的人不存在"><a href="#3-月-8-日-和你完全契合的人不存在" class="headerlink" title="3 月 8 日 - 和你完全契合的人不存在"></a>3 月 8 日 - 和你完全契合的人不存在</h4><p>我觉得现在很多人包括我自己在找对象的时候，心里都会有那种<strong>一定要找到与自己完全契合的人</strong>的想法。这种想法出发点是好的，但是实际情况是，<strong>和你完全契合的人根本不存在</strong>，或者即使存在你也不一定能遇得上。我觉得还是要学会妥协，毕竟人无完人，你的理想对象只要在最核心的<strong>观念、生活态度、为人处世</strong>等方面能和自己保持一致就够了，其他东西都是可以适当放宽标准的。毕竟我们自己也并不完美，可能在对方眼里 Ta 也有类似这样那样的顾虑。如果你们两个人都固执地认为要「完全契合」才能走下去，那么这段感情大概率很难产生什么结果。所以，尽管去试试吧。感情真的是靠积累出来的，而且观念一致的两个人如果能久处不厌的话，慢慢对彼此会越看越顺眼，越来越喜欢。陪伴是最长情的告白。</p><h4 id="3-月-9-日-我们为什么阅读"><a href="#3-月-9-日-我们为什么阅读" class="headerlink" title="3 月 9 日 - 我们为什么阅读"></a>3 月 9 日 - 我们为什么阅读</h4><p>了解一个人的最佳方式是看他的书架。不仅仅是看他看哪些书，还有书的排列方式、新旧程度，书架上是否有其它杂物等等，都可以看出书架的主人是一个什么样的人。从不阅读的人和假装喜欢阅读的人都可以很容易就能分辨出来。我们为什么需要阅读？只有感受过阅读带给自己的好处的人才会喜欢上阅读，而喜欢上阅读之后，读书写作就成了他们日常生活中的一部分了。闲下来的时候，翻几页书，写几句话，阅读其实就像阳光和养料一样，给我们提供了成长的能量，获得更多有益的思考，改变自己的思维，增长见识，优化习惯。写下这些是为了提醒自己，不要忘记阅读的好处，不要因为忙碌和懒惰就不阅读了，你需要它们。阅读、冥想、运动、充足睡眠，这些是保证生命高质量运行下去的基础因素，永远要花时间维护好这些习惯。</p><h4 id="3-月-10-日-未来的学校教育"><a href="#3-月-10-日-未来的学校教育" class="headerlink" title="3 月 10 日 - 未来的学校教育"></a>3 月 10 日 - 未来的学校教育</h4><p>未来学校教育会被在线教育取代吗？我觉得不会，因为学校教育其实不仅仅提供了知识获取的渠道，更重要的是提供了一个供学生们学习、社交以及进行其它各种活动的环境，这点是在线教育永远都无法替代的。另外，相比传授知识和技能，学校教育最大的作用是培养学生<strong>如何学习</strong>的能力，以及<strong>传递好观念</strong>。我觉得随着在线教育的发展，未来学校教育中知识传授方面的功能会被外包出去（<a href="https://www.nber.org/papers/w28511">来源</a>），慢慢形成以在线教育为主，加上老师现场辅导的模式。因此，对于大部分教师而言，其教学能力的重要性会越来越弱，更重要的是教师们的管理能力，和学生的沟通能力，以及他们的<strong>思维和观念。</strong>学生往往受益于学校创造的环境，而不在于传授什么样的知识。</p><h4 id="3-月-11-日-放下偏见，感受当下"><a href="#3-月-11-日-放下偏见，感受当下" class="headerlink" title="3 月 11 日 - 放下偏见，感受当下"></a>3 月 11 日 - 放下偏见，感受当下</h4><p>相遇即是缘分，无论是你身边的人或者你工作的公司，既然能够遇到彼此，就说明你们还是有缘的。既然如此，那就应该好好珍惜这种缘分。也许你对自己的家人、朋友、同事有这样那样的不满意，也许你也曾经幻想过如果自己能力更强就能摆脱当下的这种环境，但是，我们无法改变过去。所以，不要再用幻想和白日梦填充满足自己不切实际的愿望，好好看看你眼下周围的一切。其实他们也很可爱，只不过你常常忽视了他们身上可「爱」的一面，而选择只看到你讨厌的地方。<strong>放下心中的偏见，感激自己拥有的一切，感谢他人的付出，享受努力的过程</strong>。抱着这种心态，无论当下的你处于什么样的境地，你都能感到轻松自在，快乐而又满足。</p><h4 id="3-月-12-日-诚实面对自己的欲望"><a href="#3-月-12-日-诚实面对自己的欲望" class="headerlink" title="3 月 12 日 - 诚实面对自己的欲望"></a>3 月 12 日 - 诚实面对自己的欲望</h4><p>发现自己有时候会没来由地感到害羞，比如在食堂排队打饭的时候，突然就会觉得害羞、不好意思。反思之后，我发现这种害羞其实最根本的原因还是我<strong>无法真实面对自己的欲望</strong>。因为总是想要掩盖自己的欲望，所以我的想法和行为有了不一致，正是这种不一致让我自己无法接受自己的行为，有时候甚至无法接受自己的想法，于是只能为自己感到羞愧。所以，诚实面对自己吧，承认自己有欲望，承认自己有时候也会贪吃，承认自己喜欢年轻而又美好的异性，承认自己会对他人抱有性幻想。这是人最自然的状态，没什么不好意思的。越是压制这种欲望就越有可能被欲望反噬，你要尽可能做到和欲望和谐共处，正视自己的欲望，接纳它，而不是一味逃避。利用自己的欲望去为他人创造价值，去做出一些有意义的事情。</p><h4 id="3-月-13-日-停止给自己找借口"><a href="#3-月-13-日-停止给自己找借口" class="headerlink" title="3 月 13 日 - 停止给自己找借口"></a>3 月 13 日 - 停止给自己找借口</h4><p>人总是喜欢给自己找借口，我给自己找的最大的借口是什么呢？我是个性格害羞的人。那么，我为什么会害羞？主要是因为我的成长环境，小时候经常受到长辈、师长的打压，还有我对自己的外表不自信。具体而言呢？我的个子不高，我的牙齿不好看，门牙大而且有牙缝。但是，真的是因为这些原因我才成为了一个「害羞」的人吗？</p><p>仔细反思之后，我觉得其实这些都只是我给自己找的借口，我选择用这种方式来解释自己的性格，是因为我想要用性格内向、害羞来掩盖自己不擅长沟通的缺陷，然后用「如果我性格外向活泼，我的身边就会有一大堆朋友」等说辞来安慰自己。所以，说到底还是自己太懒惰，懒得去提高自己的社交技能，懒得去做自己不喜欢做的事，只喜欢待在自己的舒适区，然后用不自信和性格内向等借口来为自己的无能和不作为开辩，让自己能心安理得地维持现状。停止给自己找借口吧，大方承认自己身上的缺点，放弃那种「因为我如何如何，所以我不能如何如何」的心态，积极行动起来，勇敢地去做自己想做的事。改变自己，就从这一刻开始。</p><h4 id="3-月-14-日-亲密关系和营造你想要的环境"><a href="#3-月-14-日-亲密关系和营造你想要的环境" class="headerlink" title="3 月 14 日 - 亲密关系和营造你想要的环境"></a>3 月 14 日 - 亲密关系和营造你想要的环境</h4><p>如何建立和维护亲密关系呢？我觉得这是每个人都要面对的问题。一直以来，我都在刻意回避这个问题。我喜欢用「我不擅长」和「一个人也能过得很开心」这种话来麻痹自己。但是，这种态度并不能解决你想要逃避的问题，只会拖延问题带来的后果的显现，而且有时候可能会让问题变得更加严峻。的确，建立一段亲密关系很难，难度不亚于维护好一段亲密关系，需要你有勇气和决心，以及对自己想要什么有清晰的认识，还需要一点点运气。你需要不断地学习，首先学会正确地认识自己，然后学会如何与自己相处，如何与他人相处，还得有耐心去了解他人，看到他人身上的优点和不足，再对比你所希望看到的特质，学会取舍，然后再慢慢互相了解，互相吸引，表达自我，引导对方也开始自我表达，在两人逐渐熟悉的过程中，建立起彼此的连结。</p><p>无论是交友和还是寻找合作伙伴，我觉得除了技巧性的东西之外，更重要的是两个人是否是同一类人，我们信仰的东西是否一致，我们的观念和做事态度、认知水平是否接近，如果相差过大，相处起来就会不那么容易。这也同样说明了环境的重要性，你身边的人观念会影响到你的观念，如果你不去刻意营造出自己想要的环境，你会慢慢变得和你的环境一致。</p><h4 id="3-月-15-日-生活就是给自己找到存在下去的理由"><a href="#3-月-15-日-生活就是给自己找到存在下去的理由" class="headerlink" title="3 月 15 日 - 生活就是给自己找到存在下去的理由"></a>3 月 15 日 - 生活就是给自己找到存在下去的理由</h4><p>人一开始的目的只是为了生存。草原上裂开了一道口子，食物变少了，人只能从树上来到地面上，寻找更多的食物，从直立行走到学会使用工具，又被逼着学会和他人的交流合作，然后一群人渐渐开始往外迁移。在这一过程中，与其他人相遇，和有些人合作，和有些人竞争甚至互相杀戮。随着继续往外扩张，慢慢地，他们学会了使用更多的工具，学会了更大规模的合作。直到最后，他们征服了所有的大洋和大陆，同化（也被同化）了所有的近亲，直到最后，地球上只剩下了这一个人种（智人），于是他们继续各自独立发展，继续彼此间的合作与竞争。</p><p>人一旦满足了生存的需求之后，就会开始寻找存在的意义，我相信这点无论是在几十万年前还是现在都是一样的。我觉得<strong>存在本身并没有意义，是我们赋予其意义</strong>。关于人生意义最合适的表述我觉得是阿德勒所说的<strong>获得贡献感，即觉得自己有用</strong>。而且这一表述可做的解释非常广阔。既可以是西西弗斯日复一日滚石上山，也可以是成吉思汗尽可能多地征服土地，还可以是霍比特人过着与世无争的生活。哪怕是一个人过，只要能让自己觉得「我作为人类的一份子，我对他人有用，我能够通过做一些事获得贡献感」，那么，我们也能获得继续生存下去的理由。说到底，生活就是给自己找到存在下去的理由。</p><h4 id="3-月-16-日-配或不配"><a href="#3-月-16-日-配或不配" class="headerlink" title="3 月 16 日 - 配或不配"></a>3 月 16 日 - 配或不配</h4><p>当感到自己变得傲慢或者懒散的时候，问自己一个问题：我配的上我现在所拥有的一切吗？如果答案不是斩钉截铁的『是』，那么就应该好好反思自己了。另外，还得警惕心中那种觉得自己高人一等，觉得周围的环境配不上自己的想法。如果事实真的是这样，那就更应该反思自己了，为什么没有勇气去逃离并寻找到适合自己的环境？缺乏勇气也是一个人配不上的标志之一。反过来看这个问题同样有意义，当你觉得自己不值得拥有更好的东西的时候，问问自己：为什么？是我不够努力吗？还是只是因为别人告诉自己「你不配」？又或者是我在心中贬低自己而已？无论是哪种情况，都要找到原因，看看它是否客观。如果不是，那么忽视它，然后行动起来，去努力，去争取，去达到目标。大部分情况下，只要你愿意付出努力，你就配得上任何你想要的东西。</p><h4 id="3-月-17-日-第一家公司对人的影响"><a href="#3-月-17-日-第一家公司对人的影响" class="headerlink" title="3 月 17 日 - 第一家公司对人的影响"></a>3 月 17 日 - 第一家公司对人的影响</h4><p>越来越觉得，第一家公司对一个人的影响是巨大的，可能比他上的什么大学还要重要。第一家公司往往让你第一次明白应该如何做事，包括你的工作态度，如何面对困难，如何调整心态，如何与人合作，如何与同事、上下级建立关系以及建立什么样的关系，还会影响到你的价值观，对自我的认知等等。这些东西一旦形成想要改变是非常困难的，无论我们如何换工作，身上始终都会带着第一家公司对你的影响。</p><p>对我来说，我的第一家公司是一家 SAAS 公司，表面上看我面对的是公司上级领导布置给我的任务，而背后实际上是客户的需求，所以，在我的印象中，只要能满足客户的需求，那么我的工作就算完成得不错了。但是，这种心态是有问题的，会让人陷入「只为满足客户需求才做某事」的习惯里，长此以往，人会慢慢失去思考如何寻找最佳方案的习惯。于是，当我进入了一家需要做出好产品而不仅仅是满足客户需求的公司，继续采用这种心态去做事，这时候才发现自己身上有很多问题。我需要改变这种习惯，脑海中思考的应该是如何把事情做好，而不是为了让某个「客户」满意。把自己作为用户，发现问题，解决问题，这样才能一步步走得更远。</p><h4 id="3-月-18-日-是否应该为钱工作？"><a href="#3-月-18-日-是否应该为钱工作？" class="headerlink" title="3 月 18 日 - 是否应该为钱工作？"></a>3 月 18 日 - 是否应该为钱工作？</h4><p>最近心里想的比较多的一个矛盾点是：到底应不应该为钱工作？总是觉得人到了一定年纪之后，就不应该眼里只看到钱了，应该想想自己的目标和理想：我有什么想要做的？我死之前有什么愿望想要实现？我现在做的事离我儿时的梦想有多远？好像有点太理想主义了，可能人在解决温饱问题之后，就会想得比较多吧。和那些还在为生存辛苦奔波的人比起来，我已经算幸运的了。但是，如果想要完全满足自己的欲望的话，那么还是得赚很多很多钱，我现在只能算刚刚脱贫而已。</p><p>有部分人的观点是，钱是最好的度量标准，标志着你的能力和创造的价值，虽然「小富靠勤，大富靠命」，但是，如果你能通过某种方式赚到钱也就说明了你擅长什么，于是你只需要不断打磨那方面的技能，然后提供更好的服务就可以了，最终，在获得金钱激励的同时也能收获贡献感。而且即使是为了赚钱养家而工作，看到你的家人因为你获得更好的生活，这同样能收获人生的幸福和快乐。另一方面，为钱工作听上去的确没有为理想工作好听。不停听到有人鼓励大家要追随自己的热情和梦想，去做自己想做的事，为了实现人生价值去工作而不是为了物质享受辛苦打拼。人生短暂，活着是为了体验生命更丰富的可能性，也许最终会过得不如别人安稳，但是只要你能乐在其中、感到幸福，那就足够了。</p><p>我不知道以上哪种观点适合自己，现在的我只能走一步看一步，普通人毕竟没有太多尝试的机会。但是，我觉得其实也没必要太过着急，人生还很长，现在的我不知道怎么选也没关系。而且即使现在选错了，也并不意味着未来就没有调整的机会了，慢慢来，慢慢想清楚自己到底想要什么，同时好好努力。这样，即使到了 50 岁、60 岁，你依旧有选择的权力。</p><h4 id="3-月-19-日-用不批判的态度看待他人"><a href="#3-月-19-日-用不批判的态度看待他人" class="headerlink" title="3 月 19 日 - 用不批判的态度看待他人"></a>3 月 19 日 - 用不批判的态度看待他人</h4><p>每个人都有自己的偏见，但是我们应该尽量保持一个不批判的态度去看待他人。无论他人身上有何种缺点，都应该首先尝试理解他们，也就是要有同理心。同理心也是需要锻炼才能慢慢形成的。如果任由偏见指导我们的日常生活，那么任何人都不值得交往，但是正是因为人具有同理心，我们可以从他人的遭遇中得到他们形成这种行为模式或者思维定式的解释，所以即使不认同，我们也能够或者至少应该尝试去理解。更何况<strong>我们自己也并不完美</strong>，一个人的任何一种特质一旦过了头就成了他的缺陷，或者换一种场景就是缺点。我们要做的是时刻注意自己的想法，思索解决问题的办法，让自己变得更好，同时也让他人变得更好。人是感性的动物，但是我们尽量要让理性占主导，感性让我们的生活有更多的意外和起伏，但是唯有理性才能让我们生活得更加幸福。</p><h4 id="3-月-20-日-学会与人合作，他人是你的伙伴"><a href="#3-月-20-日-学会与人合作，他人是你的伙伴" class="headerlink" title="3 月 20 日 - 学会与人合作，他人是你的伙伴"></a>3 月 20 日 - 学会与人合作，他人是你的伙伴</h4><p>发现自己常常有种心态，那就是不喜欢和他人合作，总觉得和别人一起做某事还不如我自己一个人做效率更高。而且当遇到问题的时候，心里总是会憋着一口气，直到实在没办法了才去求助他人。这种做事方式，一方面的确有优点，可以避免很多无效的沟通，锻炼自己解决问题的能力；但是，另一方面，却也会让人陷入「孤狼」的境地，他人觉得你难以接近、不近人情，然后有问题的时候第一时间想到的也不会是你，这样你就失去了更多解决问题的机会。和人沟通一开始只是建立信任的阶段，等到你们过了这个阶段，彼此的沟通效率提高之后，很多问题可能三两句话就能解决，而且随着对彼此了解更多、更熟悉之后，可以省去很多不必要的互相猜忌，也能用彼此更容易接受的方式进行沟通。总之一句话，与人合作需要时间建立信任，需要你保持开放的心态，从他人身上学习。他人是你的伙伴，而不是给你制造问题的人，即使给你提出了问题，这也是锻炼你的能力的机会。</p><h4 id="3-月-21-日-人生没有一劳永逸"><a href="#3-月-21-日-人生没有一劳永逸" class="headerlink" title="3 月 21 日 - 人生没有一劳永逸"></a>3 月 21 日 - 人生没有一劳永逸</h4><p>人生有什么是一劳永逸的吗？除了死亡，我想不到别的了。所以，不要想着「如果我如何如何，就能如何如何」，现实中根本就不存在这样的事。我喜欢吴主任说过的一句话：活着，<strong>有人爱，有事做，就够了</strong>。至于生活中那些不停出现的麻烦和困难，去面对和解决就好了，躲是躲不了的，越躲问题只会越多。以这种方式思考，虽然问题和困难不会减少，但是至少在面对它们的时候，自己可以多一份勇气。因为只要还活着，问题就有被解决的机会。死亡是一件需要更大的勇气才能面对的事，现在思考它没有意义。只有当勇气缺失、失去理智的时候，人们才会把它作为一个可选项。当然，真正自杀成功的人的想法的确有很多种可能，比如完全经过理性思考后的放弃生命，但是那样的人在人群中是极少数，可以忽略不计。</p><h4 id="3-月-22-日-向内探索"><a href="#3-月-22-日-向内探索" class="headerlink" title="3 月 22 日 - 向内探索"></a>3 月 22 日 - 向内探索</h4><p>想要不拿自己和别人比较是很难的，因为你总要出门，看到大街上来来往往的人，看到别人拥有一些美好的东西，你多少会有一点羡慕，也会勾起自己心底的欲望，然后忍不住去比较自己，我什么时候才能像他们一样呢？但是，这种比较往往只会徒增烦恼，因为在声色犬马的大城市里，你总是能遇到更多、更好的人和物，人的欲望是永远也无法完全被满足的。想要不被这种比较拖累，我们应该先观察自己现在已经拥有的一切，然后问问自己，我真的需要那些东西吗？的确，也许拥有之后能立马满足我们的欲望或者某方面的需求，但是这种满足是持久的吗？我觉得大部分在此类比较中产生的欲望都不是。所以，我们还是应该向内探索：真正让我感到快乐、有成就感，并且能持续产生正向的、积极的情绪的事物来自何处？答案还是通过工作、兴趣爱好、融洽的人际关系等等。只有在创造价值的活动中获得的情感激励才是最长久的，而其它东西只是附带的价值，如果把它们作为最终的目标，只会让我们渐渐迷失自我。</p><h4 id="3-月-23-日-不要放弃追求自己的理想"><a href="#3-月-23-日-不要放弃追求自己的理想" class="headerlink" title="3 月 23 日 - 不要放弃追求自己的理想"></a>3 月 23 日 - 不要放弃追求自己的理想</h4><p>每个人都想进大公司，尤其是我们这一行，进大公司首先对能力有挑战，同时意味着获得更多的机会，遇到优秀的同事和上司的几率也更大，还有回报也比绝大部分小公司优厚。但是，进大公司往往难度也不小，需要看你的学历背景、工作经历，最最重要的是你的能力，不仅仅是技术能力，还有沟通、合作、应对压力等等方面的表现。对我来说，最难的部分还是技术能力。作为程序员，其它方面并没有那么重要，只要你的技术够强，其它东西都可以忽略不计。所以，问题又变成了如何提高自己的技术水平？这个就要看平时的积累了，如果你平时都是看剧、游戏、玩乐，那么靠面试前的突击是没用的，只有长时间的学习，查漏补缺，阅读源码，才能在关键时刻把自己的实力展现出来，尤其是项目中的经验、掌握的技巧等等。所以，还是要耐心一点吧，<strong>想清楚自己想要什么，然后定好目标和计划，每天学习进步一点点</strong>，总会慢慢接近自己的目标的。不要放弃自己的理想，也不要随波逐流，更不要轻易做出妥协。</p><h4 id="3-月-24-日-改变靠行动"><a href="#3-月-24-日-改变靠行动" class="headerlink" title="3 月 24 日 - 改变靠行动"></a>3 月 24 日 - 改变靠行动</h4><p>这几天看了很多关于程序员群体中的人才与招聘的文章，扪心自问，我是否达到了作者们说的那种人才标准？老实说，还有很远的距离。那么，是什么造成了这种差距？我觉得最根本的原因是，自己的认知和态度没有达到那种水平。第一，过于寻求安逸，而不是主动给自己制造挑战，导致自己在这样的环境中逐渐磨灭了激情和信心。第二，缺乏长期且明确的目标，所以一直以来都是随波逐流，成了为工作而工作的人。第三，习惯和环境的问题，没有营造一个积极向上的环境，养成良好的学习习惯，让自己能够突破瓶颈、不断进步。还有，在这一过程中，随着时间的推移，慢慢对自己所处的环境麻木了，继而开始怀疑自己，觉得自己不够热爱，甚至觉得不适合、不擅长。不过，意识到这些是好事，但是如果长期陷入这种状态还不去改变，那就是自己的问题了，而想要改变就得积极<strong>行动起来</strong>才行。</p><h4 id="3-月-25-日-关于选择"><a href="#3-月-25-日-关于选择" class="headerlink" title="3 月 25 日 - 关于选择"></a>3 月 25 日 - 关于选择</h4><p>“生活必须选择，而且不可逆，没有如果。选择，并且负责。选择更好的生活，<strong>选择难走一点的路</strong>，累是必然的，偶尔小小的抱怨一下，甚至悄悄哭一会，都是可以的，然后继续加油吧。”</p><p>“选择从来不是一件确定的事情，并不是说向左走就一定会给你带来幸福，而向右走就一定会将你带入歧途。<strong>很多选择所带来的结局，其实是漫长的一系列时间里，你所有行动的结果。</strong>”</p><p>“在你今后的人生中需要做很多选择：做什么工作，读什么专业，住在哪个城市。如果在每个分叉路口的时候，你都选择了那些<strong>自己更感兴趣的、让自己兴奋的、能激发你的好奇心的</strong>，你就会在下一个分叉路口继续选择让自己更喜欢的，在下下个路口继续选择你更喜欢的……当你一直这样做的时候，有一天你会醒来，认识到：你正在做着自己真正怀有激情的事情。”</p><p>“人人都想做出正确的选择，但我觉得，选择本身没有对错，<strong>做出选择后你做了什么</strong>，才反过来决定了你的选择是对是错。”</p><p>“那些真正努力的人，也许并没有这么勤奋，也不用过得那么痛苦，因为他们并不期待短期努力即刻就有巨大的回报。他们<strong>选择了一个正确的方向，以专注和热情持续地浇灌，以一种正确的、智慧的方式缓慢但平和地前进着</strong>，他们可以一边努力着一边享受着当下的生活。他们所有的努力，都不是给别人看的，而是为了自己内心真正的追求。而这些有价值的努力，也一点一滴真正到达了他们的内心，变成了他们真正的能力。”</p><p>最近在工作上需要做出一个选择，内心有点迷茫，所以翻了很多过去的笔记和摘抄。都说选择比努力更重要，所以越是在这种时刻就越是需要冷静下来，慎重思考，毕竟自己还太年轻，缺乏足够的经验。很多时候，一个错误的选择可能意味着未来自己的发展方向就完全不同了。但是，既然有选择也就会有新的机遇和挑战，如果自己判断正确并且把握住了机会，那么未来也有可能会发展地越来越好。不得不承认，有时候运气对一个人的命运来说，可能会起决定性的因素。</p><h4 id="3-月-26-日-和平的不易以及尝试行脚僧的生活"><a href="#3-月-26-日-和平的不易以及尝试行脚僧的生活" class="headerlink" title="3 月 26 日 - 和平的不易以及尝试行脚僧的生活"></a>3 月 26 日 - 和平的不易以及尝试行脚僧的生活</h4><p>昨天晚上玩滑板的时候在听故事 FM，讲了一个退伍军人在缅甸边境冲突期间去当地做志愿者，不幸卷入战争并被羁押拘留的故事。最后他说，对于普通人来说，能够过上安稳的生活就是一种莫大的幸福。也许只有经历过的人才知道这句话到底意味着什么吧。人类的苦难一大部分都是因为少部分人的激情和不理智引起的。我们作为普通人，只能尽力把自己的生活经营好，然后祈祷历史上的那些「强人」不要再出现。相反，科学和技术的不断进步才是我们应该期望看到的。而作为普通人中的一员，我们只要把自己的生活过好就足够了。改变人类命运的，把人类向好的一面推进的人总会慢慢出现，我们要做的只是耐心等待，然后用自己有限的生命，创造价值，传播善良和爱。这也是在为人类进步做贡献了。</p><p>昨晚还遇到一个行脚僧，在国道边的小公园里。他吃完泡面后看我玩滑板，问我练这个是不是为了参加比赛，我说不是，只是为了玩儿。然后他又看我玩了一会儿，玩了一会儿手机，接着就拿出睡袋在长椅上睡觉了。我怕打扰到他就早早离开了。回来路上在想，我是不是有机会也应该尝试下行脚僧的生活。什么都不去想，也不用定任何目标，只管走，看看这世间的人和事。无论遇到什么样的人，都是一种缘分。也许对世界和自己都会产生新的看法吧。</p><h4 id="3-月-27-日-不断更新你的知识库"><a href="#3-月-27-日-不断更新你的知识库" class="headerlink" title="3 月 27 日 - 不断更新你的知识库"></a>3 月 27 日 - 不断更新你的知识库</h4><p>绝大部分知识和技能长时间不使用就会被遗忘，无论是某种语言还是你过去掌握的某种技能。所以，我们需要不停地回顾，不停地练习。但是，这种遗忘也是有好处的，因为随着平均寿命的增加，我们一生不可能只从事一种职业，未来需要我们不断学习新技能。而抛弃过去的经验也是为了给大脑减轻负担，更快地去适应、学习新的知识和技能。另外，很多学科之间的知识都是可以迁移和复制的，一种知识放在另一种环境下也有其发挥作用的地方。就像芒格说过的，要建立多元思维模型，只有这样，我们才能更好地理解一个事物，而不是陷入一个单一视角，只看到我们习惯看到的，却忽略了其它同样重要的信息。广泛地阅读和实践，制定目标，定期回顾自己的学习进度，然后修正自己的目标，不断改进、积累。除了更新自己的知识库之外，还要思考人生的方向和战略问题：<strong>我现在能做什么，我下一步应该做什么，此刻对自己来说最重要的事情是什么？</strong>然后再去更新相应的知识和技能。随着知识库的不断更新以及能力的提高，你能解决的问题也会越来越多，对自己的认识也会逐步增加，生活也会更井然有序，你会感到更加自在和平和。</p><h4 id="3-月-28-日-按照你的信念和价值观去生活"><a href="#3-月-28-日-按照你的信念和价值观去生活" class="headerlink" title="3 月 28 日 - 按照你的信念和价值观去生活"></a>3 月 28 日 - 按照你的信念和价值观去生活</h4><p>我相信什么？我心底最深层次的价值观有哪些？我觉得这两个问题是我们需要时常问自己的。人是被思想和信念塑造出来的产物，我们最终都会根据自己的价值观去行动。而有时候如果我们没有按照价值观和信念去生活，那只是因为我们还不够相信，或者缺乏足够的勇气。另外，正如《精力管理》中所说的，只有在行动中体现的价值观才是「美德」。</p><p>对我来说，我最重要的价值观是：<strong>友善、正直、诚实、为他人创造价值、快乐</strong>。那么，我应该如何培养自己的习惯，让自己能更充分地按照这些价值观去生活？首先，我需要学会相信他人，与他人合作，并且要学会习惯性地向他人表达自己的友好和善意，理解、同情、关心他人。要相信这个世界上的大部分人都是善良的，而且很多人都很努力，但是生活却不一定过得很好，所以，你更应该对自己的所拥有的一切感到感恩，除了让自己生活得更好，还应该去尽可能地帮助身边那些需要帮助的人。正直，意味着我要遵守自己的承诺，并且对自己和他人保持诚实，不说假话。为他人创造价值则可以体现在很多方面，既可以通过我的工作，也可以通过贡献出自己的休息时间，去参与一些公益事业的活动，即使很小很不起眼也值得去做，日常生活中的每一件小事也都算数。快乐是每个人生活的目标，但是要注意区分出那些低层次的快乐，不断提高自己的技能和领悟能力，去享受那种不需要依赖外物、从单纯的思考以及与自我和他人的心灵沟通中就能收获到的快乐，这种快乐能持续更长的时间，并且也会使人的精神变得更加富足。</p><h4 id="3-月-29-日-body-mind-spirit-and-feelings"><a href="#3-月-29-日-body-mind-spirit-and-feelings" class="headerlink" title="3 月 29 日 - body mind spirit and feelings"></a>3 月 29 日 - body mind spirit and feelings</h4><p>这个世界很大，你要多去尝试，才能知道什么样的生活才是适合自己的。有时候我们会习惯性地根据当下的生活来推断自己未来的生活，但是，要知道，这个世界是在不断变化中的，眼下的一切并不意味着未来的我们会以相同的方式继续生活下去，尤其是对于不超过 30 岁的年轻人来说。不要太早给自己盖棺定论。只要你<strong>敢于去挑战不同的生活方式，去面对未知以及你内心的恐惧，去选择做难一点的事</strong>，你的未来也许会发生很多有意思的、意想不到的变化。最重要的一点是，一定要不断地学习，多拷问自己：我现在做的事是否有意义？能否给我带来有益的成长？是否符合我的价值观？只要答案是 YES，那么就放手去做吧。即使在其他人眼中并不靠谱也没关系，因为你的人生并不依赖外界对你的看法。你需要把自己的生活过好，这是你的责任。照顾好自己的身体、心灵、灵魂和情绪，同样也是为自己负责。</p><h4 id="3-月-30-日-分享、给予和帮助他人"><a href="#3-月-30-日-分享、给予和帮助他人" class="headerlink" title="3 月 30 日 - 分享、给予和帮助他人"></a>3 月 30 日 - 分享、给予和帮助他人</h4><p>拥有越多的人，往往也更愿意去分享和给予。可能正是因为他们热爱分享和给予，所以获得了更多的机会以及得到了更多人的帮助，于是才能获得成功。但是，无论是否出于这样略显功利的目的，给予和分享的确是我应该努力做得更好的地方。其实单纯地分享和帮助他人，就已经能让人收获很多了，比如让人感受到快乐和被需要，得到他人的尊重，变得更乐观和积极向上等等。越是向他人索取，索取得越多，别人就越是离你越远，因为别人会感受到你是一个黑洞，只会吸收一切而不会发出自己的光亮去照耀他人；给予越多，你吸引到的人也越多，而且你吸引到的人很可能是和你一样热爱分享和帮助他人的人，这样你们就一起创建出了一个给予、分享、互助的环境，大家会一起变得越来越好。的确，有时候也会有一些烂人出现，但是那样的人最终是会被识别出来的，大家会自然而然地远离、孤立他们，所以，就算他们会对你造成一定的伤害，但这伤害也是有限的。所以，尽可能多地去分享、给予和帮助他人吧。</p><h4 id="3-月-31-日-自我美化的倾向"><a href="#3-月-31-日-自我美化的倾向" class="headerlink" title="3 月 31 日 - 自我美化的倾向"></a>3 月 31 日 - 自我美化的倾向</h4><p>每个人都有自我美化的倾向，比如我们想让自己在他人面前显得更聪明、更漂亮、更富有、更优雅等等。其实也不仅仅是出于虚荣心，因为我们天生都想要获得更多人的关注与尊重，得到他人的赞美。这是写在我们的基因里的。因为我们是社交动物，只有获得更多人的羡慕和认可，我们才能感受到自己的地位和价值，得到更多的生存空间，所以这种受到关注和赞美的感觉常常让人欲罢不能。虽然人性不可抗，但是，我觉得我们依旧可以利用这种人性的「弱点」去创造价值。比如利用这种心理去<strong>传播善良和爱，去积极地分享，不断地反思自己并超越自己</strong>。认识到自己的缺陷，同时也能看到自我的价值，在不断改进自身的同时，为他人创造价值，并且在分享、思考、改进中，形成一个正向的循环。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layout and State</title>
      <link href="/layout-and-state/"/>
      <url>/layout-and-state/</url>
      
        <content type="html"><![CDATA[<img src='https://4.bp.blogspot.com/-NnAkV5vpYuw/XNMYF4RtLvI/AAAAAAAAI70/kdgLm3cnTO4FB4rUC0v9smscN3zHJPlLgCLcBGAs/s1600/Jetpack_logo%2B%25282%2529.png' width=80%/><blockquote><p>跟随<a href="https://developer.android.com/courses/pathways/compose">官方文档</a>学习 Compose 的第二篇。第一篇：<a href="https://ajiew.github.io/thinking-in-compose">Thinking in Compose</a>。</p></blockquote><h2 id="Layout-in-Compose"><a href="#Layout-in-Compose" class="headerlink" title="Layout in Compose"></a><a href="https://developer.android.com/jetpack/compose/layouts">Layout</a> in Compose</h2><h3 id="Theming"><a href="#Theming" class="headerlink" title="Theming"></a><a href="https://developer.android.com/jetpack/compose/themes">Theming</a></h3><p>Android 之前的主题系统非常复杂，而且也很难用，我相信这是大多数开发者的共识。Android 开发团队当然也注意到了这一点，在设计 Compose 时，抛弃了（但也兼容）旧的系统。因此，在使用 Compose 时，应用 Material Design 主题或者自定义主题变得前所未有地简单和高效。</p><p>Compose 框架内置了 Material Design 主题，所有的组件都构建在该主题之上，与此同时，也非常易于自定义。<code>MaterialTheme</code> 由 <code>color</code>、<code>typography</code> 和 <code>shape</code> 三部分组成，所有的主题都是以树型的方式自顶向下应用到组件之上的，多个主题可以嵌套使用，因此，我们可以非常灵活地应用、修改、重用主题。又因为 Compose 中自定义组件非常常见，所以我们可以修改、应用主题到单个组件的级别。</p><span id="more"></span><h3 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h3><p>Modifier 有点像 React-Native 中的 StyleSheet，你可以使用它修改 composable 组件的外观、行为，添加额外信息等。Modifier 和普通的 Kotlin 对象没什么区别，可以作为变量使用，也可以和其它 Modifier 组合起来使用。</p><p>相比传统的 View 的属性，Modifier 还有一个额外的优势，那就是可以根据当前上下文推断出那些属性可用，防止你用错。另外，Modifer 属性应用的顺序也会直接影响到组件的外观。比如，<code>Modifier.padding(8.dp).clickable&#123;&#125;</code> 和 <code>Modifier.clickable&#123;&#125;.padding(8.dp)</code> 的可点击区域的大小是不同的，前者可点击区域在 padding 之内，后者可点击区域包括了 padding。</p><h3 id="Slots-APIs"><a href="#Slots-APIs" class="headerlink" title="Slots APIs"></a>Slots APIs</h3><p>Compose 中绝大多数内置组件的最后一个参数都是 <code>content: @Composable () -&gt; Unit</code>，结合 Koltin 的 <a href="https://kotlinlang.org/docs/lambdas.html#passing-a-lambda-to-the-last-parameter"><strong>trailing lambda</strong></a> 的语法，我们就可以很方便地写出相互嵌套的组件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Button &#123;<br>    Row &#123;<br>        MyImage()<br>        Spacer(<span class="hljs-number">4.</span>dp)<br>        Text(<span class="hljs-string">&quot;Button&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Container-Layout"><a href="#Container-Layout" class="headerlink" title="Container Layout"></a><a href="https://developer.android.com/jetpack/compose/layouts/basics">Container Layout</a></h3><p>Compose 从一开始就借鉴了很多 Flutter 元素，对于基础的布局而言尤其如此。如果你熟悉 Flutter，你一定对不会 Container 感到陌生，它是最基本的容器，所谓的「容器」指的是用于包含其它子元素的布局。在 XML 中，我们有线性布局、相对布局、FrameLayout 等容器布局，在 Compose 中，最基础的容器布局是：<code>Row</code>, <code>Column</code>, <code>Box</code>。</p><h3 id="Custom-Layout"><a href="#Custom-Layout" class="headerlink" title="Custom Layout"></a>Custom Layout</h3><p>Compose 中最基础的组件是 <code>Column</code>、<code>Row</code> 和 <code>Box</code>，通过它们我们可以组合出复杂的布局。但是，我们有时候可能也会用到一些更复杂的布局，这个时候就需要通过自定义 <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main-release:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/layout/Layout.kt"><code>Layout</code></a> 组件了。</p><h4 id="Compose-中的布局原则"><a href="#Compose-中的布局原则" class="headerlink" title="Compose 中的布局原则"></a>Compose 中的布局原则</h4><p>每个 composable 函数在执行之后都会释放出 UI 组件并被添加到视图树中，每个元素都有一个父元素以及多个（可能的）子元素，而且该元素有一个相对父元素的坐标 (x,y) 和大小 (width &amp; height)。每个元素在被添加到视图树之前，都需要被测量一次，并且需要满足父元素的限制条件，比如最小和最大的宽高。如果元素具有子元素，那么还需要测量其所有的子元素决定其自身的大小之后再被绘制出来。</p><p><strong>Compose 不允许元素多次测量</strong>，也就是说所有的元素<strong>只能测量一次</strong>，这么做的原因当然是为了性能考虑。因为 recomposition 的存在，如果同一个元素多次被测量会造成极大的性能浪费，尤其是在 UI 树嵌套很深的情况下，如果所有元素都测量多次以上，那么整个视图树 recomposition 的性能消耗将是巨大的。</p><h4 id="自定义-LayoutModifier"><a href="#自定义-LayoutModifier" class="headerlink" title="自定义 LayoutModifier"></a>自定义 LayoutModifier</h4><p>我们可以通过实现（扩展函数）Modifler 的 <code>layout()</code> 函数来修改如何显示一个元素。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Modifier.<span class="hljs-title">customLayoutModifier</span><span class="hljs-params">(...)</span></span> = Modifier.layout &#123; measurable, constraints -&gt;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>实现 LayoutModifier 需要用到两个参数：</p><ul><li><code>measurable</code>：代表需要被测量和放置的元素</li><li><code>constraints</code>：元素最小和最大的宽和高等</li></ul><p>除此之外，我们通过调用 <code>layout()</code> 返回一个 <code>MeasureResult</code> 供 LayoutModifer 确定测量结果（大小、对齐方式、位置等）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Modifier.<span class="hljs-title">customLayoutModifier</span><span class="hljs-params">(...)</span></span> = Modifier.layout &#123; measurable, constraints -&gt;<br>    <span class="hljs-comment">// measure UI</span><br>    <span class="hljs-keyword">val</span> placeable = measurable.measure(constraints)<br><br>    <span class="hljs-comment">// do other things</span><br><br>    layout(placeable.width, height) &#123;<br>        <span class="hljs-comment">// place it</span><br>        placeable.placeRelative(<span class="hljs-number">0</span>, paddingY)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意在 <code>layout()</code> 函数中，必须调用 <code>placeXXX()</code> 函数，否则元素将不可见。</p><h4 id="自定义-Layout"><a href="#自定义-Layout" class="headerlink" title="自定义 Layout"></a><a href="https://developer.android.com/jetpack/compose/layouts/custom">自定义 Layout</a></h4><p>除了自定义如何排列元素之外，我们还可以自定义 Layout。与自定义 LayoutModifier 类似，首先需要测量所有子元素的位置，然后根据 constraints 放置到合适的位置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">CustomLayout</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    modifier: <span class="hljs-type">Modifier</span> = Modifier,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// custom layout attributes goes here</span></span></span><br><span class="hljs-params"><span class="hljs-function">    content: @<span class="hljs-type">Composable</span> () -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>    Layout(<br>        modifier = modifier,<br>        content = content<br>    ) &#123; measurables, constraints -&gt;<br>        <br>        <span class="hljs-comment">// Measure each child</span><br>        <span class="hljs-keyword">val</span> placeables = measurables.map &#123; measurable -&gt;<br>            measurable.measure(constraints)<br>        &#125;<br>        <br>        <span class="hljs-comment">// Set the size</span><br>        layout(constraints.maxWidth, constraints.maxHeight) &#123;<br>            placeables.forEach &#123; placeable -&gt;<br>                <span class="hljs-comment">// Position each item</span><br>                placeable.placeRelative(x = <span class="hljs-number">0</span>, y = calculated)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Constraint-Layout"><a href="#Constraint-Layout" class="headerlink" title="Constraint Layout"></a>Constraint Layout</h3><p>尽管在 Compose 框架中，布局嵌套的深度对性能的影响并不是太大，但是我们依旧可以在一些布局复杂的场景中使用 Constraint Layout 来简化布局的实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">TestConstraintLayout</span><span class="hljs-params">()</span></span> &#123;<br>    ConstraintLayout(modifier = Modifier.fillMaxHeight()) &#123;<br>        <span class="hljs-keyword">val</span> (button1, button2, button3, button4, text) = createRefs()<br><br>        Button(onClick = &#123; <span class="hljs-comment">/*TODO*/</span> &#125;,<br>            modifier = Modifier.constrainAs(button1) &#123;<br>                start.linkTo(parent.start, <span class="hljs-number">16.</span>dp)<br>                top.linkTo(parent.top, <span class="hljs-number">16.</span>dp)<br>            &#125;) &#123;<br>            Text(text = <span class="hljs-string">&quot;Button1&quot;</span>)<br>        &#125;<br><br>        Button(onClick = &#123; <span class="hljs-comment">/*TODO*/</span> &#125;,<br>            modifier = Modifier.constrainAs(button2) &#123;<br>                top.linkTo(button1.top)<br>                end.linkTo(parent.end, <span class="hljs-number">16.</span>dp)<br>            &#125;) &#123;<br>            Text(text = <span class="hljs-string">&quot;Button2&quot;</span>)<br>        &#125;<br><br>        Button(onClick = &#123; <span class="hljs-comment">/*TODO*/</span> &#125;,<br>            modifier = Modifier.constrainAs(button3) &#123;<br>                start.linkTo(button1.start)<br>                bottom.linkTo(parent.bottom, <span class="hljs-number">16.</span>dp)<br>            &#125;) &#123;<br>            Text(text = <span class="hljs-string">&quot;Button3&quot;</span>)<br>        &#125;<br><br>        Button(onClick = &#123; <span class="hljs-comment">/*TODO*/</span> &#125;,<br>            modifier = Modifier.constrainAs(button4) &#123;<br>                top.linkTo(button3.top)<br>                end.linkTo(button2.end)<br>            &#125;) &#123;<br>            Text(text = <span class="hljs-string">&quot;Button4&quot;</span>)<br>        &#125;<br><br>        Text(text = <span class="hljs-string">&quot;Center&quot;</span>, modifier = Modifier.constrainAs(text) &#123;<br>            top.linkTo(parent.top)<br>            bottom.linkTo(parent.bottom)<br>            start.linkTo(parent.start)<br>            end.linkTo(parent.end)<br>        &#125;)<br><br>        Button(onClick = &#123; <span class="hljs-comment">/*TODO*/</span> &#125;,<br>            modifier = Modifier.constrainAs(createRef()) &#123;<br>                centerHorizontallyTo(parent)<br>                top.linkTo(text.bottom, <span class="hljs-number">24.</span>dp)<br>            &#125;) &#123;<br>            Text(text = <span class="hljs-string">&quot;Button5&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">val</span> barrier = createEndBarrier(button1, text)<br>        Text(<br>            text = <span class="hljs-string">&quot;To Be or Not To Be, that&#x27;s a question&quot;</span>,<br>            modifier = Modifier.constrainAs(createRef()) &#123;<br>                top.linkTo(text.top)<br>                start.linkTo(barrier, <span class="hljs-number">8.</span>dp)<br>                end.linkTo(parent.end)<br><br>                <span class="hljs-comment">// wrap content according to the constraints</span><br>                width = Dimension.preferredWrapContent<br>            &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src='../assets/2021-03-19/constraint_layout_example.png' width=30%/><p>Compose 中的 Constraint Layout 的用法和 View 系统中的 <a href="https://developer.android.com/training/constraint-layout">ConstraintLayout</a> 的用法差不多，主要包括以下几个部分：</p><ul><li>使用 <code>createRef()</code> 或者 <code>createRefs()</code> 来创建引用，其中 <code>parent</code> 是默认会被创建的引用</li><li>使用 <code>Modifier.constrainAs(referenceName)</code> 来创建约束内容</li><li>使用 <code>linkTo</code>、<code>centerHorizontallyTo</code> 等方法约束布局，还可以使用 <code>width</code> 等自定义 <code>Dimension</code></li><li>使用 <code>createXxxBarrier</code>、<code>createGuidelineFromXxx</code>、<code>createHorizontalChain</code> 等方法创建帮助约束</li></ul><p>除此之外，我们还可以使用动态约束，比如下面这个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">DecoupledConstraintLayout</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 根据不同的屏幕方向使用不同的 Constraint sets</span><br>    BoxWithConstraints &#123;<br>        <span class="hljs-keyword">val</span> constraints = <span class="hljs-keyword">if</span> (maxWidth &lt; maxHeight) &#123;<br>            decoupledConstraints(margin = <span class="hljs-number">16.</span>dp) <span class="hljs-comment">// Portrait constraints</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            decoupledConstraints(margin = <span class="hljs-number">32.</span>dp) <span class="hljs-comment">// Landscape constraints</span><br>        &#125;<br><br>        ConstraintLayout(constraints) &#123;<br>            Button(<br>                onClick = &#123; <span class="hljs-comment">/* Do something */</span> &#125;,<br>                modifier = Modifier.layoutId(<span class="hljs-string">&quot;button&quot;</span>)<br>            ) &#123;<br>                Text(<span class="hljs-string">&quot;Button&quot;</span>)<br>            &#125;<br><br>            Text(<span class="hljs-string">&quot;Text&quot;</span>, Modifier.layoutId(<span class="hljs-string">&quot;text&quot;</span>))<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create your own constraint sets</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">decoupledConstraints</span><span class="hljs-params">(margin: <span class="hljs-type">Dp</span>)</span></span>: ConstraintSet &#123;<br>    <span class="hljs-keyword">return</span> ConstraintSet &#123;<br>        <span class="hljs-keyword">val</span> button = createRefFor(<span class="hljs-string">&quot;button&quot;</span>)<br>        <span class="hljs-keyword">val</span> text = createRefFor(<span class="hljs-string">&quot;text&quot;</span>)<br><br>        constrain(button) &#123;<br>            top.linkTo(parent.top, margin = margin)<br>        &#125;<br>        constrain(text) &#123;<br>            top.linkTo(button.bottom, margin)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Intrinsic"><a href="#Intrinsic" class="headerlink" title="Intrinsic"></a>Intrinsic</h3><p>之前说过自定义布局的时候，Compose 只允许我们测量一次，否则会报错，但是，当我们需要在 measure 之前就知道布局的宽高信息的时候，该怎么办呢？这个时候就需要用到 Intrinsic 信息了，包括：</p><ul><li><code>(min|max)IntrinsicWidth</code>：在当前高度下，最小或最大的可用布局宽度</li><li><code>(min|max)IntrinsicHeight</code>：在当前宽度下，最小或最大的可用布局高度</li></ul><p>使用例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">TwoText</span><span class="hljs-params">(modifier: <span class="hljs-type">Modifier</span> = Modifier, text1: <span class="hljs-type">String</span>, text2: <span class="hljs-type">String</span>)</span></span> &#123;<br>    Row(modifier = modifier.height(IntrinsicSize.Min)) &#123;<br>        Text(text = text1,<br>            modifier = Modifier.weight(<span class="hljs-number">1f</span>).wrapContentWidth(Alignment.CenterHorizontally))<br><br>        Divider(color = Color.Black,<br>            modifier = Modifier<br>            .fillMaxHeight()<br>            .width(<span class="hljs-number">1.</span>dp))<br><br>        Text(text = text2,<br>            modifier = Modifier.weight(<span class="hljs-number">1f</span>).wrapContentWidth(Alignment.CenterHorizontally))<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p>此时，Row 的高度是由子元素中高度最高的元素决定的，而 Divider 因为使用了 <code>fillMaxHeight()</code> 所以其高度会填充此最小高度。</p><h2 id="State-state-in-Compose"><a href="#State-state-in-Compose" class="headerlink" title="[State][state] in Compose"></a>[State][state] in Compose</h2><h3 id="什么是-State"><a href="#什么是-State" class="headerlink" title="什么是 State"></a>什么是 State</h3><blockquote><p><strong>State</strong> in an application is <strong>any value that can change</strong> over time.</p><p>For example it may be a value stored in a Room database, a variable on a class, or even the current value read from an accelerometer.</p></blockquote><p>官方的解释是，应用中任何会随时间发生变化的值都可以被称作 State，比如网络状态，应用数据，UI 动画等等。</p><h3 id="创建-State"><a href="#创建-State" class="headerlink" title="创建 State"></a>创建 State</h3><p>我们可以通过使用 <code>mutableStateOf()</code> 给 composable 函数添加内部状态，当状态改变的时候，依赖该状态的 composable 函数会自动再次执行。创建 State 主要有以下几种方法：</p><ul><li><code>val state = remember &#123; mutableStateOf(default) &#125;</code>，直接取得 <code>MutableState</code></li><li><code>var value by remember &#123; mutableStateOf(default) &#125;</code>，通过关键字 <code>by</code>，以委托的方式初始化，需要导入 <code>androidx.compose.runtime.getValue</code> 和 <code>androidx.compose.runtime.setValue</code></li><li><code>val (value, setValue) = remember &#123; mutableStateOf(default) &#125;</code>，通过解构 <code>MutableState</code> 获得 setter 和 getter 函数</li></ul><h3 id="记住-State"><a href="#记住-State" class="headerlink" title="记住 State"></a>记住 State</h3><p>注意到上面创建 State 的方法中，全都使用了 <code>remember()</code> 函数，该函数用于记住该状态，如果不记住状态，那么该状态每次都会在 recomposation 的过程中被重新初始化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> color = remember(key = todo.id, calculation = &#123; randomTint() &#125;)<br></code></pre></td></tr></table></figure><p><code>remember()</code> 函数接受 key 和 calculation 函数，如果不传 key 则只有在 composition 才调用 calculation，否则会先比较 key 是否发生变化，然后再决定是否调用。</p><p>在使用 <code>remember()</code> 之前，需要问自己的一件事是：该状态是否有可能需要暴露给外界？如果是，那么就把它定义为 composable 函数的参数；否则，才使用局部变量。</p><p>另外，还需要注意到，当 Compose 组件被移除的时候，其「记住」的状态也会被移除，这在 LazyColumn 等组件中尤其需要注意，当列表长度很长并在可见区域之外时，组件可能会被移除掉并在回到原位置后重新渲染组件，因此记住的状态也会丢失。所以 <code>remember()</code> 只适用于记住一些暂时的状态。</p><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p><strong>Unidirectional data flow</strong>，即事件向上流动（事件输入），状态向下流动（更新状态）。比如 ViewModel 中通过方法调用传送事件，最后通过 LiveData 将状态更新通知给 UI。</p><img src='../assets/2021-03-19/unidirectional_data_flow.png' alt='unidirectional data flow' width=30%><p>Compose 中所有的内置组件都被设计成是单向数据流的，也即都是 Stateless 的。</p><h3 id="结合-ViewModel-的使用"><a href="#结合-ViewModel-的使用" class="headerlink" title="结合 ViewModel 的使用"></a>结合 ViewModel 的使用</h3><p>为了实现单向数据流和达到解耦的目的，我们可以将事件处理放到 ViewModel 中，再通过 LiveData 实现对状态更新的监听：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterViewModel</span> : <span class="hljs-type">ViewModel</span></span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _count = MutableLiveData(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">val</span> count: LiveData&lt;<span class="hljs-built_in">Int</span>&gt; = _count<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateCount</span><span class="hljs-params">(count: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        _count.value = count<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br>    <span class="hljs-keyword">val</span> viewModel <span class="hljs-keyword">by</span> viewModels&lt;CounterViewModel&gt;()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContent &#123;<br>            Surface &#123;<br>                Counter(count = viewModel.count.observeAsState().value!!,<br>                    updateCount = &#123; viewModel.updateCount(it) &#125;)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里关键的一步是对 <code>count</code> 值的监听，使用 <code>observeAsState()</code> 将 ViewModel 中的 LiveData 转换为可触发 recomposition 的 State。</p><h3 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h3><p>有时候，composable 函数可能需要将状态暴露给调用方，比如调用方需要通过获取状态进行一些操作或者为了方便测试，这种做法称为状态提升（state hoisting）。状态提升可以避免重复状态的出现以及引入 bug，因为如果在一个 composable 函数中使用了过多状态，通常会增加代码复杂度从而使得代码难以维护和容易产生 bug。</p><p>我们可以通过在 composable 函数中添加状态值（Value）和状态改变器（onValueChange: (T) -&gt; Unit）来实现状态提升：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Counter</span><span class="hljs-params">(count: <span class="hljs-type">Int</span>, updateCount: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    Button(onClick = &#123; updateCount(count + <span class="hljs-number">1</span>) &#125;) &#123;<br>        Text(<span class="hljs-string">&quot;I&#x27;ve been clicked <span class="hljs-variable">$count</span> times&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用状态提升的好处是<strong>只有创建该 composable 函数的地方，才能修改其状态</strong>。我们可以通过状态提升将一个 Stateful 组件转换成一个 Stateless 组件，而 Stateless 组件的优势是可以更方便地组合重用。</p><p>另外，在使用状态提升时，第一步需要考虑组件的<strong>状态树</strong>，尤其是在组件是由多个子组件嵌套形成的时候，需要考虑该组件的使用场景，以及应该将该状态提升到哪一级。</p><p>[state]: <a href="https://developer.android.com/jetpack/compose/state">https://developer.android.com/jetpack/compose/state</a> </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Android </tag>
            
            <tag> Compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thinking in Compose</title>
      <link href="/thinking-in-compose/"/>
      <url>/thinking-in-compose/</url>
      
        <content type="html"><![CDATA[<img src='https://3.bp.blogspot.com/-VVp3WvJvl84/X0Vu6EjYqDI/AAAAAAAAPjU/ZOMKiUlgfg8ok8DY8Hc-ocOvGdB0z86AgCLcBGAsYHQ/s1600/jetpack%2Bcompose%2Bicon_RGB.png' width=90%/><p>Compose 终于迎来了第一个 Beta 版本，这意味着其 API 已经基本稳定了，所以这个时候开始学习 Compose 是最合适的。这篇主要是我在读了<a href="https://developer.android.com/jetpack/compose/mental-model">官方文档</a>后做的笔记，关于 Compose 的开发模式以及需要注意的地方。</p><h2 id="什么是-Compose"><a href="#什么是-Compose" class="headerlink" title="什么是 Compose"></a>什么是 Compose</h2><blockquote><p>Jetpack Compose is a modern <strong>declarative UI</strong> Toolkit for Android. Compose makes it easier to write and maintain your app UI by providing a <em>declarative API</em> that allows you to render your app UI without imperatively mutating frontend views.</p></blockquote><p>和 React-Native、Flutter、SwiftUI 一样，Compose 是一种声明式编程的 UI 框架。简单来说，就是让你可以直接使用 Kotlin 代码编写视图，而不需要每次从视图树中获取视图并进行修改。</p><span id="more"></span><h2 id="声明式编程范式"><a href="#声明式编程范式" class="headerlink" title="声明式编程范式"></a>声明式编程范式</h2><h3 id="传统方式的缺点"><a href="#传统方式的缺点" class="headerlink" title="传统方式的缺点"></a>传统方式的缺点</h3><p>视图树中的每个组件都在内部维护着自己的状态（State）。在修改组件之前需要先找到该组件，然后调用相应的方法去修改状态（命令式）。这种方式不旦繁琐，而且容易产生 bug，比如修改视图状态时造成冲突。</p><h3 id="Declarative-UI-model"><a href="#Declarative-UI-model" class="headerlink" title="Declarative UI model"></a>Declarative UI model</h3><p>只需声明组件，当状态发生变化时，重新生成并更新视图，在 Compose 框架中此过程叫做 <a href="https://developer.android.com/jetpack/compose/mental-model#recomposition">Recomposition</a>。不过，在实际情况下，为了减少性能损耗，Compose 框架会判断哪些组件需要更新，从而只更新需要更新的部分。</p><p><strong>优点1：</strong>将可变的状态暴露成方法参数，从而可以和架构模式中一些组件（比如 ViewModel）结合起来使用：Compose 接受初始数据，当用户输入数据时将事件通知给 ViewModel 去处理，然后 ViewModel 再通知 Compose 重新对视图进行渲染。</p><p><strong>优点2：</strong>动态性。可以充分发挥 Kotlin 语言的优势，只需要很少的代码就可以轻松写出灵活多变的视图结构。</p><h2 id="Composable-函数的组成部分"><a href="#Composable-函数的组成部分" class="headerlink" title="Composable 函数的组成部分"></a>Composable 函数的组成部分</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Greeting</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> &#123;<br>    Text(<span class="hljs-string">&quot;Hello, <span class="hljs-variable">$name</span>!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Composable 函数必须使用 <code>@Composable</code> 注解。使用该注解告诉 Compose 编译器可以将该方法转换成 UI。</li><li>Composable 函数接收参数。</li><li>Composable 函数没有返回值。</li><li>Composable 函数运行具有等幂性（idempotent）、无副作用（side-effect free）、运行快的特点。<ul><li>等幂性即使用相同参数调用一次和调用多次的结果相同，不依赖全局变量或者随机结果函数。</li><li>只修改 UI 而不产生任何 side-effects，即不造成除 composeable 函数以外的任何变化，比如修改成员属性或者全局变量的值、读写数据库、更改 ViewModel 的状态等等。</li></ul></li></ul><h2 id="Recomposition"><a href="#Recomposition" class="headerlink" title="Recomposition"></a>Recomposition</h2><p>传统开发方式中，当我们需要修改视图的时候，会先找到该视图然后进行修改，但是在 Compose 框架中，我们通过重新调用 composable 函数（传入新数据），然后由 Compose 框架对视图进行修改，此过程就叫做 <em><strong>recomposition</strong></em>。</p><p>之前说过，重新生成整个视图树代价高昂，所以出于性能考虑，Compose 框架只会对发生变化的部分进行修改，此过程也被叫做 <em>intelligent recomposition</em>。</p><p>正因如此，在 recomposition 的过程中，一些函数、lambda 表达式有可能会被跳过，也是因为这个原因，我们才不能依赖任何 side-effects，比如：</p><ul><li>对一个共享对象的属性值进行修改</li><li>更新 ViewModel 中的 Observable</li><li>更新 SharedPreference</li></ul><p>另外，composable 函数可能被多次执行，甚至每一帧执行一次（比如执行动画的时候），所以如果你的 composable 函数中包含一些耗时操作（比如读写 SharedPreference），最好放到子线程中进行，比如使用 <a href="https://kotlinlang.org/docs/coroutines-overview.html">Coroutine</a> 并将结果作为参数传递到 composable 函数中。</p><p>除此之外，在使用 Compose 的过程中还需要注意以下这些问题。</p><h4 id="Composable-函数不一定会按顺序执行"><a href="#Composable-函数不一定会按顺序执行" class="headerlink" title="Composable 函数不一定会按顺序执行"></a>Composable 函数不一定会按顺序执行</h4><p>通常情况下，composable 函数的确会按顺序执行，但是当一个 composable 函数中包含其它 composable 函数时，就不一定是按顺序执行的了。Compose 框架会识别出具有更高优先级的 UI 组件，并对它们优先进行渲染。所以，当嵌套使用 composable 函数的时候，要记得每个 composable 函数必须是独立的，不能依赖其它 composable 函数的执行状态。</p><h4 id="Composable-函数可能同步执行"><a href="#Composable-函数可能同步执行" class="headerlink" title="Composable 函数可能同步执行"></a>Composable 函数可能同步执行</h4><p>在 recomposition 过程中，为了加快运行速度，多个 composable 函数可能会同时被执行。另外，这也意味着某些 composable 函数会被放到后台子线程中执行。比如，当 composable 函数参数中包含 ViewModel 中的方法，那么该方法有可能在多个线程中被执行了多次。所以，我们不能在 composable 中引入 side-effects。</p><h4 id="Recomposition-会尽可能多地被跳过"><a href="#Recomposition-会尽可能多地被跳过" class="headerlink" title="Recomposition 会尽可能多地被跳过"></a>Recomposition 会尽可能多地被跳过</h4><p>正如之前所说，Compose 只会更新需要更新的部分，剩下的部分会被跳过。</p><h4 id="Recomposition-是乐观的并且可能会取消并重新执行"><a href="#Recomposition-是乐观的并且可能会取消并重新执行" class="headerlink" title="Recomposition 是乐观的并且可能会取消并重新执行"></a>Recomposition 是乐观的并且可能会取消并重新执行</h4><p>每当参数发生变化的时候，recomposition 就会发生。乐观的意思是 Compose 通常会认为在接收到新的参数变化之前，已经完成了上一次的 recomposition，所以，当参数发生变化时，如果上一次 recomposition 还没完成，Compose 会优先取消掉它并使用新的参数重新执行 recomposition。</p><p>同样的，如果你在 composable 函数中包含 side-effects，比如修改了某个全局参数，那么该参数有可能在 recompositon 取消并重新执行的过程中被修改了多次。所以，再次提醒，一定要保持 composable 函数的等幂性 idempotent 和无 side-effects。</p><h4 id="Composable-函数可能被频繁执行"><a href="#Composable-函数可能被频繁执行" class="headerlink" title="Composable 函数可能被频繁执行"></a>Composable 函数可能被频繁执行</h4><p>在某些情况下，composable 函数可能每帧都被执行一次，比如使用动画的时候。所以，记住不要在 composable 函数中执行诸如 IO 等耗时的操作。一般的做法是将数据定义在 composable 函数的参数中，如果获取数据比较耗时则应该放在子线程中，然后使用 MutableState 或者 LiveData 对数据进行接收。</p><p>链接：<a href="https://developer.android.com/jetpack/compose/mental-model">Thinking in Compose</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Android </tag>
            
            <tag> Compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>活着真好</title>
      <link href="/2021-2/"/>
      <url>/2021-2/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/nYhmuDfacpI" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>每年的二月通常都是一个人最慵懒的时候，尤其是春节假期临近的那段时间，我觉得这个时候是修改你的新年计划最好的时机。并不是所有人都喜欢春节，我虽然也会期盼春节，但是主要还是希望能有段时间放松一下，见见久违的家人，心安理得地过上一段懒散日子。但是，前提是希望家人亲戚可以不聊那些让彼此不舒服的话题，每次聊那些话题都会给家人间的温情时光蒙上一层阴影。不过，这个矛盾很难调和吧。正是因为我们是家人，所以大家的边界感才会比其他人更弱一些，所以我们才自以为可以聊一些敏感的话题。毕竟，有再大的气在一句「我还不是为了你好」面前都会漏气。另外，春节也是也是一个极佳的反思自己的时机，看看自己的家人，你一定能从他们身上发现自己的影子，即使你不怎么回家，你的思维方式总归有一部分继承自你的家人，你的缺点有一半都能在他们身上找到。家人就是一面镜子。</p><p>除开春节，二月过得其实还挺普通的。只不过在冬天即将过去的时候，突然觉得有点留恋，喜欢这个一件羽绒服可以穿好几个星期的季节，还喜欢热气腾腾的早餐店，戴着手套和大帽子的环卫工人，一进办公室扑面而来的温暖空气，总是被各种装饰灯点亮着的树枝，穿着外套的宠物狗，踉跄着往前跑的、被裹得严严实实的小娃娃，还有早晨温暖的被窝。每次注意到这些琐碎的生活日常的时候，都要记得在心中提醒自己：活着真好。</p></blockquote><h4 id="2-月-1-日-Money-health-wit"><a href="#2-月-1-日-Money-health-wit" class="headerlink" title="2 月 1 日 - Money, health, wit"></a>2 月 1 日 - Money, health, wit</h4><p>人生最核心的问题有哪些？Money, health, wit.  鲁迅先生说：梦是好的；否则，钱是要紧的。没有经济基础的支撑，谈其它所有的一切都显得有点乏力。赚钱能力是一个人应该具备的最基本的能力。而健康应该是比钱更重要的，没有健康其它一切都没有了意义。所以，永远要把健康放在第一位，努力维持好它。至于智慧，它决定了一个人如何生活，能否获得幸福和平静，能做出什么样的事业，能影响到多少人，能给这个世界带去什么样的益处。努力增加自己的智慧是我们一生的功课。</p><span id="more"></span><h4 id="2-月-2-日-复盘人生，不断进步"><a href="#2-月-2-日-复盘人生，不断进步" class="headerlink" title="2 月 2 日 - 复盘人生，不断进步"></a>2 月 2 日 - 复盘人生，不断进步</h4><p>晚上冥想的时候用上帝视角观察了一下自己。到目前为止，我已经生活了快 27 年，人生差不多过去了三分之一。但是，在这三分之一的时光里，我的绝大多数时间都用在了求学以及建立对这个世界的基本认识上。接下来的几十年将是我人生中的壮年时期，我将在这段时期经历人生中最重要的一些事情，包括和他人建立长期的友情、爱情关系，创造出我这一生中能创造的绝大部分财富，以及更广阔而深入地探索这个丰富多彩的世界。</p><p>我觉得我们能够生活在这个多变的时代是幸福的，社会高速发展，我们比前人有更多的机会去尝试人生的各种可能性。但是，机会多并不意味着所有人都能拥有同等的待遇，我们还是得努力去创造价值，让自己能够做出更多选择，去体验不同的人生。</p><p>抛开过去和未来，我喜欢自己现在的状态吗？尽管有不太满意的地方，但是总体而言，我觉得自己还算是比较幸运的。那么，我现在有清晰的努力的方向吗？只能说有一个模糊的方向，但是并不算是有具体的目标。终极目标是想要度过一个幸福且有意义的人生。这需要我：第一，在这座城市立足，拥有房产，安定下来；第二，能有一定的积蓄，可以去做自己想做的事而不是被迫谋生；第三，结合自己的兴趣和优势，为他人和社会创造价值。现在看来，光是完成第一点就已经非常非常难了，更不要说其它了。不过，还是要有信心，尤其是在当前这个阶段要足够努力。不仅仅是提升技能，积累财富，还得培养好习惯，开阔眼界，结识优秀的人，和比自己更强的人靠近，不断进步下去才行。</p><h4 id="2-月-3-日-获取信息的方式"><a href="#2-月-3-日-获取信息的方式" class="headerlink" title="2 月 3 日 - 获取信息的方式"></a>2 月 3 日 - 获取信息的方式</h4><p>我是如何获取信息的呢？除了有意识地获取自己感兴趣的内容之外，大部分信息都来自于发散式的获取。比如偶然看到一篇文章，被其中的某些内容吸引，点开链接，然后搜索相关内容，接着发现自己从来没有接触过的领域，然后加入收藏，并进一步阅读和学习。大部分信息都像一个个神经节点，通过发现一个新节点，就可以顺着通路触摸到其它越来越多的新节点。我觉得这种获取新信息的方式还是挺有趣的，也挺高效的，虽然你无法掌控自己会接触到什么样的信息，但是因为未知，所以才有惊喜，而且能吸引到你的都是你感兴趣的内容，你会更有动力去挖掘出隐藏的好玩的东西。不过，这种方式也有缺点，那就是你容易陷入同质化的内容里。所以这就要求你能筛选自己的信息获取渠道，保证它们的来源尽量是丰富且多样化的，还有就是要用多个渠道获取信息，不要依赖某个单一渠道。</p><h4 id="2-月-4-日-学会更好地沟通"><a href="#2-月-4-日-学会更好地沟通" class="headerlink" title="2 月 4 日 - 学会更好地沟通"></a>2 月 4 日 - 学会更好地沟通</h4><p>和他人沟通的时候，有时候我们会觉得对方不可理喻，或者觉得对方的理解能力很差。但是，不能仅凭一点点信息就对对方的人格或者能力下定论，很多时候可能只是我们的表述不够准确，导致对方没有完全理解我们想要表达的意思。我发现自己在工作中常常会犯这样的错误，比如对方没有给出有针对性的回复，或者并没有完全解答我的问题，我就会在心中默默给对方贴上「笨」或者「懒」的标签。然后下次再和对方接触的时候，心中就会带着这样的偏见，这样只会导致两个人的沟通变得更不顺畅。所以，第一步，我需要消除自己的偏见，保持谦虚，因为他人本可以用敷衍甚至恶劣的态度来应对你的傲慢，但是他们没有，这更说明你应该保持对对方的尊重。其次，记住沟通的目的，是为了交换信息，而不是证明谁比谁更聪明。最后也是最重要的一点，要学习并掌握沟通的技巧，具体方法在看过的<a href="https://book.douban.com/people/85276219/collect?sort=time&tags_sort=count&filter=all&tag=%E6%B2%9F%E9%80%9A&mode=grid">书</a>中都有了，我需要做的是对照自己的不足之处多多练习。</p><h4 id="2-月-5-日-成为让人感觉如沐春风的人"><a href="#2-月-5-日-成为让人感觉如沐春风的人" class="headerlink" title="2 月 5 日 - 成为让人感觉如沐春风的人"></a>2 月 5 日 - 成为让人感觉如沐春风的人</h4><p>我觉得一个男性身上能发生的最糟糕的变化是变得油腻以及变得没有风度。前者可以靠自律解决，但是后者纠正起来就比较困难了。最好的做法是在年轻的时候就养成<strong>永远保持风度</strong>的习惯。无论是和异性还是和同性在一起，很多细节都可以体现出一个人的风度。比如进门后给后面的人挡一下门，上车时让女性先上，坐地铁时主动给孕妇、老人等有需要的人让座，走路轻巧，避免打扰、影响到他人，聊天时照顾他人尤其是弱者的感受，不说不合时宜的话等等。我觉得这些是体现一个人风度和修养的基本表现，越是在年轻的时候养成这些习惯，它们就越容易成为你的一部分。日常生活中多注意这样的细节，多思考如何改进自己的行为举止让自己变得更有风度，时间长了之后，你会感觉不到自己在刻意保持风度。那种状态可能就是大家说的<strong>让人感觉如沫春风的人</strong>吧。</p><h4 id="2-月-6-日-塑造自己的环境"><a href="#2-月-6-日-塑造自己的环境" class="headerlink" title="2 月 6 日 - 塑造自己的环境"></a>2 月 6 日 - 塑造自己的环境</h4><p>昨晚看了《我住》新的<a href="https://www.hezhimeng.cn/videoDet.html?videoId=771b936402178e107bf1696c048ec7c7">一集</a>，被主人公那种乐观、勇敢、拼搏的精神打动了，忍不住在想，到底是什么让我们如此不同？为什么有的人明明拥有那么少但是却可以在精神上如此富有？他们明明可以堕落但是反而却在一直努力奋斗，走出一条属于自己的路，不但改善了自己的处境也影响了周围其他人的生活，让别人和自己一起变得更好。如果真的只是基因的原因，那么照理说进化应该早就让所有人都具备这样的基因了。</p><p>我觉得更大的原因还是我们所处的环境，包括我们所受的教育，自幼被灌输的观念，选择以什么样的人作为自己的榜样，以及在我们的成长过程中，我们是如何认识这个世界和自己所处的环境的，我们开始持有什么样的信念，接触到的形形色色的人和事物，如何解读它们，等等等等。这些综合起来，造就了此刻的我们，让我们对同一件事可以产生天差地别的看法，让人群中有今朝有酒今朝醉的人，也有以实现伟大人生理想为目标的人。</p><p>这也提醒了自己，要注意塑造自己的环境，你就是自己周围环境的产物。<strong>看看自己的四周，看看你工作和生活的环境，这差不多就是你的真实样子。</strong>如果你不喜欢这样的环境，那就思考下什么样的环境才是最理想的，你需要做出哪些改变才能让自己慢慢接近那种理想的状态。另外，这个时代还给我们提供了一个便利：互联网。即使周围环境不太理想，我们也可以在网络上找到丰富的资源去提升自己；只要你愿意展开怀抱，就可以在网络上找到和自己志同道合的人。如果这样你还无法改变自己，那么就不应该责怪环境了。《黑客与画家》中有句话我觉得很对：<strong>我们这个世界，你向下沉沦或者向上奋进都取决于你自己，不能把原因推给外界。</strong></p><h4 id="2-月-7-日-To-Think-List-和感受当下"><a href="#2-月-7-日-To-Think-List-和感受当下" class="headerlink" title="2 月 7 日 - To Think List 和感受当下"></a>2 月 7 日 - To Think List 和感受当下</h4><p>人一天绝大部分时候都处于无意识状态，既不是在思考问题，也没有产生任何有价值的想法。比如跑步、走路、做家务的时候，我常常会用听音乐、播客来充斥自己的时间，并不是说它们不好，因为很多时候通过这些媒体的确能让我收获一些有价值的信息，获得陪伴，得到继续下去的动力。但是如果能摘掉耳机，单独和自己的内心相处，思考一些有价值的问题，其实也是一件有意义的事情。我觉得我们每个人都应该准备一个 To Think List，记录日常生活中一些值得思考的想法，然后在某些独处时刻，可以把这些问题拿出来思考。又或者什么都不想，只是专注感受当下的一切，感受周围的事物，你眼中的世界，听到的声音，空气中的味道，微风吹拂脸颊的感觉，感受你身体的状态，此刻的情绪。这也是冥想的一种。</p><h4 id="2-月-8-日-不要说教，吸引你的同类"><a href="#2-月-8-日-不要说教，吸引你的同类" class="headerlink" title="2 月 8 日 - 不要说教，吸引你的同类"></a>2 月 8 日 - 不要说教，吸引你的同类</h4><p>人是观念的产物，越来越认同这句话。无论社会环境、时代如何变迁，人始终是以观念分群的。但是，有时候也要注意，不要急于把自己的观念灌输给他人，因为你无法在短时间内改变一个人，哪怕是圣人也做不到。所以，最好的做法是，偶尔提个一两句就够了，剩下的用行动来证明。至于他人能否被改变，或者是否认同我们的观念，这就要看运气了。还有，与其花精力改变那些和自己关系不那么亲近的人，不如把更多的时间用于改变自己身边最重要的人。那些和自己朝夕相处、未来长期和自己为伴的人无非就是家人、爱人和好友，尽量把好观念分享给他们，让他们和自己一起慢慢变得更好，就够了。改变自己的家人可能比较难，因为他们的观念往往已经定型了。不过，哪怕他们无法接受我们的观念，只要能维持相亲相爱的程度也就足够了。但是，对于爱人和好友，这是我们能够选择的。只要我们有足够的耐心，培养出足够的分辨力，能看出什么才是对自己真正有益的东西，心中始终不放弃希望，坚持自己的信念，那么，吸引到自己的同类的是件大概率的事情。</p><h4 id="2-月-9-日-让他人因你而受益"><a href="#2-月-9-日-让他人因你而受益" class="headerlink" title="2 月 9 日 - 让他人因你而受益"></a>2 月 9 日 - 让他人因你而受益</h4><p>很多时候我们感到幸福或者不幸，都取决于我们如何解读自己的处境。如果我们选择用负面、消极的视角去看待他人和周围的一切，那么我们自然就会感到不快乐、不满足，但是如果我们使用一种更乐观积极的态度，那么，所有人都是我们的朋友，周围人所做之事都是善意的。我们会感到知足，同时感恩自己所拥有的一切。毕竟我们时时刻刻在接受他人的付出，也为他人付出。但是，我觉得<strong>我所得到的远远大于我为他人的付出</strong>，所以这就更应该感恩了。我现在能做的是，慢慢变得更成熟，承担更多的责任，为自己的家庭做出更多的贡献，然后延伸开来，帮助更多的人，为更多的人做出贡献。首先要让自己变得更好，然后让更多的人和自己一起变得更好；先让身边的人受益，然后再让更多的人因我而受益。</p><h4 id="2-月-10-日-假期中的自我纠正"><a href="#2-月-10-日-假期中的自我纠正" class="headerlink" title="2 月 10 日 - 假期中的自我纠正"></a>2 月 10 日 - 假期中的自我纠正</h4><p>假期在家最大的问题是作息和饮食不规律。昨天在家第一天，起的还算早，但是到了晚上就熬夜了，导致今天早上睡到 8 点半，而且睡了懒觉，结果感觉没睡醒，睡眠效果还不如平时睡 7 个小时。吃的方面也没法控制好，总是容易吃得太多，还会吃一堆乱七八糟的东西，所以肚子老是感觉有点胀胀的不舒服。解决办法当然还是要养成习惯，提醒自己要少吃一点，尽量保持平时的生活节奏。还有就是要做好计划，虽然不一定能精准执行，但是能避免让自己处于无所事事、不知道该干什么的状态。所以打算重新开始写每日计划，包括要看的书，要完成的项目，复习计划，以及娱乐——要看的电影和美剧等等。晚上的时间一般不会被打扰，所以可以用来看书和写作，以及早点上床睡觉，每天按时起床，不要睡懒觉。假期还剩 8 天，希望自己除了好好休息之外，尽量多阅读，多思考，多产出一些对自己和他人有意义的东西。</p><h4 id="2-月-11-日-承担家庭责任"><a href="#2-月-11-日-承担家庭责任" class="headerlink" title="2 月 11 日 - 承担家庭责任"></a>2 月 11 日 - 承担家庭责任</h4><p>今天除夕，也是在家的第三天，假期还剩 7 天。有时候觉得自己有点虚伪，因为感觉自己的想法和行动并没有保持一致。嘴上说要为家人做贡献，但是实际上大部分时间什么都没干，待在自己房间做自己的事，都没有下楼去看看有什么忙能帮的。可能还是习惯了接受家人的付出了吧，爸爸妈妈忙里忙外，姐姐打扫卫生，而我好像什么都不用干。不过这样的模式也没有多久可以持续了，姐姐马上要结婚了，明年春节家里可能就只剩我和爸妈了吧。其实自己也不小了，有时候真的应该用更成熟的视角来看待自己，比如多对比他人的付出和你的付出，多想想你能为他人做什么，而不是一味地索取，不要以为一切都是理所当然的。还有关于金钱，有时候如果你能主动承担一些家庭开销，其实这也是一种负责任的表现，不要觉得这不关自己的事，即便没多少钱，但是也能让爸妈感到开心和欣慰。</p><h4 id="2-月-12-日-家人最重要"><a href="#2-月-12-日-家人最重要" class="headerlink" title="2 月 12 日 - 家人最重要"></a>2 月 12 日 - 家人最重要</h4><p>今天正月初一，在家第 4 天，假期还剩 6 天。昨天下午很早就吃完了年夜饭，老妈和老姐在收拾，我和老爸出去散步。一路上听他描述村里的建筑，以及经过的都是谁谁谁家，彼此关系等等。突然有一阵感到有些沮丧，我发现我们只能停留在这种表层的沟通，而无法深入沟通一些更深层的话题，了解彼此内心最深处的想法。不过，从这些日常的话题中，也能看出彼此观念上的差异。我们终究差了一个世代，很多观念注定是没法互相理解的。其实很早之前就察觉到这个问题了，只不过那时候自己的人生观也还在形成当中。但是，我多少也受到了父母的一些影响，也从他们身上学到了一些东西，比如基本的公序良俗，与人为善、边界感等等。我曾经也渴望与父母有更多亲密的交流，但是由于我们所受教育的不同，往往不能如愿。不过这并不影响我爱他们，而且我知道他们也很爱我。虽然可能少了点什么，但是这世上本来就充满遗憾。我所能做的只是多与他们沟通，尤其是老爸，平时和老妈视频比较多，但是常常忽略了他。这是我今年需要改变的地方。</p><p>另外，每次过年都会察觉到家里关系的微妙变化，比如今年老姐的变化是最大的，可能是因为她要结婚了吧。一个人结婚之后就会从原生家庭慢慢剥离出去，和原生家庭的关系也会慢慢变淡，毕竟她要组建自己的家庭了。未来的我也会经历这个阶段吧。</p><p>还有就是钱的问题，今年的我突然意识到这个问题。每次过年家里的年货都是父母负责，这几年老姐也开始负责一部分，尤其是今年，老姐还给家里买了一个冰柜，然后我也开始在心里觉得有点过意不去，毕竟我也是这个家庭的一份子，但是好像什么都没有付出。明年应该可以做出一点改变吧，哪怕只是一点点礼物或者金钱，有时候仅仅展示出一种 gesture 也是好的，至少说明你愿意为这个家出一份力。</p><p>关于老妈，有时候总觉得母爱太让人窒息了，总觉得自己没法回报她的爱，而且这种爱并不是那种乍一看多么伟大的爱，很多时候都是一些小细节，比如在你还没起来的时候就把早餐做好，把好吃的东西都留给你，在你回家的时候，把所有细节都处理好，让你在家里过得温暖舒适等等。我有点怀疑自己有了小孩之后能否做到她这种程度。除了感恩之外，目前来看，我能做的是努力提高自己的能力，把自己的生活过好、过得幸福，这应该是她最大的愿望了。未来等自己的能力足够的时候，希望自己能有更多的时间陪伴他们，把我眼中的世界分享给他们，以及让他们生活得更幸福。</p><h4 id="2-月-13-日-接受彼此生活习惯的不同"><a href="#2-月-13-日-接受彼此生活习惯的不同" class="headerlink" title="2 月 13 日 - 接受彼此生活习惯的不同"></a>2 月 13 日 - 接受彼此生活习惯的不同</h4><p>今天正月初二，在家第 5 天，假期还剩 5 天。在家的这几天，感觉到自己越来越不把家当做「家」了，而是觉得自己只是一个临时回来的「住户」，不知道为什么会有这种感觉。分析了一下，我觉得可能主要有两方面的原因。一方面是因为自己年龄变大了，意识到自己是个成年人之后，就无法再心安理得地接受父母的付出了；另一方面，由于和父母在观念、生活习惯方面的差异慢慢加大，很多时候无法认同彼此的一些想法和习惯，所以自然而然就有一种疏离感。过去因为我们朝夕相处，一些问题都察觉不到，但是随着自己的成长，回家的次数减少了，观念上的差距也逐渐加大了，这造成了我们行为方式的不同。因此，每到春节等长假期的时候，这种差异才会如此明显地显现出来。大到衣服应该手洗还是用洗衣机洗，小到厨房用品的摆放等等，分歧可以说是无处不在。</p><p>不过，我也能理解他们，因为成长环境的不同，他们那一代人的生活习惯是比较粗线条的，而且习惯了能省则省、绝不浪费的生活方式，尽管很多时候这种「节俭」在我们后辈眼里都是不必要的。但是，无论如何都要学会尊重彼此的不同吧。而且讲道理，这是他们的家，他们想怎么干就怎么干，我们作为子女也无权插手干涉。所以，即使再怎么不舒服也得忍着。这也提醒了自己，要好好赚钱，早点拥有自己的房子，这样就可以按照自己的想法去布置、去按自己的想法生活了。</p><p>这么一想更加让我坚定了「成年人一定要离开父母独自生活」，作为过去和他们朝夕相处、一起成长的人都无法忍受他们的一些生活习惯，又怎么能要求一个陌生人（伴侣）能够接受他们呢？另一方面也说明了两个人在一起，彼此相似的生活习惯有多么重要。如果差异过大，很难想象两个人怎么能长期生活在一起。不过，我也知道两个人完全契合的可能性有多低，肯定还是需要彼此磨合一段时间。但是，只要一些根本的观念没有太大的分歧，其实那些细枝末节的地方，只要彼此提前沟通好，加上相互妥协和谅解，问题也都能解决的。</p><h4 id="2-月-14-日-以爱意报答爱意"><a href="#2-月-14-日-以爱意报答爱意" class="headerlink" title="2 月 14 日 - 以爱意报答爱意"></a>2 月 14 日 - 以爱意报答爱意</h4><p>今天正月初三，在家第 6 天，假期还剩 4 天。在外婆家玩的时候，老妈问外婆某个东西有没有拿出来吃，因为不吃会坏了。外婆说没有，于是老妈非常担心的样子，去找到并拿了出来而且一定要让外公吃一个，外公说不想吃，外婆说让我吃一个，于是老妈转头问我要不要。其实，当老妈多次劝外公吃一个的时候，我心里已经有点不开心了，因为想到她之前也是这样「强迫」让我接受她觉得好的东西的。于是我情绪突然变得激动，提高声音说了一句「你自己想吃就吃呗，干嘛一定要让别人吃？！」老妈听了，委屈地说了一句「让你吃东西你还要骂我」。然后外婆也打圆场说是我让你吃的，我小声回答我现在不想吃。</p><p>老实说，当时做出这种反应的确有点冲动了，没有控制好自己的情绪。所以说人往往在爱自己的人面前才会失去控制自己情绪的能力。仔细反思下，我当时为什么会对老妈有这么大的情绪？其实不仅仅是因为曾经被迫接受她「对我好」的经历，还有想到这种行为背后隐藏的我无法照顾好自己，不好意思说出自己心底的想法、需要他人代劳的潜台词，这是变相的对我的能力的贬低，暴露出我不如他人等等。</p><p>不过，这一切都是我自己的解读，我当时选择用这样的方式解读其实说明了我还不够成熟，没有意识到自己相比过去其实已经改变了很多，我已经不是那个弱小无助的人了，现在的我对自己的人生享有完全的掌控权，除非得到我的允许，他人无法再控制自己了。所以，我不应该再被那些想法绑架，我应该认识到，老妈这种行为背后并没有别的意图，只是因为她爱我，想要把她觉得好的东西分享给我，仅此而已。我要做的是接受她的爱以及学会感恩。连岳说过，要以爱意报答爱意，而不是以恶意回馈爱意。对自己爱的人尤其如此。<strong>世界上没有完美的家人和爱人，幸福就是能注意到他人身上的闪光点。</strong></p><h4 id="2-月-15-日-我们这一代人的幸运以及逃离农村"><a href="#2-月-15-日-我们这一代人的幸运以及逃离农村" class="headerlink" title="2 月 15 日 - 我们这一代人的幸运以及逃离农村"></a>2 月 15 日 - 我们这一代人的幸运以及逃离农村</h4><p>今天正月初四，在家第 7 天，假期还剩 3 天。昨天中午在外婆家吃饭，老爸和舅舅又喝多了，坐那聊了一下午。听他们聊天，我发现酒后吐真言是真的，一个人喝多之后才会把自己心里最真实的想法都说出来。尽管有些话在旁人眼里显得非常无稽可笑，但是越是可笑就越说明 Ta 喝得有多醉。他们那一辈人最担心哪些问题呢？无非就是钱、子女、养老，其它所有的话题都是围绕着这几个核心展开的。那作为晚辈的我们能做什么呢？除了管好自己的事，就只剩努力了吧。他们那一代人受环境、教育、眼界的限制，所拥有的机会是少于我们这一代人的。我们这一代人相对来说比较幸运，可以说是踩在他们的肩膀上向前发展的。所以，除了学会感恩，感恩这个时代，感恩他们的付出，最重要的还是要意识到自己的责任。既然我们拥有优渥得多的条件，那就应该好好利用好它们，不断努力，提高自己的认知和能力，争取比上一代人走得更远。一代更比一代强，这就是家族发展的理想路线。</p><p>除此之外，每次过年期间总是能注意到亲戚家人身上的一些观念上的差异，最明显的是重男轻女。每次吃饭的时候，如果客人比较多，通常女性都会自觉地站在一旁帮忙稍后才入座，但是男性往往会心安理得地先入座，无论你是长辈还是晚辈都一样。另外，餐桌上发言的对象往往也是以男性为主，话题也基本是由男性主导。不过，这只是冰山一角而已，类似这样的场景比比皆是，甚至有的亲戚会直接说出「生女儿就是不如生儿子好」的话来。我也只能摇头无奈，除此之外也没有什么能做的了，只能庆幸自己不是女性吧。如果太过刻意去纠正别人、说一些反对的话，反而显得有点自讨没趣，而且有种得了便宜还卖乖的感觉。只有在这种环境下成长起来的女性才能切身体会到这种不平等带来的伤害吧。我们能做的只有改变自己的环境，说实际点其实是逃离这样的环境。所以，我觉得未来农村的消亡是必然的，因为优秀的女性不会选择留下来，而等着男人们觉醒又太难了，尤其是这种根深蒂固的观念，连受这种观念伤害的女性自己，最终都会被这种思想同化。所以，想要让这种观念不传递到下一代人身上的话，那就只能选择逃离了。</p><h4 id="2-月-16-日-能力与爱情"><a href="#2-月-16-日-能力与爱情" class="headerlink" title="2 月 16 日 - 能力与爱情"></a>2 月 16 日 - 能力与爱情</h4><p>今天正月初五，在家第 8 天，假期还剩 2 天。在家这几天，最大的感触是人都挺现实的。不过，现实点也好，可以让人变得更清醒，懂得努力的重要性。在这样的环境之下，如果不努力你就会在与他人的比较之中处于劣势，然后感觉抬不起头。对于自尊感弱的人来说，这种比较带来的压力还是挺大的。不过，其实<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E5%84%95%E5%A3%93%E5%8A%9B">同侪压力</a>到了哪里都一样，也不仅仅是农村才有，即使是自尊感很强的人，即使不依靠物质优渥与否以及外界评价高低也能活得很开心的人，长期在这种环境下生活下去，难免也会受到一些影响。归根结底，最重要的还是你的能力，能力越强，经济实力越雄厚，你就越不用担心他人的眼光，也能更好地照顾好自己和家人，至少不用在钱的问题上纠结。</p><p>另外，现在无论走到哪里，无论遇到什么人，基本都会聊起婚恋的话题，转眼间我也到了被催婚的年纪，真是应了那句「你看光阴饶过谁」。说实话其实我并不着急，尽管恋爱经验很少，但是我相信只要遇到对的人，不需要太多花里胡哨的东西，只要用一颗真心也能打动彼此。<strong>观念是最重要的</strong>，虽然农村里这方面不占什么优势，但是只要我自己始终保持正确的观念，不断学习，不断进步，勤奋努力一点，相信最后该有的也都会有。不过，我觉得自己的心态的确应该改变一下了，26 岁其实也不小了，应该主动一点，和合适的女孩子多接触接触，制造更多的机会，多交往才能知道到底什么样的人才是适合彼此的。对于婚姻，我觉得很多长辈的话是对的，只要彼此真心相爱，其他东西都不重要。<strong>爱情无论在什么时候在什么地方都是奢侈品，如果能幸运地遇到并拥有就要好好珍惜。</strong></p><h4 id="2-月-17-日-优化你的习惯"><a href="#2-月-17-日-优化你的习惯" class="headerlink" title="2 月 17 日 - 优化你的习惯"></a>2 月 17 日 - 优化你的习惯</h4><p>今天正月初六，在家第 9 天，假期还剩 1 天。回顾了下这一周多的生活，除了陪家人、偶尔帮忙和拜年等事务之外，绝大部分独处的时间都花在了看电影电视剧、刷 YouTube 上，真正有意义的活动，就只剩下冥想、练打字和滑板了。其实和亲戚们的相处还算愉快，但是如果有得选的话，我还是愿意花更多的时间一个人独处。</p><p>昨晚洗完澡后读了两小时《掌控习惯》（又是一本被书名耽误的好书），短短两个小时的时间，收获的有价值的信息远超这一周以来的总和，这也是为什么阅读如此重要。习惯其实就是我们的做事方式。你的思维方式，你说的每一句话，做的每一件事，每一个小动作，都是由过去一些微小习惯逐渐积累而来的。养成好习惯意味着以更高效的方式学习、工作和生活。所以，掌控了自己的习惯就掌控了自己的人生。所有的人生意义都离不开如何过得幸福以及创造价值的话题，而这一切都需要我们拥有好习惯。<strong>提示（让它显而易见）、渴望（让它有吸引力）、反应（让它简便易行）、奖励（让它令人愉悦）</strong>，围绕这四个因素，结合书中的方法，有耐心地、持续不断地想办法改进、优化自己的习惯。</p><h4 id="2-月-18-日-谈谈我的家人"><a href="#2-月-18-日-谈谈我的家人" class="headerlink" title="2 月 18 日 - 谈谈我的家人"></a>2 月 18 日 - 谈谈我的家人</h4><p>今天是假期的最后一天。想谈谈家人，但是却不知道从哪里开始。父母和我一样都是在农村长大的，他们受教育程度不高，很多东西和他们说了以他们的认知可能也理解不了。所以，在家呆的时间越长，就越发觉得和他们沟通的难度很大。唯一可以确定的是他们很爱我和我姐，只不过有时候这种爱是用一种非常笨拙的方式来表达的。这点在其他长辈身上也能观察到，大家都差不多吧，毕竟他们那一代人所受的教育、成长环境相似，所以思维方式和观念也都差不多。</p><p>父母都是普通人，有着普通人身上都有的缺点。先说说老爸吧。老爸爱打牌，小时候老妈常常会因为老爸打牌输掉很多钱而和他吵架，吵得凶的时候会摔东西甚至还动过手。老妈总是弱势的那个人，而且也的确很委屈，她常常把老爸当作反面教材来教育我们，所以一直以来我和我姐都和老妈比较亲。不过，自从我上大学尤其是工作之后，老爸就收敛很多了。老爸有时候喝了酒之后爱说大话，还会撒点无关大雅的小谎，不过我想和绝大多数油腻的中年男人相比，他算是很不错的了。今年过年，我注意到我和老爸的关系变得有些微妙起来。老实说，过去我是有点害怕他的，因为我感觉每次和他说话都会被他打压，但是今年他好像变了很多，总是有意无意地夸我，让我有点不太习惯，不知道这是因为年纪大了还是因为别的什么。不过，无论出于什么原因，能看到他的性格变温和是一件挺好的事，不但老妈和我们都会开心，他自己也能受益。之前也说过，今年要多关心老爸，多花时间和老爸沟通交流。虽然不奢望能彼此心灵相通，但是至少可以做到对彼此有更多的了解。</p><p>老妈非常爱我们。我总觉得自己能成长为今天的自己，主要是因为老妈。想起小时候和老妈相处的经历，我想到的是她的坚毅、善良、耐心、豁达，这些词其实还不足以形容，在她身上，我觉得可以看到每一个母亲身上都有的那种「慈爱」。很开心自己能够幸运地拥有这样一位老妈。但是，老妈身上也有不少缺点，比如有时候比较粗线条，对细节不太注意，有时候太过节俭，有时候对别人太忍让，对新事物不太感冒，容易听信一些养生「专家」的话等等。不过，我觉得老妈和老爸在一起还是幸福的。虽然有时候她恨老爸恨得咬牙切齿的，但是我知道她还是爱老爸的，为自己爱的人付出再多也是心甘情愿的。有时候我也会为我从他们身上看到的爱情而感动，她对我们的爱其实也是她的爱情的一部分。希望我以后也能有幸拥有这样的爱情，希望今后她从老爸那里能收获同等程度的爱和足够的回应。</p><p>我姐一半像我爸一半像我妈。她既有老爸的果敢、决断力、真性情，也有老妈的勤劳、吃苦耐劳、善良。她既是老爸的贴心小棉袄，也是老妈的知心乖女儿。从我记事起，她就承担了一半母亲的角色，无论到哪我都喜欢跟着她，虽然那时候她自己也还只是一个小小孩儿。不过，我想每个在农村长大的有个弟弟的女孩都有类似的经历吧。从小家中的家务事基本都是她干，而我一般都只顾着玩。小时候我们经常吵架和打架，但是大多数时候都是她让着我，不过，我到现在都还记得小时候她用床单扮鬼把我吓得不轻，后来都不敢晚上去上厕所了。等再大一些的时候，我们的关系就好多了。我们喜欢相同的明星，她喜欢听周杰伦、王力宏的歌，所以后来我也喜欢上了他们。再到后来她去上学、工作，回家的次数比较少，而我也开始上学，见到彼此的机会少了，因此关系也慢慢变淡了许多。在我上大学之后，由于我们都在杭州，所以偶尔有机会还是能见见面吃吃饭。等到我也工作之后，基本上就只有节假日才能见到，每到周末或者节假日坐她的车一起回家。总的来说，我还是挺感激自己能有个姐姐的。从小能有人陪伴着一起长大，相比在独生子女家庭长大的孩子，少了很多孤单。而且想到今后始终都能有人一起分享彼此的人生经历，一起分担照顾父母的责任，心里多少也会觉得宽慰一些。</p><p>虽然平时和家人沟通不多，我们的共同话题也比较少，彼此的喜好更是相差很大，但是无论怎样，我们都是一家人。我们见证了彼此的成长，未来也会以血缘关系为纽带，继续在彼此的人生中始终占有一席之地。希望我们能一直相亲相爱，分享、鼓励、帮助彼此，一起变得更好。</p><h4 id="2-月-19-日-冥想、孤独与耐心"><a href="#2-月-19-日-冥想、孤独与耐心" class="headerlink" title="2 月 19 日 - 冥想、孤独与耐心"></a>2 月 19 日 - 冥想、孤独与耐心</h4><p>冥想的时候，总是会被脑海中的想法反复折磨，有时候甚至会情不自禁地胡言乱语。不过这可能也是冥想的作用之一吧，让自己有机会重新回顾记忆中的一些场景，把心底的想法表达出来。人是一架非常精密的仪器，想要让它保持高效运转就需要进行细心的维护和保养。所以，我们需要吃健康的食物，需要时常运动，保持身体健康，需要写日记和冥想，及时发现并处理自己的不良情绪，保持心理健康。除此之外，我们还需要维持一定程度的社交，通过与他人相处感受到幸福，需要不断学习，通过创造价值获得人生的意义感等等。</p><p>但是，有时候发现自己会被一种孤独感所困扰，那种「这个世界上只有我一个人」的感觉。虽然知道这种感觉肯定不太健康，但是似乎却无力改变。我知道更深层的原因还是我没有找到自己真正热爱的事，我不知道去哪里寻找自己的归属感。现在的我能够投入地去做好自己的工作，但是我知道这不是我自发想要去做的事。<strong>我想要变得更优秀，为他人创造价值，但是却不知道努力的方向。</strong>也许是自己还不够有<strong>耐心</strong>吧，等到把现在的工作做得足够好，把技能水平磨练到更高的水平，也许那时候我才能发现它的价值以及爱上它。</p><h4 id="2-月-20-日-警惕生活中那些习以为常的时刻"><a href="#2-月-20-日-警惕生活中那些习以为常的时刻" class="headerlink" title="2 月 20 日 - 警惕生活中那些习以为常的时刻"></a>2 月 20 日 - 警惕生活中那些习以为常的时刻</h4><p>最近在看掌控习惯，发现自己有时候会习以为常地做某些事，甚至都意识不到自己为什么要这么做。比如早上到公司的第一件事就是打开电脑上的微信公众号看文章，然后刷新邮件列表看 newsletter，接着看 github 主页信息流，做完这一套流程起码需要花费我 30 分钟的时间，但是我从来没有质疑过为什么要这么做。还有中午吃完午饭散步回来后，坐到座位上的第一件事是打开手机开始刷推，刷至少 30 分钟才肯放下手机开始午睡。晚上回到房间后打开电脑总是忍不住想要看一会 YouTube 视频，然后一看就是一个小时，有时候甚至是好几个小时。做这些事的时候几乎不需要动脑子，完全是机械式地行动，但是总是在事后忍不住自责，没有把时间利用好，到了第二天却依旧如此。所以，我们真的需要警惕自己生活中的这种已经习以为常的时刻，要多问问自己：做这件事对我有什么好处？我真的需要这么做吗？不做又有什么影响？我应该如何优化并利用好这段时间？<strong>改变一定要从这一刻开始。</strong></p><h4 id="2-月-21-日-关注他人身上的优点"><a href="#2-月-21-日-关注他人身上的优点" class="headerlink" title="2 月 21 日 - 关注他人身上的优点"></a>2 月 21 日 - 关注他人身上的优点</h4><p>我们总是把自己的想法投射到周围的人和事上。某一个人或某一件事给我们带来究竟是积极的还是消极的的影响，取决于我们的想法和信念。比如，我们爱自己的家人，所以会从他们的行为中解读出我们想要解读的信息，而如果同样的行为是由陌生人来完成的，我们的感受可能将会完全不同。反之，同样的过程也会发生在我们讨厌的和喜欢的人身上。每个人都有自己的偏好，我们很难做到完全不带偏见地去对待他人。我们能做的只有尽量让自己保持平和的心态，遇事克制冷静，尽量不被自己的情绪左右，以积极的视角去看待他人和他事。对于自己喜欢的人，除了看到他们身上的优点，还得以公正的眼光，察觉到那些被我们忽视的缺点，提醒并帮助他们改正；对于自己不喜欢的人，尽量发现他们身上的优点并忽视掉他们的「缺点」，或者用积极的方式去解读那些我们眼中的「缺点」。</p><h4 id="2-月-22-日-孤僻与个人成长"><a href="#2-月-22-日-孤僻与个人成长" class="headerlink" title="2 月 22 日 - 孤僻与个人成长"></a>2 月 22 日 - 孤僻与个人成长</h4><p>我是一个孤僻的人吗？读小学的时候，身边玩伴数量还是挺多的，大家也都喜欢我，但是随着年龄的增长，似乎身边的朋友越来越少。其实最主要的问题是我不会交朋友，基本都靠别人主动来认识我，而自己从来不会主动去认识其他人。上大学之后，身边认识的人为零，结交的新朋友也仅限于室友和同班同学，也许偶尔会认识一两个其它班级的人，但是那些最多只能称作熟人而已。工作之后，身边的朋友就更少了，刚毕业那会儿还有几个实习期认识的朋友，等到我换工作之后，基本上朋友数量就降为了零。我自己也懒得去认识新朋友，再加上不喜欢社交的性格，以及和老朋友联系也比较少，慢慢地，我就成了一个<strong>没有社交、生活只有上下班、节假日就回家</strong>的人，而且我也渐渐习惯了这种一个人的生活。</p><p>所以，答案是 Yes，我可能真的比较孤僻吧。不过，这样有什么不好呢？虽然没有朋友，但是我一个人过得也挺不错的啊。的确，有时候会感到孤单，如果身边有朋友在的话会好很多，但是，一个人也有一个人的好处，比如更自由，能有更多的时间关注自己的内心世界，不必浪费时间在一些无趣的活动上等等。虽然给自己定了目标，今年要结交更多新朋友，但是还是要顺应自己的天性，绝不要为了认识、讨好别人而失去了自我，始终要以自己的成长作为首要目标。</p><h4 id="2-月-23-日-子女教育和理想不分高低"><a href="#2-月-23-日-子女教育和理想不分高低" class="headerlink" title="2 月 23 日 - 子女教育和理想不分高低"></a>2 月 23 日 - 子女教育和理想不分高低</h4><p>看了辉哥的一篇<a href="https://mp.weixin.qq.com/s/TH56EfeGfC_4vw9RsmDPtQ">文章</a>，有几点感触。家长能给孩子提供什么样的教育决定了孩子的起点。就像辉哥说的「子女教育的关键在于家长的自我突破」，如果家长自身实力不够强大，那么就不能给孩子树立一个好的榜样。孩子很多时候只是父母的一面镜子。还是那句话，你是什么样的人，就能吸引到什么样的人。父母是什么样的人，很大程度上影响了孩子未来能成为什么样的人。我们的价值观、好奇心基本来自于我们童年所受的教育。</p><p>另外还有一点，正是因为我们的父母给的起点不同，所以我们的理想也不同。比如像辉哥故事中的主人公，至少他们家庭不需要为房子、车子这些物质条件所忧虑，所以他们的子女可以安心追求全世界最好的教育，慢慢找寻自己的人生目标。大多数人都无法拥有像他们这样的家庭条件，很多人可能要用几个世代才能追赶上他们。但是，这并不影响我们应该以同样的努力去追求实现自己的人生理想。无论是在城市立足、赚钱养家也好，还是成为数学家、造福人类也好，我们的理想是我们生存在这个世界上的基石，即使对他人而言无足轻重，但是只要对我们自己来说有意义，那么就值得为之努力奋斗下去。</p><h4 id="2-月-24-日-学会幽默式表达"><a href="#2-月-24-日-学会幽默式表达" class="headerlink" title="2 月 24 日 - 学会幽默式表达"></a>2 月 24 日 - 学会幽默式表达</h4><p>善良的人有时候总是容易显得过于正经，而不会适时地使用幽默来缓和气氛。也许说得过于绝对，但是我还是认同这句话的。幽默是什么呢？是一种调侃或讽刺，对象往往是他人的缺点或者糗事。但是心地善良的人往往不忍心伤害或者得罪他人，所以往往不会使用这种语言。也许我应该换种思路，只要不是带有恶意的调侃，其实也没什么好过意不去的。有时候看到一件好玩的事，比如别人出糗，如果你不知道如何使用幽默，只是保持沉默，或者更糟糕一点，用一些关心他的话去应对，别人只会觉得更尴尬，而且觉得你有点虚伪。幽默其实是一种更高级的表达方式，也是一种社交技巧，如果能掌握好，对自己结交朋友也是非常有帮助的。所以，多留心观察身边的事，思考如何用一种幽默的方式把它表达出来，慢慢就会培养起自己的幽默感了。举个例子：同事买了特斯拉，他以后去相亲终于可以多一个话题了。</p><h4 id="2-月-25-日-最重要的东西以及对钱的态度"><a href="#2-月-25-日-最重要的东西以及对钱的态度" class="headerlink" title="2 月 25 日 - 最重要的东西以及对钱的态度"></a>2 月 25 日 - 最重要的东西以及对钱的态度</h4><p>长期来看，什么东西对我来说才是最重要的？这个问题似乎挺难回答的，一时半会儿想不出答案是什么。但是可以使用排除法，对我来说什么东西不重要或者重要性没那么高。比如钱，虽然听上去有点虚伪，但是钱的优先级真的不高。我的欲望很低，除了房子之外，我对其它物质上的享受基本不在乎。过去犯的最大的错误就是仅仅看在钱的份上就选择了一份工作，而没有花更多时间思考这个问题。其次是圈子和人脉，我也不太热衷，我的性格是大多数时候我宁愿一个人待着。哪怕什么都不干坐着发呆，对我来说也比和另外一个人陌生人闲聊强。所以，对我来说最重要的东西还是个人的成长吧。无论是给我带来见识上的成长还是能力上的成长，这些长期来看对我的影响才是最大的，我需要通过不断的成长来感受这个世界，以及获得意义感和幸福感。不过，这并不是说我就应该一直独自进行自我提高，因为很多时候需要与他人合作，向他人学习、求教，有些能力是很难通过一个人的独自学习或练习来提高的。不过，生活在这个时代检验你的学习成果的最好的指标还是金钱。金钱一定是你成长之后带来的副产品之一。而且对于大多数人来说，钱的重要程度还是非常高的。对于金钱，我的理想目标是无论到什么年纪，都不用为了钱去和任何一个人发生争吵，尤其是我身边亲近的人。</p><h4 id="2-月-26-日-小孩子的成长与教育"><a href="#2-月-26-日-小孩子的成长与教育" class="headerlink" title="2 月 26 日 - 小孩子的成长与教育"></a>2 月 26 日 - 小孩子的成长与教育</h4><p>和孩子相处总会让我得到一些新启发，其实让小孩子喜欢你的秘诀是把他们当成和你一样的成年人。小孩子天生比较好奇爱玩，所以只要顺着他们的天性就好了。比如 3-5 岁的孩子喜欢玩玩具、听故事，因为这个年纪的孩子好奇心、探索欲特别强，语言能力也才刚开始发育，所以你需要多陪他们玩，和他们一起认识这个世界；而 6-8 岁的孩子已经开始接触成年人的世界了，他们对这个世界的运行规则已经有了一定程度的认识，察颜观色的能力也已经非常强了，这个时候他们开始知道大人们想要什么，以及如何获得大人们的认可，这个年龄段的孩子最需要鼓励。至于再大一点的孩子，基本上他们已经和成年人一样了，只不过依旧需要依赖成年人才能生活，所以，这个时期，父母、老师的教育以及他们身边的人对他们造成什么样的影响是非常重要的，我们的观念会慢慢传递到他们身上，他们也会从此慢慢形成自己的做事方式和行为习惯。如果没能在这个时期养成一些好习惯，未来想要再培养起同样的习惯，难度就会高上很多。假如我以后有了小孩，我觉得最需要培养的三个习惯是阅读、运动以及与人合作。</p><h4 id="2-月-27-日-工作是磨练心性"><a href="#2-月-27-日-工作是磨练心性" class="headerlink" title="2 月 27 日 - 工作是磨练心性"></a>2 月 27 日 - 工作是磨练心性</h4><p>工作为什么那么重要？我觉得工作的价值不仅仅在于获得成就感、提升能力、得到报酬这些方面，更重要的是<strong>磨练自己的心性</strong>。面对困难和挑战，我们是如何应对的？是消极对抗还是冷静思考并想办法解决？面对琐碎和重复的工作，我们又是什么样的态度？是感到厌倦无聊随便应付了事，还是始终保持一丝不苟的态度，争取把每个细节都做到足够好？<strong>我们如何对待自己的工作反应了我们如何对待自己的生活</strong>。生活中同样会出现各种各样的问题，有的问题比工作中出现的问题还要困难和棘手，这个时候如果你在工作中磨练出了不惧困难、坚韧不拔、认真仔细的态度，加上爱思考、有耐心、善于与人合作等特质，那么，你解决问题的概率也会大大提高。</p><p>生活本身充满了各种各样的挑战，我们一生都在锻炼自己去解决更多、更大、更难的挑战，而幸福时刻大概只占全部生活的 1%，但是为了这  1%，我们愿意去承担各种辛苦，学习的辛苦，技能养成的辛苦，不断自我完善的辛苦等等，正是这些辛苦才让那些幸福时刻显得珍贵和让人感到满足。想起了少有人走的路里的那四句话：尊重事实、承担责任、推迟满足感、保持平衡，就按照这个思路去做吧。</p><h4 id="2-月-28-日-来者犹可追"><a href="#2-月-28-日-来者犹可追" class="headerlink" title="2 月 28 日 - 来者犹可追"></a>2 月 28 日 - 来者犹可追</h4><p>昨晚刷牙的时候突然意识到自己已经毕业快 4 年了，感到一阵心慌，我这几年都是怎么度过的？我现在过的是我想要过的生活吗？打开相册翻了下过去这几年d 照片，回忆起一些琐碎的片段，我发现现在还印象深刻的基本都是我在上家公司发生的事，还有出去旅游等一些新奇的经历，大多数和现在日常工作相似的记忆好像都被我抹掉了。所以人的大脑真的只对与当下不同的、新鲜的事更敏感吧。至于为什么会感到心慌，一是对未来的不确定，不知道自己以后应该往哪里走；二是对自己能力的不自信，觉得自己过去这几年并没有什么长进，技能水平并没有达到自己预期的水平。一方面是因为自己的确比较懒散，浪费了很多时间在游戏、影视剧等等玩乐的事情上；另一方面，没有给自己营造一个更好的环境，而且过于封闭自己了。</p><p>不过，也不能完全否定自己吧，至少在某些方面，我已经迈出了第一步，比如认知的改变，勇敢做自己，不再像过去那样胆小自卑；多倾听自己的内心，真正爱自己，学会表达自己；要开始为自己思考，我是谁，我是什么样的人，我应该追求什么样的目标，我人生的意义感来自什么；要养成好习惯；要不断努力，提高自己的能力；要提高自己的影响力并且造福更多人；等等。但是，有时候却觉得自己心有余而力不足，我进步得太慢了，也根本摸索不出究竟什么样的路才是适合自己的。虽然反复告诉自己不要太贪心，要一步步来，先把眼下的事情做好，然后再去想其它。但是，有时候还是会不断地自我怀疑，并且重新陷入原来的坏习惯之中。理想和现实落差过大，难免会觉得心灰意冷。还是不要想太多，尽管去做吧。一直坚持行动下去，疑问也许自身就能慢慢得到解答。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS 配置指南</title>
      <link href="/macos-config/"/>
      <url>/macos-config/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录自己最常用的 macOS 配置，包括系统设置以及部分常用软件的设置。我常用的软件见：<a href="https://ajiew.github.io/software-list/">software-list</a>。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个开发者，第一个需要面对的问题是开发机器的选择。虽然目前看来，越来越多的开发者已经开始向 Linux 甚至向 PC 迁移，但是，我依旧认为 Mac 是最适合普通开发人员的开发设备，原因是它拥有最佳的用户体验和完备的软件和开发者生态。</p><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><p>所有的 Mac 电脑所使用的操作系统都称为 <a href="https://en.wikipedia.org/wiki/MacOS">macOS</a>（过去叫 OS X，更早的时候叫 Mac OS X），macOS 最早是基于一个类 Unix 系统 <a href="https://en.wikipedia.org/wiki/NeXTSTEP">NeXTSTEP</a> 开发而来的，所以相比基于 Windows 操作系统的 PC，macOS 其实更接近 Linux，而相比基于 Linux 内核的操作系统，它的 UI/UX 又得到了非常大的提升。总体而言，macOS 兼顾了效率和使用体验，这也是目前它依旧受主流市场欢迎的原因。</p><span id="more"></span><p>正是因为 macOS 是基于类 Unix 系统开发而来，所以它对命令行操作的支持也更加友好，这是它的另外一大优势。无论你是哪个平台的开发者，一般都会建议你学习使用 Linux，而 macOS 对于学习 Linux 而言也非常友好，因为大多数 Linux 上的命令都可以直接在 macOS 中使用。</p><p>使用命令行进入系统根目录可以看到，macOS 的系统目录结构和 Linux 系统非常相似：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh">/ ls -al<br>total 9<br>drwxr-xr-x  20 root  wheel   640 Dec  8 07:39 .<br>drwxr-xr-x  20 root  wheel   640 Dec  8 07:39 ..<br>drwxrwxr-x  60 root  admin  1920 Jan 25 18:06 Applications<br>drwxr-xr-x  68 root  wheel  2176 Dec 14 12:35 Library<br>drwxr-xr-x@  9 root  wheel   288 Dec  8 07:39 System<br>drwxr-xr-x   6 root  admin   192 Dec  8 07:39 Users<br>drwxr-xr-x   3 root  wheel    96 Jan 25 21:02 Volumes<br>drwxr-xr-x@ 38 root  wheel  1216 Dec  8 07:39 bin<br>drwxr-xr-x   2 root  wheel    64 Jun  6  2020 cores<br>dr-xr-xr-x   3 root  wheel  4574 Dec 26 22:58 dev<br>lrwxr-xr-x@  1 root  wheel    11 Dec  8 07:39 etc -&gt; private/etc<br>lrwxr-xr-x   1 root  wheel    25 Dec 26 22:59 home -&gt; /System/Volumes/Data/home<br>drwxr-xr-x   2 root  wheel    64 Jun  6  2020 opt<br>drwxr-xr-x   6 root  wheel   192 Dec  8 07:39 private<br>drwxr-xr-x@ 65 root  wheel  2080 Dec  8 07:39 sbin<br>lrwxr-xr-x@  1 root  wheel    11 Dec  8 07:39 tmp -&gt; private/tmp<br>drwxr-xr-x@ 11 root  wheel   352 Dec  8 07:39 usr<br>lrwxr-xr-x@  1 root  wheel    11 Dec  8 07:39 var -&gt; private/var<br></code></pre></td></tr></table></figure><p><code>bin</code> 是保存系统基础命令的目录，<code>dev</code> 设备目录，<code>etc</code> 系统配置，<code>usr</code> 用户安装软件及配置，<code>var</code> 其它目录（如日志和缓存）。唯一的不同之处是多了一些大写开头的文件夹，这些是 macOS 独有的，比如：<code>Applications</code> 应用文件夹，系统和第三方应用都会被安装到这里；<code>Library</code> 第三方库文件夹；<code>System</code> 保存系统文件；<code>Users</code> 用户文件夹；<code>Volumes</code> 磁盘。</p><h2 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h2><h3 id="最佳屏幕显示"><a href="#最佳屏幕显示" class="headerlink" title="最佳屏幕显示"></a>最佳屏幕显示</h3><p>为了让 Retina 屏幕发挥出最大的作用，让文字显示达到最佳效果，我们需要关闭 font smoothing。</p><p>设置方法：Big Sur 之后的系统，需要通过在命令行中输入 <code>defaults -currentHost write -g AppleFontSmoothing -int 0</code> 并重启。</p><p>参考文章：<a href="https://tonsky.me/blog/monitors/">Time to upgrade your monitor</a> by <a href="https://twitter.com/nikitonsky">@Nikita</a>。</p><h3 id="三指拖动"><a href="#三指拖动" class="headerlink" title="三指拖动"></a>三指拖动</h3><p>之前拖动窗口都是使用点住并拖动的方式，后来才发现使用三指拖动的方式比点按拖动优雅不少。</p><p>设置方法：打开系统设置中的 <strong>Accessibility &gt; Pointer Control</strong>，选择 <strong>Trackpad Options &gt; Dragging Style &gt; Three Finger Drag</strong>。参考：<a href="https://support.apple.com/zh-cn/HT204609">开启适用于 Force Touch 触控板的“三指拖移”</a>。</p><p>这样设置之后，切换桌面以及 Mission Control 都会自动变成四指。</p><p>我们还可以在拖动窗口时切换桌面从而快速将一个应用切换到另一个桌面，做法是首先在 <strong>Keyboard &gt; Shortcuts &gt; Mission Control</strong> 中开启使用 <kbd>control</kbd> + <kbd>1</kbd> Switch to Desktop 1 和 <kbd>control</kbd> + <kbd>2</kbd> Switch to Desktop 2，之后只要轻微拖动窗口的同时使用快捷键切换桌面，就可以将该窗口带到相应的桌面了。</p><h3 id="键盘映射"><a href="#键盘映射" class="headerlink" title="键盘映射"></a>键盘映射</h3><p>通过将键盘映射可以让常用的按键使用更加方便快捷，比如将 Esc 映射为 Caps Lock，<strong>Keyboard &gt; Keyboard Shortcuts &gt; Modifier Keys</strong>，选择 <strong>Caps Lock key</strong> 的执行动作为 <strong>Escape</strong>。</p><p>对于更复杂的键盘映射可以使用 Karabiner-Elements 等软件来实现。</p><h3 id="拖动窗口切换桌面"><a href="#拖动窗口切换桌面" class="headerlink" title="拖动窗口切换桌面"></a>拖动窗口切换桌面</h3><p>我们可以通过拖动应用窗口到屏幕边缘然后等待 1 秒来切换桌面，可以使用以下命令设置等待时间：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">defaults write com.apple.dock workspaces-edge-delay -<span class="hljs-built_in">float</span> 0.15;killall Dock<br></code></pre></td></tr></table></figure><p>使用下面命令取消设置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">defaults delete com.apple.dock workspaces-edge-delay;killall Dock<br></code></pre></td></tr></table></figure><h3 id="Hot-Corners"><a href="#Hot-Corners" class="headerlink" title="Hot Corners"></a>Hot Corners</h3><p><strong>System Preferences Mission Control &gt; Hot Corners</strong>，下面是我的设置：</p><ul><li>  左上角：Start Screen Saver</li><li>  左下角：Desktop</li><li>  右上角：Notification Center</li><li>  右下角：Launchpad</li></ul><p>除此之外，还有一些默认配置：</p><ul><li>滑动到左下角后，两指上下滑动调整屏幕亮度，轻触三指锁屏。</li><li>滑动到右下角后，轻触三指最小化应用。</li></ul><h3 id="Quick-Look-Plugins"><a href="#Quick-Look-Plugins" class="headerlink" title="Quick Look Plugins"></a>Quick Look Plugins</h3><p>为 Quick Look 添加更丰富功能的插件，可以通过 <a href="https://brew.sh/">Homebrew</a> 安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">brew install qlcolorcode qlmarkdown quicklook-json qlstephen --verbose<br></code></pre></td></tr></table></figure><p>详细介绍见：<a href="https://github.com/sindresorhus/quick-look-plugins">quick-look-plugins</a>。大多数插件在安装之后需要在 <strong>Security &amp; Privacy</strong> 中点击允许运行才可以正常使用。另外有个小 tip，Mission Control 下也是可以按 <kbd>space</kbd> 来使用 Quick Look 的。</p><h3 id="关闭-Spotlight"><a href="#关闭-Spotlight" class="headerlink" title="关闭 Spotlight"></a>关闭 Spotlight</h3><p>对我来说，大多数时候，使用 Raycast 和 uTools 就足够了，所以 Spotlight 反而多余。</p><p>首先，在菜单栏不显示 Spotlight: <strong>Control Center &gt; Menu Bar Only &gt; Spotlight (Don’t show in Menu Bar)</strong></p><p>其次，关闭快捷键: <strong>Keyboard &gt; Keyboard Shortcuts &gt; Spotlight &gt; Uncheck “Show Spotlight search”</strong></p><h2 id="应用设置"><a href="#应用设置" class="headerlink" title="应用设置"></a>应用设置</h2><h3 id="Finder"><a href="#Finder" class="headerlink" title="Finder"></a>Finder</h3><h4 id="显示文件路径"><a href="#显示文件路径" class="headerlink" title="显示文件路径"></a>显示文件路径</h4><p>底部显示/隐藏路径，快捷键 <kbd>command</kbd> + <kbd>option</kbd> + <kbd>P</kbd></p><h4 id="显示隐藏文件和文件夹"><a href="#显示隐藏文件和文件夹" class="headerlink" title="显示隐藏文件和文件夹"></a>显示隐藏文件和文件夹</h4><p>快捷键 <kbd>command</kbd> + <kbd>shift</kbd> + <kbd>.</kbd>，或者在命令行下输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 显示</span><br>defaults write com.apple.finder AppleShowAllFiles TRUE; killall Finder;<br><span class="hljs-meta">#</span><span class="bash"> 隐藏</span><br>defaults write com.apple.finder AppleShowAllFiles FALSE; killall Finder;<br></code></pre></td></tr></table></figure><p>另外，隐藏和显示某个单独的文件或文件夹，在命令行下输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chflags hidden file-path<br>chflags nohidden file-path<br></code></pre></td></tr></table></figure><h4 id="其它小-tips"><a href="#其它小-tips" class="headerlink" title="其它小 tips"></a>其它小 tips</h4><ul><li>  修改默认打开文件夹，<strong>Finder Preferences &gt; General &gt; New Finder window show</strong></li><li>  打开右键菜单后，按住 <kbd>option</kbd> 键显示更多操作，比如复制路径</li><li>  在文件属性分割线或者宽度调整按钮上双击，就可以自动调整宽度为当前列文件名字最长的宽度</li><li>  调整窗口宽高时按住 <kbd>shift</kbd> + <kbd>option</kbd> 键，整个窗口大小会随之变大或变小</li><li>  下载 <a href="https://github.com/Ji4n1ng/OpenInTerminal/releases">OpenInTerminal-Lite</a>，然后按住 <kbd>command</kbd> 并拖动应用 icon 到 Finder 菜单栏，选择打开方式为 iTerm2，然后就可以快速在 iTerm 中打开当前文件夹路径了</li></ul><h3 id="iTerm-2"><a href="#iTerm-2" class="headerlink" title="iTerm 2"></a>iTerm 2</h3><h4 id="1、安装-oh-my-zsh"><a href="#1、安装-oh-my-zsh" class="headerlink" title="1、安装 oh-my-zsh"></a>1、安装 <a href="https://github.com/ohmyzsh/ohmyzsh">oh-my-zsh</a></h4><h4 id="2、配置-Dracula-主题以及修改-icon"><a href="#2、配置-Dracula-主题以及修改-icon" class="headerlink" title="2、配置 Dracula 主题以及修改 icon"></a>2、配置 <a href="https://draculatheme.com/iterm">Dracula</a> 主题以及修改 <a href="https://github.com/jasonlong/iterm2-icons">icon</a></h4><h4 id="3、配置按键"><a href="#3、配置按键" class="headerlink" title="3、配置按键"></a>3、配置按键</h4><p>如果你键盘中的 iTerm 按键被其它软件覆盖了，可以通过下面的方式手动设置<em>按字符跳转</em> 功能：<strong>Preferences &gt; Profiles &gt; Keys</strong>，先将 Left Option Key 设置为 Esc+，然后添加 Key Mapping：</p><ul><li>Keyboard Shortcut 设置为 <kbd>option</kbd> + <kbd>←</kbd>，Action 选择 Send Escape Sequence，Esc+ 输入 <kbd>b</kbd></li><li>Keyboard Shortcut 设置为 <kbd>option</kbd> + <kbd>→</kbd>，Action 选择 Send Escape Sequence，Esc+ 输入 <kbd>f</kbd></li><li>Keyboard Shortcut 设置为 <kbd>option</kbd> + <kbd>↑</kbd>，Action 选择 Send Text，内容输入 <kbd>cd ..</kbd></li></ul><h3 id="BetterAndBetter"><a href="#BetterAndBetter" class="headerlink" title="BetterAndBetter"></a><a href="https://www.better365.cn/bab2.html">BetterAndBetter</a></h3><p>这是一个通过为触摸板和键盘提供丰富的快捷操作、提升 Mac 使用效率的应用。</p><h4 id="触摸板"><a href="#触摸板" class="headerlink" title="触摸板"></a>触摸板</h4><ul><li>  三指点击调整系统音量（3Finger_TipTap_Left/Right/Middle -&gt; Volumn Down/Up/Mute）</li><li>  四指点击调整屏幕亮度（4Finger_TipTap_Left/Right -&gt; Brightness Down/Up）</li><li>  四指双击输入 Mac 密码（4Finger_DoubleTap）</li></ul><h4 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h4><p>BAB 内置了一些调整窗口位置的键盘快捷键，我参考了 <a href="https://github.com/rxhanson/Rectangle">Rectangle</a> 的快捷键，设置如下：</p><ul><li><kbd>control</kbd> + <kbd>option</kbd> + <kbd>←</kbd>，当前窗口占据屏幕左半边</li><li><kbd>control</kbd> + <kbd>option</kbd> + <kbd>→</kbd>，当前窗口占据屏幕右半边</li><li><kbd>control</kbd> + <kbd>option</kbd> + <kbd>↑</kbd>，当前窗口占据屏幕上半边</li><li><kbd>control</kbd> + <kbd>option</kbd> + <kbd>↓</kbd>，当前窗口占据屏幕下半边</li><li><kbd>control</kbd> + <kbd>option</kbd> + <kbd>C</kbd>，当前窗口占据屏幕中心</li><li><kbd>control</kbd> + <kbd>option</kbd> + <kbd>M</kbd>，当前窗口最小化</li><li><kbd>control</kbd> + <kbd>option</kbd> + <kbd>↩︎</kbd>，进入全屏</li><li><kbd>control</kbd> + <kbd>option</kbd> + <kbd>⌫</kbd>，退出全屏</li><li><kbd>control</kbd> + <kbd>option</kbd> + <kbd>R</kbd>，恢复到之前的位置</li></ul><p>其它 BAB 默认绑定的快捷键：</p><ul><li><kbd>control</kbd> + <kbd>option</kbd> + <kbd>A</kbd>，打开应用程序文件夹</li><li><kbd>control</kbd> + <kbd>option</kbd> + <kbd>command</kbd> + <kbd>B</kbd>，打开 BAB 设置界面</li></ul><p>另外，BAB 还可以结合 AppleScript 来使用快捷键，比如：</p><ul><li><p><kbd>command</kbd> + <kbd>shift</kbd> + <kbd>control</kbd> + <kbd>P</kbd>，Spotify 播放/暂停</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">using terms from application <span class="hljs-string">&quot;Spotify&quot;</span><br><span class="hljs-keyword">if</span> player state of application <span class="hljs-string">&quot;Spotify&quot;</span> is paused <span class="hljs-keyword">then</span><br>tell application <span class="hljs-string">&quot;Spotify&quot;</span> to play<br><span class="hljs-keyword">else</span><br>tell application <span class="hljs-string">&quot;Spotify&quot;</span> to pause<br>end <span class="hljs-keyword">if</span><br>end using terms from<br></code></pre></td></tr></table></figure></li><li><p><kbd>command</kbd> + <kbd>shift</kbd> + <kbd>control</kbd> + <kbd>L</kbd>，Spotify 播放下一首</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">tell application <span class="hljs-string">&quot;Spotify&quot;</span><br>next track<br>end tell<br></code></pre></td></tr></table></figure></li><li><p><kbd>command</kbd> + <kbd>shift</kbd> + <kbd>control</kbd> + <kbd>H</kbd>，Spotify 播放上一首</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">tell application <span class="hljs-string">&quot;Spotify&quot;</span><br>previous track<br>end tell<br></code></pre></td></tr></table></figure></li></ul><p>音乐的播放/暂停、上/下一首这些功能用 BAB 内置的脚本也能用，但是前提是必须先让你的目标软件获得音频焦点，所以还是用自己的脚本比较好。</p><h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><h4 id="按-F5-刷新"><a href="#按-F5-刷新" class="headerlink" title="按 F5 刷新"></a>按 <kbd>F5</kbd> 刷新</h4><p><strong>System Preferences &gt; Keyboard &gt; Keyboard Shortcuts &gt; App Shortcuts</strong>，点击左下角的 “+” 号，在弹框中的 Application 一栏选择 Google Chrome，Menu Title 填入 “Reload This Page”，然后点击 Keyboard Shortcut 一栏，按 <kbd>F5</kbd>，最后选择 “Add” 添加完成，重启 Chrome 后生效。</p><h3 id="Automator"><a href="#Automator" class="headerlink" title="Automator"></a>Automator</h3><h4 id="Search-With-Chrome"><a href="#Search-With-Chrome" class="headerlink" title="Search With Chrome"></a>Search With Chrome</h4><p>系统内置了 Search with Google，不过是使用 Safari 打开的，我平时用 Chrome 多一点，所以可以用 Automator 添加一个服务来解决：打开 Automator &gt; 选择 Quick Action &gt; 搜索 “Applescript” &gt; 双击添加 “Run Applescript”，复制以下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">on run &#123;input, parameters&#125;<br>tell application &quot;Google Chrome&quot;<br>open location &quot;https://www.google.com/search?&amp;q=&quot; &amp; input as string<br>end tell<br>return input<br>end run<br></code></pre></td></tr></table></figure><p>保存并命名为 “Search by Google”（默认会保存到 ~/Library/Services 中），接着就可以在选中文字的时候 <strong>右键 - Service</strong> 选择该服务了。也可以在 <strong>System Preferences &gt; Keyboard &gt; Keyboard Shortcuts &gt; Services &gt; Text</strong> 中添加快捷键，比如我的是 <kbd>command</kbd>+<kbd>option</kbd>+<kbd>g</kbd>。</p><h4 id="V2rayU-添加白名单"><a href="#V2rayU-添加白名单" class="headerlink" title="V2rayU 添加白名单"></a>V2rayU 添加白名单</h4><p>使用 Pac 模式有个缺陷，那就是每次加网址都很麻烦，不过同样可以用 Automator 解决这个问题。在<a href="https://github.com/yanue/V2rayU/issues/34">这里</a>找到了 V2rayU 的 User Rules 文件的保存位置，然后在 Automator 中创建一个 Quick Action (Service)，使用默认模式并添加一个 Shell Script：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;||$1&quot; | tee -a /Applications/V2rayU.app/Contents/Resources/pac/user-rule.txt<br></code></pre></td></tr></table></figure><p>记得将脚本右上角的 Pass input 修改成 “as argument”，然后保存成 “Add to user-rule” 就好了，推荐最好添加一个快捷键，比如 <kbd>command</kbd>+<kbd>option</kbd>+<kbd>a</kbd>。注意：使用这种方式添加的网址在 V2rayU 的 Pac 面板中是看不到的，而且需要重启 v2ray-core 或者切换代理模式后才能生效。</p><p>另外，记录一下使用 V2rayU 过程中的一些小问题：</p><ul><li>v2ray 配置正确但是依旧无法正确连接的问题。首先检查时间是否设置正确，如果客户端和服务端时间误差超过 2 分钟，就会出现无法连接的<a href="https://guide.v2fly.org/prep/start.html">问题</a>；其次，如果你服务端配置了 WS+TLS，客户端需要设置 Allow Insecure，一般也能解决连接失败的问题。</li><li>v2ray-core 缺失，出现该现象的原因未知，需要手动下载 <a href="https://github.com/v2ray/v2ray-core/releases">v2ray-core</a> 并解压好放到 <code>/Applications/V2rayU.app/Contents/Resources/v2ray-core</code> 目录下。（作者已经解决了该问题，相关 issue 见<a href="https://github.com/yanue/V2rayU/issues/663">issue#663</a>）</li></ul><h3 id="Raycast"><a href="#Raycast" class="headerlink" title="Raycast"></a>Raycast</h3><p><a href="https://www.raycast.com/">Raycast</a> 是一个非常优秀的启动器，推荐将快捷键设置为 <kbd>option</kbd> + <kbd>space</kbd>。使用它除了可以完成一些文件、应用的搜索之外，我最喜欢的是它提供的各种快捷操作，比如给各种软件绑定快捷键，结合 Shortcuts 可以完成自动化很多常用的操作。</p><h3 id="Shortcuts"><a href="#Shortcuts" class="headerlink" title="Shortcuts"></a>Shortcuts</h3><p>Shortcuts 除了可以操作系统应用之外，也支持导入并运行 AppleScript，不过需要在应用设置中开启 Advanced &gt; Allow Running Scripts，这样的话它的实用性就提升很多了，我们还可以在 Raycast 的 Extensions 设置中，为 Shortcuts 添加快捷键。</p><h3 id="百度输入法"><a href="#百度输入法" class="headerlink" title="百度输入法"></a>百度输入法</h3><p>百度输入法是到目前为止为数不多的我依旧在使用的百度产品。我喜欢它简洁的界面以及丰富的<a href="https://srf.baidu.com/site/macskin/index.html">皮肤库</a>（Origami Neko），表情库（<kbd>shift</kbd> + <kbd>option</kbd> + <kbd>B</kbd>），QuickTip，自动切换英文（设置 - 高级 - App 清单）。另外，它对小鹤双拼的支持也不错，加上词库同步的功能，基本可以让我在 Mac 和 PC 之间的输入体验保持一致。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Tools </tag>
            
            <tag> Productivity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>少消费，多创造</title>
      <link href="/2021-1/"/>
      <url>/2021-1/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/3DB-uJ0TxKQ" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>2021 年的第一个月又过完了，坐下来想要写点总结的文字的时候，却不知道从哪写起，好像对自己是如何度过这段日子的已经没印象了。这说明这段时间的生活太单调，自己已经麻木了吧。不过，真正恐怖的地方在于：在坐下来写总结之前，生活在其中的每一天的你，并不觉得它们重复无聊。这也提醒了自己，要时不时地跳出日常的生活节奏，审视自己的生活，反问自己到底应该如何度过自己的每一天。当你能清醒地认识到自己为什么要做某事的时候，你对自己的生活就有了更多的掌控。你能注意到生活中的种种细节而不是麻木地应对所有发生在自己身边的事，你能确保自己的所作所为都是有益于自己和他人的，你会更多地去创造而不仅仅是去消费。</p></blockquote><span id="more"></span><h4 id="1-月-1-日-陪伴"><a href="#1-月-1-日-陪伴" class="headerlink" title="1 月 1 日 - 陪伴"></a>1 月 1 日 - 陪伴</h4><p>新年第一天，早上踏上了回家的旅程，阳光明媚，一切都很好。中午吃了外婆烧的炒面，然后在阳台上一边晒着太阳一边聊着天。下午看了很多人的年终总结和视频。晚上吃完晚饭又去外婆家坐了会儿，听家人聊那些聊了无数遍的话题。尽管如此，家依旧是让人卸下防备、完全放松做自己的地方——虽然家里冷得像冰柜。</p><p>新年计划依旧没有写完，但是我想其实也没那么重要。人生很短也很长，生活就是你每一天起床、离开家去工作，下班后陪伴家人和朋友或者学习充电，偶尔做点新鲜的事情，以及藏在琐碎细节里的每一个瞬间。我们大多数醒着的时候都是在普通而又平静的时光中度过的。给自己定目标也是为了更好地生活，而不是为了无休止地追逐欲望，刻意用学习、工作填满自己所有的时间。努力很重要，耐心也很重要，但是陪伴更重要。新的一年，希望我也能找到那个值得自己花一生时间去陪伴彼此的人。嗯，加油！</p><h4 id="1-月-2-日-训练自己的大脑"><a href="#1-月-2-日-训练自己的大脑" class="headerlink" title="1 月 2 日 - 训练自己的大脑"></a>1 月 2 日 - 训练自己的大脑</h4><p>成年人的大脑其实同样具有一定程度的可塑性。只要你掌握正确的工具和训练的方法，就可以按照你想要的方式塑造自己的大脑，从而达到最佳的学习状态，以及帮助自己养成好习惯。虽然不像电影里演的那么夸张（比如《超体》），但是从我目前接触到的<a href="https://www.youtube.com/watch?v=SwQhKFMxmDY">神经科学知识</a>来看，这种可塑性的确挺振奋人心的。</p><p><strong>感觉、感知、想法、情绪和行动</strong>，这些是哺乳动物的基本能力，同时我们还无时不刻都在受外界环境的影响。如果不受大脑的控制，身体通常只是本能地对外界刺激做出反应，或者本能地受想法和情绪的控制。比如在一些让人激动的场景下，我们的情绪也会变得高涨，和周围的环境保持一致；类似的，当我们心情低落的时候，做一些让自己兴奋的事情，我们的想法和情绪也会发生变化。这就是<strong>行动促发情绪</strong> (action leads mood or mood follows action)。通过训练，我们是可以做到越来越熟练地控制自己的想法和情绪的。另外，专注、投入、心流、成长型思维等等这些也都是可以通过后天的训练来提升的。我们要做的是，学习更好的方法，持续投入反复的练习，不断改进、优化，直至形成一种稳定的行为模式，让我们能更高效地学习和思考。</p><h4 id="1-月-3-日-学会放过自己"><a href="#1-月-3-日-学会放过自己" class="headerlink" title="1 月 3 日 - 学会放过自己"></a>1 月 3 日 - 学会放过自己</h4><p>假期最后一天，总结下自己的假期吧：新年计划——还没完成；复习安卓——也还没开始；读完《认知》——连书都没打开过。新的一年就没能开好头。但是我觉得其实没必要用各种负面情绪、心理压力来打击自己，接受自己没能完成计划的现实，然后做出调整，接下来开始好好执行，就够了。通过给自己制定更具体的计划，比如每天要完成多少，如果还是完成不了，那就再减少一些，这样计划完成度虽然降低了，但是总好过一点都没开始吧。我觉得有时候其实是被自己想要达到完美的想法给束缚了，现实和预期没能达成一致于是就开始不知所措，然后就越来越不想行动，越来越倾向于保持现状，然后去做一些杀时间的事。当最终没做出想要的成果的时候，又进一步打击了自己的信心，开始自责，在心底产生一些负面的、自我厌弃的想法，然后对于其它自己原本可以做好的事也产生自我怀疑，不想动手去做，就这样形成了一个恶性循环。</p><p>每个人都有什么都不想做，只想拖延、偷懒的时候，当这种情况发生之后，不要自责，坦然接受这样的自己，因为人不是机器，我们都需要休息来调整自己。只要懒散过后，能够重新振作起来，恢复正常的工作状态，把该做的事做好就可以了。对于没完成的计划，也要学会适时放手，或者及时做出调整。生活和工作其实没有那么紧迫，每个人都可以承受一点点损失的，而且眼前的损失其实并没有看起来的那么不可接受，在未来努力一点，也许也能进行弥补甚至超越。总之一句话：对于已经发生的事情，坦然接受，不要苛责自己，要对自己好一点；对于还没发生的事，要对自己严格一点，全力以赴，尽量做到最好。另外，不要太在意结果，因为那不是我们能控制的。如果能让自己享受其中的话，那就更好了。</p><h4 id="1-月-4-日-我到底具备哪些能力"><a href="#1-月-4-日-我到底具备哪些能力" class="headerlink" title="1 月 4 日 - 我到底具备哪些能力"></a>1 月 4 日 - 我到底具备哪些能力</h4><p>刷牙的时候想到一个问题：除去已有的身份，我到底具备哪些能力？</p><p>仔细反思之后，我觉得对我来说，目前我最大的优势是英语还不错。这个优势帮我获得了在上一家公司实习的机会。由此带来的其它优势是能够找到比较前沿的信息，这点对于编程这行来说显得尤为重要，这也是我目前能依旧待在这一行的原因之一。第二个能力是整理。听上去可能有点奇怪，整理算什么优势，但是我觉得正是喜欢整理的这个癖好，影响了我工作和生活的方方面面。比如它让我养成了将收集到的信息整理分类的习惯，让我能够保持房间内干净整洁从而让心情感到愉悦，让我的代码具有更好的可读性等等。如果没有爱整理这个习惯，我可能不会成为现在的自己。第三个优势是独立思考。如果不具备独立思考的能力，我就区分不出什么才是真正有价值的东西，我的审美能力就不会有提升，也不可能在这里通过文字分享自己的观点。那么，我可以做哪些事让自己的能力得到最大化利用呢？我觉得这个话题可以写成一篇博客了，等以后有机会再聊吧。</p><h4 id="1-月-5-日-关注你的表现而非他人的评价"><a href="#1-月-5-日-关注你的表现而非他人的评价" class="headerlink" title="1 月 5 日 - 关注你的表现而非他人的评价"></a>1 月 5 日 - 关注你的表现而非他人的评价</h4><p>昨晚做了一个梦，梦到自己在上课，老师提了一个问题，我明明知道答案，但是却没有举手回答。由于没有人举手，于是老师一个个指名让同学站起来回答，当就快轮到自己的时候，我的心情非常紧张，能听到心脏砰砰砰跳的声音。然而就在轮到我站起来发言之前，在我前面的一个同学站了起来说出了答案，答案和我想的一样。老师说了很多赞许他的话，然后全班人都为那位同学爆发了一阵喝彩声和掌声，而我心里却有一种不是滋味的感觉，说不上是嫉妒，是一种一厢情愿的「其实我也知道只是没有说出来而已」的藐视心态，同时伴随着一丝自我埋怨。</p><p>我为什么会做这样的梦？根据阿德勒心理学，梦的意图是要支持并增强一个人的生活方式，同时激发与之最相适应的感觉。我其实是对于即将到来的面试有点紧张，害怕面试失败，于是编造这样一个梦让自己相信「我其实很好，通不过面试只是因为我不想通过而已」。这是一种提前的自我安慰和自我催眠，也是想要逃避好好复习准备面试的借口。</p><p>其实在我的学生时代，这样的场景的确也经常出现。究其原因，我觉得首先自己过去是一个不自信、自卑且内向的人。但是，一方面非常渴望得到老师和同学们的认可，另一方面，又很怕在公众场合丢脸，一旦受到大家的关注的时候，心里就会非常紧张。所以，我的内心其实是非常矛盾的。这也是为什么我一直都很不习惯上课举手回答问题、开会的时候发表自己看法、面试等等类似的会被他人「judge」的场合。</p><p>但是，我相信这是可以克服的，用性格作为挡箭牌是一种认输的做法。人的适应能力非常强，多制造这样的机会主动练习，使用曝光疗法，每次进步一点点，一定可以慢慢改善，最终甚至可以和那些外向、善于社交的人做得一样好。另外，可能还需要转换一下心态，不要以一种自己在被他人 judge 的心态去看待，而是你在展示自己的能力，分享自己的观点，别人是在帮助你认清真实的自己，让你变成更好的人。</p><h4 id="1-月-6-日-拖延的原因和对策"><a href="#1-月-6-日-拖延的原因和对策" class="headerlink" title="1 月 6 日 - 拖延的原因和对策"></a>1 月 6 日 - 拖延的原因和对策</h4><p>我们为什么会拖延？我总结出以下几个原因。</p><p>1）没有给自己营造出专注的氛围。所以很多人会有自己单独的书房，用于阅读、学习、工作，如果没有这样的条件，可以尝试整理自己的书桌，把一些干扰性强的物品通通收拾移走，让自己的视线能够集中在和当前要做的这件事相关的物品上，比如一本书或者一台笔记本电脑。</p><p>2）没有给自己制定足够具体、切实可行的计划。比如我给自己制定了学习 Bash 的计划，但是却没有制定每天的学习进度，也没有指定具体要学到什么程度的目标，这样的话，很容易就进入三天打鱼两天晒网的状态。</p><p>3）完成目标的动机不够强烈。这个我觉得是最重要的，因为如果没有足够强烈的动机，我们就很难坚持下去，很容易进入拖延。所以，我们需要问问自己，这个目标是否是自己真正想要的，如果没有完成这个目标会造成什么样的后果。恐惧和害怕惩罚同样是我们完成计划的动机之一。</p><p>最后还有一些小 tips：a）在注意到自己开始拖延的时候，强迫自己先做 3 分钟，3 分钟之后之后再继续玩手机或者干别的事情（通常你会发现自己 3 分钟之后就已经进入状态了）。b）手机调成专注模式。c）开始之前先冥想或者深呼吸 5 分钟。</p><h4 id="1-月-7-日-偏爱行动"><a href="#1-月-7-日-偏爱行动" class="headerlink" title="1 月 7 日 - 偏爱行动"></a>1 月 7 日 - 偏爱行动</h4><p>昨晚看了主任的一篇<a href="https://mp.weixin.qq.com/s/v-pAdL70c8M_xp_TiQOocw">文章</a>，虽然说的都是大实话，我也基本和主任的想法一致，但是却还是忍不住有些焦虑。为什么我不能像文章中提到的那些优秀的人一样努力？我什么时候能找到自己喜欢的事情并且全情投入其中？</p><p>老实说，应该没有人喜欢偷懒吧，都想把自己的工作做好，从工作中获得成就感。但是，这个世界上能够做自己想做的事的人还是少数，我觉得更重要的是培养自己把不想做的事情做好的能力。就像此刻的我，并不想起床去上班，只想躺在被窝里再睡上 3 个小时。我们每个人其实都有从工作中获得成就感的能力，只不过大多数人都习惯性只看到工作中负面的一面，而不是工作带给我们积极意义的一面。其次，我们常常是害怕努力之后也没有结果，所以才干脆选择不努力，然后用「只要我努力了，也能XXX」这样的话来安慰自己。</p><p>怎样避免这两种倾向呢？一是学会改变自己的想法，尽量往好的方面想，这需要我们控制自己的情绪，同时做一个长期主义者；二是承认现实，接受自己是个普通人，很多事情如果不努力就比不上那些勤奋的人，更不用说那些天赋比自己强又很努力的人了。但是，只要我们积极地去做出改变了，结果一定要比不行动好。</p><h4 id="1-月-8-日-面对自己无法掌控之事"><a href="#1-月-8-日-面对自己无法掌控之事" class="headerlink" title="1 月 8 日 - 面对自己无法掌控之事"></a>1 月 8 日 - 面对自己无法掌控之事</h4><p>如何面对自己无法掌控的事情？一是预想出可能的结果，让自己在心理上准备好如何应对最差的情况，然后在心中多演练几遍，让自己能坦然接受最糟糕的结果，此时我们其实就可以去面对它了。还有就是从一个 YouTuber Matt 的视频中学到的经验，将所有经历都当成是一种人生的体验，这样的话，哪怕遇到不好的事情，虽然不开心，但是也能接受它，毕竟这件事丰富了我的人生（Live an experiential life, happy or sad.）。即使如此，我觉得最最重要的还是要不停提高自己的能力，不断地学习，这样我们才能更有自信地去面对未知以及超出我们认知范围内的事。</p><h4 id="1-月-9-日-让行动和想法保持一致"><a href="#1-月-9-日-让行动和想法保持一致" class="headerlink" title="1 月 9 日 - 让行动和想法保持一致"></a>1 月 9 日 - 让行动和想法保持一致</h4><p>我一直觉得自己有时候会给人一种很拧巴的感觉。反思之后觉得，最主要的原因是<strong>不能保持坦诚</strong>。虽然嘴上一直说要做真实的自己，但是现实中常常会为了面子或者为了维护自己在他人心中的形象来决定是否去做某些事情。嘴上说的以及实际行动和内心的想法不一致，于是就会感到痛苦，所以一切看上去就没那么自然。解决办法其实也很简单，不要太在乎他人的眼光，关注自己的真实想法，忠于自己的内心，始终保持坦诚。<strong>喜欢就说出口，想要什么东西就努力去争取。</strong>总之，要学会面对自己内心的真实欲望，学会接受和表达自己内心的真实想法，让行动和想法始终保持一致。</p><h4 id="1-月-10-日-对生活现状的不满足"><a href="#1-月-10-日-对生活现状的不满足" class="headerlink" title="1 月 10 日 - 对生活现状的不满足"></a>1 月 10 日 - 对生活现状的不满足</h4><p>今天一天宅在家什么都没干。早上起床后刷了很长时间的手机，把附近觉得不错的外卖店铺全都翻了一遍，收藏了几个觉得还不错的，想着下次想吃的时候就可以直接点了。中午吃的鸡排+各种烤串，看了最新一集的《<a href="https://www.hezhimeng.cn/videoDet.html?videoId=2b2cddf6f07a60cb9275da479bfb7bcd">我住</a>》。下午继续看了很多的视频，包括一对自驾环游世界的夫妻，看了他们在国内外一些城市的游记，心里既羡慕又好奇。一直到看完<a href="https://www.youtube.com/watch?v=sD4xE8RKvzM">这个</a>视频之后，出去练了会儿滑板，然后回来换了身衣服，出门跑步。回来的路上经过镇上的技校，第一次注意到门口的几个大字「劳动光荣，技能宝贵，创造伟大」，很土但是的确是大实话。晚上洗完澡打扫完卫生后又开始看视频，包括<a href="https://www.youtube.com/watch?v=MiRmyn-hDfU">这个</a>关于提升沟通能力的，还有<a href="https://www.youtube.com/watch?v=YFS5JBgz1Xc&t=3034s">这个</a>关于投资的。突然想起来要和老妈视频，聊完后又刷了很长时间的推。</p><p>有时候在想，我目前这样的生活好像也挺不错的，工作没太大压力，一个人也过得自由自在，但为什么还是会感到不满足？我觉得一方面，人总是想要追求更好，想要拥有更好的生活、获得更多的自由。另一方面，人也需要有意义感，需要找到能让自己全情投入的事物。目前来看，我的工作并不能帮我找到这样的意义感，所以我才会产生离职去大公司看看的想法。但是矛盾的是，以我目前的能力并不能支撑自己进入大公司的愿望，而且我也开始有点犹豫是否应该按照这种标准化的路径去提升自己来达成愿望。简单来说就是，我又陷入了迷茫。不同的是，这次的迷茫是自己的能力无法匹配上欲望。所以，摆在自己面前有两条路：一是降低自己的欲望，先学会享受现在这样的生活，不要想太多，然后慢慢寻找自己的热情和天赋所在。二是努力提升自己的能力，老老实实逼自己学习一段时间，尝试所有可能的方法达成目标。So, blue pill or red pill?</p><h4 id="1-月-11-日-延迟满足"><a href="#1-月-11-日-延迟满足" class="headerlink" title="1 月 11 日 - 延迟满足"></a>1 月 11 日 - 延迟满足</h4><p>提高自己延迟满足感的能力。现在很多人都习惯了即时享受，不喜欢等待，但是这种习惯一旦养成，通常就意味着许多机会的丧失，那么，如何培养自己延迟满足感的能力呢？方法有很多，比如在吃这件事上，间歇性断食就是一种延迟满足感的方式，断食期的克制会让自己在进食期享用的任何食物美味度翻倍。</p><p>延迟满足感对我的改变有哪些？首先，我会更有耐心地去做那些原本自己不喜欢做的事。即使不喜欢，但是通过给自己设置一些完成之后的小奖励，我会更渴望去完成它，相比原来立即满足自己的愿望而言，其实并没有付出更多的成本，只不过是把顺序改变一下而已。其次，我对诱惑的抵抗力增加了。对于能给自己带来暂时快感但是长期来看明显会对自己造成更多不利的事物，我会让自己缓一缓再去做而不是立马去做。通常过一段时间等到理智恢复之后就会发现，原来看似无法阻挡的诱惑对自己而言已经没有那么大的影响了。</p><h4 id="1-月-12-日-慢慢改变-记录自己的所有知识-记录情绪变化"><a href="#1-月-12-日-慢慢改变-记录自己的所有知识-记录情绪变化" class="headerlink" title="1 月 12 日 - 慢慢改变+记录自己的所有知识+记录情绪变化"></a>1 月 12 日 - 慢慢改变+记录自己的所有知识+记录情绪变化</h4><p>昨晚躺在床上，心里又是一阵自我发问：到底要不要离职？离职之后去做什么？我想要过什么样的生活？没有答案，也没有人可以倾诉。早上上厕所在看《被讨厌的勇气》，这是第二遍看了，看到要放弃过多的自我关注以及自我意识，寻求共同体感觉。我现在基本上已经接受了这样的观点，但是从实践上来看，还是有很长的一段路要走。现在的我还是会首先想到自己，要如何生存、如何为自己获利，然后才是我能为他人创造哪些价值。这也无可厚非。但是，要抛弃掉那种「我必须要让他人觉得自己有价值」的想法，真的很难很难。活在当下，做好眼下的事，说起来轻松但是执行起来却非常难。自信、自立、自强，这是一个漫长的过程，也许我需要给自己多一点时间吧。慢慢学习，慢慢做事，慢慢思考。一点点进步，长期积累下来也是非常了不起的成就了。</p><p>今天读了不少文章，感觉收获颇丰，尤其是下午无意间逛到一个 <a href="https://wiki.nikitavoloboev.xyz/">wiki</a>，作者在里面记录了自己的所有知识，真的是所有的知识，不仅仅是代码相关，还有他如何做知识管理、价值观、生活习惯等等，可以说是无所不包，而且发现我很早之前用过的 <a href="https://learn-anything.xyz/">learn anything</a> 也是他做的。</p><p>虽然不可能看完所有，但是仅仅读了<a href="https://wiki.nikitavoloboev.xyz/sharing">分享</a>部分中的一点点内容，对我的启发也是巨大的。于是，我也萌发了要写这样一个项目的想法。记录自己的所有知识，不但为了日后查找方便，作为一种分享，也是让他人了解自己的方式。虽然工程量巨大，但是这件事在做的过程中本身就是很有意义的，是一种反思和学习的机会，也许还能通过这种方式发现自己的优势和真正感兴趣的东西。</p><p>今天的另外一个收获是，读了 Derek Sivers 的<a href="https://sive.rs/about">博客介绍</a>，很多内容需要时间慢慢消化，但是最大的感触是，要多多观察自己的情绪，多和自己对话。比如我晚上冥想的时候才注意到早上早餐店发生的事（排队买酱香饼，但是店主给在我之后来的人先切鸡蛋饼了，我当时有点生气，并且语气不太友好地质问了店主。现在想想，为什么要生气呢？）。所以，打算以后用时间日志的同时，记录下自己的情绪变化，以便对自己心理状态的变化有更多的了解。</p><h4 id="1-月-13-日-对自己宽容一些"><a href="#1-月-13-日-对自己宽容一些" class="headerlink" title="1 月 13 日 - 对自己宽容一些"></a>1 月 13 日 - 对自己宽容一些</h4><p>我为什么做不到完全的自我接纳？老是觉得自己不够自信，不敢发表自己的看法。除非是已经非常了解的东西，否则绝对不会轻易说出自己的见解，尤其是在一群人面前的时候，哪怕这群人都是自己熟悉的人关系很亲近也还是一样。说到底，还是不能承认自己也有不足之处，害怕暴露自己的无知，害怕他人审视的眼光，尤其害怕被人看不起。但是他人的看法为什么对我有那么大的影响力？我并不依靠他人的看法才能生存，别人对我的负面看法也并不能真正伤害到我。</p><p>自尊来自于相信自己的价值，如果你把自己的价值依托于他人如何看待自己，那么自然而然你的自尊总是会在得不到他人认可的时候受到减损。我无法控制他人如何思考，我也不用为了改变他人的看法而牺牲自己。所以，只要你没有侵害到他人也没有任何恶意，你就可以自由地表达自己的意见和想法，你和他人之间的关系是平等的。即使得不到认同也没关系，我们每个人的成长环境和接触到的信息有差别，这造就了每个独一无二的个体，我们应该关注彼此身上的共同点。至于那些不喜欢的人，你当然可以选择刻意避免与他们的任何接触，但是要学会与他人和平相处，我们虽然不同但是我们依旧保持相互尊重。</p><p>接纳自己其实不仅仅在于接纳自己的不足、不再惧怕他人审视的目光，也在于能够接受自己的弱小。我们都会有感到迷茫、无助、纠结、不知所措的时候，这个时候才更需要接纳自己，而不是苛责、贬低自己。不是所有人都能足够幸运即使在逆境中也能获得勇气，不停地挑战自己的极限，也不会被眼前的失败所击垮。有的人就是需要比其他人更多的时间来积攒力量。我觉得自己就是这样的人。所以，多给自己一点时间，也对自己宽容一些吧。</p><h4 id="1-月-14-日-他者信赖"><a href="#1-月-14-日-他者信赖" class="headerlink" title="1 月 14 日 - 他者信赖"></a>1 月 14 日 - 他者信赖</h4><p>信赖他人。我为什么身边连一个可以亲近的朋友都没有？很大一部分原因是无法做到对他人无条件信赖。总是先斟酌一个人是否值得信赖，甚至习惯性地先怀疑他人。这样做之后别人当然也能注意到自己没有被信任，于是对我也常常抱着戒备心。要做到他者信赖的前提是你要先敞开自己的怀抱，不要害怕被欺骗或者受到损失，相比于得到他人的信赖，可能遭受的损失其实根本不值一提，而且回望自己过去的经历，那些不靠谱的人能给自己造成多大的损失呢？现在看来其实根本就不算什么了。所以，尽量去信赖他人吧，也不要期望每次都能得到回应，即使只有一小部分人对你做出了回应，这种和陌生人建立起信赖关系的过程也是一种非常宝贵的经验。</p><h4 id="1-月-15-日-不要害怕表达不同的观点"><a href="#1-月-15-日-不要害怕表达不同的观点" class="headerlink" title="1 月 15 日 - 不要害怕表达不同的观点"></a>1 月 15 日 - 不要害怕表达不同的观点</h4><p>和他人观点不同的时候，应该如何处理？我觉得自己过去做得非常不好的地方是，和人聊天过程中，一旦对方说出一些和我不同的观点的时候（尤其是和我截然不同的观点），我内心会非常地抗拒，甚至忍不住在心里嘲讽，有时候可能还会直接把自己的不屑表达在脸上或者言语中。当确认对方的确是这么想而不是在开玩笑的时候，通常我就会选择闭嘴，不再和对方继续交流下去，直到对方表达完他的观点，或者尝试把话题引到别的方向。这也是为什么我很不喜欢和人闲聊，尤其是关系不那么好的人，因为害怕我们会因为观点、想法不同而造成彼此关系不和，所以我也尽量避免聊一些有争议的话题。另外，我知道我的观点和想法肯定是人群中的少数派，把它们说出口是需要勇气的，目前，自己没有能力也没有动力去说服任何人。</p><p>但是，这种做法也是有问题的，最明显的是会让对方觉得你不坦诚而且有点傲慢。怎么解决呢？我觉得最好的做法是尽量在友好平等的氛围下坦诚地说出自己的想法。不要害怕观点的分歧会给你们的关系造成间隙，因为如果是那样的话，说明你和对方至少有一方心胸是不够开阔的。而且只有通过表达不同的观点，听到不同的声音，我们才能获得成长，尤其是那些少数人才持有的观点。好想法和好观点只有通过我们的努力传播，最终才能成为主流。另外，彼此坦诚说出不同的观点也是一种加深对彼此了解、增进感情的方式。所以，下次你有不同的观点的时候，尝试大胆说出来吧，养成这种习惯之后绝对受益无穷。</p><h4 id="1-月-16-日-利用好时间"><a href="#1-月-16-日-利用好时间" class="headerlink" title="1 月 16 日 - 利用好时间"></a>1 月 16 日 - 利用好时间</h4><p>如何避免自己进入无所事事的状态？我发现自己很多时候都很容易陷入一种不知道接下来应该干什么的状态，常常是别人告诉有什么东西需要处理或者想到要做什么才去做。这种状态看似随意轻松，其实对心理能量的消耗非常大。因为你经常不得不进行各种事务之间的切换。不知道该干什么的时候还得思考下一步做什么好。人的意志力是有限的，如果在小事情上耗费太多决策的精力，我们就无法在那些重要的事情上做出好的决策。所以，最好的做法是，给自己<strong>制订计划</strong>，理想情况是具体到每小时要做什么事，而且每周都要<strong>复盘和规划</strong>下周要做的事，按照优先级排序，确保自己一定先完成最重要的事。其次，就是我现在重新捡起来的习惯，写时间日志，记录下自己每天时间都花在了那些地方，然后再做出调整。时间是公平的，一个人如何对待自己的时间能反应出他的生活状态和生活质量。如果我们能意识到时间的宝贵，也能找到自己的使命，那么，活着的每一天都是生命对我们的奖励。</p><h4 id="1-月-17-日-只想当咸鱼的时刻"><a href="#1-月-17-日-只想当咸鱼的时刻" class="headerlink" title="1 月 17 日 - 只想当咸鱼的时刻"></a>1 月 17 日 - 只想当咸鱼的时刻</h4><p>度过一个慵懒的周末之后，坐在电脑前突然不知道该写点什么。虽然有很多事情要做，但是觉得提不起兴趣。觉得现在的生活也没什么不好，一个人自由自在，想做什么就可以去做，而且我对物质也没有太高的要求，生活、社交全都极简，那我为什么还要追求那么多？注意到这个想法之后，脑海里闪过一丝恐惧，难道我年纪轻轻就没有梦想了吗？😂😂</p><p>但是，我觉得这样的自己才是真实的自己。从过去的经历来看，我确实不是那种进取心特别强、特有追求的人，大多数时候我喜欢把自己的关注点放在我感兴趣的那一小块天地之中就够了，那些别人觉得应该如何如何的事情到我这是根本就是无所谓的事情。不过话虽如此，我还是很爱钱的。但是我这样性格的人，好像不太可能有机会赚到什么大钱的。既然如此，那就先追随自己的兴趣吧。做个咸鱼也没什么不好。</p><h4 id="1-月-18-日-幸福在当下"><a href="#1-月-18-日-幸福在当下" class="headerlink" title="1 月 18 日 - 幸福在当下"></a>1 月 18 日 - 幸福在当下</h4><p>没有目标是一件很痛苦的事吗？我觉得倒也未必。相比那些有目标但是苦于追求如何实现它，导致没法享受当下生活的人，我觉得还是前者更好一些。我们为什么要有目标，只不过为了过得更幸福，对他人有用，获得贡献感。但是，如果目标变成了人生唯一的目的，实现目标的过程变成了痛苦的煎熬，为了未来的自己而牺牲当下的自己，这就有点本末倒置了。生活就是每一个具体的当下，如果你无法享受此刻的自己，达成目标之后的你又怎么能感受到幸福？不要变成那种所有行动都是为了追逐、实现欲望的人。当然，延迟满足感还是很重要，但是不能完全抛弃掉此刻的自己的幸福。把握好这两者之前的平衡，是获得长久幸福的关键。</p><h4 id="1-月-19-日-解除焦虑：接受现状-合适的目标与行动"><a href="#1-月-19-日-解除焦虑：接受现状-合适的目标与行动" class="headerlink" title="1 月 19 日 - 解除焦虑：接受现状+合适的目标与行动"></a>1 月 19 日 - 解除焦虑：接受现状+合适的目标与行动</h4><p>每当感到焦虑的时候，告诉自己：这就是我的生活，这就是真实的自己，要学会接受这样的生活和这样的自己。最好的状态是能享受自己的每一个当下，如果还是不喜欢这样的自己，那就试着去改变。焦虑其实是欲望大于能力，觉得自己应该拥有更多，但是现实却不符合自己的预期，于是尝试去做点什么与现实达成统一。但是，很多时候往往做得越多就越是感到焦虑，尤其是当你一直生活在自己的幻想之中的时候。这个时候我们应该停下来思考，我想要的到底是什么？它是否适合现在的自己？如果不是，我应该怎样挑战自己去追求适合自己的东西？当你想清楚自己真正想要又适合自己的东西或目标之后，焦虑就会转换成动力，你会在努力完成目标的同时，也能享受这一过程，而不是陷入无休止的纠结与自我怀疑，同时做到能真正投入其中，也不用担心结果会怎样。即使最终无法完成目标，你也依旧能承担这样的结果，因为你做的是你真正想做的事。</p><h4 id="1-月-20-日-设立意义感而不是依靠意志力"><a href="#1-月-20-日-设立意义感而不是依靠意志力" class="headerlink" title="1 月 20 日 - 设立意义感而不是依靠意志力"></a>1 月 20 日 - 设立意义感而不是依靠意志力</h4><p>不要依赖意志力去做事，因为意志力往往是最不可靠的，而且很容易就被消耗完。当我们使用意志力的时候，其实是在逼迫自己去做自己不想做的事，在做的过程中也很难保持长时间集中注意力，一旦获得从当前这件事上转移注意力的机会的时候，我们往往会毫不犹豫去做别的事。解决的方法是，给自己寻找意义感，而不仅仅是完成这件事之后的奖励。比如我要完成一个项目 X，在做之前，我需要搞明白它的意义是什么，我为什么想要做这个项目，然后才动手去做。如果只关注做完这个项目之后能给自己带来什么样的结果，往往就没法很好地享受过程，而且也容易因为达不到预期而中途放弃。比如间歇性断食，它对我的意义是使我的身体变得更健康了，也能帮助我养成良好的生活习惯，让我对食物变得更不挑剔。设立意义之后，虽然有时候还是会想要打破规则，想要在断食期之外吃更多的东西，但是只要想到断食对我的意义，我就能立马恢复理智。而且，即使偶尔一两次打破规则，我也不会太负疚，因为我知道这并不影响我最终的目标。</p><h4 id="1-月-21-日-可以不融入"><a href="#1-月-21-日-可以不融入" class="headerlink" title="1 月 21 日 - 可以不融入"></a>1 月 21 日 - 可以不融入</h4><p>如何处理无法融入集体的感觉？我发现自己与人沟通的时候，还是很容易感到自己不被理解，或者觉得对方思维方式和自己相差很大，于是渐渐就不想和对方进行沟通交流了。或者是不喜欢对方的沟通方式，甚至是觉得对方的某些人格特质造成了我的反感，也会渐渐选择从此避免和对方产生交流。这样之后，当处在一个小团体的时候，当发现这个团体中的很多人我都不喜欢和他们交流的时候，我就会产生一种无法融入以及和周围环境格格不入的感觉，尤其是当他们开始聊天并且聊天内容中的很多观点都和你完全不同的时候，这种感觉尤其强烈。</p><p>所以，如何解决这种矛盾呢？过去我常常觉得这是我自己的问题，是我不够包容，心胸不够开阔，觉得我应该改变自己，多去听听不同的观点，这对自己的世界观也是一种完善。现在觉得这些都是废话，一个人的世界观和价值观一旦成型之后，想要改变是很难的，你不能假装被改变，也无法去改变他人。所以，我们应该做的是，找到适合自己的人和圈子。你当然可以试着去融入和自己不同的圈子，但是不要强迫自己。<strong>人是观念的产物。</strong>尤其是对于同事这样的弱关系，下班之后我们才能真正彻底放松做自己，这种情况没必要逼自己为了别人去改变。</p><h4 id="1-月-21-日-Choose-Love"><a href="#1-月-21-日-Choose-Love" class="headerlink" title="1 月 21 日 - Choose Love"></a>1 月 21 日 - Choose Love</h4><p>为什么有时候会感到失落？是因为期望太高了吗？但是说到底自己还是幸运的啊，为什么有时候会忽视这一点呢？想想看，要不是爸妈把我带到这个世界，我就看不到这个丰富多彩的世界，那些壮丽的景色，那些神奇的动植物，那些震撼人心的演出，那些来自同类的美好的情感，那些感动我的文字、音乐、艺术，还有隐藏在浩瀚宇宙深处的奥秘。正因为我来到了这个世界，所有那些我曾经、现在和将来能够感受到的一切才成为可能。所以，我为什么要抱怨自己的生活呢？希望自己以后遇到不开心的时候，都能想起此刻写下这些文字时的自己的感受。在我们生活的这个世界里，爱才是主流，那些苦闷、压抑、焦虑的情绪，都是我们主动选择的。但是，你也可以选择看到那积极的一面。</p><h4 id="1-月-23-日-追求『更好』的意义"><a href="#1-月-23-日-追求『更好』的意义" class="headerlink" title="1 月 23 日 - 追求『更好』的意义"></a>1 月 23 日 - 追求『更好』的意义</h4><p>有时候在想，人总是追求更好，比如为了获得某种资源而不停地储蓄。未来人们会改变吗？我想并不会。因为只要人类社会还在发展，我们的生活条件就会继续改善，即使现在的某些需求在未来极大丰富了，到时候一定会有别的东西出现，值得我们花更多的时间去追求。价值都是在比较中产生的，好东西永远稀缺，因为资源是有限的，不算矿物资源的使用，地球上每年所有能量的总和是一年内阳光照在地表上产生的热量再加上地核释放的能量总和，这些能量能用于生产的物质总会到达极限，而人的欲望是无穷无尽的。当主流世界都不再寻求物质满足的时候，整个社会可能就分崩离析了。所以，不断追求更好是永恒且正当的，不要怀疑它的意义。我们应该做的，是不停问自己，对我来说什么才是『好』东西？追求它能让自己感到幸福吗？</p><h4 id="1-月-24-日-只有你能为自己的幸福负责"><a href="#1-月-24-日-只有你能为自己的幸福负责" class="headerlink" title="1 月 24 日 - 只有你能为自己的幸福负责"></a>1 月 24 日 - 只有你能为自己的幸福负责</h4><p>我们应该记住：能够为你的幸福快乐负责的人<strong>只有你自己</strong>。如果你过得不快乐，问题一定出在你自己身上，而不是他人或者这个世界哪里做的不对。只要你能担起自己的责任，审视自己的内心，看看到底哪里出问题了，你才能找到问题的症结，并想办法解决掉它。</p><p>他人没有了解你的义务，你能做的是主动向他人展示自己的才能、优势、观点和特质，吸引他人的注意力也是一项重要的能力。而且这也是一门艺术，如果你能掌握它，你的能力会得到极大的释放。</p><h4 id="1-月-25-日-无依之地-Nomadland"><a href="#1-月-25-日-无依之地-Nomadland" class="headerlink" title="1 月 25 日 - 无依之地 Nomadland"></a>1 月 25 日 - 无依之地 Nomadland</h4><p>昨天看了部电影《无依之地 Nomadland》，我也不知道应该怎样描述这样的电影，关于生活方式的选择，如何对待死亡，与自然的关系，临终关怀等等，有下面一些感触：</p><ul><li>  人生很短，有些美好的东西应该早点去看看，别等到爱人离去之后才醒悟</li><li>  无论是痛苦还是快乐，我们都不应该活在回忆里，始终要往前看，应该把当下的生活过好、过充实</li><li>  在宇宙中，人类何其渺小，但是只要想到我们身体的一部分也来自宇宙星尘，就觉得自己不是孤独的</li><li>  这个世界上好人一定比坏人多，我们要多分享善意，要相信你的善良会传播出去很远</li><li>  爱让我们和这个世界始终保持联系，只要心中有爱，无论到哪里，你都不会感到孤单</li></ul><h4 id="1-月-26-日-选择看到好的一面"><a href="#1-月-26-日-选择看到好的一面" class="headerlink" title="1 月 26 日 - 选择看到好的一面"></a>1 月 26 日 - 选择看到好的一面</h4><p>为什么同样一件事，有的人觉得是好事有的人却觉得是坏事？我觉得抛去立场和偏见的因素，很大一部分原因是<strong>这是我们主动选择的结果</strong>。一个豁达乐观、心中有爱的人，往往更容易看到他人身上或者事物中好的一面，而较悲观、心理防御性很强的人则往往选择更消极的一面。我觉得自己更偏向属于后一种人。后一种状态的人也不是说不好，这种机制可以避免自己被坑，因为这个世界上总归是有一些坏人的。但是，绝大多数时候，这种心理只会让自己陷入被动。只是因为存在某些可能出现的障碍或者不利的一面，就选择不去做某事，会让我们失去很多机会。不去试试的话，你怎么知道自己的想法就是正确的呢？你看到的只是你选择看到的一面，而从来没有尝试想过还有别的可能存在。</p><p>所以，对于每天遇到的所有人或事，每当你产生负面想法的时候，提醒自己：你看到的只是事物的一面，你主动选择了这种方式去解读它，但是，有没有可能存在另外一面，好的一面，被你忽视了？比如，当看到一个人身上的『缺点』的时候想一想，他的『缺点』真的只是缺点吗？如果放在另一个场景下，他的这个特质其实是他的优点。再比如，当你想起某些给自己造成不方便的东西的时候，所谓的不方便其实也是机会，如果你用心去改进了，那是不是也能产生价值呢？多尝试用这种思路去看问题，你会发现自己对生活的态度截然不同。你会变得乐观，也更能避免不必要的负面情绪的出现。</p><h4 id="1-月-27-日-紧张时的生理状态以及如何应对"><a href="#1-月-27-日-紧张时的生理状态以及如何应对" class="headerlink" title="1 月 27 日 - 紧张时的生理状态以及如何应对"></a>1 月 27 日 - 紧张时的生理状态以及如何应对</h4><p>我为什么会害怕和陌生女生接触？因为和陌生女生相处的时候会感到非常紧张。但是为什么会这样？好像这已经成了身体的自然反应。先是会脸红，心跳加快，随后当注意到自己身上的这些变化之后，会变得更加紧张，头上开始冒汗，于是想要通过做别的事转移注意力，但是注意力此刻全在自己身上，对周围的一切都非常敏感。等到慢慢觉得没人注意到自己的时候，才渐渐冷静下来，恢复到正常的状态。我觉得可能是自己习惯了这种模式，身体形成了条件反射，有时候甚至是自己主动选择了这种方式，<strong>用害羞引起对方的注意</strong>。这是可以改变的。每当这种情况出现的时候，花更多时间去感受这种状态，然后告诉自己，你会慢慢习惯这种感觉的，把放在自己身上的注意力转移到对方以及此刻周围的环境中就好了。其实，所有让自己感到紧张的场合都可以用这种方式来对待：先注意到自己身上的变化，然后尝试转移注意力到周围环境和他人身上，告诉自己会慢慢习惯这种感觉的。当自己越来越熟悉这种场合的时候，这种感觉会慢慢消失。</p><h4 id="1-月-28-日-如何保持进步的动力"><a href="#1-月-28-日-如何保持进步的动力" class="headerlink" title="1 月 28 日 - 如何保持进步的动力"></a>1 月 28 日 - 如何保持进步的动力</h4><p>如何让自己保持动力、不断进步？首先记住 Goldilocks 法则，要去做那些<strong>难度适中</strong>的事，在有一定的挑战性、需要付出一点努力、不太容易完成的同时，又不是太难以至于想要提前放弃。其次是要及时让自己获得反馈，要让自己看到付出的努力所获得的成果，可视化自己取得的进步。这样的<strong>及时反馈</strong>可以让自己有一种「打怪升级」的感觉。另外，即使没有任何进步，也能看到自己做的不好的地方从而及时改正。</p><p>除了上面两点之外，还有最重要的一点：<strong>选择一条适合自己的赛道</strong>。如果你做的不是自己喜欢的事，而且等到投入很多时间之后才发现这一点，那么你付出的成本将是巨大的。所以，一开始的选择很重要。怎样做选择呢？首先列出自己喜欢且有一定天赋的事情，问问自己其中哪些是即使坚持十年之后没有任何结果自己也能接受的，然后再选择出其中最有商业价值的事，接下来开始努力就行了。</p><h4 id="1-月-29-日-耐心和坚持-保持热情"><a href="#1-月-29-日-耐心和坚持-保持热情" class="headerlink" title="1 月 29 日 - 耐心和坚持+保持热情"></a>1 月 29 日 - 耐心和坚持+保持热情</h4><p>如果说懒惰和拖延是自己最大的敌人，那么一个人最好的朋友是什么呢？我觉得是耐心和坚持。而且这两者是互相增强的。如果没有耐心，我就无法坚持，而通过坚持，挖掘出自己的潜力之后，我又变得更有耐心了。如何利用好这个优势呢？我觉得还是得通过寻找自己真正热爱的事物，做自己喜欢的事。没错，建立稀有又有价值的技能很重要，但是无法否认人是有情绪的动物，如果无法在这一过程中获得成就感或者快乐，那么我知道自己是一定坚持不下去的。所以问题又变成了，如何在建立技能的过程中，保持自己的热情？</p><h4 id="1-月-30-日-找到自己的位置"><a href="#1-月-30-日-找到自己的位置" class="headerlink" title="1 月 30 日 - 找到自己的位置"></a>1 月 30 日 - 找到自己的位置</h4><p>如何找到自己的位置？如果能想清楚这个问题，人生中的很多难题都能迎刃而解了。但是这又是最难的一件事，因为它涉及到认识自己，找到自己的长处。还要对这个世界有足够的了解，对同类有足够的关心和爱，能真正心怀善意，不仅为自己也为他人和这个世界创造价值。除此之外，还需要有一点点运气，因为不是所有人都能有思考这个问题的机会的，要么受环境要么受自身认知水平的限制。</p><p>我的长处是什么呢？我觉得自己最大的特点是擅长忍耐。另外，对人或物的缺点特别敏感。好像这两个都算不上是『优点』吧，不过只要是自己的特色，如果能找到它们的闪光点，并且找到让它们发挥价值的方法，那也是能被开发成优势的。了解世界需要有足够的好奇心，一个人只要具备好奇心，这个世界就是一个无穷无尽的游乐场，永远都有新东西等着他/她去探索。而善良和创造价值，我觉得这是任何一个聪明人都会做出的选择和追求。我们选择某种方式度过自己的人生是因为我们想要更多地和这个世界建立连结，去帮助自己和他人认识这个世界，去获得意义感和幸福感。至于运气的话，这就不是我们能控制的了。我们能控制的只有自己，去努力做出改变，去创造出一点点东西，去发挥出自己哪怕只是微不足道的影响力，让世界因为我们的存在而变得美好一点点。在这一过程中，保持内心的平和，最后即使生活依旧没有太大的改变，也不要觉得自己所有的努力都是徒劳的，因为我们至少改变了自己。</p><h4 id="1-月-31-日-不要停止追求理想的生活状态"><a href="#1-月-31-日-不要停止追求理想的生活状态" class="headerlink" title="1 月 31 日 - 不要停止追求理想的生活状态"></a>1 月 31 日 - 不要停止追求理想的生活状态</h4><p>我现在的生活是我想要的吗？这是一个强大而有效的问题，可以让自己立马摆脱拖延和自我欺骗，回到现实，关注当下的自我。如果你不喜欢当下的生活状态，那么就需要行动起来去做出改变；反之，你也应该审视自己，当下的生活是合理的吗？自己是否因为习惯了现状而变得容易满足，是否忽视了某些隐藏在角落里的问题，是否应该去探索更多的可能性，尝试一些不一样的东西。</p><p>自由的定义其实非常宽泛，不仅仅在于获得自己想要的东西、做自己想做的事，更在于享受自己的生活状态。大多数人都只是普通人，我们需要生活、社交、工作，如果我们每天都能朝着自己理想的生活状态迈进，那么每天都是在向自由靠近，也能因此活得更加清醒且充满动力。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Find your own rainbow</title>
      <link href="/2020/"/>
      <url>/2020/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pyxis.nymag.com/v1/imgs/7d9/066/a0c910bec614380ab9246b7fd76ea76977-11-writing.rsquare.w1200.jpg"></p><p>2020 原本是一个听上去挺吉利、挺顺耳的年份，但是估计谁也没想到事情会发展成现在这个样子。只能说人类在自然面前太渺小了，我们并没有自认为的那么无所不能。如果让我用几个词形容自己的这一年，立马想到的是焦虑、迷茫、孤独、浑浑噩噩等等类似这样的词汇，估计很多人也都差不多。不过，凡事都有两面，如果只关注负面，那这一年真的糟糕得不能再糟糕了，而如果换个角度，其实给我们带来痛苦的东西往往也给我们提供了反思和成长的机会。</p><h3 id="过去一年"><a href="#过去一年" class="headerlink" title="过去一年"></a>过去一年</h3><p>这一年对我来说原本最大的计划是换工作，结果不但没有换成功，还因为面试受到了一点打击，以至于开始审视自己：我对自己的能力是否过度自信了？由此带来的结果是，提前迎来了自己的职业危机，开始怀疑自己是否真的热爱编程，也不知道什么才是真正适合自己做的事。于是，开始看了很多心理学和自助类的书籍，总算稍微缓解了一点点内心的焦虑和迷茫。以前以为只要朝着现在的方向一直做下去，就不会遇到这样的问题，至少不会这么早。但是没想到，该来的终究还是会来的。早点认清自己优劣势，停止自我欺骗，意识到并承认过去的自己浪费了很多时间，开始思考什么才是对自己真正重要的东西，有勇气面对真实的生活和真实的自己。通过这次经历能够及时醒悟，也算是一件好事吧。</p><span id="more"></span><p>疫情刚开始的时候，我的计划就全都被打乱了，尤其是被封在家里的那段时间，每天浪费大把时间在游戏和网络空间里，以至于回杭州之后很长一段时间都适应不过来。但是从下半年开始，逐渐找回了节奏，重新恢复阅读、跑步、滑板以及规律作息。虽然换工作的计划失败了，但是还是完成了一些事情。具体来说：</p><ul><li>  开源了 <a href="https://ajiew.github.io/react-native-tag-group/">react-native-tag-group</a>；</li><li>  新建了一个<a href="https://ajiew.github.io/tags/Journal/">碎碎念</a>的分类用于发表自己每天的想法和心得记录；</li><li>  将虎哥 App 从 RN 开发切换到了用安卓原生开发，并发布了 5.0 版本；</li><li>  养成了间歇性断食的习惯；</li></ul><p>除此之外，还利用今年这次 20 年一遇的国庆遇上中秋的连续假期和朋友完成了一次<a href="https://ajiew.github.io/northwest-road-trip/">大西北自驾游</a>，看完了差不多 <a href="https://book.douban.com/people/85276219/collect">20 本书</a>，跑步 300 公里，基金收益率达到预期，滑板学会了 Ollie 且左右脚都能顺畅滑行和尾刹。</p><p>虽然离年初定下的计划有一定的差距，但是鉴于今年的特殊情况，能完成到这个程度我已经很满意了。另外，我发现自己今年最大的改变其实是从写碎碎念开始的。虽然从初中就开始写日记，但是从来都没想过要公开自己的日记。说起来可能是在看了《写出我心》之后播下的种子吧，加上后来受到<a href="https://twitter.com/ElodesNL/status/1304729277737455617">社交网络</a>上一些<a href="https://www.youtube.com/watch?v=rreXlrxVW6w&list=PLlDm9GHD1QD2IoAaghslrFrUDuyVarTcd">观点</a>的影响，慢慢意识到，自己过去这二十多年里形成的行为方式和思维模式，其实是存在一些问题的。最明显的就是，由于害怕表达自己内心的真实想法，导致自己越来越不敢表达，于是把自己关进了一个自我封闭的牢笼。</p><p>其实在这个时代，我们每个人越来越像是一个个节点，如果不去<a href="https://www.douban.com/note/783934383/">表达自我</a>，观念和思想就得不到传播。人类这个物种是建立在交流与互换的基础之上的，我们不应该把自己变成一座座孤岛，那样就失去了进化的意义了。我觉得未来一定是人们逐渐建立起更多连结的时代，我们应该尽全力传递好观念和好思想，让自己和他人都能生活得更加幸福。哪怕只能影响到几个人，那也是有意义的。</p><p>放在以前，我可能不会像现在这样思考，觉得类似这样的言论太虚，能先把自己的生活过好就不错了，想那么多有什么意义？但如果你真的开始思考意义的话，我们活着的意义是什么？有人说是为了让自己活得更好。那么怎样才能活得更好？赚更多的钱？有更多的时间去做自己想做的事？能给自己爱的人提供一个好的生活？好的，就算是这样，那么，达到这些目标的初衷又是什么？你可能会说为了生活得更幸福快乐。但幸福快乐本身，说到底只是人的感受而已啊，只要基本的生活物质资料得到满足之后，想要感受到幸福和快乐，只需要降低自己的期望或者改变自己的想法就能做到。尽管实际拥有某物以及获得某种权力和地位，和想象出来的完全不一样，但是，只要你愿意尝试着放下，你会发现自己过去苦苦渴求的那些东西，对生活的幸福度真没有那么大的影响。</p><p>所以，人还是需要有更大的意义感的，而不仅仅是满足自己的需求或者是追逐无穷无尽的欲望。这种意义感我觉得来自于<strong>为他人创造价值</strong>。关于这一点我很赞同阿德勒心理学中的观点：幸福即贡献感（对他人有用）。听上去好像很肤浅，但实际上就是这么一回事儿。我觉得这除了可以从人的社交性来解释，一定也能从生物遗传学中找到证据支持。</p><blockquote><p>  给予就是尽你所能让世界变得更好，当你这么做时，人们内心向善的一面也会发出共鸣，大家会支持、模仿、回报和培养这样的行为，然后整个世界也会跟着变得越来越好。– <a href="https://en.wikipedia.org/wiki/Jordan_Peterson">乔丹•彼得森</a></p></blockquote><blockquote><p>  自由主义思想的出发点是，认清人类合作的价值和重要性。-《<a href="https://book.douban.com/subject/1043419/">自由与繁荣的国度</a>》</p></blockquote><blockquote><p>  价值不在于单纯拥有体验，而在于能将体验转化为自由流动的数据。-《<a href="https://book.douban.com/subject/26943161/">未来简史</a>》</p></blockquote><blockquote><p>  艺术就是在做沟通。品尝孤绝的苦涩滋味，而从那里开始，与所有曾经孤单的人相濡以沫并相互怜惜。-《<a href="https://book.douban.com/subject/26822680/">写出我心</a>》</p></blockquote><p>很早之前就受到一些前辈的启发并下定决心要养成写作的习惯，但是很可惜，一直都没能坚持下来。不过经过这次疫情，偶然间养成的写碎碎念习惯之后，我觉得自己已经大大提升了通过写作表达自己观点的能力，这应该是今年最让我感到骄傲的一件事。而且我想接下来我还会继续坚持下去，把写作作为自己的武器，用于强化自己的思维能力，锻炼自己的表达能力，传递有价值的观点，与他人建立起连结。</p><h3 id="新的一年"><a href="#新的一年" class="headerlink" title="新的一年"></a>新的一年</h3><h4 id="找到自己的兴趣所在"><a href="#找到自己的兴趣所在" class="headerlink" title="找到自己的兴趣所在"></a>找到自己的兴趣所在</h4><p>2021 年最大的愿望是找到自己兴趣所在，无论是编程、写作或者别的什么。虽然对现在的工作还算满意，但是能感觉到自己进步的速度明显变慢了，也渐渐丧失了提升自己的动力。究其根本，还是因为对现在所做之事缺乏足够的兴趣，所以也曾不止一次地感到迷茫、没有方向，并且想要通过跳槽来改变自己的这种状态。现在的我终于想明白了，跳槽也许能在短期内给自己带来一些改变，但是长期来看，问题依旧存在。解决办法只有一个，那就是找到自己真正<strong>热爱</strong>且愿意<strong>长期</strong>投入精力去做的事。<strong>只有通过兴趣和优势的结合，才能让自己一直坚持下去并且慢慢创造出价值。</strong></p><p>很惭愧，工作三年多了却连这种最基本的问题都还没想清楚，不过至少应该庆幸自己不是到更大的年纪才开始思考这个问题吧。所以，到 2021 年底的时候，我希望那时候的自己在做的是他热爱的事。无论是通过继续留在现在的公司只不过改变了自己的心态，又或者是换了工作，只要能从心底接受自己当下的状态，每天早上起来都能以热情的态度迎接新的一天，享受自己当天的工作，每天结束的时候都对完成的工作感到有成就感，这就算完成目标了。</p><h4 id="个人情感"><a href="#个人情感" class="headerlink" title="个人情感"></a>个人情感</h4><p>到这个年纪，基本每次回家都会被家里人催着找对象。刚毕业那会儿还抱着无所谓的态度，毕竟身边大多数人都和我差不多，但是现在看来，的确应该认真对待起来了。虽然一个人也可以过得很好，但是如果身边有一个能够理解彼此的人，至少可以在感到孤独、情绪低落的时候相互倾诉下，而不是靠一个人独自消化。</p><p>老实说，从上大学到现在一次恋爱都没有谈过，连暧昧关系都没有过，想想也是挺惨的。自我分析一通之后，除了个人条件一般之外，我觉得自己最大的问题还是交友太被动了，而且太容易害羞。如果自己能够克服这两个障碍，其实还是有很多认识并结交异性朋友的机会的。所以，新的一年，需要改变一下自己：学会搭讪，多表达自己，机会出现的时候尽量主动一点。最差的结果只是被拒绝而已，但是如果能因此而认识一个新朋友的话，岂不是赚到？</p><p>至于害羞的话，最主要还是得克服自己的心理障碍，不要想太多，鼓起勇气说出自己心里的想法就好了。也不要在心里预演各种被拒绝之后的尴尬画面，别人做出什么样的反应不是你能控制的。而且要让自己尽量保持放松，不要担心此刻紧张或者脸红的自己有多么难堪，或者别人会怎么看自己，其实根本就没有太多人注意到你的样子。你也不用抱太高的期望，只要 go with the flow 就好了。另外，<strong>当负面想法出现的时候，要像闪电一样快速清理掉它。</strong>这样多练习几次之后，也许慢慢就会习惯了。</p><h4 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h4><p>掌握一个知识或者一项技能最快的方法是教给别人，因为在教的过程中，你是以一个初学者的心态来学习的，你能很快分辨出哪些部分才是最需要先掌握的，哪些只是细枝末节。你需要不断纠正自己的错误并发现新的知识点，在反复的尝试和扩展边界过程中，从刚开始的陌生状态慢慢走向熟悉。这就是「See one. Do one. Teach one」如此有效的原因。</p><p>对我来说，写博客就是一个把知识消化之后再教给他人的过程。虽然过去一直都有记笔记的习惯，但是我发现只有在写成博客之后，你才能对所写的知识点有更完整的理解，与复制文档或者琐碎的记录相比，用自己的话说一遍效果显然要更好。另外，在写成博客之后，因为害怕会误导他人，你也会花更多时间确保自己写的东西尽可能少出错，这个过程本身也是在学习，而且会加深你对知识的理解。最后，如果你写的博客对他人有帮助，你也会感到有成就感和满足感，这算是附加的价值吧。</p><p>今年我的计划是，尽量把自己的学习过程都写成博客，包括但不限于技术博客。数量和质量并不重要，关键在于记录。另外还有每日碎碎念，也是记录和写作的一种，我会继续坚持下去。</p><h4 id="跑步"><a href="#跑步" class="headerlink" title="跑步"></a>跑步</h4><p>跑步改变了我的生活。最早养成跑步的习惯是从大二开始的，偶然的一个晚上，被室友叫去附近的操场上跑步，去了之后有点惊讶，没想到大晚上居然有这么多人在跑步。和大多数平时不运动的人一样，第一圈跑完后我就喘得不行了。几圈下来出了一身汗，我本身就是特别会出汗的人，当时穿的还是普通的棉 T 裇，所以跑完后衣服都湿透贴在身上了。不过跑完后的感觉真的很棒，虽然很累，但像是换了一个新的身体，血液流动都变得更加畅通了一样。从那以后，我就养成了晚上出去跑步的习惯，操场、公园、马路，我学会了通过跑步探索周围陌生的世界。</p><p>跑步让我有一种掌控自己身体的感觉，虽然一开始会觉得很吃力、很累，但是几公里之后就会慢慢进入状态，你会觉得自己越来越有力量。等到快要结束的时候，你会感觉身体变轻盈了，有时候甚至会不想停下来。虽然跑的过程中还是会感到痛苦，但是跑完之后，舒畅和爽快是最主要的感受。</p><p>每次觉得情绪状态不佳的时候，跑步都能帮我释放掉一大半，而且通过运动释放的内啡肽和多巴胺也是最无害、最健康的。除此之外，跑步也会让人变得自律。通常在跑步的日子里，我会发现自己吃得更少也更健康了。控制饮食才是保持身材的关键。虽然跑步并不能减太多脂，但是它能帮你养成健康的饮食习惯。所以，对于跑步的人来说，保持身材苗条不走形是件轻轻松松的事。</p><p>可惜的是，自己常常忘记这些跑步带来的好处，所以有时候会选择宁愿赖在椅子里刷手机也不愿意出门跑上几公里。相比刚毕业那会儿，过去这一两年跑步频率越来越低。所以，最好的做法是让自己养成习惯，给自己指定每周跑步的<strong>天数</strong>和<strong>距离</strong>，每周固定<strong>频率</strong>固定<strong>时间</strong>出门跑步。</p><p>新的一年，希望自己每周至少跑 1 次，一年跑步总距离在 500 公里以上。这个目标完成起来应该不难，主要是不想给自己太多压力，这样就会有更大的动力去完成它。希望年底不会打自己脸。</p><h4 id="冥想"><a href="#冥想" class="headerlink" title="冥想"></a>冥想</h4><p>第一次认真对待冥想是在看了哈佛公开课《幸福课》之后，那时候觉得，原来冥想有这么多的好处啊，那就试试看吧，但是从来没有长时间坚持下来过。有时候只是在早上出门前还有点时间，才会坐在椅子里，尝试深呼吸，让自己的心静下来，但是大脑里还是会不受控制地胡思乱想，各种情绪起起伏伏。于是觉得自己太差劲了，完全无法控制自己的想法和情绪，只是在浪费时间，后来也就渐渐不太热衷冥想了。但过了很久之后才发现，其实这是每个刚开始尝试冥想的人都会遇到的问题，我们要做的是，学会不去批判自己，坚持下去就可以了。</p><p>直到最近，在看了不少<a href="https://book.douban.com/subject/3406401/">书</a>和<a href="https://www.youtube.com/watch?v=zC7a_gQB9YQ">视频</a>之后，渐渐重新认识到冥想的重要性。从 12 月末到现在，尝试了差不多三个礼拜的正念冥想，每天下班后第一件事就是定好闹钟坐到椅子里开始冥想 30 分钟。虽然才几周的时间，但是我已经明显能感觉到自己身上的变化。比如，焦虑感减轻了，注意力变集中了，更能注意到当下周围发生的事情了，也更能控制自己的情绪了。才冥想三周就给自己带来了这么多的改变，如果长期坚持下去的话，会给我的生活品质带来了多大的改善呢？真的非常期待。[^1]</p><p>另外，冥想其实并不太限制时间和地点，只要你愿意，在保证安全的前提下，随时随地都可以进行冥想：在通勤途中，在工作间隙，在散步的时候。经过练习之后，即使是在嘈杂的环境下，你依旧可以进入冥想状态。你只需要调整自己的注意力，并且把注意力放在充分感受自己身体和心理状态上就可以了。另外，<strong>不要试图控制大脑中的想法</strong>，要把自己当成一个观察者，情绪的起落，想法的出现和消亡，都是正常现象，只要把注意力放在一件事情上就好了，比如你的呼吸，或者某句格言，又或者身体某个部位的感觉。</p><p>今年我会继续保持这种冥想的练习，坚持每天冥想 30 分钟以上，早上出门前冥想 10 分钟，下班之后冥想 20 分钟，节假日也尽量保持这样的节奏。</p><h4 id="早起"><a href="#早起" class="headerlink" title="早起"></a>早起</h4><p>早起和跑步一样，都是能给自己的生活带来巨大变化的习惯，因为我们可以在此基础上，养成更多的好习惯，比如早起之后去运动、阅读、冥想，吃健康的早餐，有更多的时间写晨间日记等等。虽然知道早起有这么多的好处，但是从来没能坚持下来。不过相比以前，我对自己现在的起床习惯还算满意，基本 7 点的闹钟响第二遍之后，也就是在 5-10 分钟之内就能起来，不过周末还是要比平时晚 1 个小时左右。</p><p>今年我想挑战一下自己，希望到年末的时候能够养成 6 点前起床的习惯。如果成功的话，我每天在上班之前就起码还有两个小时的时间可以利用，每周就是 10 个小时，想想还是挺振奋人心的。不过打算一步步来，先从晚上早睡开始，平时强迫自己尽量 10 点半前就上床睡觉，然后把早上的闹钟慢慢调早，周末直接定 6 点的闹钟，哪怕前一晚熬夜了也一样，因为可以在白天补觉，关键是要让自己形成早起的习惯。一点点坚持，直到养成习惯并且尝到早起的甜头之后，相信未来就不会太依赖闹钟了。</p><h4 id="数字极简主义"><a href="#数字极简主义" class="headerlink" title="数字极简主义"></a>数字极简主义</h4><p>在注意力经济时代，大公司们都在想方设法夺取普通用户的眼球，为了保护自己不成为大公司业务考核下的牺牲品，最佳的抵抗方式就是减少手机的使用。去年其实也给自己定了目标，希望把每天的手机屏幕使用时间控制在两小时之内，结果当然是没能达到目标，尤其是疫情居家隔离的那段时间，每天的屏幕使用时间随随便便就超过了 6 小时。现在的话，虽然有意控制，但也基本还是维持在 3~3.5 小时之间。如果观察下自己在手机上消耗的时间，绝大部分都是为了打发无聊时间，但无聊的时候刷手机，往往会在不知不觉中越刷越久。最糟糕的是，你会逐渐养成习惯，一旦进入无聊或者无所事事状态的时候就会习惯性地拿起手机。</p><p>在我的屏幕使用时间统计中，绝大部分都花在了社交网络、视频、游戏上，主要是推特、YouTube、豆瓣、各种论坛、博客、公众号、灌水群等等。如果不看这些资讯，对我每天的生活来说基本没有影响，而且很多内容其实都是重复的，随着阅读时间的增加，对我有用的信息比例是递减的。每天的工作已经占据了我的绝大部分时间和精力，我的大脑已经没有多余的带宽去处理这些额外的信息了，因此，大部分时候这些信息对我来说只是增加了干扰和负担，占据了我本来可以用于高质量学习和休息的时间，也就是被浪费掉了。</p><p>所以，今年想要把数字极简当成一个重要的目标来完成。具体实施方案是，减少电子设备的使用（除了 Kindle），把电子设备上的软件和应用最小化，卸载掉消耗我大量时间但是对我生活没有任何帮助的应用（主要是游戏和社交类应用），除此之外：</p><ul><li>  控制每天手机屏幕使用时长限制在 90 分钟之内（仅限笔记、搜索、学习等），多使用 Zen Mode</li><li>  控制平时只用 iPad 看演讲和听课，只有周末才可以用于娱乐，且控制时间在 60 分钟之内</li><li>  只在电脑端看视频，防止自己看太长时间</li><li>  减少听音乐的时间，多冥想和静思，多反省和写作</li></ul><h4 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h4><p>很反感那种强迫自己一年要读多少本书的做法，因为我觉得<del>为了阅读而阅读是很没意义的</del>。但是从我过去一年的经历来看，尽可能多的阅读对人的影响非常大。我发现只有大量的阅读才能在短时间内对一个人的见识、认知和思维带来巨大的改变。所以，多读书，哪怕是为了阅读而阅读也是有意义的。</p><p>过去几年里买了很多的书，但是看完的可能还不到一半，尤其是技术类书籍。很多书只是听了别人的推荐才去看，但是看了之后觉得对自己的帮助不大或者不适合当下的我，所以往往只看了一点点就搁置了。接下来我觉得自己应该少看他人的推荐，而是去阅读那些自己真正感兴趣的书，尤其是要先把书架上还没拆封的值得看的书先看完。在决定阅读一本书之前一定要做足功课，问问自己，这本书是否真的值得我花时间去阅读？读完这本书之后我能从中获得什么？它能解决我的什么问题？另外，阅读也要做到足够专一，养成看完一本书之后再继续看下一本的习惯。</p><p>今年的目标是：</p><ul><li>  每两周看完一本非虚构类书籍</li><li>  至少看完 5 本技术类书籍</li><li>  每个月写至少 1 篇书评，长短不限</li></ul><h4 id="数字花园"><a href="#数字花园" class="headerlink" title="数字花园"></a>数字花园</h4><p>某天在逛 Github 的时候，通过 <a href="https://github.com/nikitavoloboev/my-mac-os">my-mac-os</a> 这个项目发现了 <a href="https://wiki.nikitavoloboev.xyz/">Eveything I know</a> 这个网站，这是我第一次接触到<a href="https://joelhooks.com/digital-garden">数字花园</a>的概念。读了作者 Nikita 的一些笔记和推荐的文章，觉得数字花园这个想法太棒了，立马决定我也要做一个类似的项目。</p><p>其实我很早就有把保存在各种应用里的摘抄、笔记等归类集中在一起管理的想法，但是一直没有找到合适的方式，现在觉得数字花园真的是一个非常适合的形式，而且这也是一种分享以及让别人了解自己的方式。目前我刚把目录部分列好了，还有很多细节需要完善，打算先把博客迁移进去，其它部分再慢慢组织和填充。以后我会把<a href="https://ajiew42.gitbook.io/dg/">这个项目</a>当成我的第二大脑，用于储存我所有的笔记和想法，未来它还有可能会成为我的灵感来源。如果长期坚持下去，我相信自己一定能从中收获更多的意外之喜。</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>除了以上这些之外，还有一些小心愿想要在 2021 年达成：</p><ul><li>提升词汇量至 10000。词源主要是柯林斯高频词，工具 WordUp 和 Anki， 每天花 30-60 分钟碎片时间记单词，每三个月用 testyourvocab.com 测一次单词量。</li><li>继续提升 Vim 熟练度。做到不需要对照 <a href="https://ajiew.github.io/vim-cheatsheet/">CheatSheat</a> 也能顺畅编辑文本的地步。</li><li>继续学习 Bash，同时熟悉 Linux 命令。做到能写一些简单的脚本，比如批量处理文本。</li><li>学习 AppleScript。能写一些常见的、简单的脚本。<ul><li><a href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/introduction/ASLR_intro.html">官方文档</a></li><li><a href="https://macosxautomation.com/applescript/firsttutorial/index.html">教程</a></li><li><a href="https://github.com/unforswearing/applescript">例子</a></li></ul></li><li>提升算法水平，争取每日一道 Leetcode，至少刷 200 道题，做到可以大部分中级题目都可以不看思路也能做出来。</li><li>学会单板滑雪。能够流畅转弯、刹车和刻滑。</li><li>滑板学会 Pop Shove it。</li><li>尝试一次室内攀岩（可选）。</li><li>尝试给家人做一次饭（可选）。</li></ul><hr><p>拖了这么久，总算把这篇年终总结和新年计划写完了，此刻长出一口气~</p><p>回过头一遍遍阅读修改自己的文字，突然忍不住想，其实这一切并没有什么意义不是吗？我写下的这些文字真的能真实反映出自己过去这一年的经历吗？我写下的计划又在多大程度上会影响到自己接下来这一年要做的事呢？既然如此，写下它们的意义是什么呢？</p><p>我觉得最大的目的还是为了写给未来的自己，希望他能通过这只言片语回忆起当时自己的状态，然后能有一个好心情。总结和计划并不影响过去发生的事，对未来即将发生的事能产生的影响也非常有限，但是它是一种对过去的自我梳理和对未来的警示，能让自己根据已有的现实提前对未来做好准备，以防理想和现实出现过大的偏差。</p><p>意识到这一点之后突然明白了，此刻的自己才是最重要的啊，未来的我的状态取决于此刻的我是如何行动的，也就是说未来某刻正在读这段文字的他的命运，完全掌握在我的手中。</p><p>突然对写作也有了新的认识，写作其实是在穿越时空和另一个自己沟通，尽管这种沟通是单向的，但是在写作的当下，这种沟通可以是双向的，我可以揣测另一个时空下的自己的想法，写下来，然后再不停地修改，修改的过程就是「沟通」的过程。当未来的我再次读起这段文字的时候，想法也许发生了变化，但是却可以注意到这种变化是如何发生的。</p><p>这大概就是写作的意义吧，与他人沟通，与自己沟通。</p><hr><p>注：</p><p>[^1]:有的人可能会怀疑冥想是否真的有用，的确，对于冥想的学术研究现在还处于比较早期的阶段，但是冥想对大脑的影响和在改善人的身心方面的作用是可以被观察到的，推荐阅读：<a href="https://news.harvard.edu/gazette/story/2018/04/harvard-researchers-study-how-mindfulness-may-change-the-brain-in-depressed-patients/">When science meets mindfulness</a></p><p>　</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
            <tag> Reviews </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录自己的想法</title>
      <link href="/2020-12/"/>
      <url>/2020-12/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/b2EKF35mevg" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>转眼到年底了，发现自己写碎碎念居然也有半年多了，能够坚持这么久也是让我挺惊讶的。回过头去翻了下，尽管有些内容明显看得出来只是为了完成任务而写的，但是那些认真写的内容还是挺有价值的，有些内容甚至让我怀疑这是我写的吗，而有些又让我觉得很感动，可能是被自己的真诚打动了吧。</p><p>我们通过文字和语言表达出来的内容只是大脑中想法的一个子集，而那些想法则是由我们过去所接触到的信息，经过我们的理解消化结合个人经验进行处理之后，才最终诞生的。写作就是一个重新挖掘出自己脑海中想法的过程。通过像这样每天不间断地记录，我能看到自己慢慢变得越来越坦诚，也越来越能注意到自己的想法。每天能无时无刻陪伴着我们的，只有我们大脑中的想法。我们的想法和我们的体验构成了我们整个的人生。为了让我们的生活过得更有意思，不停地思考，记录下自己的想法，并且借此塑造自己的大脑，改变和丰富自己的思维模式，然后更理性地去行动和做决策。这应该是我们这辈子能做的最有意义的事情。</p></blockquote><h4 id="12-月-1-日-先做一分钟再说"><a href="#12-月-1-日-先做一分钟再说" class="headerlink" title="12 月 1 日 - 先做一分钟再说"></a>12 月 1 日 - 先做一分钟再说</h4><p>如何保持对他人的兴趣？我觉得最重要的一点是要意识到你和他人其实并没有什么本质上的不同，每个人都有他们自己独一无二的成长经历，只要你保持好奇，懂得如何倾听，就一定可以从他人嘴里听到一些有意思的故事。即使是像我这样不爱说话的人，要是遇到一个会聊天且愿意倾听的人，一样也可以滔滔不绝地说上很久。我觉得想要获得这种能力其实也不难，只要你克服自己的恐惧，培养耐心，多花时间练习就好了。</p><p>不过，这样说起来，有哪件事不是这样的呢？大多数人都习惯了让生活保持现状，仅仅是想到要去做会让自己感到不舒服的事，就会觉得还是算了吧，更不要说长期坚持下去了。<strong>恐惧和懒惰是一个人最大的敌人。</strong>每当自己想要退缩的时候，问问自己：如果我现在做了，最差的结果会是什么？这个结果对我来说真的有那么可怕吗？至于和懒惰的斗争，可能要持续一辈子吧。每次想要偷懒或者拖延的时候，告诉自己：<strong>先做一分钟再说</strong>。</p><span id="more"></span><h4 id="12-月-2-日-远离诱惑，养成好习惯"><a href="#12-月-2-日-远离诱惑，养成好习惯" class="headerlink" title="12 月 2 日 - 远离诱惑，养成好习惯"></a>12 月 2 日 - 远离诱惑，养成好习惯</h4><p>昨晚玩了一晚上昆特牌，发现和炉石差不多，只不过玩法稍微有些差别而已，不过还是玩得上了瘾。当意识到自己已经坐着一动不动地玩到十点多的时候，突然反应过来，有点无奈又有点愤怒，觉得自己太不争气了，于是把游戏卸载掉了。</p><p>我从来都不是自制力很强的人，所以最好的做法还是让自己远离诱惑。其次是养成好习惯，既然我能坚持跑步和玩滑板，虽然都没有做到一流，但是至少坚持下来了，那么其他事情也一样可以用类似的方法让自己坚持下来，比如学习算法和数据结构。只要意识到自己需要改变，并且在不断地努力尝试，那么无论结果如何都不重要了。</p><h4 id="12-月-3-日-集中注意力与掌控自己的时间"><a href="#12-月-3-日-集中注意力与掌控自己的时间" class="headerlink" title="12 月 3 日 - 集中注意力与掌控自己的时间"></a>12 月 3 日 - 集中注意力与掌控自己的时间</h4><p>昨晚下班回来后，照旧先刷了一会儿视频，看了 So Good They Can’t Ignore You 的作者的 <a href="https://www.youtube.com/watch?v=qwOdU02SE0w&t=7s">Google Talk</a>，复习了一遍书中的观点：不要去追寻自己的热情，而是要先积累自己的职场资本，即掌握稀缺而有价值的技能。</p><p>看完之后很受鼓舞，于是拿出算法书开始准备看，看了大概一两页之后忍不住拿起手机刷下推，看到有条推提到了牛轧糖，很久没吃甜食了，很想尝尝，于是打开了淘宝，逛了半个多小时加好了购物车，但是发现之前买的热水袋居然还没发货，于是愤然点了退货，又重新搜了一个差不多的下单了，这时候才心满意足地放下手机。看了没两页书，觉得有点看不进去，开始发呆，然后又开始怀疑自己了。在焦虑之中打开了 Youtube，看了一个 Ted Edu 视频，讲甜食对人的大脑的影响，一狠心打开淘宝把刚刚加的一堆甜食又全都删除了。接着打开各种社交 App 刷了一下首页，觉得有些无聊，接着打开了今天刚下载的 Tinder，看到自己居然有 6 个 like 并且匹配到一个小姐姐，心里一阵窃喜，看了下小姐姐的照片，挺好看的，坐标香港，不过不知道该聊什么，就退出来了。打开某网购 app 的时候看到我有新人活动还没用，而且正好有我想买的坚果之类的零食，想着那就下个单薅点羊毛吧。研究了下规则，新人满返两张红包，也就是要下单至少两次，于是把淘宝上的热水袋给取消了，重新在 app 里下单了差不多的，接着又找东西凑单，比来比去，发现还是零食最好凑。总算凑完单下单了，觉得还可以再多买点零食，于是又花了半个多小时挑零食。等到一切就绪的时候，已经快 10 点了，差不多该洗洗睡了。</p><p>这应该是任何一个拖延症患者的都会觉得熟悉的场景，把它记录下来是为了提醒自己，如果你不去有意识地改变自己的习惯，学会集中自己的注意力，那么你就永远无法获得掌控自己时间的自由。</p><h4 id="12-月-4-日-情绪低谷时的能量来源"><a href="#12-月-4-日-情绪低谷时的能量来源" class="headerlink" title="12 月 4 日 - 情绪低谷时的能量来源"></a>12 月 4 日 - 情绪低谷时的能量来源</h4><p>这一周多差不多是我下半年以来最为焦虑的一段时间，已经到了做什么事都提不起兴趣的程度。尽管表面上还是维持出一切都很好的样子，但是只有我知道自己内心已经在呐喊了。一度怀疑自己是不是有抑郁发作的倾向，还上网查了资料，一点一点对照自己的情况，就差真的去求助心理辅导了。有几个方面的原因吧，一是几次面试的表现都不太好，有点受打击以及自信心受挫；另一方面，玩滑板摔成右手骨折，给生活带来很多不方便的地方，而且还不能去运动，有压力但却无处释放，身边又没有人可以倾诉，苦闷的情绪难免会在心中郁积。好在自己过去积攒了一些能量，知道会有这样的时刻，所以把过去收藏的文章、写的日记翻出来看看，也能稍微缓解一些。</p><p>晚上看了几个视频，Jeff Huber 16 年在 Illinois 作的<a href="https://www.youtube.com/watch?v=pVAnC_-zF_E">毕业演讲</a>，Robert Sapolsky 的<a href="https://www.youtube.com/watch?v=Y0Oa4Lp5fLE&t=11s">行为进化课</a>以及关于<a href="https://www.youtube.com/watch?v=NOAgplgTxfc&t=1846s">抑郁症</a>的讲座。虽然是完全不搭边的内容，但是却觉得自己从中汲取了足够的能量，让我能从最近的情绪低谷中恢复过来。最大的一点感悟是，我要向他们看齐，虽然可能永远也达不到他们那样的成就，但是这至少是个值得奋斗的目标。正是因为有他们这样的人存在，我们周围的世界才充满<strong>活力</strong>和<strong>希望</strong>，想到自己也能通过努力慢慢成为和他们一样的人，就觉得兴奋。创造价值，惠及身边所有人（不仅仅是你爱的人），向世界传播善良与智慧，让这个世界因为我的存在而变得美好一些。如果给自己定了这样的目标，那还有什么好沮丧的？抓紧时间去学习，去充实自己的大脑，去阅读、去写作、去与人交谈，哪还有时间浪费在自怨自艾上？年轻人，振作起来吧。</p><h4 id="12-月-5-日-改变与行动第一"><a href="#12-月-5-日-改变与行动第一" class="headerlink" title="12 月 5 日 - 改变与行动第一"></a>12 月 5 日 - 改变与行动第一</h4><p>我觉得对于一个通过自学成长起来的程序员来说，最大的问题是没有一起成长的同伴。这带来了两个问题，一个是没有合适的参照坐标，从而无法进行准确地自我评估；二是不能通过交流，分享行业内的资源以及对彼此有用的信息。对于初学者来说，可能还存在没有相互鼓励、彼此支持的环境，容易中途放弃等问题，但是工作几年之后这些问题的影响就没那么明显了。自己目前似乎就处在这样一个困境之中，但是问题也主要是自己造成的，大学毕业之后工作以来太过被动，没有主动去拓展自己的人脉交际圈，把自己弄得越来越孤立。而且自己本身自我驱动的能力不足，没能持续学习提高自己，再加上选择公司的眼光也不怎么好，因此各方面能力的进步速度也特别慢，最终导致了自己现在能做出的选择比较有限。</p><p>不过，能意识到问题就是好的开始，接下来就是想办法改变自己。想清楚自己想要什么样的生活，以及什么样的工作节奏适合自己，开始认真思考职业规划的事，同时不断学习提高自己的能力，积极主动拓展自己的人脉圈，无论是线上还是线下，主动发出自己的声音，学会表达自己的想法。最重要的一点，一定要不停地行动，光想光说其实没有任何用处，只有积极地去尝试才能发现各种可能以及新机会。</p><h4 id="12-月-6-日-有意识地生活，积极行动，同时不要停止思考"><a href="#12-月-6-日-有意识地生活，积极行动，同时不要停止思考" class="headerlink" title="12 月 6 日 - 有意识地生活，积极行动，同时不要停止思考"></a>12 月 6 日 - 有意识地生活，积极行动，同时不要停止思考</h4><p>自己到底适合做什么？这个问题光靠想是想不出答案的，只能靠实践。这个世界上有那么多和你一样迷茫有不知所措的人，每个人都在努力寻找自己最终的「归宿」，要坚信我们最终一定都会找到。当然，这条路可能有点崎岖，但是你不能放弃希望。有很多人在旅途中迷失了方向，渐渐放弃了心中的理想，然后成为了浑浑噩噩度日的人群中的一员。<strong>你不能这样。</strong></p><p><strong>追求良质，为他人创造价值，让他人感到幸福以及感受到生活的美好。</strong>这要求你自己先要过得幸福快乐。那么，我感到幸福快乐吗？生活中零星某些时刻会，但是大多数时候都是在无意识中度过的，有些时候会因为工作、生活中的不顺心感到沮丧失望，偶尔还会感到孤独、失去希望。这些问题能完全解决吗？不能，只要我还活着，就会一直体验到这些情绪和感受。那么，我能做什么呢？学会平和地接受，虽然无法避免但是我可以选择<strong>以何种方式对待它们，</strong>还有就是要<strong>养成好习惯</strong>。</p><p>首先学会<strong>有意识地</strong>度过自己生命中地每一个点滴时刻，而不是让时间在无声中溜走。当然可以有悠闲时刻，但是必须是在你个人意识之中的、主动选择的结果。至于其它的东西可以慢慢学习，专注、自律、思考、反省、大局观等等，这些东西会慢慢融汇到你的生活中的各个角落，直到生命的终结。</p><h4 id="12-月-7-日-谈勇气和关注自己内心的想法"><a href="#12-月-7-日-谈勇气和关注自己内心的想法" class="headerlink" title="12 月 7 日 - 谈勇气和关注自己内心的想法"></a>12 月 7 日 - 谈勇气和关注自己内心的想法</h4><p>勇气意味着什么？意味着放下对未知的恐惧，战胜内心深处对自己的不信任，以及关注自己最真实的愿望而不去在乎他人的看法。昨晚说到要有意识地度过每一天，这样我们就可以时刻观察自己大脑中的想法，去思考自己为什么会这样思考，自己为什么要做眼前正在做的这件事，它对于我来说有什么意义，对于别人又有什么意义。</p><p>通过这样有意识的思考我们经历的每一件事，我们能更积极地去决定出到底什么对我们来说才是最重要的，我们对自己所做的事会有更深层次的认识，而不是像个低等生命一样只是在对外界的刺激做出反应而已。要做一个主动型的人，你是你自己生命的主人，你也只能是你，才有责任和义务来决定如何度过你的每一天。不要偷懒把这件事交给别人，让别人来替你思考和做决定，即使现在的你只需要接受他人的安排就可以过得很好，但是迟早有一天你会不得不独立地承担起这个责任，所以你应该尽快让自己习惯这种生活。</p><p>冥想是一个非常重要的方法，让你更容易倾听到自己大脑中的想法，关注自己最真实的需求，发现自己真正渴望去做的事。顺应自己的内心，你才能活的更加自然且舒适。我们每个人都可以通过冥想发现自己生命最本真的样貌，而不是任由外界塑造出来的让我们自以为「理想」的生活方式。永远记得要先关注自己内心的想法，假如世界上只剩你一个人，你还会想要去做这件事或者需要某件东西吗？如果不是，你真正想要的又是什么呢？如果你不需要获得他人的关注也能过得很好，那么你会选择从事什么呢？如果你只能一个人生活，你的生活会是什么样子的呢？</p><h4 id="12-月-8-日-学会独立思考"><a href="#12-月-8-日-学会独立思考" class="headerlink" title="12 月 8 日 - 学会独立思考"></a>12 月 8 日 - 学会独立思考</h4><p>马上要年底了，即将迎来自己毕业的第四个年头，一想到都觉得有点不可思议，闭上眼仿佛昨天才刚刚参加完毕业典礼，时间真的过得太快了。今年虽然因为疫情影响，浪费了很多时间，但是我觉得今年也是我收获最大的一年。为什么？因为今年的自己遇到了太多的问题，逼着我不得不开始向内自我反省，不得不去通过思考和阅读寻找答案。虽然最终并没有得出什么结论，但是至少这是个开端，代表着自己真正开始为自己思考。这已经是一个了不起的改变了。只要能将这个习惯延续下去，那么无论未来遇到什么样的麻烦或者困难，我也可以通过自省和思考来解决它。</p><p>面临困境觉得无路可走，通常都是因为我们没有获得足够的知识和信息，或者不具备解决问题的能力，只要不断提高自己、增长智慧，那么即使遇到暂时无法解决的问题，我们也能以更积极的心态去面对它，至少能做到与问题和平相处。</p><h4 id="12-月-9-日-延迟满足感与「知易行难」"><a href="#12-月-9-日-延迟满足感与「知易行难」" class="headerlink" title="12 月 9 日 - 延迟满足感与「知易行难」"></a>12 月 9 日 - 延迟满足感与「知易行难」</h4><p>我们每天面对各种各样的娱乐方式，想要不被诱惑是很难的。这也是为什么我们要多问问自己，自己想要的到底是什么，是像现在这样每天下班后把自己的时间随意挥霍掉，还是朝自己的目标每天进步一点点？我是真的想要看这个视频，还是只是为了逃避学习的痛苦？我是为了传播有价值的观点、激发他人思考，还是只是因为孤独才打开各种社交网站？学会认清现实，你现在做的一切都将在未来埋下种子，此刻的逃避、退缩、不作为都会在未来的某一时刻被放大若干倍。「延迟满足感」虽然只有简单几个字，但背后必须要有一整个系统才能让自己建立起以此为信条的行为模式。</p><p>P.S. 早上写下这段话，然而晚上下班后依旧坐在椅子里刷了一晚上视频，一开始从各种看似信息量很大、很有教育（学习）意义的演讲，到后来开始看猎奇类纪录片、旅游Vlog，再到纯粹为了博君一笑、毫无营养的脱口秀喜剧，完美说明了「我就蹭蹭不进去」有多么地滑稽和虚伪。但是心里再怎么后悔浪费了时间也没什么用，可能要等到自己经历过真正的打击之后，才能彻底「醒悟」并开始改变吧。</p><h4 id="12-月-10-日-承认自己的私心，积极行善"><a href="#12-月-10-日-承认自己的私心，积极行善" class="headerlink" title="12 月 10 日 - 承认自己的私心，积极行善"></a>12 月 10 日 - 承认自己的私心，积极行善</h4><p>每个人都只在乎他自己。虽然所有生物都有利他的倾向，但也是因为利他就是在利己。所以我们要早点意识到，没有人是出于完全的善心才去做好事的。这样思考可以减轻我们的内疚感，使我们做好事时没有心理负担。承认自己有私心，承认自己不是完全为了他人，没什么不好意思的，这就是人性。所以，尽管去做善事吧。</p><h4 id="12-月-11-日-如何冥想"><a href="#12-月-11-日-如何冥想" class="headerlink" title="12 月 11 日 - 如何冥想"></a>12 月 11 日 - 如何冥想</h4><p>冥想有很多好处，比如能提高人集中注意力、控制情绪的能力，提升对幸福的感知力等等。那么，如何开始冥想呢？首先要放轻松，告诉自己冥想的一大目的是让自己的大脑放松下来，聚焦在当下，而不是什么都不去想。我们的大脑就像一台永远保持高速运转的计算机，想要让它完全停下来是很难的，但是我们可以通过刻意练习，让它一次只运行一个任务，就像把计算机的后台任务清除掉一样，能腾出空间专注去做更重要的事。</p><p>其次，无论是正念冥想（Mindfulness Meditation）还是超验冥想（Transcendental Meditation），都是从调整你的呼吸开始的。找一个舒服的坐姿，闭上眼睛，放慢自己的呼吸，感受自己每一次呼吸时身体的状态，比如胸腔的起伏、腹部的伸缩等等，同时注意保持住呼吸节奏。接下来尽量让自己的注意力集中在当下，可以从认真体会身体各个器官的感觉开始，比如我的眼睛、脖子、肩膀、背、腰、臀部、手臂、双腿现在是什么感觉，是否有肌肉没有完全放松等等。还可以充分感受自己的各个感观的状态，比如仔细听你现在听到的一切声音（你的呼吸声、窗外的鸟叫声、远处的汽车声等等），闻一闻房间里的味道，还有你嘴里的味道，或者想象自己现在所处的位置、房间里的各个物品的布置等等。再然后观察自己情绪的起伏，感到焦虑的时候就告诉自己我现在很焦虑，感到无聊的时候就告诉自己我现在很无聊。但是无论什么情绪出现，你都告诉自己「我现在是一个观察者，我观察到情绪的出现，但是我尽量不对它做出反应」。也许你依旧会分心，或者在某种情绪或想法中越陷越深，但是只要在意识到自己分心了的时候，马上回到之前的状态，调整好呼吸，继续观察自己的心理状态就好了。一直到闹钟响起的时候，一次冥想就结束了。初学者冥想时间设置 10 到 15分钟比较合适，时间紧的话 5 分钟也可以，但是必须要按上面说的方法认真投入地练习，否则就达不到效果。</p><h4 id="12-月-12-日-谈迷茫与如何获得幸福"><a href="#12-月-12-日-谈迷茫与如何获得幸福" class="headerlink" title="12 月 12 日 - 谈迷茫与如何获得幸福"></a>12 月 12 日 - 谈迷茫与如何获得幸福</h4><p>下午坐在江滨公园的一颗银杏树下，冥想了十分钟左右，阳光把我一侧的脸颊晒得有点烫，而另一侧脸颊则被冬日的微风吹得有点凉飕飕的。睁开眼，周围的一切都泛着一丝丝蓝光，看着江面的粼粼波光，又陷入了迷茫：我应该怎样度过自己的人生？我想要过的是什么样的生活？</p><p>视线转向在附近绿化带里工作的工人们，还有远处工地里出入繁忙的车流，突然觉得自己的问题好像有点太奢侈了。很多人努力的目的无非是为了改善自己的生活现状，而我却想要追求不一样的东西。不过，仔细想想其实也没有不一样，我们勤奋工作的无非都是为了生活得更加幸福。我只不过还没找到如何让自己感到幸福：是通过工作或者组建幸福的家庭体现自己的价值？还是通过获得更多的物质激励？如果有可以学习的模板，我应该去哪里寻找这样的模板？</p><p>也许没有人能给我答案吧。但是我毕竟才二十多岁，如果这么早就能参透人生真谛，那么往后的日子也太无聊了。谁不是一边寻找一边摸索着走过来的？所以还是有点耐心吧，把自己眼下的事做好，该完成的任务一个个完成，建立健康的生活习惯，拥有一个好身体，把家人照顾好，这就是了不起的成就了。承担责任，推迟满足感，尊重事实，保持平衡，做到这四条，人生过得幸福的概率不会太低。</p><h4 id="12-月-13-日-Show-yourself-to-the-world"><a href="#12-月-13-日-Show-yourself-to-the-world" class="headerlink" title="12 月 13 日 - Show yourself to the world"></a>12 月 13 日 - Show yourself to the world</h4><p>差不多一个月没出去夜跑，今晚换上衣服穿上鞋子出去跑了一圈，结果跑到一半开始下起了小雨，再加上挂着大风，气温差不多只有 4、5 度。有一瞬间想往回跑算了，不过最终还是坚持跑完了 8 公里。跑步这件事对自己最大的锻炼是：无论何种环境下都能坚持下去的耐力以及能够坦然接受坏运气的心态。</p><p>晚上看了几个视频，发现一个有趣的 <a href="https://www.youtube.com/channel/UCsdLbTwziL6Tg97swkuThSg">up 主</a>，曾经的程序员后来大病一场之后辞职开启新生活，去印度探险、去做各种好玩的事，看得我心情很欢乐。他算是替那些不敢去做自己喜欢做的事情的人实现梦想了吧，能有这样的勇气并且最终还能获得成功本身就很让人羡慕了。他不但选择了自己喜欢的生活方式，而且还能娱乐他人、启发他人，我觉得这也是挺有意义的。而我自己呢？好像到目前为止还没找到能让自己不顾一切放手去做的事。本质上来说，我还是比较追求稳健（其实是比较胆小、怂）的人吧。不过也没关系，我们每个人都应该选择适合自己的路，拿自己和别人比较完全没意义。既然现在还不知道自己想要什么，那就按部就班地把自己能做的先做到最好吧。另外也要学会展示自己，把自己成长的过程记录下来，也许对其他人也有启发呢？</p><h4 id="12-月-14-日-相信未来会更好"><a href="#12-月-14-日-相信未来会更好" class="headerlink" title="12 月 14 日 - 相信未来会更好"></a>12 月 14 日 - 相信未来会更好</h4><p>这是今年倒数第二个礼拜了，差不多应该开始写年终总结了。因为疫情，这一年真的过得特别快，而且几乎所有事情都和疫情沾边。但是对我来说，今年最大的主题应该还是『改变』吧。从一开始想要改变自己的工作、生活环境，到后来跳槽失败，不得不开始向内探索，开始思考自己到底想要什么，重新开始阅读、写作、跑步、练习滑板、冥想、学会表达自我，这一路下来，对自己有了更多的认识，虽然依旧看不清路在何方，但是至少没有之前那么焦虑了。这也是我毕业以来经历的第二个比较大的危机吧，而且我也隐隐觉得能否安全度过这次危机决定了自己未来几年的发展。所以，还是多给自己一点时间吧，思考清楚之后再做决定（职业发展方向等等）。</p><p>另外，人生路那么长，走错一两步其实也没什么大问题。我相信勤奋善良同时又没有什么品德缺陷的人，一般是不会掉进太大的坑里去的，哪怕真的掉进去了，也可以通过掉坑经历磨练出更坚毅、更顽强的品格。至于其它的，诸如前进路上出现的孤独、迷茫、没有方向、偶尔的颓丧和懒散，要相信这些都只是暂时的，终究会过去。一个人只要能坚持进步，不断开拓自己的边界，同时扛起自己应该承担的责任，那么一切都会朝着越来越好的方向发展。</p><h4 id="12-月-15-日-谈心灵相通"><a href="#12-月-15-日-谈心灵相通" class="headerlink" title="12 月 15 日 - 谈心灵相通"></a>12 月 15 日 - 谈心灵相通</h4><p>今天看到一条<a href="https://mobile.twitter.com/ElodesNL/status/1338472590759878660">推</a>，让我感同身受，从小到大我也从来没有和任何人（同性或异性）真正感觉到有种彼此心灵相通的感觉，同性之间更是少见，初中和喜欢的女生暧昧的时候，似乎有那么几个瞬间觉得彼此是能互相理解的，比如周末一起在我家写作业，她递给我一张她画的简笔画的纸条的时候；在走廊上偶遇但是有老师在，于是通过交换眼神确认看到彼此的时候，等等。</p><p>明明我们都渴望与他人建立更深层的情感连结，但是最终我们似乎都被排挤出彼此的内心世界。也许很多人都有类似的感觉吧，男性之间更容易将情感联系等同于彼此一起做的一些活动，比如共同的兴趣爱好、电子游戏、政治话题等等，再深入一点可能就是情感话题或者谈论彼此的家庭。但是，让我们感到彼此心灵相通的并不在于谈论什么话题，而是在长久累积起的、充足的信任中，以及觉得对方能够也愿意理解自己的前提下，我们才会去敞开心扉地与对方分享自己的一切，真正关心对方，也知道对方正在对自己表达出兴趣和爱意，此刻的我们才是真正地与彼此建立起连结的。</p><p>但是，很多时候我们都被挡在了「彼此完全信任」这座大山之下。即使和对方有了多年的相处，而且对彼此的了解也看似不少，但是我们还是会自然而然地有所保留。因为我们害怕得不到期待的回应，害怕暴露自己内心最柔软的弱点之后换来的是一片空白，所以觉得还是把一切觉得难以启齿的话都留在自己心底吧。久而久之，我们越来越不想去表达真实的自己，对于能激起情感涟漪的话题一概避而不谈，直至对所有感性的词句都渐渐变得麻木，最终连我们自己也失去了共情的能力，于是彼此间的交流仅限于那些不痛不痒的话题。希望自己可以打破这层枷锁。</p><h4 id="12-月-16-日-每周给自己设立一个挑战"><a href="#12-月-16-日-每周给自己设立一个挑战" class="headerlink" title="12 月 16 日 - 每周给自己设立一个挑战"></a>12 月 16 日 - 每周给自己设立一个挑战</h4><p>今晚去跑了一次步，室外温度显示只有 1 度，但是只有一开始才觉得冷，跑到 3 公里之后就不再觉得冷了，跑完 8 公里之后甚至发现配速比平时还快一点。所以又达成了一项新的成就：在接近 0 度的室外跑一次步✔︎。我觉得给自己设立这样子的挑战还是挺有意义的，不需要付出太多努力就能收获一种全新的体验。突发奇想，如果每个礼拜都给自己设定一个新挑战会怎样？好像挺有趣的，而且还能给自己平凡的生活添加一点色彩。那么，这周的挑战是：一周之内每天只进食一餐。其实是临时想到的，因为我已经 3 天这样做了，不吃早餐和晚餐只吃午餐。希望接下来的几天能继续坚持。</p><h4 id="12-月-17-日-谈间歇性断食的感受与心得"><a href="#12-月-17-日-谈间歇性断食的感受与心得" class="headerlink" title="12 月 17 日 - 谈间歇性断食的感受与心得"></a>12 月 17 日 - 谈间歇性断食的感受与心得</h4><p>尝试间歇性断食有一年了，虽然疫情期间中断过，但是重新开始到现在差不多也有半年多了，是时候谈谈我的感受和心得了。首先，间歇性断食最大的好处是人会瘦下来，而且是在很短时间内。我觉得那些尝试各种减肥方法之后都还瘦不下来的人真的可以试试间歇性断食，不需要太大的意志力而且还没什么成本，应该说是负成本吧。其次，你对食物的感受会发生变化，会对食物产生更多的敬畏之心，另外也不再受到食物的束缚，因为你知道，只要自己愿意，哪怕一整天不吃东西也不是什么问题，所以不用纠结晚饭吃什么这种问题了。还有就是能帮你省下一点时间和金钱，虽然省下的钱不值一提，但是积少成多，一个月下来可能也能省下每个月订阅服务的钱了。所以，如果不出意外的话，我会将这种生活方式继续下去。唯一有点担心的是，脱单之后还能保持这样的生活方式吗？</p><h4 id="12-月-18-日-两个上进指标"><a href="#12-月-18-日-两个上进指标" class="headerlink" title="12 月 18 日 - 两个上进指标"></a>12 月 18 日 - 两个上进指标</h4><p>前几天看到<a href="http://wufazhuce.com/question/3063">一个问答</a>，关于通过设计一个上进且自律的环境提高自己的自制力，其中提到一点，如何衡量自己是否处于一个上升环境中。有两个指标，一个是傻瓜指数，即问自己觉得多长时间之前的自己是个傻瓜？第二个是朋友指数，即问自己我身边有多少优秀的新朋友？</p><p>第一个问题就让我思考了很久，我看了自己过去几年写的文字，包括日记，虽然显得有些稚嫩，但是并不觉得很傻，一些基本的观念和思考方式，似乎并没有发生多大的改变。最大的改变是在今年，开始写碎碎念之后，慢慢变得越来越能接受自己，包括过去的自己，也能更加真实地对待自己以及身边的一切，并且也知道要学会表达自己，而且要以创造价值为目标，给他人带去快乐和幸福。严格算起来，可能觉得刚上大学时的自己显得有点傻吧，没有目标和方向，每天都过得浑浑噩噩，整天做一些不着边际的白日梦，也不知道去提高自己、参加校园内的活动、变得活跃、结交新朋友等，这本来是人生中最好的结交好朋友和尝试亲密关系的机会，结果四年时间就这么被浪费掉了。至于第二个指数，毫无疑问，自己目前没有达到让人满意的程度。因为如果不算同事和网友的话，我连认识的新朋友都很少，更别说优秀的了。</p><p>这样看来，自己似乎并没有处在一个上进的环境之中。但是人还是要往前看的，我觉得自己现在毕竟还年轻，才毕业 3 年多，人生可以说才刚刚起步。慢慢积累，慢慢提高自己，未来机会还是很多的。我是一个乐观主义者，而且也相信人无论到了何时、何种地步都是可以不断改变自己的。懊悔过去丝毫没有意义，只要能做好今天的事，规划好明天的任务，每天进步一点点，让自己尽量一直处在一个上升的环境之中，那么未来朝着越来越好的方向发展是必定的。</p><h4 id="12-月-19-日-行动第一与分解目标"><a href="#12-月-19-日-行动第一与分解目标" class="headerlink" title="12 月 19 日 - 行动第一与分解目标"></a>12 月 19 日 - 行动第一与分解目标</h4><p>年轻人容易迷茫，往往是因为不知道自己想成为什么样的人，也不知道自己擅长什么、适合做什么，但是我觉得一个人的热情所在从来都不是靠想出来的，而是要靠行动，不断地尝试，不断地试错，才能慢慢发现自己做得比别人好的地方。天赋这种东西也许真的存在，但是我更相信是只有通过努力练习，你才能找到自己的优势所在。</p><p>这几天我也在思考，自己有目标也有足够的自制力，但是为什么下班后坐在电脑前应该开始学习的时候却总是容易分心的问题。想来想去，可能还是达成目标的愿望不够强烈吧，「成长为高级安卓开发」这个目标只不过是我找不到方向硬给自己定下的目标，而我内心并不是真的渴望如此。即使如此，但我还是想要先达成这个目标，至少目前来说这是可行且有足够收益的事。另一方面，学习这件事本就是很苦的，过程中需要忍受枯燥乏味的细节，一时理解不了的概念、难点等等，所以也会让自己产生厌弃的想法。按之前《刻意练习》中所说的，我要做的是想办法骗过自己的大脑，让它觉得这其实是一次很有奖赏性的体验，然后把目标分解细化，让每一步看上去都不是那么难达成，这样自己就有动力去不断完成每一个阶段的挑战了。</p><h4 id="12-月-20-日-真正的体面"><a href="#12-月-20-日-真正的体面" class="headerlink" title="12 月 20 日 - 真正的体面"></a>12 月 20 日 - 真正的体面</h4><p>晚上和老妈视频聊天，聊到过冬衣服，她让我多买件羽绒服，我觉得自己羽绒服够穿了，今年没必要再买了，然后就被教育了一通，说过年了总要买件新衣服穿吧。我告诉她说只要自己活的舒服就好了，生活又不是过给别人看的，然后她也没再多说什么了。扪心自问，我其实也没能做到这么豁达，有时候还是会觉得当在他人面前要优雅、体面一些。我很羡慕那些可以真正不在乎他人看法、能够活出自己真实样子的人。</p><p>但是，真正的体面是什么呢？是有很多钱然后吃穿用度都非常高档才叫体面吗？是生活得非常精致并且能获得周围人的羡慕吗？我觉得能<strong>完全掌控自己的时间</strong>，并且<strong>做自己喜欢的事</strong>才是真正的体面。我每天起床的动力不是因为我要通过工作获得收入以维持自己的生活支出，而是我决定自己今天要完成的目标，我从心底想要去做这件事，而不是别人想要我完成这个工作。这也是为什么我们必须要找到自己喜欢的工作。当工作变成你想要做的事情的时候，工作其实就变成了你生活的一部分，你才能真正享受其中。它不但带给你收入和快乐，也让你获得自尊和成就感。所以体面其实和金钱的关系并不大。</p><h4 id="12-月-21-日-黑客与画家"><a href="#12-月-21-日-黑客与画家" class="headerlink" title="12 月 21 日 - 黑客与画家"></a>12 月 21 日 - 黑客与画家</h4><p>这周是 2020 年的最后一周了。这周应该会是比较忙碌的一周，要很多事情要做，工作上的还有自己的私事，但是越是时间安排得非常紧凑的时候，就越要让自己冷静下来，学会思考对自己来说真正重要的东西，而不是被各种事务推着往前走。</p><p>晚上看了黑客与画家，尝试第一遍速读，两个小时看完差不多一半。以书中所说的黑客标准对照自身，我可能还远远达不到那样的水平，所以一瞬间又陷入了一阵迷茫。但是过了一会儿就想通了，看这样的书目的无非是为了扩展自己的眼界和见识，并不是为了指导自己最终走上和作者一样的道路，所以也没必要焦虑。作为一个普通的程序员，能做的也就是像他们那样的顶级黑客看齐，把自己基本的工作做好，再在工作之余多花时间精进自己的技术，至于其它的话题，比如创业之类的，那已经在我目前的能力范围之外了，所以还是先努力提高自己的技术水平吧。</p><h4 id="12-月-22-日-改造你自己"><a href="#12-月-22-日-改造你自己" class="headerlink" title="12 月 22 日 - 改造你自己"></a>12 月 22 日 - 改造你自己</h4><p>没有人能够拥有完全理想的环境，所以我们要做的不是去抱怨自己所处的环境，而是想办法提升自己的能力。我们无法决定自己从什么地方开始，但是只要我们有足够的耐心，并且付出足够的努力，同样可以到达自己想要的终点。另外，不要去和他人比较，你要做的只是和过去的自己比。今天的自己是否比昨天的自己有进步？我从过往的经历学到了什么？不要把失败看成是一件可耻的事。的确，失败并不光荣，但是失败比什么都不做强一百倍。你只有不断地尝试、挑战突破自己的极限，才能发现自己有多大的潜力。不要停留在自己的安全区，也不要害怕受到伤害，学会战胜自己内心的恐惧，永远选择做难一点的事，慢慢会发现更广阔的天地。</p><h4 id="12-月-23-日-尽量多去尝试"><a href="#12-月-23-日-尽量多去尝试" class="headerlink" title="12 月 23 日 - 尽量多去尝试"></a>12 月 23 日 - 尽量多去尝试</h4><p>昨晚看了自己 16 年写的日记，突然意识到一个问题，那就是从我开始自学 Java 和 Android 到现在，差不多只有 5 年的时间，既然 5 年的时间就能从 0 开始一个新职业并且做到还不错的程度，那么其它方面是不是也类似呢？比如如果我现在觉得未来当一个营养师更适合自己，那么我是不是也可以从现在开始自学呢？但是这么类比不太恰当，毕竟现在无论如何也提供不了大学里那种学习环境，而且也没有那么多时间用于自学，只能靠下班后或者周末挤点时间出来自学，或者辞职全身心投入学习，但是这样的话要承担的风险和压力就比较大了。</p><p>不过这样思考还是有意义的，因为可以转变那种一旦选择了一个职业就只能一辈子坚持下去的思维。人的一生还是挺长的，如果不确定自己适合做什么，其实可以尽量多去尝试。每个人都有自己的天赋所在，而且我们所处的时代也比以往任何时候都要宽容，所以我们有机会去广泛地探索自己的兴趣和优势。虽然对于一个成年人来说，最好的做法是坚持目前所从事的职业，但是如果你有更好的想法或者遇到了好的机会，也不要浪费，先试试再说。</p><h4 id="12-月-24-日-探索适合自己的职业"><a href="#12-月-24-日-探索适合自己的职业" class="headerlink" title="12 月 24 日 - 探索适合自己的职业"></a>12 月 24 日 - 探索适合自己的职业</h4><p>虽然一直在强调要做自己喜欢的事，但是大多数人对于自己的工作停留在一个既谈不上讨厌也谈不上喜欢的区间之内，那么，在这种情况应该如何选择呢？我觉得应该分情况讨论。既然不讨厌这份工作，那就继续努力把它做好。对于职场新人来说这件事本身就要花去很多时间和精力了，所以可能在做好的过程中，慢慢体会到其中的乐趣，然后爱上了自己的工作也是有可能的。对于已经工作一段时间了的人来说，如果这份工作还是不能让自己体会到享受其中的感觉的话，那么的确应该好好反思下哪里出问题了。是自己投入不够？还是处于一个厌倦期？又或者更恐怖的，这份工作不适合自己——无论是在天赋还是在兴趣上。这样的话，那就需要自己在工作之余，多花时间探索其它领域，多观察自己的兴趣，尝试自己平时想做但是一直没时间做的事，释放自己的好奇心，找到自己真正擅长且比较有前景的事。这有可能是一个漫长的过程，需要自己有耐心，并且有持续探索下去的信心。</p><h4 id="12-月-25-日-耐心做好你能做的事"><a href="#12-月-25-日-耐心做好你能做的事" class="headerlink" title="12 月 25 日 - 耐心做好你能做的事"></a>12 月 25 日 - 耐心做好你能做的事</h4><p>昨晚平安夜，看完了《黑客与画家》，打扫卫生的时候想到：与其寻找自己和他人不同的地方，不如老老实实做一些别人都不愿意做的事，选择去做一些脏活累活，然后凭借耐心和坚持达到一流。每个人都想找到自己的天赋所在，并且做出一些了不起的事。但是你得承认，大多数人都只是普通人而已，做着一份普通的工作，也并不是天赋异禀。即使如此，我们还是可以做出和别人不一样的选择，那就是去做一些看上去很苦很累、没有人愿意做的事，只要有足够的耐心并且足够勤奋，能一直坚持下去。即使是普通人，最终也能脱颖而出。所以，我现在也想通了，「找到你的热情所在」并不是适合所有人的，对于我这样的人来说，「耐心做好你能做的事」才更实际一些。</p><h4 id="12-月-26-日-保持平静才能感受到幸福"><a href="#12-月-26-日-保持平静才能感受到幸福" class="headerlink" title="12 月 26 日 - 保持平静才能感受到幸福"></a>12 月 26 日 - 保持平静才能感受到幸福</h4><p>快乐无法持久，真正的幸福是能够保持内心的平静。经过一段时间的冥想，我发现自己身上发生的最大的变化是，能够比较平静地面对周围的一切，情绪波动的幅度减小了。我觉得这才是真正的幸福，你能平静地接受任何发生在自己身上的事。虽然我们都趋利避害，希望发生在自己身上的事尽量都是好的，但是人生总是充满各种不幸，如果你能用一种平常的心态对待那些不利的事，平静地接受，平静地处理，然后继续平静地生活下去，那么就没有什么能打乱你的生活节奏，也没有人可以真正伤害到你。对于快乐的情绪也是一样，虽然快乐短暂，极度快乐之后只有空虚，但是只要我们能接受快乐过后的平静，那么喜悦的情绪其实就是对自己的一种激励和奖赏，而不是特别值得追寻的事。唯有保持平静，我们才能更好地面对自己的情绪，感受到幸福。</p><h4 id="12-月-27-日-第一次滑雪的心得"><a href="#12-月-27-日-第一次滑雪的心得" class="headerlink" title="12 月 27 日 - 第一次滑雪的心得"></a>12 月 27 日 - 第一次滑雪的心得</h4><p>今天去绍兴乔波玩滑雪，第一次滑雪而且还是一个人，玩得全身湿透，一部分是汗水一部分是摔跤掉进衣服里融化后的雪水。第一次尝到了人造雪的味道，咸咸的，味道不怎么好。虽然戴了护具，不怕摔跤，但是练推坡的时候，和一个停在坡道上的妹子不小心撞上，左脚大拇指被顶到，出来一看又一整块指甲紫掉了，上次玩滑板撞到右脚，这次是左脚，看来玩板类运动一定要养成勤剪脚指甲的习惯。而且一定要穿合适的鞋子，这次部分原因也是鞋子太紧造成的。还有就是一开始练单板推坡的时候，一定要在有坡度的坡道上练，不用等到特别熟练才上坡道，只要差不多能控制住刹车就可以了，犹豫太久反而会不敢提高速度。第三个心得是：不要怕摔跤。新手是一定会摔跤的，次数多少而已，但其实只要戴好护具就不用害怕摔跤。对我来说，需要克服的最大的障碍是来自心理上的恐惧，觉得自己摔跤后的样子很狼狈、很丢脸，但实际上没有在乎你摔跤后是什么样。别人看到了顶多哈哈一笑，但其实也都没有恶意的，你只要继续练习就可以了。练习滑雪每个人都有一个慢慢变好、不断进步的过程，要专注于自己哪里做得对，至于做得不好的地方，下次注意改进就好了。</p><h4 id="12-月-28-日-如何应对自我苛责"><a href="#12-月-28-日-如何应对自我苛责" class="headerlink" title="12 月 28 日 - 如何应对自我苛责"></a>12 月 28 日 - 如何应对自我苛责</h4><p>不要忽视你心底的苛责声音。相比对待他人，我们有时候对自己会异常地坏，比如自己不小心犯的错误或者做了件看上去很傻很蠢的事，然后你就会在心底不停地苛责自己，骂自己笨蛋，是个大傻逼，再也不会有人喜欢自己这样的人了。随着你花越多的时间想这件事，就会在这样的自我苛责声中越陷越深，以至于整个人的状态越来越差，甚至开始慢慢相信这种自我贬低的语言。</p><p>我相信每个人都有这种自我苛责的时刻，我们应该做的不是去否认它或者对抗它，而是坦然接受它。每当这样的时刻出现的时候就告诉自己：好吧，我又开始自我苛责了。接着思考下这种指责或者谩骂是否有依据。如果我们还是不能把它放到一边的话，就继续告诉自己：好了，我知道这次是自己没做好，但是下次就不会犯类似的错误了，然后就不要再去想这件事，把注意力集中在其他事情上。如果依旧会想起它，那就在心底打个标记：哦，我又想起它了。一段时间之后，这样的声音就会自己慢慢消失了。</p><h4 id="12-月-29-日-目前最大的恐惧：搭讪女孩子"><a href="#12-月-29-日-目前最大的恐惧：搭讪女孩子" class="headerlink" title="12 月 29 日 - 目前最大的恐惧：搭讪女孩子"></a>12 月 29 日 - 目前最大的恐惧：搭讪女孩子</h4><p>目前来看，你最想要克服的恐惧是什么？对我来说，最大的恐惧是和女孩子搭讪，这也是我最想克服的短板。首先由于不敢和女生搭讪，而错过了很多机会。能够开口向他人示好，说出自己想要说的话，表达自己的想法，这是第一步，如果这一步都无法做到，那就不会有诸如通过聊天了解彼此，交换联系方式，乃至建立长期稳定的朋友或恋人关系等等后续了。所以，目前来看「能开口说」是我最需要克服的恐惧。但其实搭讪并没有那么多条条框框，在一个公共的环境之中，只要你觉得对方不错，而且你心底也没有恶意，说几句好听的话、夸夸对方，对别人来说其实也是一个挺好的惊喜，而且就算对方拒绝了你也没什么大不了的，我们要习惯被拒绝，这也是提升一个人心理素质的一种方式。所以，开始练习搭讪吧，别想太多，开口就对了。</p><h4 id="12-月-30-日-坦然接受每种状态下的自己"><a href="#12-月-30-日-坦然接受每种状态下的自己" class="headerlink" title="12 月 30 日 - 坦然接受每种状态下的自己"></a>12 月 30 日 - 坦然接受每种状态下的自己</h4><p>有时候挺矛盾的，觉得自己明明很孤独，但是对于他人抛来的橄榄枝却又觉得是负担，而且大部分时间里都不想花时间和精力去维持一段关系。心里知道这样是有问题的，但是就是不愿意去改变。人是高级社交动物，除了基本的社交之外，我们还需要与他人建立起深厚的友谊和亲密关系。但是，如果你把自己隔离在他人无法接触的高墙之内，那么最终就会沦落到无人可聊天、可分享情绪的地步。</p><p>有时候又觉得，没朋友真的是一件非常糟糕的事情吗？相比那些结交了糟糕朋友的人来说，没有朋友至少不会给自己添堵吧。而且像我这样的人，自己一个人其实也能过得很开心。工作加上个人爱好，基本就占去了我 95% 的精力和时间。虽然还是会偶尔感到孤独，但是只要自己能接受它，学会和孤独相处，其实也没什么大不了的。一个人有一个人的苦，两个人有两个人的苦。如果能接受每种状态下的自己，并且保持内心的平衡，其实都可以生活得很好。</p><h4 id="12-月-31-日-Goodbye-2020-2021-will-be-better"><a href="#12-月-31-日-Goodbye-2020-2021-will-be-better" class="headerlink" title="12 月 31 日 - Goodbye 2020, 2021 will be better!"></a>12 月 31 日 - Goodbye 2020, 2021 will be better!</h4><p>2020 年最后一天，心情有点复杂。其实这只是我们生活中普通的一天，但是我们却赋予了它特殊的意义，我们会在这一天去回顾，去庆祝，告别过去，迎接新的开始。既然如此，那就趁这个机会展望一下新的一年吧。新的一年，希望我爱的人和爱我的人都平平安安、生活幸福。希望自己在新的一年能更加努力，更有耐心，珍惜自己已经拥有的一切，学会感恩，帮助更多身边的人，与更多人建立连结。还有，希望疫情早日过去，所有人的生活都能早日恢复正常。Goodbye 2020, 2021 will be better!</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim 新手速查清单</title>
      <link href="/vim-cheatsheet/"/>
      <url>/vim-cheatsheet/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  该 Cheatsheet 是我在通过 <a href="http://www2.geog.ucl.ac.uk/~plewis/teaching/unix/vimtutor">vimtutor</a> 学习 Vim 以及日常使用中整理出来的，主要面向初学者。</p></blockquote><span id="more"></span><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><ul><li>移动到行尾 <kbd>$</kbd>，移动到行首 <kbd>0</kbd>，移动到行首第一个字符处 <kbd>^</kbd></li><li>移动到段首 <kbd>{</kbd>，移动到段尾 <kbd>}</kbd></li><li>移动到下一个词 <kbd>w</kbd>，移动到上一个词 <kbd>b</kbd>，移动到当前单词末尾前一个字符 <kbd>e</kbd></li><li>移动到文档开头 <kbd>gg</kbd>，移动到文档末尾 <kbd>G</kbd></li><li>移动光标到屏幕顶端 <kbd>H</kbd>，移动到屏幕中间<kbd>M</kbd>，移动到底部<kbd>L</kbd></li><li>跳到第 n 行 <kbd>ngg</kbd> 或 <kbd>nG</kbd> 或使用命令 <code>:n</code></li><li>移动到上次编辑文件的位置 双击 <kbd>`</kbd></li><li><kbd>control</kbd> + <kbd>f</kbd> 向下移动一屏，<kbd>control</kbd> + <kbd>b</kbd> 向上移动一屏</li><li><kbd>control</kbd> + <kbd>i</kbd> 从当前位置前进，<kbd>control</kbd> + <kbd>o</kbd> 从当前位置后退</li><li>光标在 <code>(</code> 或 <code>[</code> 或 <code>&#123;</code> 处时，使用 <kbd>%</kbd> 跳转匹配的 <code>)</code> 或 <code>]</code> 或 <code>&#125;</code></li></ul><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><ul><li>在光标位置插入 <kbd>i</kbd>，行首插入 <kbd>I</kbd></li><li>在光标下一个字符后插入 <kbd>a</kbd>（<kbd>ea</kbd> 在下一个单词末尾插入文字），行尾插入 <kbd>A</kbd></li><li>在下一行插入新的一行 <kbd>o</kbd>，在前一行插入新的一行 <kbd>O</kbd></li><li>替换光标后所在字符 <kbd>r</kbd>，<kbd>R</kbd> 进入替换模式，每一个输入的字符都会被删除并替换原有字符</li><li>删除一个字符 <kbd>x</kbd>，删除一个字符后进入插入模式 <kbd>s</kbd></li><li>删除一个单词 <kbd>dw</kbd>，删除单词到末尾并进入插入模式 <kbd>ce</kbd>，删除整个单词并进入插入模式 <kbd>cw</kbd></li><li>删除到行尾 <kbd>d</kbd><kbd>$</kbd> 或者 <kbd>D</kbd>，删除到行尾后进入插入模式 <kbd>c</kbd><kbd>$</kbd> 或者 <kbd>C</kbd></li><li>删除一行 <kbd>dd</kbd>，删除后进入插入模式 <kbd>cc</kbd> 或 <kbd>S</kbd></li><li>复制 <kbd>y</kbd>，复制一行 <kbd>yy</kbd> 或者 <kbd>Y</kbd></li><li><kbd>p</kbd> 粘贴删除或者复制后的内容到光标下一个字符后，<kbd>P</kbd> 粘贴到光标前</li><li>交换光标后的两个字符 <kbd>xp</kbd>，交换两行 <kbd>ddp</kbd></li><li>撤销 <kbd>u</kbd>，撤销整行 <kbd>U</kbd>，重做 <kbd>control</kbd> + <kbd>r</kbd>（撤销之前的撤销）</li><li><kbd>>></kbd> 缩进所在行，按一次之后继续按 <kbd>.</kbd> 可以继续缩进</li><li><kbd><<</kbd> 反缩进所在行</li><li>合并两行 <kbd>J</kbd></li><li><kbd>.</kbd> 在新的光标位置重复上一条操作</li><li>按下 <kbd>q</kbd> 开始录制模式，选择 <kbd>a</kbd> - <kbd>z</kbd> 为重复操作快捷键，之后开始录制；再次按下 <kbd>q</kbd> 结束录制，然后按下 <kbd>@</kbd> + 之前选择的重复操作快捷键，重复录制的操作</li></ul><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ul><li><code>:h[elp] [command_name]</code> 查看某个命令的帮助文档，比如：<ul><li> <code>:h user-manual</code> 查看帮助文档</li><li> <code>:h keycodes</code> 查看按键名称</li><li> <code>:h insert-index</code> 查看插入模式文档</li><li> <code>:h normal-index</code> 查看普通模式文档</li><li> <code>:h visual-index</code> 查看 visual 模式文档</li><li> <code>:h ex-edit-index</code> 查看命令模式文档</li></ul></li><li> 查看帮助文档时，双击或者使用快捷键 <kbd>control</kbd> + <kbd>]</kbd> 跳转链接，也可以使用前进/后退 (<kbd>control</kbd> + <kbd>i</kbd> / <kbd>o</kbd>) 在文件或者链接间跳转，如果链接是文件则可以使用 <kbd>g</kbd> + <kbd>f</kbd> 快捷键</li><li> 查看帮助文档时，按 <kbd>control</kbd> + <kbd>d</kbd> 获得命令提示，按 <kbd>tab</kbd> 进行命令补全</li><li> 按 <kbd>control</kbd> + <kbd>b</kbd> 跳到命令开头，<kbd>control</kbd> + <kbd>e</kbd> 跳到命令末尾，按 <kbd>control</kbd> + <kbd>w</kbd> 删除光标前一个单词，<kbd>control</kbd> + <kbd>u</kbd> 重新输入命令</li><li> <kbd>/</kbd> 向后匹配搜索，<kbd>?</kbd> 向前匹配搜索，<kbd>n</kbd> 匹配下一个，<kbd>N</kbd> 反向匹配下一个</li><li> <code>:set ic</code> 忽略大小写匹配，<code>:set noic</code> 关闭，仅单次搜索忽略大小写加 <code>\c</code>，比如 <code>/keyword\c</code></li><li> <code>:set hls</code> 搜索结果高亮，<code>:set nohls</code> 关闭，取消高亮直到下次搜索 <code>:noh</code></li><li> <code>:set is</code> 部分结果匹配显示，<code>:set nois</code> 关闭</li><li> <code>:s/old/new/g</code> + 回车，替换光标所在行匹配到的所有字符</li><li> <code>:#,#s/old/new/gc</code> 替换所选行 <code>#,#</code> 中匹配到的字符</li><li> <code>:%s/old/new/g</code> 替换当前文件中所有匹配到的字符，<code>:%s/old/new/gc</code> 每个替换前弹出确认提示</li><li> <code>:!</code> 执行 Shell 命令，比如 <code>:!ls</code></li><li> <code>:w fileName</code> 保存文件；<code>:x</code> 保存并退出，快捷键 <kbd>ZZ</kbd>，<code>:q!</code> 不保存文件直接退出，快捷键 <kbd>ZQ</kbd></li><li> <code>:e</code> 重新加载当前文件；<code>:e!</code> 不保存文件重新打开</li><li> <code>:e fileName</code> 在当前窗口打开（新）文件，使用 <code>:e#</code> 切换到最近的文件，快捷键 <kbd>control</kbd> + <kbd>^</kbd>，切换前必须先保存。</li><li> <code>:r</code>，retrieve 数据并插入到光标所在下一行，数据来源可以是文件或命令结果，比如 <code>:r fileName</code> 或者 <code>:r !ls</code></li><li> <code>:ls</code> 列出所有打开的文件，<code>:b n</code> 切换到指定数字下的文件，<code>:bw</code> 关闭当前文件，<code>:qall</code> 关闭所有文件，<code>:wall</code> 保存所有打开的文件</li><li> <code>:his</code> 查看所有命令历史，<code>:his /</code> 查看所有搜索历史</li><li> <code>:set</code> 更改当前 vim 配置，比如 <code>:set nu</code> 显示行号</li><li> <code>:map key1 key2</code> 映射键盘按键，默认的 <code>&lt;leader&gt;</code> 键为 <code>\</code></li><li> <code>q:</code> 查看最近命令历史，<code>q/</code> 查看最近搜索历史，按两次 <kbd>control</kbd> + <kbd>c</kbd> 退出</li><li> 按 <kbd>v</kbd> 进入 Visual selection 模式，使用方向键进行移动，之后可以对选中的文本进行操作，比如复制 <kbd>y</kbd>，删除 <kbd>d</kbd>，重选 <kbd>gv</kbd>，将选中的行保存为文件 <code>:w fileName</code> 等</li><li> 按 <kbd>V</kbd> 进入 Visual Line selection 模式</li><li> 按 <kbd>control</kbd> + <kbd>v</kbd> 进入 Visual Block selection 模式，可以垂直方向块状选择，使用 <kbd>I</kbd> 插入模式，退出后所有选中的行都会插入相同内容。</li><li> <code>:f</code> 显示文档信息和当前所在位置，或者使用快捷键 <kbd>control</kbd> + <kbd>g</kbd></li></ul><h3 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h3><ul><li>  <code>vim -o file1 file2</code>，水平方向多窗口打开多个文件，<code>-O</code> 垂直方向多窗口打开多个文件</li><li>  <code>:split fileName</code> 在打开的文件中打开水平多窗口，快捷键 <kbd>contorl</kbd> + <kbd>w</kbd>, <kbd>s</kbd>，不加 fileName 则默认使用当前文件</li><li>  <code>:vsplit fileName</code> 在打开的文件中打开垂直多窗口，快捷键 <kbd>contorl</kbd> + <kbd>w</kbd>, <kbd>v</kbd>，不加 fileName 则默认使用当前文件</li><li>  <kbd>contorl</kbd> + <kbd>w</kbd>, <kbd>h</kbd> <kbd>j</kbd> <kbd>k</kbd> <kbd>l</kbd> 或方向键，上下左右切换窗口，连按两次 <kbd>contorl</kbd> + <kbd>w</kbd> 切换下一个窗口，也可以使用光标对窗口进行选择</li><li>  <kbd>control</kbd> + <kbd>w</kbd> + <kbd>shift</kbd> + <kbd>-</kbd>，窗口垂直最大化；<kbd>control</kbd> + <kbd>w</kbd> + <kbd>=</kbd>，垂直方向等分显示。</li><li>  <code>:close</code> 关闭当前窗口，快捷键 <kbd>contorl</kbd> + <kbd>w</kbd>, <kbd>c</kbd> 或者  <kbd>shift</kbd> + 双击 <kbd>z</kbd></li><li>  <code>:only</code> 关闭其它窗口，快捷键 <kbd>contorl</kbd> + <kbd>w</kbd>, <kbd>o</kbd></li></ul><h3 id="其它-Tips"><a href="#其它-Tips" class="headerlink" title="其它 Tips"></a>其它 Tips</h3><ul><li>  <code>:set textwidth=&lt;n&gt;</code> 设置字符换行最大长度，之后按 <kbd>gql</kbd> 就可以将使得当前行超出部分自动换行</li><li>  <code>:retab</code> 格式化 Tab 为空格，使得当前文件符合 <code>.vimrc</code> 中的 <code>tabstop</code> 等配置</li></ul><h4 id="iTerm-快捷键"><a href="#iTerm-快捷键" class="headerlink" title="iTerm 快捷键"></a>iTerm 快捷键</h4><ul><li>  <kbd>command</kbd> + <kbd>/</kbd> 高亮当前文件中光标所在的位置</li><li>  <kbd>command</kbd> + <kbd>;</kbd> 获得代码提示</li></ul><h3 id="Vim-插件"><a href="#Vim-插件" class="headerlink" title="Vim 插件"></a>Vim 插件</h3><p>插件管理器：<a href="https://github.com/junegunn/vim-plug">Vim-Plug</a></p><h4 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h4><ul><li>  <a href="https://github.com/editorconfig/editorconfig-vim">editorconfig-vim</a>: EditorConfig plugin for Vim. <code>:h editorconfig</code></li><li>  <a href="https://github.com/tpope/vim-commentary">vim-commentary</a>: Comment stuff out. <code>gcc</code>, <code>:h commentary</code></li><li>  <a href="https://github.com/jiangmiao/auto-pairs">auto-pairs</a>: Insert or delete brackets, parens, quotes in pair. <code>:h autopairs</code></li><li>  <a href="https://github.com/tpope/vim-surround">vim-surround</a>: change - <code>cs&#39;&quot;</code> |delete: <code>ds&#39;</code> |add - <code>ysiw&quot;</code>. <code>:h surround</code></li><li>  <a href="https://github.com/mg979/vim-visual-multi">vim-visual-multi</a>: Multiple cursors plugin. <code>&lt;C-Down&gt;</code> / <code>&lt;C-Up&gt;</code>, <code>:h visual-multi</code></li><li>  <a href="https://github.com/scrooloose/nerdtree">nerdtree</a>: A tree explorer plugin for vim. <code>:h nerdtree</code></li><li>  <a href="https://github.com/airblade/vim-gitgutter">vim-gitgutter</a>: A Vim plugin which shows git diff markers in the sign column. <code>:h gitgutter</code></li><li>  <a href="https://github.com/itchyny/lightline.vim">lightline.vim</a>: A light and configurable statusline/tabline plugin for Vim. <code>:h lightline</code></li><li>  <a href="https://github.com/luochen1990/rainbow">rainbow</a>: Rainbow Parentheses. <code>:h rainbow</code></li><li>  <a href="https://github.com/vim-utils/vim-man">vim-man</a>: View man pages in vim. <code>:Man Command</code>, <code>:h man</code></li></ul><h4 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h4><ul><li>  <a href="https://github.com/mileszs/ack.vim">ack.vim</a>: Run <code>ack</code> in Vim. <code>:h ack</code></li><li>  <a href="https://github.com/preservim/nerdcommenter">nerdcommenter</a>: Vim plugin for intensely nerdy commenting powers. <code>\cc</code>, <code>:h nerdcommenter</code></li><li>  <a href="https://github.com/junegunn/fzf.vim">fzf.vim</a>: Vim plugin for <a href="https://github.com/junegunn/fzf">fzf</a>. <code>:h fzf-vim</code></li><li>  <a href="https://github.com/altercation/vim-colors-solarized">vim-colors-solarized</a>: Change colorscheme for Vim. <code>:h solarized</code></li><li>  <a href="https://github.com/tpope/vim-fugitive">vim-fugitive</a>: Use git in Vim. <code>:h fugitive</code></li><li>  <a href="https://github.com/vimwiki/vimwiki">vimwiki</a>: A personal wiki for Vim. <code>:h vimwiki</code></li><li>  <a href="https://github.com/ycm-core/YouCompleteMe">YouCompleteMe</a>: A code-completion engine for Vim. <code>:h youcompleteme</code></li></ul><h3 id="Vim-配置"><a href="#Vim-配置" class="headerlink" title="Vim 配置"></a>Vim 配置</h3><p>用户目录下新建文件 <code>.vimrc</code>，然后加入以下配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs sh">syntax <span class="hljs-built_in">enable</span><br>filetype on<br>filetype plugin on<br>filetype indent on<br><br>imap jk &lt;Esc&gt;<br>vmap jk &lt;Esc&gt;<br>nnoremap &lt;C-L&gt; :<span class="hljs-built_in">set</span> nu<br>nnoremap &lt;C-H&gt; :<span class="hljs-built_in">set</span> nonu<br><br><span class="hljs-built_in">set</span> nocompatible<br><span class="hljs-built_in">set</span> number<br><span class="hljs-built_in">set</span> cursorline<br><span class="hljs-built_in">set</span> ruler<br><span class="hljs-built_in">set</span> mouse=nicr<br><span class="hljs-built_in">set</span> clipboard=unnamed<br><span class="hljs-built_in">set</span> backspace=indent,eol,start<br><span class="hljs-built_in">set</span> ignorecase<br><span class="hljs-built_in">set</span> smartcase<br><span class="hljs-built_in">set</span> hlsearch<br><br><span class="hljs-built_in">set</span> autoindent<br><span class="hljs-built_in">set</span> expandtab<br><span class="hljs-built_in">set</span> shiftwidth=4<br><span class="hljs-built_in">set</span> softtabstop=4<br><span class="hljs-built_in">set</span> tabstop=4<br><br><span class="hljs-built_in">set</span> hidden<br><span class="hljs-built_in">set</span> wildmenu<br><span class="hljs-built_in">set</span> laststatus=2<br><span class="hljs-built_in">set</span> report=0<br><span class="hljs-built_in">set</span> synmaxcol=200<br><span class="hljs-built_in">set</span> updatetime=100<br><span class="hljs-built_in">set</span> dir=~/.cache/vim<br><br><span class="hljs-built_in">set</span> title<br><span class="hljs-built_in">set</span> confirm<br><span class="hljs-built_in">set</span> showmode<br><span class="hljs-built_in">set</span> ttyfast<br><span class="hljs-built_in">set</span> lazyredraw<br><span class="hljs-built_in">set</span> list<br><br><span class="hljs-string">&quot; Colorize Vim</span><br><span class="hljs-string">if !has(&#x27;gui_running&#x27;)</span><br><span class="hljs-string">  set t_Co=256</span><br><span class="hljs-string">endif</span><br></code></pre></td></tr></table></figure><p>在 Vim 中查看 vimrc 示例文件 <code>:e $VIMRUNTIME/vimrc_example.vim</code>，更多配置见 <code>:h vimrc-intro</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cheatsheet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快乐的秘诀</title>
      <link href="/2020-11/"/>
      <url>/2020-11/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/hNruTLsAqaI" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>今年秋天天凉的比较晚，都快 12 月了我才想起来该穿秋裤了。而且随着每天下班时候的天色越来越暗，小区楼下玩滑板车的小孩子越来越少，以及银杏树的叶子越来越黄，我才慢慢意识到：嗯，冬天快到了。我喜欢杭州四季分明的天气，但是每当冬天来临的时候，一个人走在路上，不知道为什么，心里总会感到一阵深深的孤独感。但是孤独这件事从来无法靠他人来排解，我们每个人生来就是孤独的，总归有心中有话却无人可倾诉的时刻。这个时候学会独处就显得特别重要了，写碎碎念就是一种和自己对话的方式。无论怎样，我们始终都可以选择以何种方式、何种态度<a href="https://www.youtube.com/watch?v=iuCp-TC_HsI">对待孤独</a>。同样的，想要变得快乐其实也非常简单，只要改变你的想法就好了。</p></blockquote><span id="more"></span><h4 id="11-月-1-日-忠于自己的内心"><a href="#11-月-1-日-忠于自己的内心" class="headerlink" title="11 月 1 日 - 忠于自己的内心"></a>11 月 1 日 - 忠于自己的内心</h4><p>昨晚和老妈视频，然后老爸也在，聊了几句，发现自己还是没法很好地和老爸聊天，总是觉得他说的话里包含一些否定自己的成分，然后自己的情绪也受影响变得稍微有些负面。我觉得自己不自信的根本原因有一部分也是因为得不到他的肯定吧。总是会怀疑自己，而且常常对自己犯的错耿耿于怀，对于他人的批评也总是持比较负面的态度，而不是去思考自己身上的确存在的问题，也总是做不到虚心接受他人的建议然后用于改善自我。</p><p>但是自己的问题还是要靠自己来解决，抱怨并不能使自己的处境变好。既然意识到了，那就想办法去改变。要意识到我是一个独立的个体，他人的肯定对我真的那么重要吗？可能是挺重要的，因为我们总是渴望得到自己信赖的人的赞许与肯定，尤其是父母。不过，决定我们如何行动的，不能仅仅是为了得到他人的肯定，更重要的是要忠于自己的内心。只要是有利于自己和他人的事情，那就应该去做，即使得不到身边人的肯定甚至是被反对也一样要去做。另一方面，喜欢质疑自己也有个好处，你会经常反省自己，这是一个好习惯，至少可以保证自己不会变得太骄傲或者犯太离谱的错误。</p><h4 id="11-月-2-日-Find-your-own-rainbow"><a href="#11-月-2-日-Find-your-own-rainbow" class="headerlink" title="11 月 2 日 - Find your own rainbow"></a>11 月 2 日 - Find your own rainbow</h4><p>昨晚 8 点多回到家，然后发了条朋友圈，表达了自己在公司待了两年多却没有什么归属感的问题。一方面是不断有同事离职，另一方面是觉得自己没有受到重视，感觉自己没有那么重要。毕竟作为一个程序员，我提供的价值只是开发和维护项目，这是我的核心业务能力。但是它并不够稀缺，只要有更便宜的人力出现的时候，我随时都可以被替换掉。不由地想起了最近又火起来的「内卷」这个概念。但是，这个行业真的内卷了吗？我觉得从定义上看并不算是，因为高级人才始终稀缺，而且大部分人仍有进步、改善自己的空间。只不过对某些进入中年的人来说，的确，环境不那么友好了。但是正因如此，我们才更要有危机意识，年轻的时候不要随大流，也不要放弃自我成长，即使发现自己不适合这个行业，也要尽早通过努力去发现真正适合自己的事业。</p><p>想到前不久摘抄的一句话：<strong>To deeply and consciously know and trust what makes you different. You have to find your own rainbow to follow. There is no gold at the end of somebody else’s rainbow.</strong></p><h4 id="11-月-3-日-大胆地表达出你的想法"><a href="#11-月-3-日-大胆地表达出你的想法" class="headerlink" title="11 月 3 日 - 大胆地表达出你的想法"></a>11 月 3 日 - 大胆地表达出你的想法</h4><p>昨晚跑完步，回小区的路上尝试着自言自语，我发现在大脑中和自己对话和组织语言把想法说出来是两件完全不同的事情。因为大脑会自动给你的想法润色，让你忽略了很多细节，而当你真正用语言把自己想表达的东西说出来的时候，才会发现自己并不能非常清晰地把自己的想法表达出来。这也让我更加意识到，当众演讲之所以困难，其实不仅仅在于要鼓起勇气以及克服羞怯感，更在于你要学会如何更好地组织语言，把你大脑中的想法用最合适的、口语化的语言表达出来。所以，不要去嘲笑那些当众发言的内容让你觉得有点 low 的人，如果是你去做，你表现得可能比他们还差。这也是为什么我们应该在平时尽可能多地与人沟通，建立自如表达自己想法的能力。一开始总是会觉得困难，但是只要多尝试，总会有进步的。</p><p>大胆地说出你的想法吧，毕竟，你有什么好害怕的呢？</p><h4 id="11-月-4-日-Express-yourself"><a href="#11-月-4-日-Express-yourself" class="headerlink" title="11 月 4 日 - Express yourself"></a>11 月 4 日 - Express yourself</h4><p>最近看到一个有趣的思维游戏：对人类文明而言，最重要的发明是什么？答案不是蒸汽机，也不是交流电，而是语言。智人有30万年的历史，但是直到5到10万年前语言出现之后，才开始快速扩张，并且取代了地球上所有的其他人种，发展出农业文明、工业文明，开始慢慢向I型文明靠近。智人和现代人类在智力和身体构造上的差异非常小，如果语言早10万年出现，那么我们这个时间点下所处的社会会是什么样？</p><p>语言及文字让我们的知识和经验得以快速传播，而互联网让每个人都成为一个节点，如果我们把整个人类的知识都看成一个整体，那么只要你没有把自己通过各种途径获得的知识、经验表达出来，那你就阻断了信息在整个网络中的流动，而这最终损害的将是所有人的利益。</p><p>另外，不要害怕自己的表达没有价值，因为表达的类型多种多样，不一定非得是创新的思想，也可以是你日常生活、工作中的思考，只要对他人有启发，能提升他人生活的幸福度，哪怕只是很小的一部分人，那也是有意义的，因为你造成的影响会累积和扩散。</p><p>除了追求更好的生活品质以及更丰富人生体验之外，我们还需要人生的意义感，而表达自我以及寻求与他人的连结就是最好的建立人生意义感的工具。</p><h4 id="11-月-5-日-做你想做的事"><a href="#11-月-5-日-做你想做的事" class="headerlink" title="11 月 5 日 - 做你想做的事"></a>11 月 5 日 - 做你想做的事</h4><p>我们有时候很容易陷入自我怀疑，比如我做的事有什么价值，我说的话能对他人造成什么影响等等。但是，只要我们确定做的是自己想做的事，并且对提升自己的能力有帮助，那么就应该去做。你要有自己的判断，而不是根据别人的看法来决定自己应该怎么做。当然，不是说他人的意见就完全不重要，因为我们生活在一个与他人紧密联系的世界中，所以有时候还是要根据他人的看法，对我们的行动进行调整。但是，千万不要让他人的想法阻碍了你，你的思考和行动应该完全根据自己的需要来进行，你是一个独立的个体，你要有自己独立的思考，没有人能替代你做这件事，始终要记住这一点。</p><h4 id="11-月-6-日-抛弃刻板印象，接受与人沟通时的不确定性"><a href="#11-月-6-日-抛弃刻板印象，接受与人沟通时的不确定性" class="headerlink" title="11 月 6 日 - 抛弃刻板印象，接受与人沟通时的不确定性"></a>11 月 6 日 - 抛弃刻板印象，接受与人沟通时的不确定性</h4><p>我们在和他人沟通的时候，要小心自己那些先入为主的观念。我们通常会受到一些刻板印象的影响，有些刻板印象是我们所处的社会以及文化带给我们的，而有些则是在我们的成长过程中逐渐形成的。每个人的经历不同，形成的刻板印象也有些许差异，这导致我们对相同一个人或者一件事的看法可能产生很大的差别。</p><p>与他人沟通时，我们应该不带任何偏见，并且抛弃掉过往的经验，把自己和对方的交流当成一次全新的体验。<strong>你的态度会影响到他人</strong>，不要凭借经验就假定对方如何如何，也不要去猜测他人会做出何种反应，只要你真正把自己投入到这次谈话之中，那么他人任何的反应都将是你学习的机会。坦然接受与陌生人沟通时可能出现的不确定性，你就能做到和任何人自如地沟通了。</p><h4 id="11-月-7-日-不要读别人推荐的书"><a href="#11-月-7-日-不要读别人推荐的书" class="headerlink" title="11 月 7 日 - 不要读别人推荐的书"></a>11 月 7 日 - 不要读别人推荐的书</h4><p>如何判断一本书是否值得自己阅读？阅读之前首先要问问自己：我期望通过阅读这本书解决我的哪些问题？它能给我的生活带来哪些帮助？它是否能让我生活得更加幸福，比如提升我的认知水平，加深对自己以及这个世界的认识，使我的心智得到增长，使我的人生态度更加积极、乐观。或者，它是否能够提升我某一方面的能力，比如增加我的专业知识和技能水平，提升我的人际关系处理能力、财务管理能力，让我能更高效地工作，或者养成更多有益的生活习惯，等等。如果只是看了别人推荐就去阅读，而不去思考这本书是否适合当下的自己，最终可能会发现你只是浪费自己的时间而已。</p><h4 id="11-月-8-日-孩子在哪长大更好？"><a href="#11-月-8-日-孩子在哪长大更好？" class="headerlink" title="11 月 8 日 - 孩子在哪长大更好？"></a>11 月 8 日 - 孩子在哪长大更好？</h4><p>昨晚去外婆家玩，路上和老姐聊到农村孩子和城市孩子的区别，然后说到她和包哥达成一致的问题是：如果他们以后有了小孩，一定要让孩子在城市长大。我问为什么，我们自己不就是在农村长大的吗？她说可是你不觉得我们和城市长大的孩子的确有些不一样吗？（她指的是城市里长大的孩子更加能说会道，比如从小就会英语，接触、见识过的东西也更广。）其实我觉得她提到的这些，更本质的还是家庭教育的问题。如果父母受教育程度高，眼界开阔，思想开明，同时经济实力也足够强，能让孩子从小接触到各种各样的新事物和新环境，学会与各种不同类型的人打交道，那么，这样的孩子在哪里长大其实都可以成长得很好。</p><p>在农村的长大的孩子唯一让我觉得有劣势的是教育环境。即使家庭教育做的再好，农村的学校教育一定是远远比不上城市的。学校的环境还决定了你能接触到什么样的同学和老师，同学、老师的影响虽然比不上父母，但是也能左右一个人的成长。而且仔细想想，我觉得有能力的父母可能绝大多数都会选择生活在大城市里吧。因为大城市除了能提供更好的教育环境之外，往往还意味着更多的工作机会，更好的医疗条件，种类更多、更好的服务以及各种各样的娱乐方式，最重要的是<strong>聚集了更多优秀的人</strong>。即使大城市有很多缺点，比如生活成本相比农村高得夸张，空气质量更差，交通拥堵等等，但这些都不足以让人产生逃离城市的想法，即使有，也只是一瞬间而已。所以，对大多数人而言，在大城市完成养育下一代的职责依旧是最好的选择。</p><h4 id="11-月-9-日-克服对贫穷的偏见"><a href="#11-月-9-日-克服对贫穷的偏见" class="headerlink" title="11 月 9 日 - 克服对贫穷的偏见"></a>11 月 9 日 - 克服对贫穷的偏见</h4><p>每个人都有偏见，我觉得自己最大的偏见就是对于贫穷的看法，觉得穷是原罪以及穷是可耻的。没错，贫穷给人带来的影响是巨大的，它会改变一个人的世界观以及看待事物的方式，它会影响到一个人与周围人的相处模式以及对自身的认知。不过，贫穷虽然会让人觉得心酸、讨厌、不舒服，但是它归根结底只是一种状态而已，如果我们能改变自己的心态，穷也能成为一种促使自己不断进步、不断向前的动力。</p><p>以我自己为例，从小在农村长大，小时候虽然并没有觉得我们家比别人家穷，因为我能接触到的无非是亲戚邻居等，大家的家庭条件都相差不大，有时候甚至会觉得和村里的有些家庭一比，我们家的条件算是不错的了。但是随着慢慢长大，接触到更多的同学和他们的家庭之后，才发现自己家和别人家不一样的地方。尤其是上了高中之后，发现他们喜欢看的动漫，喜欢玩的游戏，不少都是我之前没有接触过的，包括有些同学用的电子产品，比如 iPod touch 之类的，我之前从来都没听说过。还有和人聊天的时候，看到他人侃侃而谈心里总会有些羡慕，尤其是每次轮到自己发言的时候，心里都会害怕自己会说错话，害怕暴露出自己不知道大家都知道的某些「常识」。甚至是在大学毕业、工作多年之后的现在，自己依旧会有这样的心态，有时候会觉得自己表达的东西太过「幼稚」。而且和那些家庭条件比自己优渥的人聊天的时候，声音都会变小，也不敢说出自己内心真实的想法，总是害怕会受到他人的嘲笑，也不愿意主动发起聊天，就算聊到了自己感兴趣的话题，也不敢完全说出自己的心里话，总是会有所保留。</p><p>一个人身上体现出的这些「穷」的痕迹很容易被观察到。但是只要意识到，贫穷带给我们的伤害，更多的是由我们自己的想法和偏见造成的。那么，摆脱这些负面的想法，接受自己的过去，做真实的自己，就不是一件太困难的事了。</p><h4 id="11-月-10-日-Play-by-the-rules"><a href="#11-月-10-日-Play-by-the-rules" class="headerlink" title="11 月 10 日 - Play by the rules"></a>11 月 10 日 - Play by the rules</h4><p>昨晚参加了一场线上面试，除了技术部分面得一塌糊涂之外，感觉还行😅。基本每次面试都是裸面，也难怪每次面完都会觉得受打击。这次面试结束之后我也在反思，到底应该不应该去记那些每次面试都会问到的问题，比如性能优化，常见的设计模式等等。我真的很反感去死记硬背这些东西，但是不去刻意地记一记的话又很难通过面试，或者给面试官留下一个好印象。也许是自己心态不对吧，you need to play by the rules，既然选择了这个行业，那就按照行业内的规则来玩，如果有固定规则的游戏你都玩不好，那还怎么去玩没有规则的、自由竞争的开放世界游戏？所以，下次面试前，一定要多花点时间准备。</p><p>另外，不要害怕面试通不过，每次面试都是一次学习的机会，面试之后总结经验，查漏补缺，发现自己做的不好的地方，再进行针对性地练习、纠正就好了。而且你要相信自己，毕竟一直都算是独立开发，要论开发和解决问题的能力，应该是足够应付绝大多数的场景了。所以，没什么好怕的，哪怕被问到自己不了解的技术细节，不会的地方就直接说不会就好了。知道自己是一个终身学习者，并且还有进步的空间，就够了。</p><h4 id="11-月-11-日-不要把自己限定在一个角色之内"><a href="#11-月-11-日-不要把自己限定在一个角色之内" class="headerlink" title="11 月 11 日 - 不要把自己限定在一个角色之内"></a>11 月 11 日 - 不要把自己限定在一个角色之内</h4><p>我们每个人都有自己的角色，尤其是在一个特定的场景下的时候。比如在公司的时候，我是一个开发人员，那我就应该是沉默寡言、不苟言笑的，甚至看上去有点木讷也是正常的。但是，我们应该问问自己，是否一定要接受这样的设定。有时候尝试扮演一下他人的角色，往往能够体验到更多的乐趣。</p><p>这种角色的切换包括职位上的，比如从测试的角度，从技术经理的角度，从技术副总的角度来思考问题。还有性格角色方面的转换，比如现在大家对你的印象是不爱交谈、不够热情的人，那你可以尝试改变一下，向某个外向的同事学习，主动和人聊天，主动引起话题，主动帮别人做一些你力所能及的小事，主动赞美他人，等等。当然，你的角色转换也可以是反过来的，比如从话唠到只听不说等。通过这样的角色转换，你不但能得到一段全新的体验，改变他人对你的印象，而且也能挖掘出自己的潜能，发现更多的可能性。</p><h4 id="11-月-12-日-找到你的独特之处，做别人做不了的事"><a href="#11-月-12-日-找到你的独特之处，做别人做不了的事" class="headerlink" title="11 月 12 日 - 找到你的独特之处，做别人做不了的事"></a>11 月 12 日 - 找到你的独特之处，做别人做不了的事</h4><p>有时候在想，虽然以自己目前的能力，还不足以进入大公司，哪怕跳槽可能也只是在中小型公司里做开发，但是我很享受自己目前的状态。工作不会占据生活的全部，压力也不算太大，每天下班之后可以有时间看书、玩滑板、跑步等，能早早上床睡觉。工作之余有大把的时间，哪怕用来发呆什么事都不干，心里也不会有负罪感。不过，安逸会毁掉一个人的上进心，年轻的时候还是尽量多努力一点才好，不然等年龄增长，那时候的压力会更大吧。</p><p>有时候也会迷茫，自己到底适不适合做开发，因为觉得自己似乎并没有持续精进下去的动力，而且也谈不上有多热爱编程。但除了编程以外，又找不到自己更擅长的事了。最近看到很多言论说要<strong>找到自己独特的地方</strong>，去做其他人做不了的事，比如你的几个技能交界点处的事情。而我的技能似乎比较单一，除了写代码和还算过得去的英语能力，其它几乎没了。既然如此，那就先把这两样事情做到 95% 好吧。</p><h4 id="11-月-13-日-拥抱变化，相信结果会越变越好"><a href="#11-月-13-日-拥抱变化，相信结果会越变越好" class="headerlink" title="11 月 13 日 - 拥抱变化，相信结果会越变越好"></a>11 月 13 日 - 拥抱变化，相信结果会越变越好</h4><p>人生唯一可以确定的就是不确定性。我们在面对选择的时候难免会纠结，会评估选择之后的结果，然后还得考虑各种潜在的因素会给自己的生活带来哪些或好或坏的变化。但是，如果你让自己一直保持在确定之中，失去的会更多，因为你放弃了尝试更多可能性的机会。<strong>不要追求稳定</strong>。大多数变化，只要是你经过深思熟虑之后做出的决定，那么，大胆拥抱它就好了。很多时候往往是那些想象出的困难阻碍了我们的行动。要相信自己的判断，哪怕做出的选择不是最合适的，但只要我们始终不放弃心中的信念，<strong>坚持改变</strong>和让自己<strong>不断进步</strong>，那么最终结果一定是朝着越来越好的方向发展。</p><h4 id="11-月-14-日-学会项目管理"><a href="#11-月-14-日-学会项目管理" class="headerlink" title="11 月 14 日 - 学会项目管理"></a>11 月 14 日 - 学会项目管理</h4><p>今天刷推看到一个有趣的言论，每个人最重要的能力是<strong>项目管理</strong>能力。无论是学习新技能，还是选择何种生活方式，其实最终考验的都是你的项目管理能力。设定进度表，确定自己要做哪些事情，以及定期检查自己的完成状况，所有的事情都可以通过项目管理的方式来进行。哪怕是「如何度过自己的人生」这样的话题，也可以根据项目管理的思想来运作，比如根据你个人最看重的价值观制定出适合自己的目标，然后确定目标的优先级，决定如何分配你的时间，养成合适的习惯，哪些事情应该多做，哪些事情应该少做。接着，还可以将人生目标继续拆解，然后用同样的逻辑对小目标进行管理。哪怕人际关系也是一样，和人聊天的时候，首先确定目标，然后向对方提出具体的问题或者说出你的观察，得到反馈后进一步提问，就这样一步步建立起彼此的联系。突然觉得有必要买本项目管理的书来看看了😆。</p><h4 id="11-月-15-日-孤独以及与人沟通要注意的地方"><a href="#11-月-15-日-孤独以及与人沟通要注意的地方" class="headerlink" title="11 月 15 日 - 孤独以及与人沟通要注意的地方"></a>11 月 15 日 - 孤独以及与人沟通要注意的地方</h4><p>人年轻的时候更容易感到孤独吧，尤其是像我这样单身又不怎么会交朋友的人。但是，一个人要像一支队伍。做好自己该做的事，有目标，有规划，这样应该能减轻一大部分的孤独感。忙起来就没时间去自怨自艾了。另外，还要学会主动寻找和自己有同样目标或者相似兴趣爱好的人。只要待人真诚善良，加上积极主动，那你就不会一直一个人下去。</p><p>我们都只是普通人而已，没必要觉得自己高人一等或者要匍匐在他人的脚下，交流中平等才是第一位的。展现真实的自己，表达你的所思所想。如果你觉得你说出的话会让自己或者他人感到尴尬，那么很有可能你并不是真的这么想，或者并没有从心底里认同这些想法。只要你不是抱着自己绝对正确的态度，那么就没有什么东西是不可以和人讨论的了。还有最重要的一点，要保证谈话的氛围是轻松愉快的。这要求你不要急于表现自己，因为对别人来说你知道什么其实并不重要，甚至你能传递多少有价值的信息给他人也不重要。如果对方不喜欢和你对话，只是想尽快逃离，那么你们的有效沟通也就结束了。</p><h4 id="11-月-16-日-又一次滑板摔跤"><a href="#11-月-16-日-又一次滑板摔跤" class="headerlink" title="11 月 16 日 - 又一次滑板摔跤"></a>11 月 16 日 - 又一次滑板摔跤</h4><p>昨天下午去文化村玩滑板，回来的时候走错路口，进入了去酒店的路，心想既然过来了那就进去探索下吧，没想到悲剧就从这里开始了。从酒店的西北停车场出来有很长的一个坡道，心想：这里没车，路况也很好，滑下去应该没啥问题吧。结果立马打脸了，下去之后才发现一个坡道到底之后还有另外更长更陡的一个坡，而这个坡到底之后是一个急转弯道。等我看到弯道的时候，再想刹车已经来不及了。当时速度已经非常快，尝试用脚刹把速度减了一点下来，但是已经没什么用，因为弯道太急，然后又不会横刹，所以最终只好用手刹了，所幸没有脸刹。</p><p>那一瞬间大脑一片空白，完全不知所措，只能任凭本能行动。事后回忆，自己是往左边摔下去的，左肩和左手重重砸到地面上，然后本能地想要用两个手掌支撑住身体。结果两个手掌都破了口子，左手肘更是一片狼藉，最严重的是右手腕，由于支撑的角度问题，有可能伤到了韧带，并且明显感觉到使不上劲了。确认了一下自己身体其它部位没啥大问题而且还能走路之后，第一反应是赶紧离开这里，因为边上有很多人，觉得太丢脸了。</p><p>最让我觉得沮丧的是，除了一对父女一直远远地在看着我，然后在我经过他们身边的时候提醒我说赶紧去处理一下伤口之外，边上的其他人根本就当作什么都没发生过一样。不过，还好之前来过这里一次，比较熟悉，于是赶快走到酒店健身房，先去卫生间用水清洗了一下伤口，然后去求助酒店工作人员，他给我手上的几个伤口涂了一些碘伏，这个时候才发现原来左腿膝盖也摔出了一个口子，裤子也破了洞。</p><p>回小区之后，去附近药店，医师帮我清理了伤口，疼得不行。这个时候才意识到自己这次真的摔得有点严重了，右手腕开始肿胀，已经无法自如弯曲，两个手掌和手肘伤口很深，不知道会不会留下伤疤。医师一如既往地提醒我说有可能骨裂，最好去医院拍个片子，但是我说我不想请假，还是等明天看看能不能消肿，实在不行再去医院。</p><p>晚上回来后，本来要出去跑步的，结果计划也泡汤了。有点怀疑接下来几周之内还能恢复到以往的状态吗？现在连生活自理都困难。和老妈视频也不敢告诉她自己摔跤了，只能装作一切都很好的样子。在想如果以后我有子女了，他们也会这样吗？才 10 点多就上床睡觉了，但是一晚上睡得并不好，凌晨 3 点多的时候醒来一次，口渴，手肘流出了很多血水，手腕也很疼，于是起来在手腕上贴了块活血止痛膏。早上醒来情况似乎也没有好转，但是还是在犹豫中挣扎着起床了。</p><p>早上去公司，来了个新的运营同事，长得挺好看的一个大姐姐。因为手腕疼，今天一天都不怎么在状态，看公众号文章，集成了友盟推送，测试完毕，划水，下午得知后端用的个推，于是又集成了一遍个推，测试，和 UI 确定了通知栏 icon，看完了 David Perell 的文章 <a href="https://www.perell.com/blog/the-price-of-discipline">the price of discipline</a>，到点下班。下班后想去医院拍个片子的，去问了才知道他们已经下班了拍不了。出来的路上，看到商铺门口有人在打羽毛球，街上人群来来往往，有一种全身被孤独感包围的感觉。</p><p>回来后把手上的创可贴和无菌贴都给拆了，发现伤口有点发白，觉得还是应该保持空气流通，让伤口与空气接触慢慢结痂之后好得快一些。然后坐在椅子里看了一会儿书，发现看不太进去，于是开始刷手机、看视频。到 8 点多，回家结婚的室友回来了，给了我一包糖，拆开一看，头一次看到还有在喜糖盒子里面放瓜子花生的。然后和领导请了明天一天假，接着就坐在椅子里刷 Youtube，直到 10 点多才去洗澡。洗澡的过程是最痛苦的，右手手腕不能用力，左手手掌有伤口，一接触泡沫就疼得不行。于是只能用左手擦肥皂，再用右手轻轻擦洗。好在人的痛感也容易疲劳，慢慢适应之后就觉得疼得也不是那么厉害了。花了比平时多一倍的时间才洗完澡，而且还是在并没有洗的太仔细的情况下，之后吹头发也折腾了很长时间。</p><p>此刻坐在懒人椅里，打着字的时候还能隐隐感觉到身体各个部位传出的感觉，疼痛、不舒服、肌肉紧张。这就是为什么只有病人才最懂得健康的意义，好好爱护自己的身体吧。经过这一遭，也算是给自己提个醒了，凡事三思而后行，鲁莽和不计后果往往只能带来伤害和毁灭。</p><h4 id="11-月-17-日-传递好观念"><a href="#11-月-17-日-传递好观念" class="headerlink" title="11 月 17 日 - 传递好观念"></a>11 月 17 日 - 传递好观念</h4><p>早上去医院看了骨科，拍了片子，才发现原来真的骨折了，诊断书上写的是「骨皮质中断」，总之就是桡骨裂开了一点点口子，医生给我上了膏药，夹了夹板（看的中医骨科），说是多休息别乱动差不多一个月能恢复。回来路上，想到自己居然某一天也会把手臂挂在胸前走在大街上，就忍不住觉得好好笑。</p><p>中午吃外卖的时候，看了一个视频，纪录片导演李一凡的一席演讲<a href="https://www.youtube.com/watch?v=j7vsG4Metvc">我拍了殺馬特</a>，才发现原来杀马特的生活是那样的。我们习惯带着偏见看待那些和我们不同的人，但是只有等到你真的了解了一个群体的生活之后，你才会发现最可笑的其实是你自己。一直自诩思想开放、包容，但是对于那些你甚至没有尝试去了解过的群体，却会形成这样深刻的偏见。</p><p>还有就是感到自己是多么的幸运。虽然同样在农村长大，但是至少从小爸妈都在身边，家庭条件算不上是富裕，但是至少从来不愁吃穿，也能得到除父母之外的其他长辈的关爱。相比那些留守家庭长大的孩子，父爱母爱的缺失，早早辍学外出打工，最终和父母走上同一条道路，他们的生活才是真的无望和贫乏到了极点。</p><p>不过，自己作为一个普通人，也无力去改变这种现状。即使是放到现在，被穷困和贫乏侵扰的人群的数量依旧很庞大。我们作为社会的一份子，能做的只不过是多一点宽容，允许他人选择他们自己的生活方式，不要用有色眼镜去评判那些和我们不同的人。还有就是要好好努力，创造价值，传递好观念。你只能影响到你身边的人，但是你的影响会累积和扩散，最终会有越来越多的人因为你传递的价值观而受益。</p><h4 id="11-月-18-日-做个容易知足的人"><a href="#11-月-18-日-做个容易知足的人" class="headerlink" title="11 月 18 日 - 做个容易知足的人"></a>11 月 18 日 - 做个容易知足的人</h4><p>昨天下午坐得太久，于是出门走了走。出了小区，基本上是漫无目的地闲逛，经过一个路口哪边先绿灯就走哪条路。耳机里放着故事 FM，边走边听。经过商场的时候，进去找地方休息了一会儿。工作日商场里基本只有大妈和带娃的妈妈们。看着那些玩得不亦乐乎的小孩子们，觉得自己的心情也变得特别好，尤其是在听了那么多人讲的故事之后。</p><p>活着真好呀，只要有一个健康的身体，能自食其力，那就没什么可抱怨的了。如果还能找到自己喜欢做的事以及喜欢的人，然后每天和她聊聊自己今天做的事以及彼此的心里话，那么生活该是多么的幸福。</p><p>越来越觉得容易知足也是人生幸福的关键之一。</p><h4 id="11-月-19-日-给自己创造一个改变的环境"><a href="#11-月-19-日-给自己创造一个改变的环境" class="headerlink" title="11 月 19 日 - 给自己创造一个改变的环境"></a>11 月 19 日 - 给自己创造一个改变的环境</h4><p>突然意识到今天居然已经礼拜四了，时间过得好快。这几天手上夹着板子，对生活还是造成了一点不便的，最明显的当然是凡事都只能用左手了。左手开门，左手洗脸，左手刷牙，左手拿一切东西。发现自己的适应能力还真的蛮强的，本来以为会一直固定不变的习惯，几天之内就可以被改变。所以在想，那些声称自己无法坚持、无法改变自己习惯的人，也许只是少了一个足够强烈的动机吧。如果给自己创造出一种不得不去做的环境，那么任何习惯都是可以慢慢被改变的。对我自己来说，我也有了一个新的顿悟，那就是尽管去做自己想做的事情，其实困难并没有你想象得那么大。给自己设立一个挑战：每天尝试被陌生人拒绝一次。</p><h4 id="11-月-20-日-冥想对我的意义"><a href="#11-月-20-日-冥想对我的意义" class="headerlink" title="11 月 20 日 - 冥想对我的意义"></a>11 月 20 日 - 冥想对我的意义</h4><p>冥想是过去几个月以来我一直想要养成的习惯。冥想能让我放空自己的大脑，发现自己心底最隐秘的想法。每当冥想进入状态的时候，我都觉得自己的大脑和身体会相互脱离，我能以一个第三者的视角来观察坐着的这个人。当那些让他觉得或恼怒或羞耻或后悔的事情在大脑中一闪而过的时候，我能体会到这些情绪的来源是什么，可能和他的哪一次经历或者哪一个人给他造成的影响有关。然后慢慢地，我觉得没有人能够比我更理解他。他过去的经历造就了现在的他，而我此刻只是一个观察者。我能够用更全面的视角，帮他理清所有事情的来龙去脉，帮助他扫除他眼前所有的困难和障碍。</p><p>如果以后我也能开自己的公司的话，我一定会设置一个冥想室，让所有员工随时都有地方冥想，通过冥想理清思路，工作效率也一定大幅提升。但是，注意到自己这两天都没有早起冥想，起床后上厕所洗漱完，写完碎碎念，再整理下东西，提醒出门的闹钟就响了。可能还是自己太磨蹭了吧。所以，为了有足够的时间冥想，那就只能再早一点起床了。这意味着我晚上上床睡觉的时间必须再提前一点，那么以后就 10 点半之前上床睡觉吧。</p><h4 id="11-月-21-日-懂得感恩的人更容易幸福"><a href="#11-月-21-日-懂得感恩的人更容易幸福" class="headerlink" title="11 月 21 日 - 懂得感恩的人更容易幸福"></a>11 月 21 日 - 懂得感恩的人更容易幸福</h4><p>心怀感恩，更容易感到幸福，我们要学会感谢他人的付出。很多时候，我们都习惯了抱怨，抱怨自己没有别人的好运气，抱怨他人拥有比我们更为优渥的条件。习惯抱怨之后就会忘记自己有多幸运。回想一下，我们的命运经常是在一瞬间被改变的，由于大学里上的某堂课，由于机缘巧合接触到的某方面资料，由于工作认识的某个人等等。如果没有那些偶然发生的事件，我们可能走不到今天。如果没有那些无私帮助、点播过我们的陌生人，我们就不会成为今天的自己。所以，我们应该也必须学会感恩，感谢那些为我们默默付出的普通人。同时也要感恩自己此刻拥有的一切。只有当你学会去回顾以及欣赏自己以及拥有的东西之后，你才会懂得珍惜，也更能体会到它们的价值。</p><h4 id="11-月-22-日-勇敢做自己"><a href="#11-月-22-日-勇敢做自己" class="headerlink" title="11 月 22 日 - 勇敢做自己"></a>11 月 22 日 - 勇敢做自己</h4><p>不要害怕被他人评判，勇敢做自己。我们每个人生来都不完美，因此每个人内心深处都有自卑的一面。自卑是因为觉得自己有提升的空间，所以自卑其实也不是完全负面的东西，如果利用好也是有利于我们的个人发展的。我们要意识到，那些已经在自己身上发生的事情都属于过去，而且也只能代表过去的我们，对我们来说将来还未发生的事才是真正重要的。所以，不要沉湎于过去，也不要对他人为你的过去打上的标签而耿耿于怀。你需要做的，只是去接受事实，承担起自己的责任，做好眼前的事，按你心中的计划打造出你想要的未来。没有人比你更了解你自己，你需要的只是接纳过去的自己，相信此刻的自己，并且对未来的自己满怀期待。要始终按照你内心的想法去生活，而不是轻易被他人的想法改变。</p><h4 id="11-月-23-日-Slowly-信件"><a href="#11-月-23-日-Slowly-信件" class="headerlink" title="11 月 23 日 - Slowly 信件"></a>11 月 23 日 - Slowly 信件</h4><p>今晚花了很长的时间在 Slowly 回了一个网友的信。通过网络和完完全全的陌生人真心地去沟通、表达自己的观点真的是件很奇妙的事，希望她能接收到我的善意。</p><h4 id="11-月-24-日-改变只能靠自己"><a href="#11-月-24-日-改变只能靠自己" class="headerlink" title="11 月 24 日 - 改变只能靠自己"></a>11 月 24 日 - 改变只能靠自己</h4><p>人只能靠自救，只有你从心底想要改变，改变才有可能发生。说过很多次改变自己的话题，但是我觉得自己始终没能迈出那一步的最根本的原因还是：内心并不是真的想要改变。总是每次往前试探着迈出一小步，觉得不太舒服，于是又把腿给收了回来。想要让自己真正发生改变，首先要得从内心接受自己的全部。我不喜欢我现在的生活，我想要我的生活发生一些变化，我想要认识更多有趣的人，想要去做自己真正热衷且能让自己感到自豪的事情，我想要能和更多人自由地分享我的想法，并且获得他人的理解和认可。但是，为了做到这些，我首先要走出自我封闭的牢笼，主动寻求与他人连结，向他人暴露自己的弱点，去不断地尝试，不断地寻找，不断地碰壁，不断地督促自己进步。只有当确定自己愿意承担这些的时候，才能证明自己已经做好改变的准备了。</p><h4 id="11-月-25-日-一个人要像一支队伍"><a href="#11-月-25-日-一个人要像一支队伍" class="headerlink" title="11 月 25 日 - 一个人要像一支队伍"></a>11 月 25 日 - 一个人要像一支队伍</h4><p>昨晚原本想要继续刷算法的，可是回来之后就开始刷手机，刷 YouTube。一边看着别人的 Vlog，一边憧憬着自己什么时候也能过上像他们那样的生活，但是却不想做出任何的改变。人终究是好逸恶劳的动物吧，明明知道自己的目标，也知道应该积极地朝着目标行动起来，养成想要的习惯，改变自己的生活，但是…就是不愿意去做。还是要对自己多一点耐心吧。万事开头难，一旦习惯养成，进步的过程是很快的。要学会自我激励，尤其是像现在这样身边没有人鼓励自己的情况下，一个人要像一支队伍。</p><h4 id="11-月-26-日-Make-your-plan"><a href="#11-月-26-日-Make-your-plan" class="headerlink" title="11 月 26 日 - Make your plan"></a>11 月 26 日 - Make your plan</h4><p>感觉自己最近又陷入了焦虑和自我怀疑的陷阱。前几天刚看完一篇文章讲 Mental Mastery，里面提到改变的 10 个阶段，Motivation &gt; Minor deviation &gt; Socialization &gt; Reality settling in &gt; Re-motivation &gt; Bargaining &gt; Doubt &gt; Embarrassment &gt; Denial &gt; Resignation，几乎可以完整地看到自己是如何一步步经历这些阶段的。现在频繁在 4、5、7 之间摇摆，但是还没到 8，偶尔会想到 9，不过清楚地知道 10 不可能是自己的最终选项。</p><p>晚上看了不少文章，也去论坛上搜了相关的讨论，似乎找到了自己的问题所在。现在目标有了，也知道了自己应该在哪些方面进行改进，接下来就是制定计划以及如何督促自己去有效地实施计划的问题了。所以，有问题的时候，尤其是大脑里想法很多、很乱的时候，把遇到的问题写下来，对自己的思考真的很有帮助。</p><h4 id="11-月-27-日-保持情绪稳定"><a href="#11-月-27-日-保持情绪稳定" class="headerlink" title="11 月 27 日 - 保持情绪稳定"></a>11 月 27 日 - 保持情绪稳定</h4><p>很多时候，看到那些工作或者学习效率很高的人，心里都会很羡慕他们。因为他们似乎不会被外界环境影响，哪怕遭到不公正对待，或者遇到不好的事情，他们依旧能守住自己的节奏，保持冷静以及对事态有一个清醒的判断。反观自己，常常受到一些负面情绪的影响，于是工作心不在焉，也无法静下心来学习，大脑里的思绪仿佛乱成一锅粥，老是忍不住去东想西想，最后导致自己浪费了大把的时间。</p><p>所以，怎样训练自己让自己能保持情绪稳定呢？首先要增加自己的阅历，见的人和事多了，自然就不容易自乱阵脚。其次，还要学会保持内心的平衡，实事求是地分析眼前的这个问题，把它当成是对自己的一种挑战，想办法解决问题而不是想着逃避。另外，实在解决不了的时候也要学会放弃。最后，还是老生常谈的那句话：养成好习惯。健康饮食、充足睡眠、勤于锻炼、冥想、阅读、写作，这些基本的习惯养成了，你的生活态度一定不会太差，至少整个人的面貌会是积极、乐观、向上的。只有这样，当遇到问题的时候，你才有动力和精力去解决问题，而不是立马就崩溃。</p><p>慢慢来吧，毕竟自己还年轻，还有很多东西需要学习，经常反省自己，不断改进，总归是会一点点做得越来越好的，要对自己要有信心！</p><h4 id="11-月-28-日-多站在他人角度思考问题"><a href="#11-月-28-日-多站在他人角度思考问题" class="headerlink" title="11 月 28 日 - 多站在他人角度思考问题"></a>11 月 28 日 - 多站在他人角度思考问题</h4><p>反思了一下为什么自己身边的朋友很少，最主要的原因还是习惯性地以自我为中心，大多数时候都在想怎么让自己开心，让自己舒服，或者太爱表现自己，希望得到他人的赞赏和崇拜。但大多数人其实并不在乎你有多么厉害，别人在乎的是你能给他们带来什么。你能让他们在和你相处的这段时间内感到开心快乐吗？你能给他们提供哪些有趣的、有价值的信息？或者带来哪些实际上的利益？另外要记住，和实用价值相比，情绪价值同样重要，而且在某些场景下可能显得更为重要。如果常常往这方面思考，你会发现你身边的人都会越来越喜欢和你相处，那你自然就不用担心没有朋友了。</p><h4 id="11-月-29-日-再谈职业规划"><a href="#11-月-29-日-再谈职业规划" class="headerlink" title="11 月 29 日 - 再谈职业规划"></a>11 月 29 日 - 再谈职业规划</h4><p>如何做职业规划？写下这个话题的时候，我的内心是有点沉重又有点欢乐的。沉重是因为这本身就是一个严肃且对于每个人来说都很重要的话题，感到欢乐则是因为我自己最近正在遭遇这方面的困扰，所以写这个话题有点像自己给自己把脉的感觉。以前觉得职业规划有点遥远，觉得只要是在创造价值，且工作也还过得去（自己喜欢且能获得回报）就行了。另一方面那时候要学的东西太多了，似乎还没到可以思考这个问题的阶段。但是时间过得太快了，如今的我工作也满三年了，所以也是时候好好认真思考下这个问题了：我未来应该往哪个方向发展？</p><p>最近几天一直在思考这个问题，但是也没能得出什么结论。短期的目标无非就是进大公司，当一颗螺丝钉，或者提高自己的技术水平，能 match 到更高的薪资水平，以及做更有挑战性的工作。但是，在这之后呢？更长期的计划是什么呢？从我这几天的表现来看，我开始有点怀疑这条路是否走得通。因为我非常抗拒刷题以及背面试题，这个过程甚至让我对编程都产生了厌恶的感觉。我开始怀疑自己能否一直保持当初那种对编程的热情。当然，我知道我自己的终极目标是什么，那就是创造价值，做出好产品。但是达成这个目标的途径有很多种，并不只有编程这一条路。虽然目前选择了这条路，但是这条路是否就真的适合我呢？不过，如果换跑道的话，似乎也只能往相近的赛道转，比如做设计或者产品，但是自己相关的基础和经验并不多，切换意味着一切又要重新开始，我能承担这样试错的成本以及万一失败后的结果吗？</p><p>虽然没能得出结论，但是至少说明自己意识到问题了，接下来就是找出答案的过程。耐心地思考，然后搜集相关资料，再通过仔细分析自己的优劣势以及倾听内心真正的想法，也许答案就会慢慢浮现出来吧。</p><h4 id="11-月-30-日-做个行动派"><a href="#11-月-30-日-做个行动派" class="headerlink" title="11 月 30 日 - 做个行动派"></a>11 月 30 日 - 做个行动派</h4><p>晚上又反思了很久，觉得自己还是应该继续走技术这条路。老实说，其实之前的那些焦虑以及纠结都来自于我想要逃避学习的痛苦才产生的，而觉得没有热情或者不适合自己都只不过是借口。然而逃避终究是没有用的，该面对的迟早都得面对。所以，还是要老老实实去啃那些难啃的骨头，把自己过去偷懒、耍小聪明欠下的债都给还上，脚踏实地一步一脚印地去慢慢提高自己。</p><p>学习这件事终究还是没那么简单的，如果真的有什么轻松的方法的话，那就不会有人迷茫了。好在自己还年轻，一切都还来得及。而且生活在这个资讯发达的时代，几乎任何问题都可以通过网络获得牛人的解答，剩下的只不过是执行的问题。只要你肯努力，并且愿意通过不断地学习提高自己，那么你就是无敌的了。行动起来吧，没什么好怕的，只要去做就会有反馈，做了之后的迷茫和什么都不做的迷茫，前者甩后者十条街。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>追求幸福</title>
      <link href="/2020-10/"/>
      <url>/2020-10/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/iggmiF7DNoM" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>这个月过得特别漫长，好在时间总是能冲淡一切，加上年轻这个因素，运动几次，睡几个饱觉，看几本好书，一切就又都向着有利于我们的方向发展了。最大的感触是，孤独其实并不是一件多么可怕的事，并且是可以避免的，很多时候都是因为我们太封闭自己了。工作、生活、交友，在这些过程中慢慢成长，我们要敢于表达真实的自我，寻求与他人的连结，也需要去探索生命的意义，找到自己的使命，而最终的目的都是为了生活得更加幸福。</p></blockquote><span id="more"></span><h4 id="10-月-1-日-10-月-8-日：西北大环线之旅"><a href="#10-月-1-日-10-月-8-日：西北大环线之旅" class="headerlink" title="10 月 1 日 - 10 月 8 日：西北大环线之旅"></a>10 月 1 日 - 10 月 8 日：<a href="https://ajiew.me/northwest-road-trip/">西北大环线之旅</a></h4><h4 id="10-月-9-日-旅行的意义"><a href="#10-月-9-日-旅行的意义" class="headerlink" title="10 月 9 日 - 旅行的意义"></a>10 月 9 日 - 旅行的意义</h4><p>昨晚 10 点半到家，这九天过得很充实。这次的旅行让我开始期待下一次的旅行，也许这就是旅行的魅力吧，在路上能看到平时看不到的风景，见到平时见不到的人，做平时不会做的事。今天是休假回来后上班的第一天，希望自己能集中精神。旅行目的之一也是为了帮助自己调整心态，让自己能保持最佳状态继续努力工作，不要忘记这一点。</p><h4 id="10-月-10-日-我-26-岁啦"><a href="#10-月-10-日-我-26-岁啦" class="headerlink" title="10 月 10 日 - 我 26 岁啦"></a>10 月 10 日 - 我 26 岁啦</h4><p>今天是我生日，祝我生日快乐🎂。今年的生日是和同事聚餐中度过的，算是凑巧吧。别人过生日都是和家人朋友庆祝，而我每年的生日基本都是一个人过。听上去挺惨的吧，但其实习惯了也还好。</p><p>对我来说，生日最大的意义在于可以给自己一个设立目标的机会，类似与新年计划。不过我在生日当天许下的愿望或者说订下的计划，更多是和兴趣爱好相关的，比如去年是学会滑板，今年原本想设立学会一项乐器的目标，但是觉得自己未来一年可能没有那么多时间和精力，所以暂时先待定吧。</p><p>即将开启 27 岁的旅程，希望自己不畏将来，不念过往，做好自己该做的事，积极努力地过好每一天。</p><h4 id="10-月-11-日-不是每个人都要登上珠峰"><a href="#10-月-11-日-不是每个人都要登上珠峰" class="headerlink" title="10 月 11 日 - 不是每个人都要登上珠峰"></a>10 月 11 日 - 不是每个人都要登上珠峰</h4><p>有时候觉得，人的一生像是在爬山，一开始我们出生在不同的山脚下，或者在同一座山的不同位置，但是我们的目标都是一样的，那就是登顶。每个人都要先努力征服眼前的这座高山，然后才能看到其它山峰。不过，有的人比较幸运，不但出生在离山顶较近的地方，而且还能提前看到下一座山峰的位置。大多数人都是普通人，我们需要花很多力气，不停地努力，才能保证自己不落后。而且也许穷尽一生的努力可能也无法登顶，更不用说征服下一座山峰了。尽管如此，只要意识到我们每个人都有自己的山峰需要攀登，并且登顶之后仍然有下一座山峰等待着我们去征服，这就足够了。不是每个人都要登上最高的山峰的，因为珠峰只有一座，只有那些出生在大本营的人才应该把珠峰作为自己的目标。对于其他人来说，眼前的这座山峰就是珠峰。只要付出了努力，最后登顶成功的喜悦都是一样的。</p><p>其实想说的只有一个，那就是：不要拿自己的目标和别人比较，只要一直努力下去就好了。</p><h4 id="10-月-12-日-接受天意的安排"><a href="#10-月-12-日-接受天意的安排" class="headerlink" title="10 月 12 日 - 接受天意的安排"></a>10 月 12 日 - 接受天意的安排</h4><p>很多事情本就是非常偶然的，比如精子和卵子的结合，你的初中班主任，你的高中同桌，你的大学室友等等，如果当初某些事件没有发生，也许现在的你完全就不是这个样子了。所以我更愿意相信这是天注定的， 冥冥中上天自有安排。还有一种解释是平行宇宙的理论。每当我们做出一个选择的时候，就会产生另外一个或者 N 个我们做出了其他选择的宇宙。比如如果你同时收到了两个公司 A 和 B 的 offer，你选择了 A，这个时候就会产生一个平行宇宙，在那里你选择了公司 B 的 offer 并且过上了另外一种生活。但是我们毕竟一次只能生活在一个宇宙中，所以做出选择之后，最好就把它当成是自己的最佳的选择，然后努力使其达到最优，而不是去纠结如果当初做了另外一种选择，自己身上会发生什么。这也是「活在当下」的意义所在了吧。</p><h4 id="10-月-13-日-相遇即是缘分，善待你身边的人"><a href="#10-月-13-日-相遇即是缘分，善待你身边的人" class="headerlink" title="10 月 13 日 - 相遇即是缘分，善待你身边的人"></a>10 月 13 日 - 相遇即是缘分，善待你身边的人</h4><p>自从学会主动和陌生人打招呼之后，感觉自己每天上下班变成了一件新奇的事，因为每天路上都能遇到不同的人。过路口的时候，等红绿灯的时候，走在人行道上的时候，只需要简单笑一笑或者点个头，一般就能收到对方的回复，看到对方脸上的表情由冷漠转变为满脸笑容的时候，真的觉得这开启了我一天的好心情。</p><p>如果我们把今天当做自己一生中最棒的一天去过，那么我们的生活将会变得有意思得多。所谓的好人生就是乐观、积极、快乐地过好每一天，认真对待身边的每一个人。这个星球上曾经居住过 1000 亿人，现在也有接近 80 亿人在这个宇宙偏僻一角的小石头上生活着，我们能够恰好出现在这个时空并且遇到彼此，这本来就是一种缘分了。从本质上看，我们都是一样的人，无法选择自己的出生，也不知道自己将在何时离开这个世界，但是既然一同生活在这个星球上，就要让彼此的生命变得更有意义一些。我们的所作所为也许无法惠及太多人，但是至少可以给那些与我们相遇的身边人带去快乐与温暖。</p><h4 id="10-月-14-日-改-Bug-心得"><a href="#10-月-14-日-改-Bug-心得" class="headerlink" title="10 月 14 日 - 改 Bug 心得"></a>10 月 14 日 - 改 Bug 心得</h4><p>这几天一直在改 bug，但是效率不高，一方面是因为刚旅游完回来，不能马上进入工作状态，容易分心；另一方面，发现自己在遇到难题的时候，很容易陷入焦虑、茫然不知所措的状态，并且老是想做一些其它事情来转移注意力，也就是喜欢拖延，结果越拖越焦虑，并且浪费了更多的时间。</p><p>其实办法也有，之前也说过。首先不要被困难吓倒，仔细分析下真正的难点在哪里，然后去相应的地方摸清逻辑。难点之所以难是因为它的逻辑比较复杂，以至于我们不知道该从哪里下手。这个时候可以想象有个虚拟的 pair 对象，然后把自己遇到的问题以及可能的解决方案说给他听，再逐个尝试是否可行。在这一过程中，你会对难点看得原来越清晰，解决方案最终也会慢慢浮出水面。</p><p>还有一个比较重要的点是，要培养自己集中注意力也就是专注的能力。当我们注意力不集中的时候，很容易东想西想，然后被大脑里的各种想法牵着跑，不知不觉就会去做别的不相关的事情了，于是浪费了大把时间。我们要尽量减少让自己分心的事物，比如工作时不看手机，不刷社交网站，控制同时打开的标签页的数量（使用 Workona），还有就是坚持冥想。另外，注意休息也很重要，长时间保持专注人的大脑很容易疲劳，最好每隔半小时眼睛就要离开显示屏一会儿，每隔 90 分钟就站起来走动一下。除此之外，环境也很重要：办公室噪音（戴降噪耳机），显示器位置，你的座椅高度；还有一些不好的习惯，比如你的坐姿，眨眼的频率，双腿如何摆放，平时习惯性的一些小动作等等，都是需要时刻注意并改善的。</p><h4 id="10-月-15-日-做独立的人，只为自己活"><a href="#10-月-15-日-做独立的人，只为自己活" class="headerlink" title="10 月 15 日 - 做独立的人，只为自己活"></a>10 月 15 日 - 做独立的人，只为自己活</h4><p>我觉得作为一个成年人，真正重要的能力是：能在任何地方不靠任何人都能生存下来。一个人只要有这种自信，那么他/她就彻底没什么好怕的了。不用担心自己被他人抛弃，也不用在乎他人对自己的评价，更不用看别人的脸色行事，这才是彻底的自由。但是自由也不是没有代价的，这需要你承受完全独立以及随之而来的所有压力。你需要保证自己的技能或者能提供的价值，在市场上具有足够的竞争力，来获得雇主或者客户的青睐。</p><p>但我觉得这种代价或者压力真的太值得了，因为随着你的技能的提升或者你创造的价值的增加，你的自信心、对工作和生活的热情以及对自己人生的掌控感都会显著地提高，你会更容易感到幸福。希望我们都能朝这种改变迈进。</p><h4 id="10-月-16-日-自由地表达自我"><a href="#10-月-16-日-自由地表达自我" class="headerlink" title="10 月 16 日 - 自由地表达自我"></a>10 月 16 日 - 自由地表达自我</h4><p>中午午睡的时候想到一个问题，我们为什么会在不同场合下采用不同的行为模式？比如有的人线上非常活跃，思维敏捷、妙语连珠、话题不断，但是到了线下却完全变成了另外一个人，变得沉默寡言，甚至给人感觉有点木讷。还有，我们通常在同事面前和在朋友面前会有不同的表现，而在家人面前又变成了另外一副样子。这是因为我们彼此共有的经历不同，关系的亲近程度也不同，这带来了相互间信任程度的差异。</p><p>但是，抛开这些外在条件的限制，我觉得我们始终可以选择自己以何种态度对待他人。比如在和同事相处时，虽然知道 Ta 和我有工作上的利益关系，但那只是一方面而已，我们需要从更深层次意识到，抛开工作内容、职级等条条框框之后，你们都只是一个普通的个体而已。因此，你们可以进行任何和其他陌生人一样坦率而真诚的交流。从这个角度出发，我们就能够更加坦然地进行沟通，而不需要感到有压力，只要专注于表达自己就可以了。不过，拥有这种心态只是第一步，但沟通毕竟是两个人及以上的事，有时候你的自我表达可能得不到有效的回应。但是也不用气馁，总有人会愿意做出回应并且最终被你影响，逐渐踏上自我表达的道路，你只需要和他们结伴就可以了。</p><p>我最终级的目标是：<strong>能够在任何时候、任何场合，自由地表达心中最真实的想法，和他人进行交流。</strong>因为我觉得如果能做到这样，我会变得更快乐以及更享受当下的每一刻。人是社会型动物，在和他人的互动中，我们能感知到自己的生命和他人是紧紧连在一起的，并且能以此认识自己，获得成长。</p><h4 id="10-月-17-日-不去猜测他人的心理，高欲望、低期望"><a href="#10-月-17-日-不去猜测他人的心理，高欲望、低期望" class="headerlink" title="10 月 17 日 - 不去猜测他人的心理，高欲望、低期望"></a>10 月 17 日 - 不去猜测他人的心理，高欲望、低期望</h4><p>昨晚谈到要自由地表达自我，然而现实中却依旧觉得很难做到，无法知行合一。发现自己最大的顾虑是，担心他人会如何对自己做出评价，还有就是害怕得不到期望的反应。之前说过这种心理是非常糟糕的，因为一旦进入了这种被他人审判的视角，我们就再也无法自然、真诚地表达自己了。我们会希望营造出一种让自己符合外界期望的样子，我们说的话不再是自己心里最真实的声音，而是为了迎合他人。</p><p>表达真实自我的要义是，高欲望、低期望，只专注表达自我而不去猜测他人会做出何种反应。你向山谷中喊叫，即使没有人回应也会有回音，而通过这回音，我们能更清楚地听到自己心中最真实的渴望，了解到自己平时都不曾注意到的那一面。</p><h4 id="10-月-18-日-忠于自己的内心，做真实的自己"><a href="#10-月-18-日-忠于自己的内心，做真实的自己" class="headerlink" title="10 月 18 日 - 忠于自己的内心，做真实的自己"></a>10 月 18 日 - 忠于自己的内心，做真实的自己</h4><p>我觉得写碎碎念最大的一个好处是可以记录自己的生活。每当翻看过去写的碎碎念，就能大致回忆起当时自己的状态。如果没有开始写碎碎念，我可能都不知道原来自己可以生产出这么多有意思的想法。而且通过文字表达自己的想法，也提升了我的写作水平。最重要的是，我开始意识到，<strong>要忠于自己的内心</strong>。只有表达出自己的真实想法之后，我们才能进一步加深对自己的了解，认识到自己的优缺点、内心深处的渴望等等，并且学会以良善为准则指导自己的行动，最终在生活中也能表现出最真实的自己。</p><h4 id="10-月-19-日-享受改变的过程"><a href="#10-月-19-日-享受改变的过程" class="headerlink" title="10 月 19 日 - 享受改变的过程"></a>10 月 19 日 - 享受改变的过程</h4><p>今早清晨五点多醒来，还是被个人问题折磨得睡不好。明知道自己不该这么焦虑，但是却又不受控制。既然已经意识到自己需要改变，那就去改变就好了。过去的已经发生，无法挽回，未来才更重要。只要你下定决心，一切都还来得及。你会认识很多良师益友，包括人生最重要的伴侣。从现在起，你需要更乐观积极地去生活，学习新技能，勤于锻炼，保持身体健康，改掉一些坏习惯，养成更多好习惯。活得久才有可能认识更多你想认识的人。保持开放的心态，表达真实的自我，对他人保持兴趣和好奇。至于剩下的，这个世界会如何回应，这就不是我们能控制的了，你只需要享受其中就好了。</p><h4 id="10-月-20-日-遵循宇宙运行之道"><a href="#10-月-20-日-遵循宇宙运行之道" class="headerlink" title="10 月 20 日 - 遵循宇宙运行之道"></a>10 月 20 日 - 遵循宇宙运行之道</h4><p>感恩自己所拥有的一切。当我们觉得不幸的时候，要记得我们当前所经历的，只不过是寻常人都会经历的、极其普通的一个挫折而已。我们会感到伤心难过，但是要及时振作起来，而不是陷入自怨自艾的漩涡之中。人生非常短暂，我们要把时间留给那些值得我们爱并且也爱我们的人，他们是我们存在这个世界上的基石之一。</p><p>尽管如此，我们还是应该看到更大的图景，那就是要爱所有人类，要为全体人类谋福利。更进一步，爱这宇宙万物中的一切。我们从宇宙中诞生，由宇宙提供给我们能量，最终自身所有的元素又将重新分解，回归宇宙。所谓的灵魂只不过是一系列生化反应综合起来给人的假象，但是这假象却是我们存在下去以及始终保持理性的原因所在。宇宙自有其运行之道，我们要心怀敬畏之心，因为我们的所作所为都将成为宇宙彰显其意志的途径。</p><h4 id="10-月-21-日-哲学的本质：追求良善"><a href="#10-月-21-日-哲学的本质：追求良善" class="headerlink" title="10 月 21 日 - 哲学的本质：追求良善"></a>10 月 21 日 - 哲学的本质：追求良善</h4><p>最近在看斯多葛学派的代表作之一的《沉思录》，提倡遵循自然法则，追求人自身的美德，以平和的态度对待发生在周遭的一切，爱出现在你生活中的每一个人，不苛求任何一个人，宽恕他人犯的错。</p><p>这些观点和孔子的仁爱思想有很多异曲同工之处，所以在豆瓣上看到有人说「哲学最后的本真总有一种万宗归一的感觉」。无论是宗教还是古代大思想家，他们所提倡的都是相似的，因为这些符合人类作为一个需要在与他人合作的社会中生存、发展的物种的基本要求，那就是我们常说的「良善」。我相信这些思想是亘古不变的，即使未来人类消亡，或者发展成其它更高阶的智慧物种，也同样会去追求良善，追求与自然的和谐统一。</p><h4 id="10-月-22-日-改变你能改变的"><a href="#10-月-22-日-改变你能改变的" class="headerlink" title="10 月 22 日 - 改变你能改变的"></a>10 月 22 日 - 改变你能改变的</h4><p>能知足常乐的人是幸福的。我们感到痛苦常常是因为欲望太多。想要的东西却无法得到，于是感到不安、焦虑，继而怅然若失，甚至还会去想象假如自己拥有了它们之后自己会是什么样的状态。但是花太多时间沉醉在这种幻想之中，只会让我们离目标越来越远。我们要让自己成为意志坚定之人，认清现实，让头脑始终保持对自身清醒的认知。这样，我们就不会陷入对不属于自己的东西的苦苦渴求的状态，而是将自己投入到做好自己该做的事情上。我们应该对自己的技艺保持自信，并且坚信日复一日磨练提升它就是对自我的完善，也是一种修行。</p><h4 id="10-月-23-日-重新认识身边的人"><a href="#10-月-23-日-重新认识身边的人" class="headerlink" title="10 月 23 日 - 重新认识身边的人"></a>10 月 23 日 - 重新认识身边的人</h4><p>最近晚上加完班下班回家的路上，常常有种孤独感，以前从没有过的那种感觉，像是自己身体少了一个部分。最根本的原因还是，觉得自己应该拥有<strong>更丰富且感到满足</strong>的亲密关系。然而事实却是，自己思想上虽然已经接受了要多与他人沟通，表达真实的自己，但是还是做不到和他人真诚地进行交流，有时候甚至都不愿意和身边的人开口说话。知道自己需要改变，但是却什么也改变不了，这是最痛苦的。也许我需要换个思路看待自己吧。抛弃过去心中存在的偏见以及他人会如何看待自己的心理负担，重新开始认识对方吧。</p><h4 id="10-月-24-日-程序员与创造未来"><a href="#10-月-24-日-程序员与创造未来" class="headerlink" title="10 月 24 日 - 程序员与创造未来"></a>10 月 24 日 - 程序员与创造未来</h4><p>今天是 1024 程序员节，祝所有今天加班或者不加班的程序员节日快乐啦。真的挺庆幸自己当初选择了这个职业，不但适合自己的性格，而且回报也相对丰厚。虽然偶尔工作强度有点大，但是平均薪资还是高于其它大部分行业的，这也是享受了时代发展的红利吧。虽然不知道以后会怎样，但是我相信至少未来十年之内，程序员相关的岗位依旧会受到追捧，因为互联网还远远没有发展到成熟的状态，现在只是发展了桌面端、移动端以及智能设备，但是 5G 和物联网 + AI 时代到来之后，还会发展出更多的平台和应用场景，好奇到时候我们的生活会变成什么样。作为程序员，自己能作为其中一员参与到这场变革，真的是一件幸福的事。</p><h4 id="10-月-25-日-不要放弃尝试，先修练自己，成为更好的人"><a href="#10-月-25-日-不要放弃尝试，先修练自己，成为更好的人" class="headerlink" title="10 月 25 日 - 不要放弃尝试，先修练自己，成为更好的人"></a>10 月 25 日 - 不要放弃尝试，先修练自己，成为更好的人</h4><p>今天是重阳节，也是老年节，祝所有老人身体健康，长命百岁。昨晚看到喜欢的人在朋友圈发和她男友去迪士尼玩的照片，心里很不是滋味，先是感到一阵失落，然后是为自己感到悲哀，觉得非常受挫。但是过了一会儿等理性恢复之后，又觉得没必要沉湎于这种消极的情绪之中。既然人家已经做出了选择，那就祝福她就好了。这世界那么大，适合自己的人成千上万，不要因为一次受挫就放弃了尝试。要记住，你永远都拥有选择的权利。积极与消极之间，永远要选择更积极的视角。归根结底，我们都只是普通人而已，只不过想要在短短几十年的生命中，尽可能多地去体验人世间的一切可能性，想要通过自己的努力去获得幸福，获得他人的认可与尊重，为他人也带去幸福与快乐。而这一切都需要时间，先让自己成为更好的人：去阅读，去旅行，去维持健康的身体，去磨练自己的技艺，去创造价值，去结交和自己有同样价值观的人。至于剩下的，交给天意就好。</p><h4 id="10-月-26-日-管理好你的社交媒体"><a href="#10-月-26-日-管理好你的社交媒体" class="headerlink" title="10 月 26 日 - 管理好你的社交媒体"></a>10 月 26 日 - 管理好你的社交媒体</h4><p>昨天花了点时间整理了下自己在 twitter 上 follow 的人，unfo 了一些发表的观点对我来说是无效信息的人，现在我的 following 中只剩四种人，Entrepreneur：发表的是他们创业过程中的观点，对我来说很有启发；Developer &amp; Designer：专注开发和设计相关的话题，让我了解到业界最厉害的那一批人在关注和做些什么；KOL：主要是一些特定领域内的专家，比如一些知名的 Blogger，作家，科学家，播客主持人等，他们的观点包罗万象，借助他们的力量可以帮助自己用更开阔的视野了解到一些前沿的信息；最后是一些让自己放松的账号，比如关注了几个日本动物园的账号，经常发一些可爱的动物的照片，还有我喜欢的专业滑板手以及有趣的男人、女人等。以前觉得 twitter 只是用来打发时间用的，这当然是目的之一，毕竟我们总有一些无法做其它事的碎片时间。但是如果我们有意地对自己接受的信息进行筛选，那么即使是刷 social media 也能让自己获得更多有用的信息，而不只是接受 AI 为了满足我们的无聊而投递给我们的毫无价值的信息。</p><h4 id="10-月-27-日-阅读的形式"><a href="#10-月-27-日-阅读的形式" class="headerlink" title="10 月 27 日 - 阅读的形式"></a>10 月 27 日 - 阅读的形式</h4><p>昨晚看了理财博主 Ramit 的两个 Ultimate Guide，一个是关于社交技巧：<a href="https://www.iwillteachyoutoberich.com/guides/ultimate-guide-to-social-skills/">The art of talking to anyone</a>，另一个是关于如何提<a href="https://www.iwillteachyoutoberich.com/guides/ultimate-guide-to-asking-for-a-raise-and-negotiating-salary/">涨薪</a>。第一个和我最近接触到的 Social Animal 分享的观点很类似，我有点怀疑是不是 Rubin 当初也看过这篇文章。第二个和每个人的工作都有关，所以可以参考下。</p><p>越来越觉得，其实阅读是不分形式的，无论是阅读他人写的博客还是阅读书籍，只要你能从中获得启发，那就是有益的阅读。当然，通常来说，想要较深入地了解一个领域的时候，阅读书籍会让你看得更全面一些。博客可以让你开始思考，但是真正的 hardwork 还是要靠你自己去做。</p><h4 id="10-月-28-日-预算与愿望清单"><a href="#10-月-28-日-预算与愿望清单" class="headerlink" title="10 月 28 日 - 预算与愿望清单"></a>10 月 28 日 - 预算与愿望清单</h4><p>这两天调整了自己的预算，把每年旅游支出和购买各种 gadget 和软件的支出翻了一倍，原因是看到一个观点：如果你能在自己喜欢的事物上多花 2 倍的钱，这会给你的生活带来多大的改变？如果是 3 倍呢？4 倍呢？</p><p>这问题除了让我对自己的「所爱」有更深的了解之外，也让我意识到，真正能让你感到快乐的消费其实并不多。而且反过来这也更让我明白钱对我的意义是什么，还有不用太多钱我也能获得幸福和快乐。这也是做预算和愿望清单的好处，你能清楚地看到自己在哪些方面花掉了最多的钱，以及最想要的都是些什么。而且，真正重要的不是满足自己的愿望，而是当愿望满足之后，我接下来要怎么做？我追求的东西对我来说真正的意义什么？认真审视自己的愿望清单，你会加深对自己的了解。</p><h4 id="10-月-29-日-学会妥协"><a href="#10-月-29-日-学会妥协" class="headerlink" title="10 月 29 日 - 学会妥协"></a>10 月 29 日 - 学会妥协</h4><p>我们每天的工作、生活中，一定存在一些需要我们去将就的事，因为毕竟不可能事事顺遂，所以这就要求我们一定要学会妥协。学会妥协不是认怂，而是在判断当前自己所处的形势之后，选择一条最合适的解决之道。如果没有两全其美的办法，那么就只能选择一个折衷的办法。我们不可能在所有事情上都不吃亏，有时候也要考虑他人的利益，因此在与他人进行合作的时候，更要学会如何妥协。只有这样，我们才能不惧困难地、主动地去解决问题，同时也能获得与更多人合作的机会。</p><h4 id="10-月-30-日-哲学让你热爱生活"><a href="#10-月-30-日-哲学让你热爱生活" class="headerlink" title="10 月 30 日 - 哲学让你热爱生活"></a>10 月 30 日 - 哲学让你热爱生活</h4><p>早上看沉思录看到一句：真正的哲学应该是热爱智慧，追求一种优秀的生活艺术。很有共鸣，这和我之前说的「不能让人更加热爱生活的哲学没有任何意义」所表达的意思是一样的。斯多葛为什么受到越来越多的人的追捧，其实和它的务实以及贴近生活不无关系。所以，当感到困顿或者疲乏，对生活失去信心的时候，应该多看看哲学书。好的哲学是会让你重燃对生活的希望的。热爱生活，不要光用嘴说，而是要用行动去证明。</p><h4 id="10-月-31-日-我的幸福和他人的幸福"><a href="#10-月-31-日-我的幸福和他人的幸福" class="headerlink" title="10 月 31 日 - 我的幸福和他人的幸福"></a>10 月 31 日 - 我的幸福和他人的幸福</h4><p>最近感觉自己突然想明白了很多事情，关于自己目前的状态，关于自己的工作，关于个人社交形象的管理，以及如何平衡内心期望与外部现实的矛盾。很多事情其实并没有那么复杂，只要你坚守自己的原则，并且时刻提醒自己，为了达到目标需要付出哪些代价，而这些代价又是你愿意付出的，那么，只要去做就好了。别人怎么想或者如何评论都不重要，只要你忠于自己的内心，那就没什么好怕的。毕竟，我们都是赤手空拳来到这世上，而且最终也带不走任何东西。你的思维方式很重要，要多想想我们能给这个世界遗留下哪些东西，而不是能得到些什么。不断学习、进步，创造价值，把自己的生活过好，把你爱的人照顾好，然后再去考虑如何影响并改善更多人的生活。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西北大环线之旅</title>
      <link href="/northwest-road-trip/"/>
      <url>/northwest-road-trip/</url>
      
        <content type="html"><![CDATA[<img src='../assets/2020-10-08/IMG_20201006_085702.jpg' width=100%/><p>今年因为疫情，原本以为一年一次的出游计划会中断，至少无法出远门了，但是没想到国内疫情控制得很好，所以当听说有机会去西北大环线自驾的时候，毫不犹豫地决定要跟着小伙伴一起去了。另外，今年难得十一遇上中秋，假期比往年多了几天，虽然我还是请了几天假，但是这样的机会本就不多，所以还是要珍惜呀。</p><p>西北大环线应该是最近几年才开始热门起来的，由于疫情的因素，大家都无法出国门，所以今年也是特别热门。我们自驾的路线是先在西宁集合，然后从西宁出发，第一天：青海湖-茶卡盐湖-德令哈；第二天：小柴旦湖-东台吉乃尔湖-水上雅丹-柴旦镇；第三天：翡翠湖-火星营地-石油小镇-瓜州县；第四天：瓜州县-策克口岸-居延海；第五天：额济纳旗胡杨林景区；第六天：张掖丹霞-兰州；第七天：兰州-西安，在西安游玩半天，最后回杭州。完整的行程可以看我制作的 <a href="https://www.google.com/maps/d/u/0/edit?mid=1He523J3wt24XoAkwHWiG85Q65LhpBRBI&usp=sharing">Google Map</a>。行程安排得满满当当，好在总体还算是比较顺利，虽然中间也发生过一些不愉快的事情，但是最终都完美地解决了。</p><p>旅行的意义除了看别处的风景之外，也在于给自己一个体验不同的生活方式的机会，还有就是认识各种不同的人，这次结伴出行的小伙伴们，也是我们在网上认识的。原本是陌生人的我们，偶然间相识并一起分享旅途中的点点滴滴，这也是一种缘分吧。</p><p>接下来请欣赏我流水账式的旅行日记(•̀ᴗ•́)و ̑̑</p><span id="more"></span><hr><h5 id="2020-9-30-杭州-西宁K392"><a href="#2020-9-30-杭州-西宁K392" class="headerlink" title="2020/9/30 杭州-西宁K392"></a>2020/9/30 杭州-西宁K392</h5><p>早上 4 点就被室友和他的猫吵醒，然后就睡不着了，躺在床上胡思乱想了一阵，关于接下来的行程，关于自己最近生活和工作现状的方方面面，突然间感到有些孤独。</p><p>稍微眯了一会儿就到 5 点了，然后起床上厕所洗漱，微波炉热了芝士牛肉卷当早饭吃，结果锡纸没完全摊开糊了一个角而另一边还是冰的，随便吃了两口然后开始整理行李箱，写下九月最后一篇碎碎念，复制到博客并提交发布，出门。</p><p>好久没有起这么早过了，叫滴滴等了 5、6 分钟才有人接单，然后坐地铁去杭州站，中途需要转 5 号线，结果我自作聪明地提前下车换乘了 5 号线，然后发现时间居然多了接近十分钟，心里暗骂一声傻逼。不过还好最终还是提前半小时赶到了。在车站和小伙伴们汇合之后，聊了没多久就进站准备出发了。</p><p>上车整理完东西，才意识现在居然才 8 点多，平时这个点自己才刚刚出门吧。也许以后我也应该继续像今天一样坚持早起。早上看到路边晨跑的人也在想，他可能每天 10 点钟就睡觉了，但是晨跑洗漱完吃完早餐后，依旧还有两个小时去做其它事然后再去工作。这就是早起的好处，习惯早起的人可能比其他人多了五分之一的生命吧。</p><p>接下来要在火车上度过漫长的 32 个小时。车上无事可做，能做的只有聊天、睡觉、玩手机或者看书。当然，结伴出行有个 buff 就是可以一起玩棋牌类游戏打发时间。于是，我们三个和对面床位下铺一起玩起了双扣。就这样玩了一下午，从杭州到安徽再到河南，睡一觉起来明天应该就到陕西了，然后经过兰州，下午再到终点站西宁。这样就又解锁了一列从始发站到终点站的火车，之前解锁了从上海到拉萨的 Z164，这次是杭州站到西宁站的 K392。其实我还挺享受坐火车的，平时生活节奏太固定，偶尔体验一下这种和陌生人共处一室的感觉也挺好。然后也有可能认识一些新朋友，当然前提是，你要始终保持开放的心态，愿意和人聊天，了解他人的生活，倾听他们分享自己的经历和故事。</p><p>也许自己这方面还需要加强吧，有时候没说几句就觉得索然无味了。自己内心里面其实还是非常封闭的一个人，非常在意外界对自己的看法，无法做到完全放开自己。这也说明了自己内心依旧是一个非常自卑的人，无法做到全盘接纳自己，无法以完全尊重事实的态度对待自己当下的处境。</p><p>其实承认自己没那么好有多难呢？只要克制住自己的虚荣心就可以了。还有要提醒自己，你只是一个普通人，来自一个普通的农村家庭，接受的是很一般的教育，工作也没什么亮点。但是，你应该接受自己的身份，而不是感到焦虑和自卑，因为你的特殊性不是由这些外在条件决定的，而是取决于你能为他人创造多少价值。心里始终装着别人的人，就不会有太多时间和精力只关注自己了。这也是自我意识太强的人的一种自我解救的方法。</p><hr><h5 id="2020-10-1-西宁"><a href="#2020-10-1-西宁" class="headerlink" title="2020/10/1 西宁"></a>2020/10/1 西宁</h5><p>今天早上很早就醒了，当然是被吵醒的，每到一站都能听到列车员过来提醒乘客下车，所以感觉自己基本没怎么睡着过。接下来躺了一整天，看书、睡觉、胡思乱想。这时候才觉得时间过得好慢。而且下午的时候隔壁床位还有讨厌的小孩子，不停地发出各种尖叫声、吵闹声等等，觉得心烦却也无可奈何。在想如果以后自己有了小孩也这样不听话，那我是不是也只能束手无策。</p><p>下午 4 点多终于到西宁站，出站排了老长的队，然后去酒店。整理完东西，洗了把脸洗了个头，之后和小伙伴一起去附近逛逛。走了好几条街还是没法决定去哪儿吃晚饭，最终还是回到了最开始进去过的餐馆点餐。</p><p>晚上等大家都到齐之后，我们和其他小伙伴互相认识了一下，第一次见面，感觉还不错。吃完饭大家一起去街上逛夜市，我忘记带我的自拍杆了所以买了根自拍杆。然后牛哥开车带我们去市区里好玩的地方逛了逛，拍了城市夜景，最后 10 点多回酒店洗漱上床休息。</p><img src='../assets/2020-10-08/IMG_20201001_220702.jpg' width=60%/><img src='../assets/2020-10-08/IMG_20201001_222229.jpg' width=60%/><p>第一天过得挺轻松的，希望接下来几天也能玩得开心～</p><hr><h5 id="2020-10-2-西宁-青海湖-茶卡盐湖-德令哈"><a href="#2020-10-2-西宁-青海湖-茶卡盐湖-德令哈" class="headerlink" title="2020/10/2 西宁-青海湖-茶卡盐湖-德令哈"></a>2020/10/2 西宁-青海湖-茶卡盐湖-德令哈</h5><p>今天早上 5 点半起床，洗漱之后整理好行李 6 点多向青海湖出发。差不多开了 3 个小时才到湖边，藏区风景真的好美，一路上也拍了不少照片。</p><img src='../assets/2020-10-08/IMG_20201002_082349.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201002_082603.jpg' width=100%/><p>我们在湖边的一个度假村附近下车，去青海湖边打卡拍照。原谅我要开始发自拍了(◐‿◑)</p><img src='../assets/2020-10-08/IMG_20201002_091156.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201002_092956.jpg' width=100%/><p>差不多在湖边呆了一个小时，然后继续出发。</p><p>西北是风力资源丰富的地方，路上有很多这样成片的风力发点机场。</p><img src='../assets/2020-10-08/IMG_20201002_120424.jpg' width=100%/><p>路上有一搭没一搭地聊着，差不多又开了两个小时，到了茶卡盐湖天空一号景区。人不多，天空非常干净，湖面倒映着蓝天，并且可以清晰地看到浅白色的湖底沉积物。远处是一排排的风力发电机，地平线尽头是绵延的群山，和天空连结成一片。看着这样的风景，一切烦恼都会烟消云散。</p><img src='../assets/2020-10-08/IMG_20201002_125357.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201002_132037.jpg' width=100%/><p>接着我们出了景区，在路边吃了自热米饭当午餐。没有地方停车，所以就直接停在路口一个废弃的亭子附近，风很大，吹得人冷飕飕的。这也算是一种特殊的体验吧。</p><p>下午继续向德令哈出发，差不多两个半小时到，然后发生了一件让大家都很无奈的事情，我们提前订好的酒店被酒店方以“未提前打电话确认”为理由拒绝给我们登记入住了。最后只能报警找警察过来解决，但是他们也无权管辖，所以我们只好自己另外找住宿，耽搁了差不多 3 个多小时才把这事解决。我们另外订了两间房间，运气不错居然还有房间能订到，虽然是不同的旅馆。然后分成男女两队入住这两间房，今晚大家只能将就一下了。但是还得小心不被酒店发现。晚上大家一起去小餐馆吃饭，安抚一下牛哥的情绪。这事的发生说明旅途路上一定会有意外，所以要提前做好心理准备。像这种订好的酒店被取消的事情还好解决，但是有些事就说不定了。</p><hr><h5 id="2020-10-3-德令哈"><a href="#2020-10-3-德令哈" class="headerlink" title="2020/10/3 德令哈"></a>2020/10/3 德令哈</h5><p>今天的行程是先去小柴旦湖，然后再去东台吉乃尔湖和水上雅丹，最后折返柴旦镇住宿。这一路上土地变得沙漠化，各种因风蚀而形成的特殊地貌开始出现在我们眼前。</p><p>开了两个半小时到达小柴旦湖，我们非常没素质地越过了路边铁丝网，为了到湖边打卡拍照。</p><p>湖水波澜不惊，阳光不算强烈，但是湖边的风还是吹的人有点冷。</p><img src='../assets/2020-10-08/IMG_20201003_080946.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201003_090747.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201003_090926.jpg' width=100%/><p>到这里土地已经开始沙漠化了。</p><img src='../assets/2020-10-08/IMG_20201003_093634.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201003_105457.jpg' width=100%/><p>到东台吉乃尔湖的时候才感受到十一假期人满为患是什么样，堵很长的车，最后我们只能把车停在路边，然后走到湖边。这里不收门票，管理人员不足，这也是为什么这里游客会这么多、场面这么混乱。</p><p>这里也是盐湖，盐分结晶后形成湖边白色的湖岸。</p><img src='../assets/2020-10-08/IMG_20201003_124105.jpg' width=100%/><p>由于人太多，呆了没多久就出来了。再次在路边风餐露宿，吃自热米饭和煮泡面。接着我们继续向乌素特（乌苏特就是「水上」的意思）雅丹地质公园出发。离得不远，而且景区门票依旧对浙江人免费，第一次觉得受到了反向的“地域歧视”。</p><p>雅丹是小土包的意思，雅丹地貌形成之后，由于地壳运动，青海湖的湖水灌入这一地区于是形成了这样的“水上”雅丹的特殊景色。</p><p>公园很大，我们坐观光车到景区深处逛了逛，拍了点照片，然后觉得有点视觉疲劳，于是就出来了。</p><img src='../assets/2020-10-08/IMG_20201003_153815.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201003_154224.jpg' width=100%/><p>路上的雅丹地貌，看着不免让人联想到少女的乳房，原谅我的色情 ( *・ω・)✄╰ひ╯。</p><img src='../assets/2020-10-08/IMG_20201003_180953.jpg' width=100%/><p>之后我们折返回柴旦镇住宿，牛哥需要先送他女朋友回去，然后明早再来接我们出发。</p><hr><h5 id="2020-10-4-柴旦镇"><a href="#2020-10-4-柴旦镇" class="headerlink" title="2020/10/4 柴旦镇"></a>2020/10/4 柴旦镇</h5><p>凌晨 4 点多醒来，有点失眠所以开始补写游记。我们住的是当地一个小区内的民宿，两室一厅，此刻我正躺在客厅的床上写这篇旅行日志。现在差不多凌晨5点半，一个小时后我就要起床洗漱，然后和大家一起准备出发。今天的行程是先去翡翠湖（离柴旦镇不远），接着是火星营地，然后是玉门关（可能来不及去），最后到瓜州县住宿。希望一切顺利吧。</p><p>早上 6 点半起床，洗漱完整理了下行李，然后一起去吃早餐，随便吃了碗牛肉面，牛哥也差不多时间到，等大家吃完然后就出发回去整理行李了。8 点左右出发，先去了附近的大柴旦湖，也就是翡翠湖，由于湖水中含有矿物质，所以呈现出漂亮的绿色，而且随着水分蒸发得越多，颜色也就越深。</p><p>下面这张照片拍的是我们在离公路不远处发现的一个人工挖掘出来的小水渠，我觉得比翡翠湖的景色更好看。四周荒无人烟，寸草不生，只有这里有一汪清泉。虽然这水应该并不能喝😂。</p><img src='../assets/2020-10-08/IMG_20201004_121151.jpg' width=100%/><p>之后我们向火星营地出发，路上的车越来越少，景色也越来越荒芜，经过的一些地方可能方圆几十公里之内都看不到任何生物存在的迹象。</p><p>快到火星营地的时候，需要经过一段颠簸的土路，远处高高扬起的风沙宣示着这里的荒凉。</p><img src='../assets/2020-10-08/IMG_20201004_141743.jpg' width=100%/><p>在颠簸的土路上开了半个多小时，才到了火星营地。营地里有一些帐篷和四四方方的工作仓，四周是自然形成的丹霞地貌和一些形状奇怪的巨大的沙丘，由于风实在太大，我拍完照就上车了。</p><img src='../assets/2020-10-08/IMG_20201004_141330.jpg' width=100%/><p>等出了火星营地的时候已经是下午了，我们找加油站加满油，然后开始向石油小镇出发。</p><p>到石油小镇的时候差不多已经快日落了，于是赶紧冲到售票处买票进去，匆忙中拍了日落，并逛了逛废弃的小镇里的一些建筑。从建筑风格和墙上的标语能明显看出上个世纪那个特殊时代的痕迹。</p><img src='../assets/2020-10-08/IMG_20201004_190741.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201004_184109.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201004_192455.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201004_192002.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201004_193111.jpg' width=100%/><p>出了石油小镇差不多快天黑了。我们开始向瓜州县出发，今晚在那里住宿。</p><p>等到的时候差不多十一点了，有点闹肚子，上完厕所洗漱完就赶紧上床休息了。</p><hr><h5 id="2020-10-5-瓜州县-策克口岸-居延海"><a href="#2020-10-5-瓜州县-策克口岸-居延海" class="headerlink" title="2020/10/5 瓜州县-策克口岸-居延海"></a>2020/10/5 瓜州县-策克口岸-居延海</h5><p>今天的行程不会像昨天那样太赶，早上慢悠悠地吃了早餐才出发。</p><p>目的地是额济纳旗，先找预订好的民宿入住，然后去居延海和策克口岸。</p><img src='../assets/2020-10-08/IMG_20201005_125739.jpg' width=100%/><p>一路上经过无人区，有野骆驼和野山羊出没。</p><img src='../assets/2020-10-08/IMG_20201005_130516.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201005_130621.jpg' width=100%/><p>开了差不多六个小时才到额济纳旗，这里最著名的当然还是胡杨林，可是我们到的时间有点晚所以打算明天再去胡杨林景区逛。</p><p>到民宿放下行李后去附近吃了午饭，然后出发去策克口岸，由于时间比较赶，所以到口岸拍了中国和蒙古国的界碑、国门，然后逛了逛口岸的小市场就出来了。</p><img src='../assets/2020-10-08/IMG_20201005_171225.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201005_171442.jpg' width=100%/><p>赶在日落前到达居延海，日落很美。</p><img src='../assets/2020-10-08/IMG_20201005_184638.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201005_185229.jpg' width=100%/><p>出来的时候刚好天黑，之后开始往回折返。</p><img src='../assets/2020-10-08/IMG_20201005_192551.jpg' width=100%/><p>回到市区后，我们一行人找了个烧烤店，点了当地的特色烧烤驼肉羊排等，吃完就回去洗漱休息了。晚上依旧住的是小区里的民宿，我睡在一张行军床上，边上是一个大鱼缸，今晚就和这些可爱的小鱼儿一起入睡了。</p><hr><h5 id="2020-10-6-额济纳旗胡杨林"><a href="#2020-10-6-额济纳旗胡杨林" class="headerlink" title="2020/10/6 额济纳旗胡杨林"></a>2020/10/6 额济纳旗胡杨林</h5><p>今天早上 7 点不到就醒了，然后上厕所洗漱完才不到 7 点半，刷了会儿手机开始写游记。昨晚睡的还不错，差不多睡了有 6 个小时。今天去逛胡杨林，刚到景区门口就发现已经有一大堆人了。进去买完票，然后开始从一道桥开始逛。景区入口人很多，一直走到二道桥才发现不错的适合拍照的地点。金色的胡杨林有点像枫叶林，但是比枫叶林更特别一些，因为每棵胡杨长得都不一样。</p><img src='../assets/2020-10-08/IMG_20201006_085702.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201006_091029.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201006_091722.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201006_091856.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201006_103010.jpg' width=100%/><p>之后我们从二道桥坐大巴车到七道桥，然后走到大巴上车点去八道桥。八道桥的特色是沙漠，我从来没有去过沙漠，所以在这里多玩了一会儿。然后还为景区做了点贡献，捡回了一袋子垃圾😂。</p><img src='../assets/2020-10-08/IMG_20201006_113925.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201006_115924.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201006_122229.jpg' width=100%/><p>从八道桥出来后就直接坐车去了四道桥。这边有很多树龄比较大的胡杨树，有的是明朝初年到现在的，想到数百年前这些树就在这里了，不免觉得好神奇。不出意外的话，几百年之后它们还会继续站立在这里。</p><img src='../assets/2020-10-08/IMG_20201006_133731.jpg' width=100%/><p>跟随人群走到四道桥出口之后已经快一点了，觉得逛得也差不多了所以打算回去。等车的时候同行的一个小姐姐被蜜蜂蛰了一下，不过还好似乎不太严重。</p><p>之后继续向下一个目的地张掖丹霞出发，开车差不多要 6 个多小时。中间还经过酒泉卫星发射基地，去门口路过了一下，可惜没遇上发射卫星😂。</p><img src='../assets/2020-10-08/IMG_20201006_164016.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201006_163852.jpg' width=100%/><p>一路看书、睡觉，时间很快也就过去了。晚上10点左右到达丹霞景区门口的民宿，登记入住后，洗漱完整理了下东西早早就睡了。</p><hr><h5 id="2020-10-7-张掖丹霞"><a href="#2020-10-7-张掖丹霞" class="headerlink" title="2020/10/7 张掖丹霞"></a>2020/10/7 张掖丹霞</h5><p>昨晚差不多 11 点半就睡了，但是早上醒得有点早，差不多 6 点就醒了，然后就睡不着了，任由脑子里各种思绪翻飞了一阵，然后浅睡到 7 点 20 才起床洗漱，搞定之后刚好 8 点。下楼发现几个小伙伴已经在大厅等我了，于是一起出发去景区。在路边小餐馆吃了个早餐，一点也不好吃，感觉早起的整个心情都被破坏了😏。长了个记性，以后不要进那些在路边招揽顾客的餐馆，特别是景区附近的。</p><p>进北门售票厅买了门票，然后就进去坐大巴去第一个观景台。</p><p>人很多，不过没有昨天的胡杨林景区人多。由于光线比较强，所以拍出的照片效果也一般，不过还好可以用 Google Photos 的滤镜效果挽救一下，Google 牛逼~</p><img src='../assets/2020-10-08/IMG_20201007_093025.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201007_095617.jpg' width=100%/><p>听人说下雨天的丹霞更好看，不知道有什么道理。</p><img src='../assets/2020-10-08/IMG_20201007_112508.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201007_112653.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201007_113637.jpg' width=100%/><p>我们逛得算是比较快的，差不多在一个观景台待半个多小时，到逛完最后一个景点的时候才 12 点不到。</p><p>出景区的时候写了张明信片寄给自己，还怂恿小姐姐给我也写了一张，现在想想觉得当时的自己能有这个勇气已经挺反常的了(•̤̀ᵕ•̤́๑)ᵒᵏᵎᵎᵎᵎ</p><img src='../assets/2020-10-08/IMG_20201007_120321.jpg' width=60%/><p>小伙伴接上我们几个之后，开始出发去本次自驾的最后一站：兰州。午饭在一个小县城吃的麻辣烫。到这里以后发现气温已经没那么低了，正午时分一件长袖足矣。</p><p>一路沿着祁连山脉前行，晚上 7 点左右到达兰州，找了个算是当地特色的餐厅，作为我们这一次结伴旅途的散伙饭。这一路虽然也有一些不愉快的经历，但是好在最终都没有演变成更糟糕的事件，总的来说我还是挺享受这次旅行的。</p><p>当然，如果还有下次这样的自驾的话，我希望最好还是和熟悉一些的人一起。旅行虽然也是一种认识新朋友的机会，但是这里的新朋友最好是朋友的朋友。如果是陌生人的话，总觉得哪里不对劲，好像隔着一层膜。也许是因为我们都不擅长和陌生人打交道吧，尤其是我。不过这次认识的小伙伴都非常好，虽然大家都不怎么爱说话，但是都是很善良的人儿。</p><p>吃完散伙饭，牛哥先送我们去火车站，下车的时候刚好下起了小雨，也许老天也在为我们的分离感到不舍吧（好矫情~）。火车站外面由于人太多我和我的小伙伴走散了。在候车室发生了件好玩的事，检票口站着几个戴小红帽的人，嘴里一直喊着我们要坐的那个车次已经可以进站了的话。等到和小伙伴们汇合后才知道，原来他们是提供搬运服务的人，目的是收费 10 块钱然后你可以进人更少的地方等待发车。我这才明白，怪不得他们喊得这么卖力呢～</p><p>这次我依旧睡上铺，上车收拾完东西之后就准备睡了。和这次旅行认识的小姐姐约定下次去武汉玩的时候找她带逛，她也答应了，好开心也很期待～</p><hr><h5 id="2020-10-8-兰州-西安"><a href="#2020-10-8-兰州-西安" class="headerlink" title="2020/10/8 兰州-西安"></a>2020/10/8 兰州-西安</h5><p>早上睡到 6 点多，昨晚比我预想的要睡得更好。下去上了个厕所，然后整理完东西就躺着发呆了。</p><p>这一路看到的风景让我觉得，旅行对自己有更多、更大的意义，也意识到了旅行的重要性。不仅仅是为了看风景，还有如何与自己的想法相处。旅行也提供了一个全面认识自己的机会。还有认识新朋友的机会，虽然我们并不总是会在旅途中遇到值得交往的人。另外，我发现自己在旅行的时候，会变得更愿意与人沟通。也许是因为此时的自己没有任何压力，可以卸下自己平时的防备，而且也有了一个结交他人、和他人聊天的理由吧。我觉得这就是这趟旅行带给我的最大的收获了。</p><p>早上 8 点多到达西安站，去火车站附近寄存了行李然后吃了羊肉泡馍当早饭，火车站附近的东西又贵又难吃是一定的，不管哪儿都一样。</p><p>因为时间有限，所以决定去逛逛西安城墙，作为这次旅行的“收官之战”。可能是因为早上吧，城墙上几乎没什么人。</p><img src='../assets/2020-10-08/IMG_20201008_090859.jpg' width=100%/><img src='../assets/2020-10-08/IMG_20201008_092937.jpg' width=100%/><p>看到有租自行车的地方，于是我们决定骑车绕城墙一圈。</p><img src='../assets/2020-10-08/IMG_20201008_095515.jpg' width=60%/><p>不过还没骑多久就开始下起了小雨。我们在一个自动售货机下面躲了一会儿雨，聊了一会儿天，然后继续往前骑。</p><img src='../assets/2020-10-08/IMG_20201008_101020.jpg' width=100%/><p>绕过一个游客很多而且有导游讲解的西安皇城沙盘模型，导游在讲解当年发生的玄武门事变，听了一会儿觉得有点无聊，于是继续往前骑。再令人称道的丰功伟业也终将烟消云散，而我们中的大多数人只不过是其中的过客。</p><img src='../assets/2020-10-08/IMG_20201008_113143.jpg' width=100%/><p>一个小伙伴抱怨骑得腿酸，所以只好一边鼓励她一边继续往前，因为我们赶到车站的时间会比较紧，我们要坐下午 1 点 40 的高铁。骑过东城墙的时候，一看时间果然快要来不及，于是我们赶紧骑到终点去还车，然后跑去车站附近取行李。等拦上出租的时候已经 12 点 40 了，这边到西安北站不堵车也要 40 多分钟，而这个时候路上不堵是不可能的。一路上我们都已经在讨论，如果没赶上能否改签以及晚上住哪的问题了。结果司机师傅就比较厉害了，说一定给你们按时送到。最终还真的让我们刚好在发车前 5 分钟刷身份证进去了。一切有惊无险，有惊无险~</p><p>回杭州的高铁上一路无话，把 GOTs1 剩下的两集看完了，然后睡了一觉+冥想。边上坐了一个小姐姐，想搭讪，但是一直找不到合适的话题，而且中间她在看电视剧，笑得特别大声，我觉得她有点奇怪，于是就放弃了搭讪的想法了。Anyway，这次西北之行已经认识了一个小姐姐，也算是一个额外的 bonus 了。我觉得我现在已经可以打开心门，保持开放的心态去认识他人了。能有这种转变，就够了，改变都是从一点点开始的。</p><p>晚上差不多 9 点多到达杭州东站，出站的时候又和小伙伴们走散了，于是直接往地铁站赶，结果上了地铁又遇到了两个小可爱，这世界可真小。晚上差不多 10 点半才到房间，洗了个澡，简单收拾了下东西就睡了。</p><p>旅途结束了，但是我的心还留在大西北。下次旅行会是什么时候呢？</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Travel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Everything counts</title>
      <link href="/2020-9/"/>
      <url>/2020-9/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/nNLXMElv3RM" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>  九月，最大的体会是「念念不忘，必有回响」是真的。在一些奇妙的缘分之下，发现了一些和自己当下所思所想非常一致的人，看到他们表达的内容让我有种「我所想的都被他们说出来了」的感觉。与其把它说成是种奇妙的缘分，我更觉得这是一种必然，因为如果我们的思考不在同一维度，那么，即使这些观念和想法进入了我们周围的世界，我们也不会觉得它们有多特殊，也就无法意识到它们的珍贵之处。所以，每个人当下经历的一切都是有意义的，因为你永远不知道未来某些事情的发生，是以目前你在做的这件事为基础的，而眼下的你根本看不出这两者之前的联系在哪。冥冥中自有天意，但是这天意是否有利于我们，取决于我们的投入和付出的程度。从这点上看，时间永远不会骗人。</p></blockquote><span id="more"></span><h4 id="9-月-1-日-线上交友平台使用心得"><a href="#9-月-1-日-线上交友平台使用心得" class="headerlink" title="9 月 1 日 - 线上交友平台使用心得"></a>9 月 1 日 - 线上交友平台使用心得</h4><p>这两天通过使用一个线上交友的平台，更加意识到认识女生真的只能靠自己主动，因为大多数人都喜欢等对方主动，这样就造成一个结果，那就是越是被动的人所获得的机会就越少，而习惯主动的人因为不停尝试和新的人交流，所以比较容易找到适合自己的人。这也符合常识，但是问题是，怎样转变成主动的人呢？除了打破自己内心的藩篱，告诉自己要有勇气，做好被拒绝的准备之外，我发现最有用的方法是：把它当成一个游戏。每当被拒绝或者彼此不匹配、聊不下去的时候，想象有个虚拟的经验进度条会往上增加一点点，随着时间的累积，你判断对方是否与自己合适的准确率会越来越高，你的应对会越来越有技巧，你吸引到喜欢的人概率也会越来越高，而且你也更能坚持下去（只能这样给自己打气了😅）。</p><h4 id="9-月-2-日-财富自由及其联想"><a href="#9-月-2-日-财富自由及其联想" class="headerlink" title="9 月 2 日 - 财富自由及其联想"></a>9 月 2 日 - 财富自由及其联想</h4><p>晚上看了个关于投资理财的<a href="https://www.youtube.com/watch?v=T71ibcZAX3I">视频</a>，挺有收获的。一直以来都觉得基金定投非常适合我这样的懒人，但是没想到居然也是一种可以靠它实现财富自由的方式。看完之后，发现其实道理也真的蛮简单，自己去挑选股票需要耗费你大量的精力去研究各个公司，看他们的财务表报等等，而且还容易出错，但是定投宽基指数基金就不需要担心太多，因为市场上总有一部分走势向好的公司和一部分不那么好的公司，好公司帮你赚到的钱可以抵消掉后者的损失。虽然也会受到行情的影响，但是也有应对策略。年轻的时候，因为我们有现金流，所以只要在市场下行的时候加码买入就行了（指数基金只看长期收益，不在乎短期波动）；当我们进入退休期的时候，就可以适当多配置债券等稳健型资产，在市场下行期将他们卖出作为现金流用于加仓，然后在上涨回来的时候再调整回去。</p><p>算了下，如果自己年支出 6 万左右，那么为了实现财富自由的目标，只需要积累 150 万资产就足够了。虽然现在离这个目标还很远，但是看起来也不是完全不可实现。如果不买房，可能 35 岁之前就能实现这个目标。所以，财富自由并不是那么遥不可及，只要有毅力且能坚持，日积月累下来，还是很有奔头的。但是我觉得财富自由更大的意义是让我们去思考：当你不再需要为钱工作的时候，你生活的重心应该是什么？</p><p>我觉得财富自由之后，我还是会继续工作，只不过不是为了钱，而是真的想要去创造价值以及享受创造过程中的乐趣。那么，现在为什么不可以呢？我现在的工作不能创造价值吗？我无法在工作中体会到乐趣吗？</p><p>突然对自己的工作有了新的看法🤓。</p><h4 id="9-月-3-日-传递好观念"><a href="#9-月-3-日-传递好观念" class="headerlink" title="9 月 3 日 - 传递好观念"></a>9 月 3 日 - 传递好观念</h4><p>越来越觉得，相比财务上的投资，对于年轻人来说，更为重要的是对自己的头脑以及技能的投资。对于技能的投资不用多说，这与我们日后的工作息息相关，决定了你能否自食其力以及会过上什么样的生活。这方面我觉得我们的教育是相当失败的，因为技能的学习需要大量的练习，但是少有学校注重这方面的训练，大部分本科教育还不如一些技校做得好。其次是头脑的投资，这个比较微妙一些，我觉得靠运气的成分更多一些。因为毕业之后还能持续不断阅读、学习，广泛涉猎各个领域知识的人，终究是少数，除非你出生在这样的家庭环境中。我们通常更容易沉迷于各种各样的娱乐之中，并且渐渐习惯待在自己的舒适圈里，从而放弃了自我成长。就像树林里的两条路，大多数人都会选择容易走的那一条。另一条路更崎岖，需要花费更多的力气，但是随着你走得越远、越深入，你获得的快乐和成就感也越大。</p><p>我觉得自己终究还是幸运的人，所以有义务把这份「运气」传递给更多的人。只要有越多的人开始走这条路，我们社会的整体幸福感会呈指数级上升。虽然现在自己的影响力还很小，但是我相信改变都是从一点一滴开始的，先把自己的工作和生活改造成理想的状态，然后再把自己的观念传递给身边的其他人。</p><h4 id="9-月-4-日-不要怕做笨事"><a href="#9-月-4-日-不要怕做笨事" class="headerlink" title="9 月 4 日 - 不要怕做笨事"></a>9 月 4 日 - 不要怕做笨事</h4><p>有时候笨一点才是真聪明。过去自己有个倾向，那就是喜欢处处彰显自己的聪明，但其实这是内心自卑的人才会这样做，因为害怕被人说笨。而且一味地展示自己的聪明容易陷入一个陷阱，那就是会高估自己，并且忽视了向他人学习，从他人的做事的方法中学到对自己有用的东西。这就是「聪明反被聪明误」。</p><p>另外，笨一点，也意味着你愿意去做那些看起来很傻、很没必要的事，比如工作中的一些脏活、累活，没人愿意做，但是你去做了，你给人的印象就更加好一些。而且不要小看这些「脏活」，很多时候正是需要你从这些最基本的工作中才能了解到全局，这对于未来的你在此基础上启动更大的项目是有帮助的。最后，笨一点，别人也会更愿意与你合作，处处透露着精明的人会让别人很难对你产生信任，因为别人知道和你合作得不到多大的好处。有时候只需要你付出吃一点小亏的代价，就能收获赢得一份友谊的机会。</p><h4 id="9-月-5-日-不要封闭自己"><a href="#9-月-5-日-不要封闭自己" class="headerlink" title="9 月 5 日 - 不要封闭自己"></a>9 月 5 日 - 不要封闭自己</h4><p>昨晚写到要做个笨人，但是我知道自己很多方面还是得继续提高，做个聪明人。比如如何与同事打交道，如何更好地与人沟通等等。虽然基本的道理都懂，比如要真诚，多站在对方的角度看待问题，要为对方提供有用的信息等等，但是某些沟通能力的确需要学习。比如如何建立两个人之间的连接，如何创造轻松愉悦的谈话氛围，如何聊一些轻松的话题，如何让他人愿意与你聊天等等。这些都是目前的自己还很欠缺的能力，需要慢慢培养。</p><p>回顾自己短短三年的职场经历，一直以来，自己都是个埋头做事的人，和同事沟通很少，平时工作中也基本上是一言不发，除了吃饭等一些场合很少和同事闲聊。我在想自己是不是应该改一改这种态度，有时候和同事闲聊也是一种调剂。不过这也和我自己的性格有关系，向来不喜欢泛泛而谈，而且我喜欢的话题别人不一定感兴趣，另外也害怕引起不必要的争执，所以还是做个闷葫芦最安全。</p><p>还是那句话，不要封闭自己，当你封闭自己的时候，就放弃了很多让自己成长的机会。</p><h4 id="9-月-6-日-你能对世界造成多大程度上的影响"><a href="#9-月-6-日-你能对世界造成多大程度上的影响" class="headerlink" title="9 月 6 日 - 你能对世界造成多大程度上的影响"></a>9 月 6 日 - 你能对世界造成多大程度上的影响</h4><p>昨晚睡前想到一个问题，那就是：如果明天你从世界上消失了，你会给除了你的家人以外的世界，造成多大程度上的影响？</p><p>思考这个问题，我想大多数人都会意识到，自己最大的价值是通过自己的工作来体现的。我们在生活中也许能影响到除了家人以外的一部分人，但是最主要还是通过工作来创造价值、影响他人的。所以，尽量做好自己的工作，尽可能地创造出更大的价值，为自己也为他人。这是证明我们存在过的最好方法。如果仅仅是为了存在而存在，那对生命来说就有点浪费。<strong>活着，就意味着要做点什么。</strong>创造价值以及美的东西，或者是抚慰他人（无论是从物质上还是精神上），或者是启发他人思考，等等等等，这就是我们这一代人存在的最大的目的。</p><h4 id="9-月-7-日-想脱单就不要玻璃心"><a href="#9-月-7-日-想脱单就不要玻璃心" class="headerlink" title="9 月 7 日 - 想脱单就不要玻璃心"></a>9 月 7 日 - 想脱单就不要玻璃心</h4><p>发现自己心态有时候真挺差的，比如和人聊天，别人不回就觉得对方对自己不感兴趣，然后自己也就不想继续聊了。但其实如果多尝试不同的话题之后，再来看对方的态度，如果还是觉得聊不下去，这时再考虑是否合适，这样会好的多。不会因为自己无作为而懊恼，也不会因为没有深入了解错过对方而后悔。不用觉得会没面子，因为沟通的目的本来就是为了增进彼此间的了解嘛。</p><h4 id="9-月-8-日-我失去「爱」的能力了吗"><a href="#9-月-8-日-我失去「爱」的能力了吗" class="headerlink" title="9 月 8 日 - 我失去「爱」的能力了吗"></a>9 月 8 日 - 我失去「爱」的能力了吗</h4><p>有时候会怀疑自己是不是具备爱他人的能力，因为种种迹象表明，自己似乎不太热衷与人交流，也不擅长与他人相处。陌生人就不提了，连对自己的家人也是这样。虽说现在我和家人的相处也算是轻松自在，聊天也能聊得下去，但是总觉得少了点什么。比如事后我会发现自己并不是真的在关心他们，而只是在做出关心他们的样子而已。对家人尚且如此，对于身边关系不那么亲近的人那就更不用说了。我似乎从来都没有真正关心过身边的人，从来没有试图主动取悦他人，让他们感到开心、舒适。虽然爱一个人的含义不应该仅限于让他们感到开心，但是如果这点都做不到或者做不好，那又怎么能叫「爱」呢？</p><p>也许爱也是需要练习的吧，学会关心他人的感受，体会他人的情绪，多问问他人的想法，努力让他们感到开心舒适，使双方都保持一个愉悦的好心情，以及学会用更友好、礼貌的方式表达自己的意见（尤其是在观点不同的时候）。这些都是最基本的方法，但是还有一个大前提，那就是你要对他人保持<strong>尊重</strong>和<strong>好奇</strong>。我们每个人都是独一无二的个体，没有一个人和我们有过相同的经历，而这些不同的经历造就了我们每个人所独有的思维模式与行为方式。但是，我们不应该仅仅根据这些不同就讨厌甚至厌恶一个人，我们要学会尊重这些不同。每个人都有自己的价值，如果你能看到的他人身上的闪光点，那么你会发现他们都是和自己一样的、有缺点也有优点的普通人。当然，这个世界上的确存在一些十恶不赦的坏蛋，但是我相信这种人在人群中的比例很低很低。只要你能放下心中的偏见，就可以去了解他们、爱他们，然后从这些人中选择你愿意与他们一直相处下去的人做朋友或者伴侣。</p><h4 id="9-月-9-日-不要光想着自己"><a href="#9-月-9-日-不要光想着自己" class="headerlink" title="9 月 9 日 - 不要光想着自己"></a>9 月 9 日 - 不要光想着自己</h4><p>不要光想着自己，只要尽你所能地努力寻找对方的特点就好了。</p><h4 id="9-月-10-日-感恩老师们"><a href="#9-月-10-日-感恩老师们" class="headerlink" title="9 月 10 日 - 感恩老师们"></a>9 月 10 日 - 感恩老师们</h4><p>今天教师节，感谢过去所有不厌其烦谆谆教导过我的老师们，也感谢那些依旧选择老师这份职业，并且以把孩子们培养成能干、自立、果敢、自信的人作为目标的老师们，没有他们我们的未来无法想象，尤其是那些贫困地区的老师，他们是真正有理想的人。这也激励了我们这样普通的上班族，虽然我们不像他们那样，肩负教书育人的重担，但是想要做出一番成就，同样需要付出艰辛和卓绝的努力，加油吧。</p><h4 id="9-月-11-日-Try-new-things"><a href="#9-月-11-日-Try-new-things" class="headerlink" title="9 月 11 日 - Try new things"></a>9 月 11 日 - Try new things</h4><p>You need to try different things you haven’t tried before and put yourself to different sorts of tests. </p><h4 id="9-月-12-日-感动我的事"><a href="#9-月-12-日-感动我的事" class="headerlink" title="9 月 12 日 - 感动我的事"></a>9 月 12 日 - 感动我的事</h4><p>今天感动我的事：</p><ul><li>  早上经过消防队门口，看到消防战士和来看望他的妻子女儿相聚，尤其是爸爸抱着女儿的画面。</li><li>  晚上跑步经过没有路灯的路口，司机主动停下来等我先跑过去。</li><li>  看到一段非常美的环球旅行纪录片的剪辑片段。</li></ul><h4 id="9-月-13-日-成为协作者"><a href="#9-月-13-日-成为协作者" class="headerlink" title="9 月 13 日 - 成为协作者"></a>9 月 13 日 - 成为协作者</h4><p>晚上刷到一条<a href="https://twitter.com/Elodes12/status/1304729276508508164">推</a>，觉得简直把我这种社恐患者的心理说得太透了。我就是属于 Defector 类型的人，觉得身边的大部分人都无趣且不可信任，从来不会主动去进一步了解对方，而且习惯于仅从一些表面现象就判定一个人的类型，然后决定不再和对方继续交往下去，常常会觉得对方和自己不是同一类人。但是，如果你不去自我揭露，向他人传达你是个什么样的人的信息，别人也不会向你自我揭露，你们之间进一步的交流也就不会产生。久而久之，你就会觉得身边的人都没有意思，或者找不到和自己同一类型的人去交往。</p><p>所以，不要怕被拒绝或者被他人忽视，只要一直保持高自我揭露，向他人发出邀请，喜欢你的人自然会被你吸引，并且慢慢向你聚拢。虽然这样做需要你有很大的勇气，而且被拒绝的滋味的确也不好受，但是在这个越来越多人习惯被动而不喜欢主动的氛围下，如果你能做到这点，那么你就具有了巨大的先发优势。首先，你交友的范围会扩大，认识想认识的人的可能性会增加，而且因为人际圈的扩大，你提升自己的动力也会更足。所以，尽量让自己成为一个协作者，而不是逃避者。</p><h4 id="9-月-14-日-Don’t-Play-Safe"><a href="#9-月-14-日-Don’t-Play-Safe" class="headerlink" title="9 月 14 日 - Don’t Play Safe"></a>9 月 14 日 - Don’t Play Safe</h4><p>关于昨天的话题还想继续再聊一聊。首先，我觉得大多数人天生就是 Cooperator，就像兔子爱吃草、马儿跑得快一样，这是我们的祖先通过几十万年的时间，经历无数代的繁衍，才逐渐将这种品质写入到我们基因中去的。至于为什么越来越多人正在向 Defector 靠拢，我觉得最主要还是我们现在所处的时代太棒了。环境非常宽容，成年后的我们基本不再需要依赖他人来求得自己的生存。虽然「Play Safe」也是基因尽力保存自己的一种方式，但是现代人显然应该意识到我们不应该被基因挟持。我们不再需要害怕暴露自己的弱点给敌人，或者需要时刻提防他人会攻击自己的劣势。我们需要克服的只是对被拒绝和被忽视所产生的心理上（或许还有部分生理上）的痛苦感。而且这种痛苦感同样只是大脑的一种自动的、过时的防御策略，只要稍加训练，我们就能习惯它。</p><h4 id="9-月-15-日-要有一个大心脏"><a href="#9-月-15-日-要有一个大心脏" class="headerlink" title="9 月 15 日 - 要有一个大心脏"></a>9 月 15 日 - 要有一个大心脏</h4><p>早上醒来看到一条微信消息，是我加的第一个一周 CP 微信好友，但是昨晚睡得有点早，没看到，隔着屏幕都能感觉到尴尬。突然想到，也许自己到现在依旧单身，部分原因也是太容易觉得尴尬吧。想到过去自己经历过的一些极其尴尬的时刻，大多数时候其实别人并不觉得有什么，只是自己先觉得很不好意思、很不舒服，然后让他们也跟着你觉得不舒服了。哪怕真的发生了一些令人尴尬的事情，只要你自己心态摆正，该道歉就道歉，能开个玩笑就过去的也就过去了。最怕的是只有你自己一个人耿耿于怀。所以，心放大一些吧，其实没什么大不了的。</p><h4 id="9-月-16-日-Stop-censoring-yourself"><a href="#9-月-16-日-Stop-censoring-yourself" class="headerlink" title="9 月 16 日 - Stop censoring yourself"></a>9 月 16 日 - Stop censoring yourself</h4><p>昨晚看到一个<a href="https://www.youtube.com/watch?v=0lKRM76uFeI">视频</a>，同样也是因为上周末刷到的<a href="https://twitter.com/Elodes12/status/1304729277737455617">一条推特</a>才发现了这个频道，看完之后感觉自己的大脑就像被开了光一样。虽然这个频道主不是什么知名的 Youtuber，频道是去年底才创建的，而且讲的内容好像也没什么特别的（甚至还会有一点 PUA 的味道），但是我觉得他说的那些真的让我很有共鸣。</p><p>我也有过和他一模一样的感觉，而且现在依旧如此。总是不由自主地 censor 自己的想法，明明想要和他人沟通，也想要向他人展现真实的自己，但是有时候话到嘴边却又咽了回去。这样的结果就是，自己几乎交不到什么朋友。所以，我觉得我必须要改变。我的目标是能<strong>随时随地和任何人交流</strong>。不要 censor 自己的想法和情绪，做真实的自己，勇敢去认识身边的陌生人。先努力踏出第一步，重新认识身边的熟人，比如同事、每天都要见到的那些人，主动打招呼、多聊天，然后再试着去搭讪陌生人，再然后是主动去认识想认识的女生。</p><p>希望自己能坚持下来。</p><h4 id="9-月-17-日-最佳学习方式以及冗余信息的重要性"><a href="#9-月-17-日-最佳学习方式以及冗余信息的重要性" class="headerlink" title="9 月 17 日 - 最佳学习方式以及冗余信息的重要性"></a>9 月 17 日 - 最佳学习方式以及冗余信息的重要性</h4><p>晚上洗澡的时候想到一个问题：为什么阅读是最佳的学习方式？是因为文字和图片视频相比，能够传递的信息更多吗？不见得，因为有些时候一张图片能够传达的信息可能要用成千上万的文字才能完整表达，比如有时候一个 emoji 表情可能就比完整的一段话更能表达你的情绪。那是为什么呢？</p><p>仔细思考之后我的结论是：对于新知识，一些你从来没有接触过的信息，最佳的传达方式是文字。因为你可以在阅读的过程中，慢慢理解其中的概念，并且通过已有的知识，运用类比、联想等方式去掌握它们。而图片和视频虽然也能传达大量信息，但这需要在你已经掌握某些知识的前提下才能起作用。对于新知识，用图片、视频的形式可能效率并不会太高，因为你的思考容易被图片、视频所呈现的内容固定住，而缺失了自己想象、重建、理解新知识的这一过程。图片、视频的优势在于连结你已有的知识。这也给了我启发，如果我们在看视频的时候能多停下来思考、联想，可能这才是最佳的学习方式，但是我们认真看视频的时候，一般都会把自己代入到视频的内容中去。这似乎是个悖论，因此很难做到。</p><p>另外，文字和图片、视频相比还有一个优势，那就是占用空间小，也就是冗余信息少。但是，这个优点另一方面也是缺点，因为我们人类习惯于与人面对面交流，正是这些冗余信息才让我们相处起来感到舒适自在。你可能阅读过一个作家的许多作品，但是这不代表你和这个作家面对面沟通的时候会是轻松自在的。这也是为什么我们应该多与人进行面对面的交流，因为与人相处的秘诀就藏在那些冗余信息之中。</p><h4 id="9-月-18-日-人生计划与求解"><a href="#9-月-18-日-人生计划与求解" class="headerlink" title="9 月 18 日 - 人生计划与求解"></a>9 月 18 日 - 人生计划与求解</h4><p>早上刷牙的时候，意识到一个问题，那就是：我已经26岁了，但是依然没有一个明确的人生计划。要不要买房（先不讨论买不买得起的问题）？我理想中的生活方式是什么样的？我长期的目标是什么？</p><p>之前有想过出国看看，换一个不同的工作、生活环境，但是一直停留在想法阶段，从来没有付出实际行动去验证其可行性。以至于对现在的工作也开始用怀疑的态度了，这真的是我想要从事一辈子的事业吗？如果我未来想要创业，那么现在应该涉足哪些领域？</p><p>这些问题都是亟待解答的，但是又不可能一下子得到答案，需要自己去一点点去探索，慢慢接近答案。而且所要花费的时间也很长，也许是 3 年、5 年，甚至是 10 年或者更久。眼前最大的需要改变的地方是，努力变得 social 一些，去认识更多的人，同时这也能磨练自己的心智，不再害怕被拒绝。</p><h4 id="9-月-19-日-认识陌生人，勇敢表达自己"><a href="#9-月-19-日-认识陌生人，勇敢表达自己" class="headerlink" title="9 月 19 日 - 认识陌生人，勇敢表达自己"></a>9 月 19 日 - 认识陌生人，勇敢表达自己</h4><p>最近发现一个有趣的频道 <a href="https://www.youtube.com/c/SocialAnimal">Social Animal</a>，主题是鼓励和陌生人交流以及勇敢表达自己，几乎看完了其中的所有视频。我觉得他们的想法很棒，每个视频都给我一种『啊，的确就是这样』的感觉。因为现在很多人都习惯于线上交流，甚至都忘了怎么在线下去认识新朋友。</p><p>只要是生活在大城市里的人，每天都有很多认识新朋友的机会，然而我们还是依赖线上的交友 app 去认识新朋友。大多数人喜欢用个性害羞、不想打扰他人、会被拒绝等作为理由，害怕或者不敢去主动认识每天从我们身边经过的陌生人，但是如果我们能克服这些心理障碍，我们的生活会发生多大的变化？</p><p>每一次和陌生人的相遇都是一个认识你未来的好朋友的机会，也许其中还有你未来的伴侣。而所需要付出的代价是什么？仅仅是你愿意冒着被拒绝的风险。而带来的成长包括：变得自信、勇敢，保持头脑冷静，学会与各种各样的人聊天、相处的技巧，等等。这是一种百利而无一害的人生策略。</p><p>所以，我打算花时间培养起这种能力。也许完全掌握需要几个月甚至几年的时间，但是我相信自己最终一定会慢慢变得越来越熟练。</p><h4 id="9-月-20-日-知行合一的难处"><a href="#9-月-20-日-知行合一的难处" class="headerlink" title="9 月 20 日 - 知行合一的难处"></a>9 月 20 日 - 知行合一的难处</h4><p>今天下午难得没下雨，于是拎上我的大鱼板，想出去试试找人搭讪。</p><p>第一次尝试就失败了，想和一个在路边执勤的交警聊上几句，结果他看了我一眼就没再理我了。我也没太在意，毕竟他在工作，可能不太想说话。然后继续往前，沿着附近的居民区转了一圈，经过一个公园的时候也遇到不少人，打篮球的、遛狗的、健身的等等，每次想要开口说点什么的时候，话到嘴边又给憋了回去。包括路边的环卫工人，有的很友善，朝我点头微笑，我想上去问点什么的时候，却又觉得不该问，<strong>觉得太傻了</strong>。总觉得心里有个人一直在冷笑着看着自己。</p><p>也许这就是知行合一的难处吧，你知道的是一回事，但是执行起来的又是另一回事了。不过也没关系，第一次这样也正常，下次也许会多开口几次吧。</p><h4 id="9-月-21-日-You-can-do-whatever-you-want-to-do-alone"><a href="#9-月-21-日-You-can-do-whatever-you-want-to-do-alone" class="headerlink" title="9 月 21 日 - You can do whatever you want to do, alone!"></a>9 月 21 日 - You can do whatever you want to do, alone!</h4><p>有时候在想，自己在做某件事之前，为什么那么需要别人的确认才去做？可能是因为不自信吧。自信就是相信自己可以不依赖任何人，做到任何自己想做的事。哪怕结果没做成，也不会担心是自己不够优秀或者不够好。如果能达到这种程度的自我接纳，那才算是真正的成熟吧。</p><h4 id="9-月-22-日-如何处理情绪低潮"><a href="#9-月-22-日-如何处理情绪低潮" class="headerlink" title="9 月 22 日 - 如何处理情绪低潮"></a>9 月 22 日 - 如何处理情绪低潮</h4><p>每隔一段时间都会陷入自我怀疑的漩涡之中，比如我现在做的工作有意义吗？我真正喜欢做的事情是什么？但是问这种问题的时候，基本上是自己工作不太顺利的时候，所以结果一般也都是负面的，因此会在这种负面的情绪中越陷越深，感到迷茫无助。我觉得最好的做法是：让自己忙碌起来，忙到没有时间去想这些事。做一些简单的事情，比如整理东西，打字，外出运动等等，让自己暂时忘掉那些烦恼。另一方面，这也可以让自己恢复活力，同时避免时间被无意义地浪费掉。另外，我觉得像这种时候，自己过去写的日记就可以排上用场了。把自己过去写的文字拿出来读一读，就可以发现原来自己过去也经历过类似的阶段，也有过类似的情绪。所以，当意识到这一切都会过去的时候，就没有那么焦虑了。睡一觉起来，第二天继续做自己该做的事，相信一切都会慢慢好起来的。</p><h4 id="9-月-23-日-为他人创造价值"><a href="#9-月-23-日-为他人创造价值" class="headerlink" title="9 月 23 日 - 为他人创造价值"></a>9 月 23 日 - 为他人创造价值</h4><p>今天下班回来后看了很多视频，按照「惯例」先看了 <a href="https://www.youtube.com/watch?v=lCxiYLerHLI">Social Animal</a> 的视频，看他搭讪陌生路人总能给我启发，有时候只要大胆说出自己内心的想法就够了，至于结果如何，随缘就好；一个<a href="https://www.youtube.com/watch?v=Mp-v65Fl9HM">越南河内</a>低成本旅游的视频，发现河内和国内三线城市的消费水平差不多；一部<a href="https://www.youtube.com/watch?v=GDyPwiVObzg">短纪录片</a>，调查在日本东京附近山区村落里的老人的生活，看到那些八九十岁独自生活的老人，背都直不起来了还坚持自己开车去超市、去地里干活，真的有种说不出的感觉，不是心疼，而是敬佩和羡慕，希望自己到了那个年纪依旧能自食其力；一个 97 岁的哲学教授的<a href="https://www.youtube.com/watch?v=qX6NztnPU-4">一天的生活</a>，从起床到吃早饭，都离不开他人的协助，无助、孤独、抑郁，听他说起后悔自己过去没有注意到吹过树枝的微风的时候，心里咯噔了一下：即使是哲学家，在生命的最后时刻，也无法平静面对死亡，也会感到恐惧和焦虑；最后是一篇<a href="https://www.youtube.com/watch?v=3QO1vvGT6e0">影评</a>，是枝裕和导演的《比海更深》，讲的是一个嗜赌的男人离婚后潦倒与困顿的生活。没看过电影，但是觉得很熟悉，类似于《百元之恋》，都是关于普通人生活中的悲欢离合，但是同样能启发人思考。</p><p>我们每个人都没办法选择自己在什么时候出生、在哪出生，每个人来到这个世界上之后都要不停面对各种各样的问题，都会经历痛苦、无助的时刻，无论你是贫穷还是富有。正因如此，如何解决这些抛在我们眼前的问题才是关键，这是证明自己活过的唯一方法。当然，有的人的确会过得更苦一些，出生在一个赤贫家庭中的人，面对的问题显然比在富有家庭中长大的人要严峻、现实得多。但是每种环境下所要面对的困难不一样，也无法比较，不见得一种会比另一种更容易解决。</p><p>我的观点是，只要你能为他人创造价值，你的人生就是有意义的。这里的创造价值可以是指你凭借自己的劳动生产出的产品，你解决了某些问题，你启发了他人，你为他人带去了快乐，或者使他人的生活变得更幸福。因此，无论你处在什么行业，从事什么职业，都可以为他人创造价值。晚上躺在床上的时候，问问自己，今天我为他人创造了哪些价值，我有没有启发他人，有谁因为我的存在而生活得更幸福了吗？哪怕只有一个人因为你的付出而受益，你也应该感到满足，可以安心入睡了。</p><h4 id="9-月-24-日-Stay-true-to-yourself"><a href="#9-月-24-日-Stay-true-to-yourself" class="headerlink" title="9 月 24 日 - Stay true to yourself"></a>9 月 24 日 - Stay true to yourself</h4><p>Stay true to yourself. 这意味着除了要真实面对自己的一切，欲望、贪婪、懒惰、焦虑、攀比、优越感、同情心，同时还要学会表达自己，关注自己的想法和需求，而不是抑制它们。我真实的想法是什么？我为什么会这样想？我想要告诉他人什么？我希望他人从我这里了解到什么？最重要的一点是：向世界展示真实的自己。</p><p>不知道为什么会有人觉得我长的帅，因为老实说，我身高不高，颜值也不高，脸上的皮肤不好，很多痘疤痘印小黑痣；眼睛也小，笑起来有点三角眼；牙齿也不整齐，门牙很大而且还有一道明显的牙缝，以至于每次笑都要捂着嘴才敢笑。用我妈的话说，我把他们（我爸和她）不好的地方都遗传下来了，她觉得唯一生的好地方是我的眉毛。可是我仔细看看觉得，我的眉毛也不好看啊，尾部有点下垂，尤其是笑起来的时候，像个小丑。</p><p>但是呢，外表是天生的，无论长成什么样你也只能默默接受。比外表更重要的是一个人的思考能力、学习能力以及内在的品格。如果缺少这些东西，外表的保质期也不会太长。而且普通的相貌有时候反而是一种优势，因为你不用经常注意他人如何评价你，也不会因为受到关注而不敢做一些不符合外界期望的事。相反，你可以专心做自己想做的事，主动接近自己想接近的人而不用担心被别人认为是别有用心，这是相貌普通的自由。</p><p>我们每个人都可以追随自己的梦想，只要我们忠于自己的内心，踏实勤奋，发挥出自己的长处，过上幸福快乐的普通人的生活并不难。</p><h4 id="9-月-25-日-习惯的养成与保持愉悦"><a href="#9-月-25-日-习惯的养成与保持愉悦" class="headerlink" title="9 月 25 日 - 习惯的养成与保持愉悦"></a>9 月 25 日 - 习惯的养成与保持愉悦</h4><p>很多时候，我们都是被一个习惯改变，比如朋友圈看到别人晒的运动记录，于是你也下定决心要开始跑步或者健身，但是尝试了没多久又放弃了。如果你相信习惯的力量，那么就一定会再次向自己发起挑战，因为习惯的养成并不是那么简单，一定会有反复，不停地中断与开始，直到某一天你发现自己根本意识不到自己每天都在做这件事，这个时候新的习惯已经融入到你每天的日常生活中了。不要怕难，只要是正确的事，每天做一点点，总有一天它会变成你的习惯。</p><p>另外，工作和学习的过程中，心情是否愉悦是影响我们产出的关键因素。那么，如何变得更快乐，从而有更高的工作和学习效率？我发现一个挺简单的方法，首先要让自己出一身汗。选择自己喜欢的运动，无氧或者有氧的都可以，运动完后冲个澡，然后站在镜子前，对着镜子里的自己露出一个大大的笑脸，告诉自己 “I love your smile, you are such a great person, I will always love you.” 然后可以一边听歌一边做一些琐事，比如刷牙、叠衣服等，慢慢进入一个轻松愉悦的状态。这之后再去做别的事，你会发现自己很容易就能进入状态，看问题的角度也变得更加积极乐观。</p><h4 id="9-月-26-日-职业规划要趁早"><a href="#9-月-26-日-职业规划要趁早" class="headerlink" title="9 月 26 日 - 职业规划要趁早"></a>9 月 26 日 - 职业规划要趁早</h4><p>今天继续聊聊个人职业的问题，之前说过不要执着于寻找自己热爱的事业，而是要把自己擅长的事情或者现在正在做的事情努力做到极致。我的观点没有改变，但是最近有看到另外一种观点，提倡及时放弃，在快速试错中寻找适合自己的最佳路径。理由是在这个信息加速流动的时代，任何事物或职业的寿命都会缩短，我们应该在短时间内尝试不同的新方向，当发现某个路径不适合自己的时候，能有决断力立马放弃，继续选择别的方向，从而在这种快速试错中，找到适合自己的最佳路径。</p><p>我觉得这种说法看上去有道理，但是执行起来非常困难。首先，怎么确定「短时间」到底是多短？3 个月还是半年或者更久？如果时间太短，你可能根本就不能接触到某一事物的本质；时间太长的话，试错的成本又太高。还有，该如何判断这个方向是否合适，或者说什么时候应该放弃？这非常难，没有长时间的积累根本做不到这样。</p><p>这种策略也许在商业变现方面值得借鉴，但是在个人成长方面，我觉得一步一脚印稳扎稳打才更合适。每个行业都有其优劣势，选择之后中途切换的成本太高，尤其是当你已经在这个行业内积累了一些经验的时候。切换跑道意味着放弃之前所拥有的一切，重新开始。除非你对自己有非常明确的认识，也做好了相应的规划，而且确定自己能一直坚持下去，那么这种时候再去切换，成功的可能性才更大。</p><p>无论如何，只要不是极度厌恶的情况下，坚持才是最佳的策略。所以，一开始的选择特别重要，如果你刚毕业时没选择好行业，那么越到职业生涯的后期切换的成本就越高。这也是为什么我们应该尽早开始做职业规划，最好在大学时期就确定好自己未来的职业道路。</p><h4 id="9-月-27-日-每天都要做一两件不想做的事"><a href="#9-月-27-日-每天都要做一两件不想做的事" class="headerlink" title="9 月 27 日 - 每天都要做一两件不想做的事"></a>9 月 27 日 - 每天都要做一两件不想做的事</h4><p>我们为什么会觉得知行合一很难？大多数时候我们都知道自己应该怎么做，比如应该经常锻炼身体，吃健康的食物，每天花时间学习，阅读书籍，维护好和亲友的关系等等，但是实际却做不到或者做不好。最主要的还是因为人的惰性，就像今天的<a href="https://mp.weixin.qq.com/s/fmgo_RhKp3Hdz6K-VMf5uQ">一句日历</a>说的：小孩和大人都一样，通常都是爱娱乐甚于爱受教育的。更准确地说，好逸恶劳是人的天性。我们需要克服这种本能，让自己习惯做这些不舒服的事，最终让不舒服变得「舒服」，只有这样我们才能获得成长。说白了就是，每天都要强迫自己去做一两件不想做的事，只有这样你才能慢慢进步。</p><h4 id="9-月-28-日-学会质疑自己"><a href="#9-月-28-日-学会质疑自己" class="headerlink" title="9 月 28 日 - 学会质疑自己"></a>9 月 28 日 - 学会质疑自己</h4><p>如何保证自己一直在进步？除了持续不断地学习之外，更重要的是一点是，不能太固执，要学会接受他人的质疑，学会反思自己是否真的犯了错。这就需要我们有开阔的胸襟，能广泛听取他人的不同意见，找到他人观点中值得自己重新思考的地方，并利用这个新视角去完善自己的思考。</p><p>另外，这也要求我们敢于承认自己的错误，每一次犯错都是一次学习的机会，我们应该感谢那些为自己指出错误的人，他们才是我们真正的老师。同时，我们也要敢于指出他人的错误，不能因为害怕伤害到彼此的关系而保持沉默，如果你真的关心对方，就应该希望他/她变得更好，尤其是当对方也是乐于追求成长的人的时候，你的沉默可能是放弃了一个加深彼此关系的机会。</p><h4 id="9-月-29-日-学会表达愤怒以及保持对他人的兴趣"><a href="#9-月-29-日-学会表达愤怒以及保持对他人的兴趣" class="headerlink" title="9 月 29 日 - 学会表达愤怒以及保持对他人的兴趣"></a>9 月 29 日 - 学会表达愤怒以及保持对他人的兴趣</h4><p>现在好像越来越多人都在强调情绪管理的能力，有的还会用「情商」来评价一个人抑制自己负面情绪的能力，虽然我不赞同所谓的「情商」，但是过去潜意识里还是会觉得应该远离那些容易生气的人。之前看阿德勒的时候有讲到，生气是我们表达不满的方式，只不过我们希望用这种更激烈的方式引起对方的注意，亦或者我们想要借此控制对方或者强调自己的权威等等。但是最近意识到，其实适当表达愤怒也是一种沟通的方式，尤其是在亲密关系中。即使最终导致的是你们发生了争吵，但是这对于你们关系其实是利大于弊的。</p><p>因为当我们抑制自己的不满情绪的时候，这种情绪会一点点累积，直到某一天失控爆发，那时候对彼此造成的伤害可能更大。另外，表达愤怒也能让对方加深对你的了解：你的底线在哪里，你最核心的价值观是什么，你希望对方做什么、什么不能做等等。</p><p>最后，敢于表达愤怒也说明了你对这段关系的看重，我们不会随便对陌生人发脾气。能在对方面前生气也证明了你已经接纳了对方，愿意向对方揭露真实的自己的脆弱又敏感的一面。这和在他人面前流露出自己伤心和无助是一样的，证明了你对他/她的信任。</p><p>回想下，自己最近一次在他人面前生气是什么时候呢？几乎想不起来，说明自己绝大多数时候都习惯性地抑制了真实情绪的表达。不过老实说，我现在连和他人基本的沟通都不愿意去做，更不用说这种更彻底的自我表达了。所以，还是要从第一步做起，主动一点，告诉他人自己的想法，保持对他人的兴趣，建立起彼此的联系。</p><h4 id="9-月-30-日-接纳真实的自己"><a href="#9-月-30-日-接纳真实的自己" class="headerlink" title="9 月 30 日 - 接纳真实的自己"></a>9 月 30 日 - 接纳真实的自己</h4><p>Permission to be human. 我们需要学会接纳自己的一切，曾经犯下的错，自己独有的、有点 weird 的特质，有时会感到孤独和饥渴，大脑中时常出现的觉得自己和周围环境格格不入的感觉，偶尔让人捉模不定的情绪起伏…这就是真实的自己。这个世界上只有你能见证到自己成长过程中的每一个细节，不要逃避或者反对它，而是要完全不带任何偏见地接纳它。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恐惧只是想象</title>
      <link href="/2020-8/"/>
      <url>/2020-8/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/cnKKqGX3kps" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>  关于八月，工作之余，主线是阅读，看了很多书，有些还是之前已经看过一遍的，但是收获比第一遍看的时候多。而且养成了一个习惯，下班回到家之后做的第一件事是，先洗个苹果然后一边啃一边拿起 Kindle 开始看，就这样保持了两三天看完一本书的节奏。这要归功于月初的一次滑板摔伤，让我无法下班后就出去玩滑板了。不过还好摔得不太严重，只是尾骨附近肿了一点，一周左右就恢复了并没有影响到生活，也算是因祸得福吧。这个月最大的感受是，发现自己过去一直在被恐惧感支配着生活。害怕改变，害怕被拒绝，害怕不被认可，害怕失去已经拥有的东西，害怕面对真实的自己。因为恐惧，所以退缩，选择走一条相对安全的道路，结果把路越走越窄，恐惧的东西也越来越多。克服的方法其实非常简单，只要意识到恐惧只是我们大脑中想象出来的，当你勇敢地站起来面对问题、努力地去想办法解决问题的时候，恐惧感就消失了。无所畏惧，这是我们每个人都要追求达到的状态，相信自己一定能做到。</p></blockquote><span id="more"></span><h4 id="8-月-1-日-从失序到有序"><a href="#8-月-1-日-从失序到有序" class="headerlink" title="8 月 1 日 - 从失序到有序"></a>8 月 1 日 - 从失序到有序</h4><p>新的一个月，有很多计划想要做，但是工作上也不轻松，另一方面还想继续过慢节奏的生活，所以充满了矛盾。不过这就是成年人的世界吧，复杂性急剧上升，可选择、可做的事情太多了，于是精神熵就加大了，如果处理不好就会感到焦虑沮丧，所以有的时候还是得静下心来，好好思考自己当下的状态，将目标整理划分出优先级，然后再制定相应的计划。这是一个从失序到有序的过程。生活中出现的所有苦恼其实都是可以解决的，只要你愿意去学习获取那方面的知识，而且又有足够的耐心。另外，要学会多多感恩，因为没有他人的付出就没有此刻的自己。</p><h4 id="8-月-2-日-努力去体验"><a href="#8-月-2-日-努力去体验" class="headerlink" title="8 月 2 日 - 努力去体验"></a>8 月 2 日 - 努力去体验</h4><p>昨天的计划只完成了一项，看完了心流，然后下午睡了一觉，醒来后一直在看我住，基本把会员部分比较想看的集数都看完了，再看一遍发现，有几集里主人公说的话和我最近告诉自己的话一模一样，也许是我无意识中记住了他们的话吧。这证明看过的东西还是能保留一部分下来的，好观念大概就是这样潜移默化地植入到我们的大脑中去的吧。这世界很大，有意思的人很多，正因如此，我们才要好好努力，让自己有能力去结交认识些有趣的人，一起体验这个丰富多彩的世界，去经历一些好玩的事。</p><h4 id="8-月-3-日-Should-I-follow-my-heart"><a href="#8-月-3-日-Should-I-follow-my-heart" class="headerlink" title="8 月 3 日 - Should I follow my heart?"></a>8 月 3 日 - Should I follow my heart?</h4><p>做自己想做的事 or 坚持打磨自己的技能直到产生心流的感觉，以前一直都认为前者是理所应当的，但是最近开始有点改变了，follow your heart 听起来很正确，但是执行起来就让人觉得困难重重了。人的注意力总是不断在变，而真正能让自己体会到擅长且愿意一直做下去的事，一般都需要你付出大量的努力。所以，正确的做法是：无论你现在在做什么，只要它是有意义的，就应该坚持做下去。当我们通过长期的刻意练习，让自己成为了某一方面的专家之后，我们会更容易地感受到其中的乐趣，体验到心流的感觉，而不会只受短期激情的支配，花太多时间做各种浅尝辄止的事。</p><h4 id="8-月-4-日-敞开怀抱，接纳他人"><a href="#8-月-4-日-敞开怀抱，接纳他人" class="headerlink" title="8 月 4 日 - 敞开怀抱，接纳他人"></a>8 月 4 日 - 敞开怀抱，接纳他人</h4><p>早上被热醒，因为睡前把空调关了。突然有点理解房间里没空调的室友了，总觉得他怪怪的，但是说不出为什么。不过我总觉得自己有时候更怪，明明每天见面，但是就是会刻意保持距离，仿佛自己身边有一道自我隔离的墙。哪怕别人想走近自己，也总是会被我挡在外面。所以自己到现在都是孤身一人是有原因的。一方面，太过被动，条件相同的情况下别人为什么要选择你；另一方面，自我意识太强，这让他人很难靠近，或者即使靠近了关系也很难进一步发展。</p><p>怎么改变呢？首先，要主动一点。看了昨天连叔的<a href="https://mp.weixin.qq.com/s/0ctdagqY0ZKynwj3j43NbA">文章</a>，连那样的王八蛋都能有人爱，我们这样的好人为什么要让自己一直单身下去？我知道这座城市里一定还有很多像我一样的人，也许观念、爱好无法完全一致，但是我的好朋友、好恋人的标准并不算高，只要诚实、勤奋、乐观、善良就够了。</p><p>只要你自己敞开怀抱，愿意用广阔的胸襟接纳他人，他人也会开始接纳你。</p><h4 id="8-月-5-日-滑板摔跤：凡事皆有成本"><a href="#8-月-5-日-滑板摔跤：凡事皆有成本" class="headerlink" title="8 月 5 日 - 滑板摔跤：凡事皆有成本"></a>8 月 5 日 - 滑板摔跤：凡事皆有成本</h4><p>晚上玩滑板摔了，这次差不多是我玩滑板以来摔得最严重的一次。才开始热身没多久，从练习荡板到练习最近刚学会的反脚尾刹，然后在一个尾刹到末尾段的时候，由于速度偏快，转身停下前没掌握好平衡，脚下一滑，整个人都向后飞了出去，结结实实地屁股先着了地。</p><p>摔到地上的一瞬间整个大脑一阵眩晕，一秒钟后努力站起来，确认了下自己还有知觉而且不会晕过去。在附近走动了十几步之后，突然眼前发黑，大脑也感到越来越晕，开始意识模糊，于是下意识地去找手机，仅存的一点意识告诉自己要在晕倒前通知别人来救自己。而手机之前被我放在了草地上，现在眼前发黑，周围光线又很弱，很难看到手机在哪，好在居然还知道利用手机镜面的反光去找。找到手机后第一件事是打开微信，心想要是晕过去了就发定位给老姐。</p><p>大概坐了几分钟，这时候明显感觉到时间的流逝变慢了。摸了摸自己摔的位置，在尾骨靠上边一些，轻轻按下去特别疼。而且神奇的是，那个位置刚好是我放钥匙的地方（我穿的跑步用的运动裤，只有后面这一个小口袋）。心想这串钥匙是为我缓冲了一部分冲击力而降低了我受伤的程度呢，还是因为受力面积减少而加重了我受的伤？</p><p>过了一会儿，发现自己开始大量出汗，痛感也变得越来越明显，于是搜了下玩滑板摔到尾骨如何处理，看到首先要确认自己有没有骨折。我蹲站了几次，似乎不算特别困难，而且按压摔伤的地方也没有特别强烈的痛感，应该没有骨折。那么有可能骨裂吗？心想如果骨裂就只有这种程度的痛感，那么我的忍耐力也太强了吧？所以最大的结果就只是软组织受损吧。想到这里就放心了。</p><p>不过还是不敢太放松，再次站起来走动，能明显感觉到疼痛。于是做一些简单的抬腿动作让肌肉恢复知觉。非常疼，尤其是当左脚向后抬的时候，只能抬一点点。休息、活动了大概半个小时，痛感总算减轻一些了，确定问题不大之后开始走回小区，洗完澡，然后去药店买了药。</p><p>这事其实给自己提了个醒吧，我一开始玩滑板出于两个目的：第一是为了好玩，它能让我享受到控制自己身体的乐趣，而且看着自己每次一点点进步很有成就感；第二是可以锻炼身体。但是，如果不注意保护自己的话，玩滑板的风险性也还蛮高的，受伤一次可能要几个月甚至几年才能恢复，而且给自己的身体造成永久性伤害的可能性也不是没有。这点其实就和我的第二个目的冲突了，所以还是要好好考虑是否应该继续坚持。</p><p>另外就是，凡事皆有成本，如果你不愿意付出相应的成本，就想享受某件事或某个人带给你的好处，那么你就是在欺骗自己，而且迟早会受到惩罚，并且这个成本最终一定会以某种形式需要你去支付。所以，贪婪的人一般都没有好下场。</p><h4 id="8-月-6-日-如何产生心流"><a href="#8-月-6-日-如何产生心流" class="headerlink" title="8 月 6 日 - 如何产生心流"></a>8 月 6 日 - 如何产生心流</h4><p>知道自己要什么，并朝这个方向努力的人，感觉、思想、行动都能配合无间，内心的和谐自然涌现。对生命胸有成竹的人，内心的力量与宁静，就是内在一致的最高境界。–《心流》</p><p>越来越能体会到这句话的正确性，有时候在想，只要做的事能让你投入进去，产生心流，那么外界的那些条条框框的束缚都不重要了。我想大多数成功的人多少都保有这种心态吧，他们一定是想做成某件事，然后把自己的身心都投入其中，整个过程就是值得享受的。只要体会过这种感觉，想停下来都难。</p><h4 id="8-月-7-日-做难一点的事-刻意练习"><a href="#8-月-7-日-做难一点的事-刻意练习" class="headerlink" title="8 月 7 日 - 做难一点的事+刻意练习"></a>8 月 7 日 - 做难一点的事+刻意练习</h4><p>最近频繁熬夜，时间总是不知不觉地就过去了。虽然不利于健康，但是我挺享受这种状态的。不过也要小心，不要觉得自己游刃有余就不去思考更长远的计划了，一定要时刻记得，做『难一点』的事，只有这样才能不断进步，并且保证自己可以一直体验到心流的状态。但是也不要一下步子迈的太大，如果自己觉得应付不过来，可以适当放慢节奏，允许自己偷会儿懒，做一些简单的活动作为放松。不过无论怎样，只要保持刻意练习，再难的东西也会一点点被掌握，直到游刃有余。</p><h4 id="8-月-8-日-消费欲望与快乐的成本"><a href="#8-月-8-日-消费欲望与快乐的成本" class="headerlink" title="8 月 8 日 - 消费欲望与快乐的成本"></a>8 月 8 日 - 消费欲望与快乐的成本</h4><p>很奇怪，有时候觉得自己的消费欲望很低（事实也的确如此，我日常开销保持在很低的水平，偶尔甚至一天的花费可能连 20 块都不到），但是有时候又会觉得自己消费欲望无穷。因为想买的东西太多了，而且基本都是一些电子产品，如果任由自己冲动消费的话，每月可能要多花掉大好几千。不过好在自己有做消费预算，而且保留了一个愿望清单，最想买的东西在列表最上面，一些可能是冲动消费的东西还会在旁边做好标记。但是，有的时候（比如今晚）还是会忍不住翻开清单，然后去网上看对应产品的最新信息、有无降价等，甚至还会去 PDD 上对比价格等等。</p><p>其实我觉得自己现在已经挺幸福的了。人的消费欲望是会随着收入水平上涨的，所以关键是要学会知足，享受自己已经拥有的东西，而不是死盯着那些还没拥有但是看起来不错的东西。快乐源于人的内心，它并非外来之物。这是卡内基《活在今天》的第一条规则里的一句话，我觉得理解了这句话基本上就可以摆脱消费主义的陷阱了。感到快乐的成本很低，只要你改变自己的想法就好了，但是前提是你的心智必须足够强大，而这又要求你有足够的阅读和思考。</p><h4 id="8-月-9-日-Don’t-be-afraid-to-speak-up"><a href="#8-月-9-日-Don’t-be-afraid-to-speak-up" class="headerlink" title="8 月 9 日 - Don’t be afraid to speak up"></a>8 月 9 日 - Don’t be afraid to speak up</h4><h4 id="8-月-10-日-改变自己"><a href="#8-月-10-日-改变自己" class="headerlink" title="8 月 10 日 - 改变自己"></a>8 月 10 日 - 改变自己</h4><p>晚上跑完步走回小区的路上在想，所有人都说拥有健康的人际关系的人生活会更幸福，但是我目前却很享受一个人的状态。写代码，看书，跑步，滑板，偶尔刷刷剧或者电影，周末宅在家，一个月回趟家，见见爸妈，吃吃他们做的家常菜，似乎已经完全习惯了没有社交的生活。我不知道自己这样算不算是普遍现象，不过偶尔也的确会觉得有些不妥。人毕竟是群居动物，需要伙伴来建立友谊，尤其是现实生活中的朋友。也知道自己应该主动一些，去和别人打招呼，哪怕和同事也是可以建立更密切的关系的。但是自己似乎完全没有动力去这么做，久而久之就觉得还是维持现状比较好。只有极偶尔感到孤单的时候，会觉得有点苦恼，比如像今天这样。所以，归根结底，还是需要改变自己吧。那么，就需要给自己制定个计划，慢慢打破这种状态。第一步，每天要和 3 个不同的人主动打招呼，并且聊上几句，从明天开始执行。</p><h4 id="8-月-11-日-写作水平的提升"><a href="#8-月-11-日-写作水平的提升" class="headerlink" title="8 月 11 日 - 写作水平的提升"></a>8 月 11 日 - 写作水平的提升</h4><p>今天晚上看了过去碎碎念，发现自己进步真的蛮大的。仅仅是决定把自己每天日记的内容公布出来，写作的能力就可以看到明显的提升。如果仅仅知道可能有人会看到自己写的东西就能使自己写作水平有提升，那么如果知道自己写的文字有更多的人看，是不是意味着自己会有更大的动力去提升自己的写作能力？所以在想是不是应该把自己写的东西发布到一些公共平台上面，比如豆瓣之类的。也许应该试试。</p><h4 id="8-月-12-日-控制心境"><a href="#8-月-12-日-控制心境" class="headerlink" title="8 月 12 日 - 控制心境"></a>8 月 12 日 - 控制心境</h4><p>越来越发现能够掌控自己心境的能力真的很重要（我不喜欢「情绪管理」这种词语，因为听起来好像「情绪」变成了负面的东西了，但情绪不过是人在受到外界刺激后做出的反应）。无论面对什么样的情景，如果我们能控制自己的心境，做到始终以不偏不倚、公正、准确、全面的角度去看待事情，那么所有问题都是可解决的，或者至少是可以被理解的。哪怕是一些会引起我们认知上不协调的东西，比如同类做出的残暴行为等，我们也可以通过人格障碍、小概率事件等来解释。另外，控制心境意味着真正的自由，即心灵上的自由，这样做其他事的时候也可以更容易体验到乐趣。如何控制自己的心境？冥想，阅读，锻炼，作息规律，多接触大自然，保持心态平和，多做对自己来说有挑战的事（每天进步一点点）。</p><h4 id="8-月-13-日-改变与有意义的生活"><a href="#8-月-13-日-改变与有意义的生活" class="headerlink" title="8 月 13 日 - 改变与有意义的生活"></a>8 月 13 日 - 改变与有意义的生活</h4><p>最近在看《亲密关系》这本书，其中多次提到安全型人格与不安全型人格在各种情景下对人际关系的处理方式的差异，对于书中出现的各种测试量表我几乎都做了，基本上可以看出自己平时的行为方式偏向属于回避型人格，也就是更少自我揭露，对待亲密关系更消极被动，更难与他人建立起合作与信任关系，对待冲突会选择逃避而不是积极解决。似乎都是不好的方面，但是这不代表自己无法改变。我知道这话自己说过无数次了，可能除此之外没有别的话可以安慰自己了。</p><p>说到改变，总会让人联想到难受、不舒服的感觉，不过从我过去的经历来看，大多数改变一开始的确会给人这种感觉，但是等到习惯之后，改变带来的正面、积极的感受会越来越多。所以只要坚持下去就好了，看着自己身上发生的一点一滴的变化，并且慢慢累积起来，直到某天发现：哦，原来我已经走了这么远了。这种感觉一定超级棒。</p><p>阅读、学习、工作，无论哪样，都是为了让自己变得更好，慢慢过上一种更有意义的生活。我相信，只要坚持这种信念，什么困难都无法将自己打倒，所有的行动都不再只是无聊的日常，而是真实且有意义的。</p><h4 id="8-月-14-日-保持诚实"><a href="#8-月-14-日-保持诚实" class="headerlink" title="8 月 14 日 - 保持诚实"></a>8 月 14 日 - 保持诚实</h4><p>保持诚实是人际交往中最重要的原则之一。因为不诚实会损坏你的信用，尤其是当你和另一方刚开始建立联系的时候。这个时候我们往往急于展现自己的价值，容易做出一些美化自己的言行，但是当别人发现你说的话和事实并不相符，反而会损害他人对你的好印象。所以，保持诚恳与真实才是我们认识新朋友时应该采纳的最佳策略。</p><p>除此之外，爱说谎的习惯对我们也有很大的危害，也许短期内能给我们带来一些甜头，但是长期来看，损失最大的还是我们自己。我们会慢慢变得更难信任他人，同时也更难赢得他人的信任。哪怕你隐藏得再好，谎言总有被戳穿的时候，而且很多时候，熟人一眼就能看出你在说谎，只是为了维护彼此的关系而选择性忽视而已。最重要的一点，保持诚实可以让你活的更加坦然且自信。</p><h4 id="8-月-15-日-择偶标准"><a href="#8-月-15-日-择偶标准" class="headerlink" title="8 月 15 日 - 择偶标准"></a>8 月 15 日 - 择偶标准</h4><p>早上很早就醒了，原本想多睡一会儿的，可惜睡不着了。躺在床上想了很多，今天要继续做哪些内容，一些往事，自己未来的女友。最后一个问题想的比较多，我又总结了几点比较重要的标准，我把它叫做 WH&amp;HH 法，即关键的两点：</p><ul><li>  What kind of person is she/he?</li><li>  How does she/he work?</li></ul><p>以及较不关键的两点：</p><ul><li>  How is her/his family?</li><li>  How is her/his look?</li></ul><p>前面两点重要是因为，第一，她是怎么样的人包含了她的性格、观念、思考的方式、过去的经历等等，这些决定了她是否和自己匹配、两个人能否走得长久。第二，她如何工作。以前没有想过择偶也需要从工作方面考虑，但其实看一个人如何工作也能知道她是什么样的人。我们一生中很大一部分时间都要花在工作上（至少目前为止是这样），如果她对待工作的态度和我不一样，那么我们在生活中肯定也和谐不了。具体而言，我希望她的工作道德是：解决问题，创造价值，坚韧不拔。不敢说自己已经做到这三点，但是至少一直在往这个方向慢慢前进。</p><p>只要前面两点没问题的话，那基本上两个人的相处就没问题了。另外较不关键的两点，家人很重要，因为长期来看，如果两个人步入婚姻的话，难免需要和对方的家人相处，如果她的家人比较难相处，这多少会给你们的关系带来一些负面的影响。再有就是外表，光看外表很肤浅，但是完全不看外表就显得有点虚伪了。一个人可以长得不好看，但是至少可以通过锻炼把自己的身材保持好，也能通过阅读和学习改善自己的气质和谈吐。身材和气质也是我们个人形象的重要一环，而且比单纯看脸更能体现一个人的长期价值，即<strong>自我控制</strong>以及<strong>持续学习</strong>的能力。</p><p>除此之外，我们通常还会考虑彼此的经济实力，对关系的满意度，彼此的忠诚度等等，但是这些都是最基本的，如果达不到彼此的标准可能两个人也不会走到一起。</p><h4 id="8-月-16-日-黄西和-Tom-Thum"><a href="#8-月-16-日-黄西和-Tom-Thum" class="headerlink" title="8 月 16 日 - 黄西和 Tom Thum"></a>8 月 16 日 - 黄西和 Tom Thum</h4><p>人生就是非常复杂同时也非常简单的，上班或上学，然后回家吃饭、睡觉，这就是人生。也许人生有时候太简单了，所以很多人为人生的意义感到困惑。…我们几乎不可能获得极致的快乐。在你人生的任何一个非常高兴的时刻，总有一些事情缠着你，使这些时刻不像理想中的那么美好。…从某种意义上来讲，幽默是面对人生不完美的最好办法。–黄西</p><p>昨晚看了一个 13 年的 <a href="https://www.youtube.com/watch?v=DFjIi2hxxf0">TED 视频</a>，一个很年轻的 beat boxer，虽然之前也在网上看过一些厉害的人表演，但是还是被他神乎其神的技巧震动到，原来一个人的声带可以发出这么多种声音，使得他一个人能表演一个乐队才能表演的音乐（还不用任何乐器！），这简直太神奇了。我想象了下他要花多少时间琢磨、研究如何发出这些声音，这不但需要大量的练习，而且还得有创造力。然后不断走上街头去试验，才能慢慢获得关注，并且通过在世界各地的演出一点点改进，最终才让他站上了 TED 的舞台向大家表演出他的『绝技』。今天看完了黄西的<a href="https://book.douban.com/subject/6872019/">自传</a>，他原本也只是一个无名小子，甚至曾经被老师抱怨是个很『慢』的学生，但是后来不但进入中科院，去到美国留学成为生物博士，还转型成为一名一流的 Stand-up comedian，曾在白宫记者年会上表演。</p><p>我觉得他们都是很好的『做自己热爱的事情』的例子，其实和之前看的 So good they can’t ignore you 也不冲突，因为黄西是基本确定自己无后顾之忧才去做 stand-up 的，而且也不是立马就辞掉本职工作去做的。我们的确应该做自己热爱的事，但确定这条路能否走得通并不需要你破釜沉舟。这之后如果你能忍受一次次失败并且还愿意坚持下去，那么你就能更坦然地面对所有可能的结果。</p><h4 id="8-月-17-日-Follow-the-rule"><a href="#8-月-17-日-Follow-the-rule" class="headerlink" title="8 月 17 日 - Follow the rule"></a>8 月 17 日 - Follow the rule</h4><p>每个行业都有自己的规则，比如如果你想要当医生，那就要先从医学院毕业，可能还得读研，参加执业医师考试、规培考试，然后是找实习，攒经验，成为主治医生，继续学习和积累经验，等等。只不过有些行业的规则可能比较死板，出路较少，而有些行业的职业发展路径比较开放。但是无论如何选择，如果想要在一个行业内取得比较好的发展，遵循既有的规则还是非常必要的。因为我们大部分人都是能力一般的普通人，做不出什么颠覆性的贡献，所以老老实实顺着前人的脚印一步步走就行了。不要觉得这也不合理那也不合理，那些只是你的抱怨。即使你是对的，如果你无法立马改变它，那也只能先接受它。Follow the rule, and then change it if you can.</p><h4 id="8-月-18-日-不要封闭自己"><a href="#8-月-18-日-不要封闭自己" class="headerlink" title="8 月 18 日 - 不要封闭自己"></a>8 月 18 日 - 不要封闭自己</h4><p>意识到自己已经毕业满三年了，都说三年是个坎，决定一个人未来的发展轨迹，但是我却觉得自己身上的一切都没有发生太大的变化，我依旧像一年前、两年前那样，上班，下班，吃饭，睡觉。工作上也不觉得自己有什么突破，技能的确增长了一些，但是还远远没有达到能独当一面的地步。也许是自己偷懒太多、不够努力？最让自己觉得不太满意的是情感经历的空白，总觉得应该发生点什么，但是最终却什么也没有发生。最主要的原因还是太封闭自己了吧，不爱出去玩也不爱交朋友。如果不学着主动一些，可能我会就这么一直一个人下去吧。所以，还是得改变哪。不要封闭自己，主动一些，反正没什么损失，不试试看怎么知道对方是不是有趣的人呢？</p><h4 id="8-月-19-日-难度适中"><a href="#8-月-19-日-难度适中" class="headerlink" title="8 月 19 日 - 难度适中"></a>8 月 19 日 - 难度适中</h4><p>晚上重新测试了下自己盲打的水平，发现不少按键的错误率更高了，于是从最简单的按键开始重新练习。其实所有技能都一样，如果一段时间不去刻意提升自己的水平，那么它就会慢慢退化。所以为了达到自己的最佳状态，就得不停地练习，而且必须是刻意练习，让保持难度在自己觉得有挑战性的区间内，而不是太难以至于想放弃或者太容易而觉得没意思。这样看来，生活、工作也是同理，如果我们让自己待在舒适区太久，要么就会感到无聊，要么就是能力退化到某天突然发现自己已经跟不上市场的需求了。希望自己能一直保持难度刚刚好的状态，不断学习，不断进步。</p><h4 id="8-月-20-日-不要急，一切都还来得及"><a href="#8-月-20-日-不要急，一切都还来得及" class="headerlink" title="8 月 20 日 - 不要急，一切都还来得及"></a>8 月 20 日 - 不要急，一切都还来得及</h4><p>突然意识到一个问题，那就是自己还很年轻的这个事实，如果按照 80 岁的寿命算的话，我的人生才过了 1/3 不到，而且前 20 年基本都是在学习，真正能够开始决定自己人生如何发展的阶段也就才几年而已。所以，不要急，慢慢来。不要觉得自己的人生已经定型了，有的人到了 60 岁都还有新的梦想，还敢去开启新的生活，更何况你才二十几岁？虽然有时候会觉得自己过去错过了很多东西，或者觉得自己浪费了很多时间，但是只要及时找到生活的方向，并且变得积极努力起来，那也是有意义的成长。我们都有自己的路要走，有的人走的比较早，有的人走的比较慢，有的人还会往回走，但是都没关系，人生本来就是探索的过程，慢慢发现自己的优势，努力创造价值，努力成为更好的人，这就是生命的意义。</p><h4 id="8-月-21-日-向外星人介绍自己"><a href="#8-月-21-日-向外星人介绍自己" class="headerlink" title="8 月 21 日 - 向外星人介绍自己"></a>8 月 21 日 - 向外星人介绍自己</h4><p>昨晚躺在床上失眠，胡思乱想了好久，突然想到如果有个外星人来到你身边，你应该如何向他打招呼并且介绍地球以及你自己。首先我会默认他能听得懂中文，如果不行那我们的交流就没有意义了，我会向他问好，然后介绍地球在银河系以及太阳系中的位置，接着介绍地球的历史，当然是简版的，可以参考这个 <a href="https://ted.com/talks/david_christian_the_history_of_our_world_in_18_minutes">TED</a>，然后我会向他介绍人类的历史，以及现阶段人类的科技水平，接着介绍我们所处的位置即中国的历史，最后是我个人的情况，我的工作，我的一些想法，对宇宙中其它文明的好奇等等。</p><h4 id="8-月-22-日-给大学新生的建议"><a href="#8-月-22-日-给大学新生的建议" class="headerlink" title="8 月 22 日 - 给大学新生的建议"></a>8 月 22 日 - 给大学新生的建议</h4><p>如果我能够回到高考结束的那个夏天，给当时的自己一些关于怎样度过大学的建议的话，我想我会告诉他下面几点：</p><ul><li>  养成阅读的习惯。阅读是最佳的开拓视野、增长心智的方式，也是自学效率最高的方法，如果能保持每月一定的阅读量，你的思维能力、洞察力甚至学习能力都会提高很多。</li><li>  定期锻炼。阅读是心智的锻炼，但是你必须拥有一个强健的身体，才能配得上一个丰富的心灵。如果我们的身体不太健康，那么想要保持一个高效的学习状态是很困难的。</li><li>  培养兴趣爱好。不要沉迷于简单易得的快感之中，多想想自己能为自己和他人创造什么价值。多做自己想做的且有意义的事。积极培养一些可以追求一生的兴趣爱好，比如围棋、绘画、舞蹈、武术、演奏乐器等等。</li><li>  掌握至少一门实用的技能。在大学里，大部分人会花很多时间学习书本上的理论知识，很少真正动手去做，也就是缺乏实践，所以我们可以想办法把自己所学的知识运用起来，多动手，最好大二之后就出去找机会实习。除此之外，也可以学习一些通用的技能，比如提高自己的英语能力，学习编程等等。</li><li>  多旅行。旅行同样是开拓眼界的方式，不同的是，你可以通过旅行认识到我们所处的这个世界是如何运行的，另外，也可能在旅途中结交一些志同道合的朋友。对大学生来说，旅行需要花时间和钱，但是这正是考验你能力的地方，如果你不想花爸妈的钱，就得思考如何通过兼职或者其它途径赚钱，以及如何更合理地分配自己的时间等等。</li><li>  多交朋友和恋爱。对这个阶段的你来说，父母在你心中的地位会逐渐被朋友替代（虽然未来还会被替换回来），所以结交一些能一起愉快相处，能互相陪伴、共同成长的伙伴，对你未来的人生来说至关重要。恋爱也是一种交友，只不过是一种更加亲密的方式。如何与异性相处也是你人生中的一门重大功课。</li></ul><p>如果能提前知道这些，我想大学四年一定会有不少收获。很可惜，大多数人都是等到快要毕业或者毕业之后才会意识到这些。希望这些建议能帮到那些即将步入大学或者还在大学校园之内的人。</p><h4 id="8-月-23-日-你住在这里的理由-amp-找到自己的生活方式"><a href="#8-月-23-日-你住在这里的理由-amp-找到自己的生活方式" class="headerlink" title="8 月 23 日 - 你住在这里的理由 &amp; 找到自己的生活方式"></a>8 月 23 日 - 你住在这里的理由 &amp; 找到自己的生活方式</h4><p>下午看了很多 A day in the life of … 的 vlog 视频，越南、泰国、墨西哥、日本等，这些国家（除了日本）的生活成本很低，所以也成了很多西方国家退休一族（包括提前退休的人）或者喜欢追求新鲜文化刺激的年轻人的热衷目的地。我在想未来自己是不是也应该去这样的地方生活一段时间，这比只是去当地旅行一两周明显更能感受当地的文化，以及体验到一种新的生活方式，比如不同的食物，新语言、新环境给人带来的挑战等等。</p><p>但是转念一想，其实在哪里生活都有一个问题，那就是你得给自己找到事情做。仅仅是去到当地很简单，去了之后干什么才是最重要的。如果是旅行，你知道自己一周或两周之后就要回去了，你的目的是在离开之前去一些好看的景点拍照、闲逛，和朋友一起享受美食等等。但是如果打算长期生活在当地，这些东西可能一个月之内你就能全部做完并且感到厌倦了，所以你必须找到自己在这里生活下去的理由，比如为了陪伴自己的爱人，获得工作机会，融入当地文化（学习语言）等。</p><p>看了这些视频，还想到另一个问题：我为什么要生活在现在这座城市？大多数人会说因为我的家人生活在这里，我在这个城市上了大学，我毕业之后就来了这座城市，这些理由看似都非常合理，但是仔细思考下，这些理由能称作理由吗？我觉得这些只是外部环境帮我们做的选择，而很少体现出这是我们自己思考后主动做出的选择。所以，我们应该问问自己，我<strong>到底</strong>为什么要继续生活在这里？这座城市的哪些地方是我特别喜欢的？如果我能重新选择，我会选择哪座城市作为我生活和工作的地方？</p><p>仔细思考这些问题，无论你是选择继续留在这座城市，还是打算开始了解另一座城市并尝试去那座城市生活，相信你对自己生活现状的感知度都会有所提高，最终也许会慢慢认识到自己想要的生活应该是什么样子。我也在持续探索中，希望我们都能找到自己想要的生活方式。</p><h4 id="8-月-24-日-3F-Focus-Feedback-Fix-it"><a href="#8-月-24-日-3F-Focus-Feedback-Fix-it" class="headerlink" title="8 月 24 日 - 3F: Focus, Feedback, Fix it"></a>8 月 24 日 - 3F: Focus, Feedback, Fix it</h4><p>专注，反馈，纠正。将技能分解成一些组成部分，以便反复地练习，并且有效地分析、确定你的不足之处，然后想出各种办法来解决它们。</p><p>这是《刻意练习》中提出的一个快速提升技能的方法。作为一个自认为自学能力还算不错的人，现在看来，其实走了不少弯路。有的时候觉得自己花的时间很多，但是学习的效果却很差，一开始还以为是自己不够努力，但其实是用的方法就有问题，还有的时候是目标不够明确。所以，动手前先动脑子思考清楚，自己的目标是什么，如何让自己保持专注，以及如何在没有旁人指导的情况下获得明确的反馈，最后再想办法纠正自己的错误。Work hard is not enough, you need to work smart.</p><h4 id="8-月-25-日-Serendipity"><a href="#8-月-25-日-Serendipity" class="headerlink" title="8 月 25 日 - Serendipity"></a>8 月 25 日 - Serendipity</h4><p>今天是七夕，但是从早上到晚上并没有感受到任何节日的气氛，可能单身狗的世界和情侣们的世界本身就不重叠吧。早上看了连叔的<a href="https://mp.weixin.qq.com/s/I1iA55FgRjXSmBJFJ0zK3Q">推文</a>，是的，我还是相信爱情的，只不过在爱情到来之前，还是先专注提升自己吧。另外，一个人也有一个人的好处，那就是自由。要好好珍惜这份自由，做自己想做的事，让自己逐渐变得更好，也许在这个过程中会有特殊的缘分降临到自己头上也说不定。</p><h4 id="8-月-26-日-重复的力量"><a href="#8-月-26-日-重复的力量" class="headerlink" title="8 月 26 日 - 重复的力量"></a>8 月 26 日 - 重复的力量</h4><p>最近发现自己的生活似乎变得非常「单调」了，早起洗漱，写晨间日记，冥想，出门，去固定的早餐店买固定的早餐，去公司，做功能，测试，提交代码，下班回家，看书，练习打字或出门滑板、跑步，洗澡，看博客自学新内容，如此循环。不过感觉自己还蛮喜欢这种生活的，也许这才是适合自己的生活节奏的吧。生活本就是平淡的，有时候还会显得重复，但是如果能在这重复中不断找到新的挑战，解决新的问题，而且自己也能乐在其中，那么也算是一种不错的生活方式吧。</p><h4 id="8-月-27-日-别光想着冬天"><a href="#8-月-27-日-别光想着冬天" class="headerlink" title="8 月 27 日 - 别光想着冬天"></a>8 月 27 日 - 别光想着冬天</h4><p>这两天天气不像前段时间那么热了，下班走路回住处也不再出一身汗了，但是经过超市的时候还是会进去买根巧乐兹，毕竟自从断食以来每天摄入的热量并不高，而且刚好可以满足下自己对甜食的欲望。走到小区的时候刚好吃完，看到西边的太阳比前几周落得更低一些了，颜色也更深沉一些了，于是突然意识到：夏天快要过完了。觉得有些沮丧，一是因为马上就要看不到这样的景象了，二是觉得时间真的过得太快了，才刚刚期待夏天不久，转眼间又要投入另一个季节了。也许是上个冬日里天色暗淡的傍晚给我的印象太过深刻了吧。再过一段时间，马上就又能体会到那种感觉了。不过还好，秋天也是我喜欢的季节，我甚至觉得比夏天还好。</p><p>还是乐观一点吧，别光想着冬天了。</p><h4 id="8-月-28-日-有梦想且一直努力的人"><a href="#8-月-28-日-有梦想且一直努力的人" class="headerlink" title="8 月 28 日 - 有梦想且一直努力的人"></a>8 月 28 日 - 有梦想且一直努力的人</h4><p>晚上尝试了一个线上组 CP 的小程序，自我介绍的最后一栏是你心动的 CP 是什么样的，我写的是「有梦想并且一直努力的人」，听上去好像有点虚、不太实际，但这真的是我真实的想法。因为我觉得首先你是什么样的人，你就会喜欢上什么样的人，我想要成为这样的人，因此我觉得她也应该是这样的人，如果这一点核心都达不到的话，那么其余的沟通都显得多余了。那么我的梦想是什么？暂时还没有答案，但是我也补充了一点「即使还处在寻找梦想的阶段，我们依然可以把目前在做的事当成自己的目标，努力做到最好」。这也是我喜欢的品质之一，即「全情投入的能力」，无论做什么事都能乐在其中，这样的人一定是个快乐的人。似乎自己不是在和人谈恋爱，而是在和各种品质谈恋爱，哈哈~然而温暖而长久的关系就一定会要求两个人都具有良好的品格，在这方面降低要求的话就是在对自己的未来生活不负责任。嗯，努力成为这样的人吧。</p><h4 id="8-月-29-日-用成长型思维思考"><a href="#8-月-29-日-用成长型思维思考" class="headerlink" title="8 月 29 日 - 用成长型思维思考"></a>8 月 29 日 - 用成长型思维思考</h4><p>人生唯一可以确定的是不确定性。喜欢用固定型思维方式考虑问题的人容易忽略一个事实，那就是我们处在一个时刻变化的环境之中，没有什么是一成不变的。在这样一个时代，如果我们不再扩展自己的边界，很快就会觉得身边的一切变得陌生，并且也无法取得任何进步，进入到更高一级的环境中。另外，固定型思维的人也容易以为自己是不可改变的（性格、社交能力、学习能力等等），但其实你现在的状态并不能代表你将来的状态，只要我们一直在尝试改变，未来会发生什么就还是未知数，无论如何也不会永远停留在现下的状态。所以只要积极一些，努力去拓展自己舒适圈，慢慢地，我们会进化成一个全新的自己。（敷衍的文字，但是我还是决定保留它们）</p><h4 id="8-月-30-日-现实世界总是不完美"><a href="#8-月-30-日-现实世界总是不完美" class="headerlink" title="8 月 30 日 - 现实世界总是不完美"></a>8 月 30 日 - 现实世界总是不完美</h4><p>晚上去电影院重新看了一遍盗梦空间，这么多年过去依旧觉得这是诺兰的经典之作。有时候在想，如果真的存在那样一个梦境或者虚拟的世界，我还会选择回到现实吗？可能会犹豫一下吧，因为随心所欲、自由建造自己的世界的诱惑实在是太大了。但是仔细思考之后，我应该还是会选择现实，因为我觉得人生正是由于存在种种不完美才显得珍贵吧，而且除非人能够实现永生，否则时间永远是最稀缺的东西。</p><p>人生只有一次，好好努力，应对生活中出现的各种各样的困难，同时也享受生活；照顾好家人，多花时间陪伴自己爱的人；做自己想做的事，尽量不要留下遗憾。这样的人生在我眼里就是完美的了。</p><h4 id="8-月-31-日-改变需要有耐心"><a href="#8-月-31-日-改变需要有耐心" class="headerlink" title="8 月 31 日 - 改变需要有耐心"></a>8 月 31 日 - 改变需要有耐心</h4><p>今天是八月的最后一天，也是周一，但是特别不在状态。一方面是刚结束周末，另一方面是开发遇到一些困难卡壳了，还有就是因为一些琐事而分心。其实想想，如果经常这样低效率地利用时间，再加上容易分心，那更加会觉得时间过得快了，所以养成好习惯特别重要。但是一个好习惯，打破一次就会一而再再而三地重复打破，所以坚持和自律也特别重要。这也是为什么我始终把「每天进步一点点」这句话作为自己的签名。习惯就是动力，那些自律的人之所以能够一直坚持下去，最关键的就是养成了好习惯，获得了正确的激励，走上了正向循环的道路。但是说起来容易做起来难，我也不知道自己能把好习惯坚持多久。不过无论怎样，只要一直保持自省，保持乐观向上的态度就足够了。改变需要有耐心。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当下的每一刻</title>
      <link href="/2020-7/"/>
      <url>/2020-7/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/ygNNpvzuNFA" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>这个月感觉过得特别漫长，好在是尤其漫长的梅雨季终于结束了，真正的夏天也来了：建筑外令人眩晕的耀眼阳光，午后不知疲倦的知了声，甜腻的冰淇淋，混杂了汗水与香水味的燥热空气，以及早上醒来后手臂上被蚊子叮咬的包。我喜欢夏天，它让我感到身边的一切都慵懒着，同时也充满了欲望。不要去担心未来会怎样，珍惜、享受、过好当下的每一刻就好了。</p></blockquote><h4 id="7-月-1-日-自我选择论"><a href="#7-月-1-日-自我选择论" class="headerlink" title="7 月 1 日 - 自我选择论"></a>7 月 1 日 - 自我选择论</h4><p>决定你的生活方式（人生状态）的不是其他任何人，而是你自己。–《被讨厌的勇气》</p><p>当我们在生活中遇到不如意的事情的时候，一开始难免会感到沮丧、失望，甚至会抱怨、诅咒他人，但是平静下来之后，需要思考造成目前这种状况出现的原因，不是别人，而是自己。无论是何种遭遇，我们都有选择权决定事态如何发展，就算一点都决定不了，至少还可以控制自己的情绪。如果你始终选择以积极的态度应对，那么就没有什么东西可以击倒你。</p><span id="more"></span><h4 id="7-月-2-日-没有什么困难是克服不了的"><a href="#7-月-2-日-没有什么困难是克服不了的" class="headerlink" title="7 月 2 日 - 没有什么困难是克服不了的"></a>7 月 2 日 - 没有什么困难是克服不了的</h4><p>你相信命运会把你带到更好的地方，相信改变的过程可以不断纠正存在。这就是探索精神的本质。–《人生十二法则》</p><p>接受不完美的世界和不完美的自己，永远不要放弃使自己变得更好的信念，没有什么困难是克服不了的。</p><h4 id="7-月-3-日-硬抗"><a href="#7-月-3-日-硬抗" class="headerlink" title="7 月 3 日 - 硬抗"></a>7 月 3 日 - 硬抗</h4><p>今晚注定是难忘的一晚，和同事在宿舍调 bug 到凌晨，然后打包又遇到各种问题，最终凌晨 3 点解决完所有问题然后发布。中间心里多次想过『算了吧，放弃好了，反正就这一次』，不过最终还是熬过来了。关键时刻还是得<strong>硬抗</strong>。</p><h4 id="7-月-4-日-找到自己的边界"><a href="#7-月-4-日-找到自己的边界" class="headerlink" title="7 月 4 日 - 找到自己的边界"></a>7 月 4 日 - 找到自己的边界</h4><p>这世上唯一不变的东西是变化，为了应对这种变化，我们就得不断调整自己的行为和与外界互动的方式，这是人类这一物种得以持续在这个星球上繁衍生存下去的原因。但是每个人能够适应的变化或者挑战是有阈值的，如果环境变化过于巨大，我们来不及调整自身，那么就会发生一些不愿意看到的事情，比如自暴自弃，逃避消沉，甚至做出一些极端的行为等等。所以，我们需要通过一点点地摸索，找出自己的边界在哪，看看自己能承受何种程度的挑战，然后尝试、失败、再尝试。慢慢地，我们在提升自己能力的同时，也会一点点加深对自己的了解。</p><h4 id="7-月-5-日-如何面对职场中的上级压力"><a href="#7-月-5-日-如何面对职场中的上级压力" class="headerlink" title="7 月 5 日 - 如何面对职场中的上级压力"></a>7 月 5 日 - 如何面对职场中的上级压力</h4><p>今天第一次体会到职场中来自上级的压力，原因是技术经理的一句「以后我说的你就要去做」。我当时只能沉默以对，但是心里已经翻江倒海，甚至不停地在想提离职的事。晚上回来后又思考了很久，自己为什么会被这样一句话击中，是反感这种命令式的口吻？觉得很没面子？还是觉得他语气中带着一种不尊重？又或者觉得自己过去这一周的加班以求项目及时上线但却没有受到认可，而感到委屈？或许都有吧。尽管知道自己最终是要离开这里的，但是还是希望在这里留下的尽量都是些愉快的回忆，而不是时常想着自己最终跳槽成功的那一天。这种状态肯定不是自己想要的。</p><p>究其根本，也不能全都怪别人吧，和自己的心态也有关系，总是容易往不好的方面想，如果自己能保持更主动开放的心态，很多事情会顺畅很多。所以，不要太在乎别人说什么，做好自己该做的事，并且问心无愧就好了。每个人都有自己的角色需要扮演，而大家的最终的目标是一致的，那就是做出好产品，提供好服务，让用户满意，还有在这一过程中，不断提升自己的能力，同时获得更大的认可和激励。</p><h4 id="7-月-6-日-关于勇敢"><a href="#7-月-6-日-关于勇敢" class="headerlink" title="7 月 6 日 - 关于勇敢"></a>7 月 6 日 - 关于勇敢</h4><p>勇敢是：当你还未开始就已知道自己会输，可你依然要去做，而且无论如何都要把它坚持到底。–《杀死一只知更鸟》</p><p>看到这句话的时候被触动到了，立马翻身想要把它摘抄下来。勇敢有很多种，敢于挑战自己的恐惧是一种勇敢，在比自己强大的敌人面前也不退缩是一种勇敢，在比自己弱小的人或事物面前，依旧保持礼貌和绅士风度，即使知道对方不喜欢甚至讨厌自己，这更是一种勇敢。</p><h4 id="7-月-7-日-知足常乐与追求更好"><a href="#7-月-7-日-知足常乐与追求更好" class="headerlink" title="7 月 7 日 - 知足常乐与追求更好"></a>7 月 7 日 - 知足常乐与追求更好</h4><p>盖茨比中有句名言：每逢你想要批评任何人的时候，你就记住，这个世界上所有的人，并不是个个都有过你拥有的那些优越条件。这句话很有借鉴意义，尤其是在目前这种不景气的社会氛围之下：对于大多数有一份稳定工作的人而言，你所抱怨的生活可能正是其他人所期望的生活。</p><p>想想自己目前的状态，工作不算太忙，下班后还能看会儿书，晚上偶尔出去跑跑步、玩下滑板，还有点儿积蓄，哪怕不工作闲个一两年也不用太担心（虽然并太不可能）。除了身边没什么人可以交流，有点郁闷之外，基本上已经实现我毕业前所有的期望了。话虽如此，知足常乐的确是一种好的心态，但是时不时的，我们还是得督促自己继续向前，不要太容易满足，当更好的机会出现的时候还是要敢于去追求。</p><h4 id="7-月-8-日-沉默的沟通"><a href="#7-月-8-日-沉默的沟通" class="headerlink" title="7 月 8 日 - 沉默的沟通"></a>7 月 8 日 - 沉默的沟通</h4><p>有时候在想自己其实无形之中也在影响着他人，比如办公室里的氛围，即使你不说话，其实你也是在和他人交流，只不过是以一种沉默的方式。比如他人在闲聊的时候，你戴上了耳机，说明你对别人的话题不感兴趣，然后他们也会觉得没意思而越来越少地进行这样的闲聊了。那么，我会选择什么样的话题参与呢？首先我需要看对方是否和自己是同一类人。这点可以从他平时说话的方式，一些行为方式等看出端倪，如果了解到对方和自己不一样，或者我的观点有可能会造成分歧，那么我就会选择保持沉默。的确，这种策略很被动，有可能会错过很多有意思的交流，但是这是作为一个 liberalist 所必须要付出的代价（为了回避冲突以及被攻击）。</p><h4 id="7-月-9-日-被注视的压力"><a href="#7-月-9-日-被注视的压力" class="headerlink" title="7 月 9 日 - 被注视的压力"></a>7 月 9 日 - 被注视的压力</h4><p>最近觉得自己状态还不错，应该继续保持下去。唯一需要改进的是，不要在心里抱怨别人，多想想别人的难处以及自己能做什么。</p><p>晚上出去跑步，没想到跑到一半开始下雨了，一开始是毛毛细雨，等跑回小区时已经是小雨加一阵阵的风了，不过这季节淋会儿雨没什么大事，只不过总觉得路人看自己的眼神不大一样，有的带着微笑像是在表示佩服，有的带着不解的眼神看我跑过去，还有的面无表情地盯着我看，等我迎上他的目光，他又转过头去了。</p><p>我以前特别害怕被别人盯着看，但是现在不会了。因为自从开始跑步之后，意识到其实并没有太多人会真的去关注你，每个人都有自己的事情要忙。对于一个陌生人而言，只要你没有妨碍到他们的行动，他们真的不在乎你在做什么。其实公众场合演讲也一样，除非观众是付过费的，否则他们并不在乎你讲的是好还是坏，你的压力纯粹是自己想象出来的。</p><h4 id="7-月-10-日-把写作当做修禅"><a href="#7-月-10-日-把写作当做修禅" class="headerlink" title="7 月 10 日 - 把写作当做修禅"></a>7 月 10 日 - 把写作当做修禅</h4><p>写作最要紧的就是真实，坦然面对自己内心最深处的想法，不要害怕会写出让自己害羞、难堪的东西，毕竟我们都只是人类而已，都会犯错，过去怎样不代表我们将来也会这样。另外，写作需要你表达出当下那一刻脑海中的想法与感受，因此不要觉得有负担，即使写出的东西让你感到震惊，觉得不像是自己，但这仅仅代表了那一刻的你自己。尽情地写吧，把写作当做禅修。</p><h4 id="7-月-11-日-向理想中的生活方式靠近"><a href="#7-月-11-日-向理想中的生活方式靠近" class="headerlink" title="7 月 11 日 - 向理想中的生活方式靠近"></a>7 月 11 日 - 向理想中的生活方式靠近</h4><p>什么样的生活方式才是适合自己的？选择自己喜欢的生活方式有多难？</p><p>写下这两个问题时，脑海中浮现的第一个想法是，一定要有很多钱吧，但是另一个声音却告诉我，那不是还有很多人没有钱但是也过的很开心吗？此刻就在我打字的时候，我知道在这个世界上的某个地方，一定有人从来不工作，生活也很简单，但是每天都在做着自己喜欢的事情。只要你生活在一个经济发达的地方，要是只求每天填饱肚子，晚上有地方住，这基本不算是什么难事。既然这样，那为什么还是有很多人过得很痛苦？我猜了下原因可能有：生活使他们变得麻木了；缺乏改变的勇气；背负着家庭的责任等等。不过虽然每个人都有自己的难处，但是我们还是应该试着去改变，哪怕只是从一点点小的改变开始。比如假如你想要当作家，那就每天抽出 10 分钟写点东西，随便什么，可以是白天工作中的奇思妙想，或者是你的晚餐，你和家人之间发生的趣事等等。</p><h4 id="7-月-12-日-接纳那个真实的、丑陋的自己"><a href="#7-月-12-日-接纳那个真实的、丑陋的自己" class="headerlink" title="7 月 12 日 - 接纳那个真实的、丑陋的自己"></a>7 月 12 日 - 接纳那个真实的、丑陋的自己</h4><p>用不着愤怒、自责或自怜，而要接受真实的自己。–《写出我心》</p><p>我们为什么难以接受真实的自己？因为接受真实的自己意味着承认自己身上也存在反复无常、胆小、迎合、嫉妒、欺软怕硬、不诚实、不道德、色情、贪婪、懒惰、丑陋、邪恶等等令人讨厌的地方。每天面对自己不喜欢的人就算了，可惜回到家还要面对不喜欢的自己。这真的太难了。但是这也正是能使我们显得伟大的地方，看到它们，承认它们，而且还要和它们共舞。不用试着去改变，只要接纳它们就足够了。生而为人，不必抱歉，正是因为我们的不完美，我们的存在才更有意义。</p><h4 id="7-月-13-日-注意大脑中的想法，保持自省"><a href="#7-月-13-日-注意大脑中的想法，保持自省" class="headerlink" title="7 月 13 日 - 注意大脑中的想法，保持自省"></a>7 月 13 日 - 注意大脑中的想法，保持自省</h4><p>注意到心中那个邪恶的自己。比如当你刷牙的时候，这个时候室友的猫走了过来，坐在一旁对你做了个撒娇的姿势，而此时你却丝毫不觉得它可爱，看到它把肚子朝向你的样子，你的脑海中甚至有一脚踩上去的想法，意识到自己刚刚的想法之后，接着就是自责与羞愧。但是那一刻之后，我选择了原谅自己，因为我注意到了自己心中恶的一面，而且还试着反复观察、了解它的根源——我因为对室友有怨气所以才迁怒于他的猫，并且一时间忘记了猫身上种种可爱的地方，这不代表我天生就是个邪恶的人。</p><p>很多时候，我们都需要保持这种自省的能力，才能保证自己走在正确的道路上。</p><h4 id="7-月-14-日-生活就是在修禅"><a href="#7-月-14-日-生活就是在修禅" class="headerlink" title="7 月 14 日 - 生活就是在修禅"></a>7 月 14 日 - 生活就是在修禅</h4><p>每个人都执着于自己的目标，每个人都为自己的目标所困扰，每个人都在经受痛苦。–《悉达多》</p><p>这世界毕竟是世俗的世界，我们无法左右，也不可能逃离太久，唯有直面生活，去经历、体验生活的方方面面，苦难、迷惘、渴望、失望、极喜与极悲、背叛与被抛弃、痛苦的抉择、亲人的离去、惨痛的失败、一无所有、受他人信任、被爱戴、被关心、被原谅，等等等等，就像悉达多，一开始是有希望、人人喜爱的婆罗门，然后成为看破红尘、不受教条束缚的沙门，接着又受世宗感化，走入尘俗事务，最终又幡然醒悟，在河边悟道，加入了船夫维苏德瓦，在河水声中参禅，接着又因为儿子的离去重新陷入痛苦，最后在维苏德瓦的帮助下才步入圆融统一的境界。</p><p>我们每个人都是悉达多，我们都有自己的痛苦需要面对，生活就是在修禅。看清生活的真相，然后拥抱生活，拥抱生命，并且热爱生命中出现的一切事物。</p><h4 id="7-月-15-日-爱情与美"><a href="#7-月-15-日-爱情与美" class="headerlink" title="7 月 15 日 - 爱情与美"></a>7 月 15 日 - 爱情与美</h4><p>说来遗憾，在我即将满 26 周岁的时候，依旧没有尝过真正的爱情的滋味，没有体验过两个人彼此信任，两颗心灵紧紧相贴的感觉。但是至少有过喜欢的人，知道喜欢一个人后，仰慕对方的同时又渴望得到对方欣赏的那种非常美妙的感觉。未来也许会遇到更多的人，或者更少的人，这些都不重要，但是一定要保持心中这种观察、欣赏他人身上的美的能力，不仅仅是对异性，同性也一样。在那些值得我倾慕的人的身上，都有一种美好的品质，它会让你觉得活着真好。</p><p>然而这世上美的东西太多了，不仅我们的同类身上存在这种美，万物都有，夕阳、云朵、草地、十字路口、喷气飞机飞过后留下的轨迹、随风摇摆的树木、水池里倒印的天空。这就是为什么我们需要旅行，去发现远方陌生世界里所存在的、我们没有见过的美。这也是为什么我们需要艺术，去借艺术家的眼光以另一种方式欣赏我们的世界或者他们心中的世界。还有人的心灵之美，一旦我们开始追求美之后，我们的心灵也会发生变化，开始变得清澈、透明，感到幸福，关心他人，热爱生命中出现的一切，平静宁和。</p><h4 id="7-月-16-日-我还健康地活着"><a href="#7-月-16-日-我还健康地活着" class="headerlink" title="7 月 16 日 - 我还健康地活着"></a>7 月 16 日 - 我还健康地活着</h4><p>我们可以训练自己忍受外界的一切痛苦，饥饿、寒冷、酷热、皮肉之痛，甚至缺氧，然而唯有身体器官病变带来的疼痛是让人无法忍受的。虽然我自己没有亲身经历过，但是从他人的描述、书本、影音中，还是能感受到人在这种痛苦面前的那种无力感。有时候是撕心裂肺，有时候是慢性疾病在悄无声息中给人带来的改变，无论是哪一种，都让人感到人类自身的脆弱与渺小。这也可以部分解释为什么现代文明出现之前，宗教、神秘主义、民间风俗信仰可以这样发达。</p><p>但是，因为人类自身的复杂性，即使是医疗水平如此进步的今天，人类还是有很多无法解决的疾病。如果把人的身体当做一架机器，那么即使是在出厂前经过最全面的分析检测与精工细作，其出现瑕疵的概率依然会高到离谱，更不要谈在这之后的维护了。一想到每个人身上都有几百亿个互相连结的神经元，在不停工作的同时还能保证不出错，就觉得不可思议。这样看来，光是「我还健康地活着」这一件事就值得庆祝。</p><h4 id="7-月-17-日-不必向任何人证明自己"><a href="#7-月-17-日-不必向任何人证明自己" class="headerlink" title="7 月 17 日 - 不必向任何人证明自己"></a>7 月 17 日 - 不必向任何人证明自己</h4><p>We are supposed to be different, when people look at us, BELIEVE IN YOURSELF.</p><p>一直以来都觉得自己不够自信，但是又不知道该如何克服。自信的人似乎都有一个特点，那就是不在乎别人觉得自己是否自信。他们身上由内而外散发出一种「我有我知道的，也有我不知道的，你呢？」的那种感觉。非常希望自己能够逐渐转换到这种心态，不必在乎别人怎么看待自己，你只须做你自己。每个人都有自己短板，不要害怕暴露它们，只要你承认了自己的无知，那么他人就成了你的老师，而不是给你打分的裁判，有时候主动示弱反而能赢得他人的好感。你不必向任何人证明自己。</p><h4 id="7-月-18-日-节食的好处"><a href="#7-月-18-日-节食的好处" class="headerlink" title="7 月 18 日 - 节食的好处"></a>7 月 18 日 - 节食的好处</h4><p>开始尝试节食有一段时间了，渐渐地对食物有了不同的看法，以前总是喜欢把食物分类，比如分为好吃的和不好吃的，健康的和不健康的，简单的和精致的，中餐和西餐，家常菜和网红美食等等，但是现在觉得，食物就只是食物而已，它可以为我们提供能量，让我们保持生存。除此之外，其它的意义都是我们为食物赋予的。比如用美食犒劳自己，这个时候食物成了我们的欲望；用食物维护巩固一段关系，这个时候食物成了一种社交手段。</p><p>节食让我更加尊重食物，无论它是否是用心制作出来的，这背后都代表着他人的劳动和付出。因此你也会开始认真对待自己的工作，因为你会意识到你的工作也能对他人造成影响。另外，它也让我抛弃了对食物的偏见，开始更愿意接受和享受各种各样的不同的食物。</p><h4 id="7-月-19-日-普通人的幸福标准"><a href="#7-月-19-日-普通人的幸福标准" class="headerlink" title="7 月 19 日 - 普通人的幸福标准"></a>7 月 19 日 - 普通人的幸福标准</h4><p>晚上在路边小公园练滑板的时候，遇到一对出来遛狗的中年夫妻，丈夫差不多 40 来岁，一直定定地站在边上看我玩，看得我都有点不好意思了。我饶着亭子滑了一圈，但是他依旧没走，于是我试着和他眼神交流了下，他便走近了和我搭话。他说看到我在这里练滑板好多次了，问我现在是不是已经很熟练了，我笑笑说还行吧。他问我几岁了，我让他猜，他老婆说我应该还在上高中，我笑了笑说，我都工作好多年了。他说他们也住在这附近。我看他依旧没有离开的意思，就问他有小孩吗，如果感兴趣我可以教他。他说他有个儿子，19岁，刚高考完，然后我说那有空可以让他过来我教他玩。我还让他们踩上滑板试了试。然后又继续看我玩了一会儿，才牵着狗走了。虽然他脸上一直没什么表情，但是我能感觉到这是一个很有爱的丈夫和爸爸。</p><p>照顾好自己和家人，然后还有时间做自己喜欢的事，这应该就算是普通人的幸福生活了吧。</p><h4 id="7-月-20-日-自燃型的我回归了"><a href="#7-月-20-日-自燃型的我回归了" class="headerlink" title="7 月 20 日 - 自燃型的我回归了"></a>7 月 20 日 - <a href="https://ajiew.github.io/self-ignite/">自燃型的我回归了</a></h4><h4 id="7-月-21-日-行动起来"><a href="#7-月-21-日-行动起来" class="headerlink" title="7 月 21 日 - 行动起来"></a>7 月 21 日 - 行动起来</h4><p>晚上一度又陷入了焦虑之中，还是没法想清楚自己到底想要什么，只知道现在的状态不是自己想要的，不喜欢眼下的一切，然而又找不到方向。也许这就是好高骛远？</p><p>但是无论怎样，跳槽也好，继续待在这里也好，现在最大的目标还是想先把新版 App 给做好，因为不想半途而废。而且这也是对自己的一个挑战，用了新的技术栈，虽然可能未来不一定会继续使用下去，但是至少拓宽了自己的知识面。其次，动起手来总比坐着空想更有意义，况且空想很容易就会让自己走进死胡同，拷问自己眼前做的一切意义何在。然而意义、目标这些东西本身就是要靠自己去寻找的，同一个人在不同阶段得到的答案也不相同。想起电影《降临》中外星人登场的那一幕，迷雾缭绕，只有打在玻璃上的神秘图案，主人公就凭着自己的专业知识去一点点破解其中的奥秘。所以，不要坐着想太久，行动起来吧，只有这样才能往前走。</p><h4 id="7-月-22-日-关心你做的事"><a href="#7-月-22-日-关心你做的事" class="headerlink" title="7 月 22 日 - 关心你做的事"></a>7 月 22 日 - 关心你做的事</h4><p>你做任何一件事，都可以把它做得很漂亮，或是很丑陋。–《禅与摩托车维修艺术》</p><p>特别认同上面这句话，尤其是在维护老项目的代码的时候。好代码逻辑清晰，容易读懂，没有模棱两可的地方；烂代码一个简单的功能都能搞得极其复杂，仿佛一团乱麻，似乎存心要让后来者看不懂。代码是否清晰易懂是区分一个程序员好坏的标准之一。但是我在想为什么有的人会写出烂代码，是因为故意这样的吗？其实不是，最主要的原因还是他们并不在乎，只要功能实现了就好了，至于后期的维护，以及是否有更好的方法，从来懒得去想。他们并不是真的关心自己做的事，所以就不在乎其完成的好与坏。</p><p>所以，我们一定尽量要用高标准要求自己，即使知道一些没有人会发现的细节也一样，因为正是那些细节决定了我们能达到什么样的高度。也许有时候很忙，会没有时间去完善，但是等到闲下来的时候一定要弥补回来。多用 todo 以及注释，这样未来自己或者他人看到这段代码的时候，至少可以知道哪一部分有问题，要从哪里开始完善。</p><h4 id="7-月-23-日-控制自己的意识"><a href="#7-月-23-日-控制自己的意识" class="headerlink" title="7 月 23 日 - 控制自己的意识"></a>7 月 23 日 - 控制自己的意识</h4><p>时间就像砂锅盖上的水，总是在你不经意的时候蒸发得越来越快。现在已经七月下旬了，孩子们的暑假已经快要过去了一半，早上听到楼上楼下两个孩子在聊天，末了约定下次一起去楼下玩耍的时间。突然有种恍惚的感觉，觉得自己也和他们一样经历过相同的事。人脑非常容易糊弄，只要拥有记忆，再加上一些细节的粉饰，我们就能把别人的体验当成是自己的。延展开来，我们的意识常常也是可以人为控制的，比如快乐时别人说了一两句扫兴的话，你的快乐可能立马就打了对折，这说明快乐不仅无法持续，而且非常受外界环境的影响，但是如果我们能控制自己的意识，事情就变得不一样起来。我们可以选择如何解读发生在自己身上的事，可以决定自己从一件相同的事情中发现两个截然不同的结论，这完全是由我们自己的意识决定的。做个实验，今天注意到所有不好的体验，然后换种角度来看待，看看会发生什么。</p><h4 id="7-月-24-日-改变自己的意识"><a href="#7-月-24-日-改变自己的意识" class="headerlink" title="7 月 24 日 - 改变自己的意识"></a>7 月 24 日 - 改变自己的意识</h4><p>有时候觉得自己似乎陷入了某种习惯的陷阱，无法摆脱，明明知道自己可以不用那么去做的，而且也不想去做，但事实上还是会无意识地去做。如何改变呢？仅仅告诉自己不去想它吗？好像没什么用，因为大脑一旦开始想白熊就没法停下来。不过好在习惯也是可以改变的吧，先尝试控制自己的意识，再尝试改变环境，制造出自己想要的结果，最后再利用外界的刺激反过来塑造自己的意识。可能多花点时间冥想也是有必要的。</p><h4 id="7-月-25-日-走自己选择的路"><a href="#7-月-25-日-走自己选择的路" class="headerlink" title="7 月 25 日 - 走自己选择的路"></a>7 月 25 日 - 走自己选择的路</h4><p>今天高考分数出来了，我们家有个小妹妹也是今年的考生，所以家族群里这几天就热闹了。晚上看到姨夫发了妹妹的分数，大概超过省内一本线十几分吧，在我眼里算是很不错了。舅舅在群里发了几张选学校的截图，大概就是让看看这分数国内有哪些好学校可以挑。其实我想说选城市最重要，能去北上广就不要去二线。但是终究还是删除了没发出去，因为从之前他们的反应来看，估计发了也没什么用。他们的观点是学校比较重要，比如浙师大就比杭师大听着好听，尽管浙师大在金华而杭师大在杭州。另外，我自己只是渣渣三本学校毕业，也没有一线城市的工作、生活经验，所以即使这么说了也显得没什么说服力。而且观念这东西，也不是光靠你一两句话别人就能接受并且发生改变的，除非你在别人的心中地位特别高或者他们特别信任你，那种情况下估计别人早就直接来问你的意见了。所以，建议可以给，但是别人是否采纳就是他们自己的事情了，毕竟每个人的路只能自己去走，自己选的不一定是最好的，但至少不会后悔。</p><h4 id="7-月-26-日-懒惰是最大的敌人"><a href="#7-月-26-日-懒惰是最大的敌人" class="headerlink" title="7 月 26 日 - 懒惰是最大的敌人"></a>7 月 26 日 - 懒惰是最大的敌人</h4><p>晚上跑步的时候突然意识到，过去每当状态不好的时候大多是因为太懒惰，懒于锻炼，懒于阅读，懒于自我探索、沉迷于廉价的感官刺激，等等。如果自己能一直保持现在这样的状态，未来会发生什么样的变化呢？我觉得至少整个人可以变得更乐观、自信，心态更平和、豁达吧，这对我来说就已经足够了。能见证自己不停成长真的很开心，只可惜没有其他人可以分享这份喜悦。不过也没关系，因为我知道此刻在这个世界的某个角落里，一定有人和我经历类似的心路里程，我不是孤独一人，也不会一直孤独一人下去。好像有点伤感，那就这样吧。</p><h4 id="7-月-27-日-感激他人的善意，他们本可不必如此"><a href="#7-月-27-日-感激他人的善意，他们本可不必如此" class="headerlink" title="7 月 27 日 - 感激他人的善意，他们本可不必如此"></a>7 月 27 日 - 感激他人的善意，他们本可不必如此</h4><p>我们要有感受他人善意的能力，同时还要学会传递善意。我非常不喜欢自己身上的一点是，有时候会忽视他人表达的善意，尤其是那些我不喜欢或者不在乎的人。虽然我觉得向他人表达善意应该是不求回报的，但是如果对方能够给自己一些正面的回馈的话，心里还是会很开心的吧，至少能证明自己想要传达的心意被对方感受到了。但是落到我自己身上，常常就做不到。比如中午食堂吃饭的时候，打菜的师傅给我多打了一些菜，但是我却没有做出任何反应。虽然知道他是好意，但是我却选择了忽视，我觉得这也是一种不礼貌吧。不要把一切都当成理所当然的，无论是陌生人还是身边的人。每当别人为你做了一件事的时候，要想到<strong>他们本可以不必如此</strong>。</p><h4 id="7-月-28-日-每天进步一点点"><a href="#7-月-28-日-每天进步一点点" class="headerlink" title="7 月 28 日 - 每天进步一点点"></a>7 月 28 日 - 每天进步一点点</h4><p>看了昨晚的碎碎念，有点感动，觉得自己能意识到自己身上的问题真的很不错，但是实际上，自己所写下的那些东西，又有多少是真的能做到的呢？这样想难免有点令人沮丧，不过，毕竟认识到自己的问题只是第一步，而<strong>改变</strong>则需要花更多的时间和精力，<strong>不断地反复，不断地自我纠正，最终改变才有可能发生</strong>。每个人都有自己的局限性，我们要做的是认识和承认这局限，然后试图一点点改变它。哪怕这种改变像西西弗斯滚石上山一样，只不过是一遍遍重复徒劳的工作，但是心智的高山却是会不停增加高度的。从这点来看，就值得感到骄傲和满足了。</p><h4 id="7-月-29-日-All-you-have-to-do-is-to-ask"><a href="#7-月-29-日-All-you-have-to-do-is-to-ask" class="headerlink" title="7 月 29 日 - All you have to do is to ask"></a>7 月 29 日 - All you have to do is to ask</h4><p>All you have to do is to ask. People are willing to help you out, don’t be hesitated to ask for help. You are brave enough to do that and don’t hold too much ego about yourself.</p><h4 id="7-月-30-日-断食的目的"><a href="#7-月-30-日-断食的目的" class="headerlink" title="7 月 30 日 - 断食的目的"></a>7 月 30 日 - 断食的目的</h4><p>昨晚完整看完了 <a href="https://www.youtube.com/channel/UCnYMOamNKLGVlJgRUbamveA">Tom Bilyeu</a> 和 David Sinclair 关于人体衰老的<a href="https://www.youtube.com/watch?v=IEz1P4i1P7s">谈话</a>，涨了很多知识，虽然可能记不住太多，但是大概可以知道断食的科学依据，现在轻断食已经挺流行的了，但是从科学角度来看，这样的知识普及真的太重要了。很多人都觉得断食就是节食，其实断食是为了让我们更好地享受食物以及生活，如果把次序弄反了那就真的得不偿失了。</p><h4 id="7-月-31-日-人生的意义"><a href="#7-月-31-日-人生的意义" class="headerlink" title="7 月 31 日 - 人生的意义"></a>7 月 31 日 - 人生的意义</h4><p>晚上坐顺风车回家，司机师傅是我们那儿附近的人，所以和他说话感觉比较亲近。听他聊了自己的工作、生活，他平时在杭州、临安两地跑网约车、顺风车，一两周回一趟家，陪女儿和家人团聚。我不可免俗地问了他的收入情况，他说他算是比较随意，早上 7 点出门，晚上 7 点结束，干这行的完全靠熬时间，要是努努力每月收入也能上一两万，但是他不想把自己搞得太累。</p><p>我们经过转塘的时候接了另外一个乘客，一个年纪不算太大的阿姨，是司机师傅通过另一个平台的顺风车接到的。听他们聊了几句，阿姨也是我们那儿的人，不过由于他们说的是他们那边的方言，我能听懂但基本插不上话，于是就听他们聊天。阿姨来杭州是为了帮大女儿带一岁半的孩子，平时周末才回家。她说她还是喜欢农村，在城市里住不惯。而且虽然她两个女儿在杭州都过得很好，但是她还是时常会晚上焦虑得睡不着觉，医生说她有抑郁症。她说她发病严重的时候还会无缘无故离家出走，不过现在好一些了。司机说人是这样的，本来在人家眼里应该过得很开心的，但是实际上却各人有各人的苦，他劝阿姨想开点。阿姨说是的，人都有他自己的难处，别说普通老百姓了，就算你是大老板也会觉得难。</p><p>我的观点和他们基本一致，人生就是这样充满了各种不如人意的地方，很辛苦，但是这辛苦应该是我们主动选择的，无论是为了我们爱的人，还是为了追求自己的理想，我们注定要奔波劳累、努力思索出路、为自己和他人付出，但是只要我们能从中找到快乐，找到自己人生的意义，那么这一切就都是值得的。对于我来说，人生的意义是什么？或许是用自己短暂的一生去寻找出属于自己的人生意义吧。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自燃型的我回归了</title>
      <link href="/self-ignite/"/>
      <url>/self-ignite/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2020-07-20/Zen-and-the-Art-of-Motorcycle-Maintenance.jpg" alt="Zen and the Art of Motorcycle Maintenance"></p><p>最近突然觉察到自己从刚毕业时到现在的变化。在博克工作的那会儿，每天上班都充满干劲，中午吃饭都要同事叫我才肯去，虽然有时候下了班会觉得累得躺在床上不想动，但是现在回忆起来，挺羡慕当时的自己的，心中像有只小老虎，生活也过得充实。再加上那时候刚出校园，觉得一切都很新鲜，下了班后有时候还会和室友一起骑车去探索周边的世界，发现各种好玩的事。</p><p>进入虎哥之后，第一年状态可能也还不错，但是后来随着工作的进展，心里的那只小老虎好像快要慢慢消失了。繁多的项目，每天埋头在各种琐碎的事务中，还得面对难以维护的老代码。好在后来开始接触 RN，有新东西需要学习，那段时间的确能感觉到自己非常投入，看文档，写博客，下了班、周末依旧在学习。但是随着项目进一步发展，慢慢地就又变成了需求的堆叠，于是再次感到自己成为了一架实现需求的机器。</p><span id="more"></span><p>非常想要找到破局之路，隐隐感觉到继续在这里待下去是没法摆脱这种状态的，于是萌生了跳槽的想法，但是各种事情缠身，一拖就拖到了下半年。去年年底前开始做计划，打算年后跳槽，结果没想到遇到了新冠疫情这种史无前例的黑天鹅。再然后开始找工作的时候才发现，「哦，原来我想去的公司要求这么高？」以及「哦，原来我的水平就这样？」，苦笑。于是决定还是暂时先缓口气，从自己身上找找原因，然后再来决定未来的路到底应该往哪儿走。</p><p>一旦放弃逃避的时候，才发现其实自己面对的问题不过尔尔。而且就算现在通过跳槽回避了，如果我自己不去改变，将来还是会遇到类似的问题，然后还是会纠结。于是，把节奏放慢，开始关注自己当下的生活，节食，跑步，练习滑板，然后静下心来看书。一开始只是为了转移一下自己的注意力，从书中找回一些因为面试受挫而受打击的自信心，结果没想到一口气看了 7、8 本很早就标记了的书。现在发现自己不但找回了自信，更是找到了生活的勇气，哈哈。想起上次从博克离职之前，也是看了不少书。不知道是因为想要跳槽所以才阅读，还是因为阅读之后坚定了我跳槽的决心呢？不过无论怎样，当觉得自己人生遇到问题的时候，拿起书本，尝试从书中找出答案，一定不会错。但是我想这次之后，自己应该是离不开阅读这个习惯了。</p><p>我很喜欢《<a href="https://book.douban.com/subject/4846035/">干法</a>》中稻盛和夫的比喻，人也可以像物质一样分为三种类型，不燃型、可燃型和自燃型，我觉得阅读使得我身体里自燃型的那部分人格又恢复回来了。所以，我知道接下来无论我做什么，只要能保持住这股火苗，至少一定可以做到让自己满意的程度。但是我也不知道这样的状态能保持多久，所以先用文字记录下来。</p><p>追求完美不现实，而且也太过自大，但是追求更好是每个人都可以给自己定的目标。</p><p><em>今年还没写过年中总结，那么这篇就算是年中总结了吧~（为自己的懒惰找借口，哈哈）。</em></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reviews </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不抱怨</title>
      <link href="/2020-6/"/>
      <url>/2020-6/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2020-06-30/summer_rain.jpg" alt="summer_rain.jpg"></p><iframe style="border: 0; width: 100%; height: 120px;" src="https://bandcamp.com/EmbeddedPlayer/album=2377184219/size=large/bgcol=ffffff/linkcol=0687f5/tracklist=false/artwork=small/track=1417447386/transparent=true/" seamless><a href="http://patriciawilde.bandcamp.com/album/the-lake-in-june">The Lake in June by Patricia Wilde</a></iframe><br/><blockquote><p>2020 过去一半了，这半年发生了很多意想不到的事，但我相信最终一切都会过去的。每当意外来临的时候，都在提醒我们要珍惜自己所拥有的一切。时常感恩，不要抱怨，凡事努力做到最好，尽量把每一天过得充实有意义，这是身为普通人的我们唯一能做的了吧。</p></blockquote><h4 id="6-月-1-日-内驱力和低潮时的习惯"><a href="#6-月-1-日-内驱力和低潮时的习惯" class="headerlink" title="6 月 1 日 - 内驱力和低潮时的习惯"></a>6 月 1 日 - 内驱力和低潮时的习惯</h4><p>有时候觉得自己缺乏动力，做事的时候缺少激情，但是又不知道该如何去改变。之前看到过好像说是人的自我驱动力也有潮汐周期，一段时间内特别有学习的欲望，但是之后就会变得稍微消沉一些。想想也符合常识，要是一直处于亢奋状态，心理肌肉和生理肌肉都消耗不起。所以，在情绪低谷的时候，适合做一些不消耗太多意志力或者不太难的事。另外，养成好习惯也有帮助，这样，即使在不想做某些事的时候，我们依然可以凭借惯性去做，比如每天打扫房间等。再有就是养成运动的习惯也很重要，运动之后身体的肌肉会被唤醒，而一些感觉有压力、焦虑的情绪也会减轻不少，还能给大脑减压，让大脑在后台把一些需要时间慢慢消化的信息给处理掉。</p><span id="more"></span><h4 id="6-月-2-日-困难与人生的独特性"><a href="#6-月-2-日-困难与人生的独特性" class="headerlink" title="6 月 2 日 - 困难与人生的独特性"></a>6 月 2 日 - 困难与人生的独特性</h4><p>有时候我们总是忍不住去问别人，关于自己应该如何处理眼前的事，或者以怎样的态度去面对。但其实没有人能真正知道到底什么样的应对方案才是适合我们的，因为没有人和我们的有着相同的处境。</p><p>想到这里有种豁然开朗的感觉，既然如此，这也可以证明我们是独一无二的吧。从宏观角度看，这世界上大部分人都是普通人，我们每天做的事对这个世界造成的影响很小很小，而且我们都处于一个类似的发展轨迹上，只是所处的位置不同。这非常让人沮丧。不过，对于每一个个体而言，我的经历是独一无二的，我每天面对的烦恼（无论是工作还是生活中的）是具体且与他人不一样的，我只能靠自己去想办法来解决这一个个问题。</p><p>这样看来，我们每个人都是这个宇宙系统中独立且不同的组成部分，我生命的意义就是靠自己的智慧与勇气去解决出现在自己生活中的种种困难，并且想办法不断改善自己与他人的处境。有点像打怪升级，只有解决的问题足够多、足够复杂后，我们才能一步步迈向下一个阶段。我觉得这种世界观还是比较适合我的。</p><h4 id="6-月-3-日-如何处理矛盾"><a href="#6-月-3-日-如何处理矛盾" class="headerlink" title="6 月 3 日 - 如何处理矛盾"></a>6 月 3 日 - 如何处理矛盾</h4><p>当觉得自己受到不公正对待的时候，如果了解了事情的前因后果，我们可能会发现完全没有必要生气了。所以有时候要多站在别人的角度考虑问题，想想别人的难处。实在不行就脸皮厚一点，直接去问别人，<strong>一定要在了解了足够的信息之后再下结论</strong>。如果是自己的问题，那就看看是否存在可改进的空间；如果的确是别人的问题，此时你已经知道对方为什么会做出这种行为了，你可以告诉对方你所拥有的信息。当两方信息同步之后，其实很多问题就已经解决了。</p><h4 id="6-月-4-日-停止焦虑，专注眼前"><a href="#6-月-4-日-停止焦虑，专注眼前" class="headerlink" title="6 月 4 日 - 停止焦虑，专注眼前"></a>6 月 4 日 - 停止焦虑，专注眼前</h4><p>焦虑并不能解决问题，过度焦虑还可能影响我们的心态，导致我们做出不明智的选择。我们应该认清现实，停止抱怨，更不要自怨自艾，专注做好手头上的事，活在当下。Fake it till you make it. 每天进步一点点，则未来可期。</p><h4 id="6-月-5-日-多花时间做自己想做的事"><a href="#6-月-5-日-多花时间做自己想做的事" class="headerlink" title="6 月 5 日 - 多花时间做自己想做的事"></a>6 月 5 日 - 多花时间做自己想做的事</h4><p>看到 Paul Graham 的一条推：「One way to tell when you’re really well suited to some kind of work is that starting doesn’t feel like starting, but more like hitting “resume.”」好像的确是这样，对于自己真的喜欢且擅长的事，每次去做都是带着愉悦的心情的，不会想太多，而是会一直做下去，有时候甚至忘了时间。而对于不热衷的事，则会在开始的时候想着『啊，又要开始做这个了』，可能心里还会盘算搞定之后去做什么。<strong>我们要想办法让自己每天多花时间做自己想做的事。</strong></p><h4 id="6-月-6-日-助人与助己"><a href="#6-月-6-日-助人与助己" class="headerlink" title="6 月 6 日 - 助人与助己"></a>6 月 6 日 - 助人与助己</h4><p>早上看了 <a href="https://mp.weixin.qq.com/s/oYdmRqSuty0c8CP7aLPhYg">辉哥</a> 的一篇公众号文章，很认可他的关于为他人创造价值的观点，这和最近看到的阿德勒的观点类似，我们都是生活在有限空间内的社会型动物，总归是要依赖他人才能生存，为他人提供价值是获得生命的意义的最重要的手段。我们不仅仅可以通过工作创造价值，其它任何形式的能为他人的生活带来便利，或者使其觉得生命变得更加丰富完整的劳动，都是在创造价值。无论是在公众号或者博客上写文章，还是在抖音上发布视频，又或者是和人一对一的聊天，只要能帮助到他人，哪怕只有一个人，那也是有意义的。</p><h4 id="6-月-7-日-有意识地生活"><a href="#6-月-7-日-有意识地生活" class="headerlink" title="6 月 7 日 - 有意识地生活"></a>6 月 7 日 - 有意识地生活</h4><p>阻止我们进步的不是别的，而是生活方式。如何养成更积极有效的生活方式呢，答案也基本能猜到：养成好习惯（健康饮食，充足睡眠，定期锻炼、冥想，阅读），高质量的社交，扩大自己的舒适圈，做内容生产者而不是消费者等等。但是具体到每一个当下，似乎我们总是会忘记这些。</p><p>我觉得最佳的解决办法是<strong>列时间表</strong>以及<strong>为自己设置场景</strong>，比如早上起来第一件事是上厕所，然后是洗漱，之后是打开电脑写晨间日记。当我们的行为形成了模式之后，一切都会按部就班进行。比如我们可以为自己设定早上到办公室后做的第一件事，让自己形成习惯，从而帮助自己进入工作状态。类似的，吃完午餐后做的第一件事、回到房间后做的第一件事等等。为自己设置场景其实也是为了帮助自己进入状态，从而不容易分心。比如规定自己坐到书桌前就不看手机（除非必要），懒人椅边上放几本书从而随时都可以拿起书来看而不是看手机等等。总之一句话，<strong>要有意识地生活，而不要过随便的生活</strong>。</p><h4 id="6-月-8-日-为他人做贡献"><a href="#6-月-8-日-为他人做贡献" class="headerlink" title="6 月 8 日 - 为他人做贡献"></a>6 月 8 日 - 为他人做贡献</h4><p>今天洗澡的时候冒出一个新想法，一个帮助我们找到生命意义的思想实验：当所有你认识的人都从世界上消失了的时候，你会怎么做？</p><p>对我来说，虽然会觉得很难接受这个现实，但是脑海中首先冒出来的想法依旧是：我能生存下去吗？只要不是年幼到还无法自立或者卧病在床行动不便的人，在这个时代靠自己的劳动独立生存下来应该还是不太难的，尤其是刚工作不久的人，职业生涯还很漫长而且机会也很多。真正难的是接下来的「存在感危机」——我为什么而活？这世上已经没有一个人和我有任何亲近的关系了，所以我必须要重新思考自己在这个时空中的位置，为自己赋予新的角色，寻找新的工作、友谊和爱情，甚至组建家庭。</p><p>这个时候，才能看出我们是否懂得与他人合作。作为生活在这个星球上人类中的一员，我们存在的意义就是相互合作。就这么简单，与人合作就是在为全人类的福祉做贡献，而且「与人合作」中的这个「人」之前和我们是什么样的关系并不重要。没错，这依旧是阿德勒的观点，但其实这和孔子说的「仁者爱人」也非常相似。</p><p>只有那些做出贡献的人才配被他人记住，哪怕只是被少数人记住（比如你的亲人朋友），如果不乐于合作，对别人不感兴趣，我们的生活就毫无成就，也不会留下任何痕迹，就像没有存在过一样。我们存在的使命就是解决问题，为全体人类谋福祉，最终我们能解决的问题越大，越符合大众利益，那么我们的生命就更有意义。</p><h4 id="6-月-9-日-在实践中学习与培养全局观"><a href="#6-月-9-日-在实践中学习与培养全局观" class="headerlink" title="6 月 9 日 - 在实践中学习与培养全局观"></a>6 月 9 日 - 在实践中学习与培养全局观</h4><p>最好的学习方式是边实践边学习，一方面通过动手可以帮助我们理解，另一方面可以快速得到反馈。但是这种方式也有个问题，那就是我们容易被细节限制住，比如遇到一个难点无法解决就被卡住从而无法继续下一步。所以这就要求我们时刻保持全局观，关注那些真正重要的东西，以及自己想要达成的目标是什么，千万不要陷入细节无法自拔，只要核心概念理解了，随着学习的深入，难点都会被慢慢解决。</p><h4 id="6-月-10-日-保持独立思考"><a href="#6-月-10-日-保持独立思考" class="headerlink" title="6 月 10 日 - 保持独立思考"></a>6 月 10 日 - 保持独立思考</h4><p>昨天偶然听到同事间闲聊的一句话，久久萦绕在我的脑海中，『姜文说过：「正经人谁写日记」』，一开始不知道如何对答，但是现在回想之后依旧不知道如何作答，大概只能说一句『哦，那真是太遗憾了』。我觉得我们的网络文化中总是充斥着各种像这样的 meme，如果我们无法独立思考，不能区分什么是对错，什么是对自己和他人真正有利的东西，那么我们会就会慢慢被塑造成大众想让我们变成的样子，而不是自己想要成为的样子。所以我一直对网络文化保持距离，不是觉得其内容低俗，而是它太容易让我们产生满足感而沉迷其中了。</p><h4 id="6-月-11-日-钱是个好东西"><a href="#6-月-11-日-钱是个好东西" class="headerlink" title="6 月 11 日 - 钱是个好东西"></a>6 月 11 日 - 钱是个好东西</h4><p>今天试用了下新买的 sony wh1000xm3，降噪效果没的说，就是感觉对人声降噪效果稍微差一些，音质很棒。不得不说，money 真是个好东西，这也是我们应该努力工作的原因之一，只有拥有更多的金钱才能享受到更多、更好的商品和服务。</p><h4 id="6-月-12-日-和自己比"><a href="#6-月-12-日-和自己比" class="headerlink" title="6 月 12 日 - 和自己比"></a>6 月 12 日 - 和自己比</h4><p>晚上跑完步，看到自己用的跑步 app 里面的级别从 16 年开始就没有变化过，如果想要升到下一级就必须在 4 小时内跑完一个全马或者跑 4 次全马。这是不是说明自己跑步的水平一直就没有进步了呢？我觉得不是，因为我在这几年中虽然中断过跑步，但是每次重新开始跑都可以轻松完成预定的跑量，最重要的是我不再害怕长跑，养成了长跑习惯，而且也很享受其中的过程。这对我来说就是巨大的进步。</p><p>对于人生中的其它问题其实也类似，不要和他人比，要和过去的自己比。道理都懂，但是很多人都做不到这样去对待自己。我们要学会放过自己，虽然这种和他人比较的心理是免不了的，但是只要意识到自己一直在跌跌撞撞地往前跑且有进步，这就已经值得为自己感到骄傲了。</p><h4 id="6-月-13-日-各地区的文化"><a href="#6-月-13-日-各地区的文化" class="headerlink" title="6 月 13 日 - 各地区的文化"></a>6 月 13 日 - 各地区的文化</h4><p>今天天气有点热，本来计划今天要花时间研究下 Lifecycle 相关然后下午出门练下滑板的，但是因为昨晚熬夜看 NASA 的视频，导致早上起得比较晚，吃完早饭后又开始刷 YouTube，而且一刷就停不下来。然后下午天气有点热，加上换床单被套、洗衣服等各种琐事，最后一天都没有出门。所以说，一日之计在于晨，如果早上起不来那一天很有可能就稀里糊涂过去了。</p><p>从早上开始看了很多视频，一开始补看了最近新出的几期《我住》，认识了一个很美而且很可爱的在华日本人七穗，让我意识到，原来建立友谊可以这么简单，哪怕是在语言不太通的情况下，只要你们喜欢同样的东西、有类似的追求，同时又对彼此感兴趣，这就够了。</p><p>另一个比较印象深刻的是一个重庆人自驾游探访重庆偏远山区的纪录片，改变了我对重庆的印象，以前只是听说重庆人都对自己的文化很自豪，现在才发现这其实只是外界人对重庆人的印象而已，更本质的原因是来自于他们那一代代流传下来的传统，使得他们形成了自己独特的文化以及与他人沟通的方式。</p><p>其实其它地区的中国人也一样，吃苦耐劳，所做的一切都是为了努力生存下去，哪怕外界环境再糟糕也依然努力保持乐观坚强、热情善良的品质，在互相连结日益紧密的今天，这些成为了让彼此生存下去愈加重要的关键，只不过各个地区的人们在这一发展过程中，慢慢形成了自己独特各异的性格。</p><p>每个人的家乡其实都有自己的独特风格。仔细回忆下，在我长大的那个人口才 7 万的小镇，隔一条江就能察觉到这种风格差异的存在，甚至是每个村子都有差异，比如我们村给我最大的印象是：好面子、在意外界的评价（好像很多小地方的人都这样）。虽然不是很喜欢这种风格，但成长在这里，性格中多多少少也受到影响。不过这只是家乡性格中的一个方面，好的地方当然也有很多，如果让我列举出从我的成长环境中获益的人或事也能说出不少。但更为关键的是，无论我们的成长环境如何，现在以及未来出生的人都不太可以一辈子都只在一个地方生活，所以我们要学会欣赏不同地区的人们的文化，然后从中汲取有用的地方来完善自我。这也是我们正确认识这个世界的方式：带着好奇心，尊重彼此的不同之处，彼此分享，共同进步。</p><h4 id="6-月-14-日-Keep-looking-don’t-settle"><a href="#6-月-14-日-Keep-looking-don’t-settle" class="headerlink" title="6 月 14 日 - Keep looking, don’t settle."></a>6 月 14 日 - Keep looking, don’t settle.</h4><p>What am I going to achieve with my life? The answer is hard to find, but it’s OK since you are still young and have a lot of time to find out, just work hard and keep your mind open and you will find your answer eventually. Keep looking, don’t settle.</p><h4 id="6-月-15-日-教育市场化"><a href="#6-月-15-日-教育市场化" class="headerlink" title="6 月 15 日 - 教育市场化"></a>6 月 15 日 - 教育市场化</h4><p>晚上看了一集纪录片 <a href="https://www.youtube.com/watch?v=48NkRFyGHMo&list=PLWB0UfoChWY2Fkc1MK0G6RssQP5ZoVsdK&index=3&t=0s">出路 (Education, Education) | 为什么贫穷?</a>，一开始被标题吸引，但是在看到培训老师在台上与私下那两段讲话的对比，立马就被吸引着继续看了下去，看到后面一度被感动到哽咽（尤其是妈妈唱歌谣那里），甚至一度萌生出了我要去帮这些学生的想法。也许是纪录片中一些场景与我自己的成长经历中有很多类似的地方吧。虽然是快 8 年前的纪录片，但是还是不敢相信仅仅 8 年前居然还有人这么穷。但是越穷的人往往他们能有的选择也越少，即使放到现在也一样。</p><p>我觉得自己已经算是非常幸运了，能够相对比较自由地获取自己想要的讯息。但是对于那些都不知道如何去获取更专业、更权威的信息的人而言呢？他们的命运可能就只能依靠教育来改变，而且还是质量堪忧的教育。唯一的解决办法就是教育市场化。这部纪录片似乎是在控诉中国教育市场化，但是真正的原因恰恰相反，正是因为我们的教育被掐的太死，导致穷人只能选择昂贵但又效率极低的教育资源（比如三本）。我自己就是一个例子，从一所民办本科毕业，大学四年在课堂中学会的唯一一样东西就是<strong>应付</strong>，而真正有用的东西基本来源于自学，在这里也要感谢互联网，给一个小镇上的无知青年提供了所有他所需要的好观念、眼界以及三观。没有那些课堂之外的『老师』我可能不会变成今天的样子。也许是机缘巧合，但是对于那些运气没那么好的人，他们没有接触到这些信息，那他们的命运就只能那样了吗？</p><h4 id="6-月-16-日-贫穷与改变"><a href="#6-月-16-日-贫穷与改变" class="headerlink" title="6 月 16 日 - 贫穷与改变"></a>6 月 16 日 - 贫穷与改变</h4><p>重新看了一遍 Hugh Evans 的 <a href="https://www.youtube.com/watch?v=ODLg_00f9BE">TED Talk</a>，这次有了不一样的想法。对于欠发达地区，我们应该致力于解决极端贫困问题，诸如饮食、居住、卫生等。至于其他问题，我们无法解决。因为我相信，基本上所有人都是主动选择了自己的生活方式，我们无法强迫他们发生改变，而且大多数人的想法是很难被改变的。如果他们真的想要改变，就算没有外界的帮助，改变依旧会发生。所以，我们应该只对那些主动寻求改变的人提供必要的帮助，而不是自以为是地去进行『人道主义救援』。相关书籍：<a href="https://book.douban.com/subject/21966353/">贫穷的本质</a></p><h4 id="6-月-17-日-失焦与确定目标"><a href="#6-月-17-日-失焦与确定目标" class="headerlink" title="6 月 17 日 - 失焦与确定目标"></a>6 月 17 日 - 失焦与确定目标</h4><p>晚上跑完步，出了一身汗，汗水流到眼睛里，非常难受，但是又不敢用手擦，于是就闭上一只眼睛，用另一只眼睛看路，过一会儿再换另一只眼睛。突然发现摘掉眼镜后的世界是如此的不同，原来熟悉的街道被打上了马赛克，车辆、红绿灯、过往行人，全都变成了一个个远处的点。然后意识到这也算是近视的一个「好处」吧，只要摘掉眼镜，立马就获得了一个熟悉的新世界。有时候我们需要主动把自己剥离开当前环境，尝试失去焦点一阵子，以便更好地思考自己此刻的位置，以及未来的目标和方向。我目前对自己生活最不满意的地方是什么？最想要改变的是什么？能改变的是什么？</p><h4 id="6-月-18-日-自卑感"><a href="#6-月-18-日-自卑感" class="headerlink" title="6 月 18 日 - 自卑感"></a>6 月 18 日 - 自卑感</h4><p>我觉得我们都需要培养一种为自己而活的态度，我们经常因为太在乎他人的看法而对自己的行为做出调整，很多时候都是不必要的。如果我们为自己设立一种「我的价值主要由我的行为以及我自己的标准决定」，那么很多心理疾病都会消失，比如自卑。这个话题讨论过无数遍，但我还是想说，自卑感是与生俱来的，但是它也是可以被克服的，需要树立正确的观念，然后要有足够的勇气去挑战和改变自己的行为方式。</p><h4 id="6-月-19-日-如何提升表达能力"><a href="#6-月-19-日-如何提升表达能力" class="headerlink" title="6 月 19 日 - 如何提升表达能力"></a>6 月 19 日 - 如何提升表达能力</h4><p>和同事讨论的时候，有时候觉得自己表达能力很差。对于一个问题，明明自以为已经很熟悉了，但是还是会被同事问蒙，然后事后才想起来哪里不对，但是聊的过程中总是反应不过来。对于这个问题，我觉得最主要还是要多练习。先学会如何快速理清思维，找到对方问题的关键点，然后再根据反馈修正细节。对于平时写代码时候的一些问题和业务逻辑，觉得理不清楚的时候，可以在脑海里尝试角色扮演，假设自己正在教给另一个人，然后把一些可能会提出的问题都解释清除，这样时间长了，训练的效果就出来了。和小黄鸭解 bug 法其实是一个道理。</p><h4 id="6-月-20-日-树立正确的财富观"><a href="#6-月-20-日-树立正确的财富观" class="headerlink" title="6 月 20 日 - 树立正确的财富观"></a>6 月 20 日 - 树立正确的财富观</h4><p>早上看到一篇文章，提到树立正确的财富观，其实说起来自己的财富观在 20 岁之后才发生了积极的变化，在开始看连岳、吴主任、菁城子等人的公众号之后，而且还连带着了解了奥派经济学，自由市场，自由交易，个人信用等等。我觉得我们所受的教育对于钱的认识都是负面居多，比如古代文人喜欢用「铜臭」这种词来形容有钱人，而且似乎还喜欢宣扬读书人不应该爱钱。这种老旧的观念如果无法一点点去除掉，对于一个人未来的发展影响非常大。再比如还有很多人都保有「钱多钱少，够用就好」这样的观点，这种观点不说它错，但至少也是属于非常消极的。如果一个人骨子里真的保持这种观念，那么他/她就会开始为自己经济能力的不足寻找借口，而且无形中也会对一些财富机会视而不见，进而降低了自己获得更多财富的可能，这是一个螺旋向下的循环。再比如关于保险，很多人都相信保险的重要性，但是却忽视了更重要的是你拥有的知识和财富，知识和财富才是人生最大的保险。花时间提升自己的知识和技能，然后应用到实践中，学习去如何获得和积累财富，这些才是提升我们应对风险的终极武器。对钱敏感，尊重财富，不为自己找借口，采取努力积极的态度，树立了正确的财富观就树立了正确的人生观。</p><h4 id="6-月-21-日-人生十二法则"><a href="#6-月-21-日-人生十二法则" class="headerlink" title="6 月 21 日 - 人生十二法则"></a>6 月 21 日 - 人生十二法则</h4><p>昨晚看完了《<a href="https://book.douban.com/subject/34870933/">人生十二法则</a>》，作者列出的法则都很具体和实用，每一条都有它适用的场景，但归根结底的目的都是相同的：成为更好的人，以及更有勇气地面对生活。有时候我们会觉得生活太复杂了，总是有各种各样的意外等着我们去处理，而我们的目标就是在混乱中寻求秩序。「把自己的生活过好」是每个人的责任。</p><p>作者在结尾总结了本书，也提出了不少问题，都是和他当下的生活相关的，然后再用本书中的原则去一一回答。我觉得这种形式很值得借鉴，当生活中出现困惑的时候，可以通过一步步追问自己，直到最核心的问题被挖掘出来，然后再通过我们已有的知识、经验去寻找出答案。比如觉得自己找不到方向的时候可以问自己：我喜欢什么？讨厌什么？最害怕的又是什么？综合考虑之后，就算找不到自己最热爱的事情，至少可以避免自己去做一些自己不喜欢的事。查理芒格说过，「反过来想，永远要反过来想」。</p><h4 id="6-月-22-日-提高对「犯错」容忍度"><a href="#6-月-22-日-提高对「犯错」容忍度" class="headerlink" title="6 月 22 日 - 提高对「犯错」容忍度"></a>6 月 22 日 - 提高对「犯错」容忍度</h4><p>总是会在社交平台上看到一些批评网络红人的帖子，比如如果网络红人发表的言论中包含错误或者有争议的内容的时候，就会激起所有人广泛的讨论。这也正常，名人享受更多关注的同时也得忍受更多的挑剔。但是我觉得我们有时候应该思考是不是非得这样，是不是应该接受「大咖也会犯错」这个事实呢？因为无论一个人过去取得了多大的成就，都不代表他们今后就不会犯错。我们需要<strong>提高自己的容忍度</strong>，容许他人犯错，就算是牛人也同样是「人」而不是神，只要是人都会犯错。把他人当成人，这是一个很重要的品质，这可以让我们更多地关注他人身上的优点，向他学习，从而帮助自己成长。另外，我们也要允许自己为人 (Permission to be human)，允许自己犯错，这是我们能不断进步的关键。</p><h4 id="6-月-23-日-维护亲密关系的秘诀"><a href="#6-月-23-日-维护亲密关系的秘诀" class="headerlink" title="6 月 23 日 - 维护亲密关系的秘诀"></a>6 月 23 日 - 维护亲密关系的秘诀</h4><p>晚上看到一个<a href="https://www.youtube.com/watch?v=yFVXsjVdvmY">视频</a>，提到关于如何维护一段长期的亲密关系，除了伴侣间的沟通方式很重要之外，影响最大的是对小矛盾的敏感度。不要放过任何一个造成彼此不愉快的地方或者小细节，因为它们可能会一点点积累起来，然后形成你们之间关系的裂缝。所以伴侣之间一定要善于分享和倾听彼此，哪怕是一些很小的意见分歧，也一定要表达出来，让对方听到你的心声，这样比闷在心里不说，在心中积累怨气，再在某一时刻爆发出来要好很多。尽管在这种相处模式下，两个人之间可能会有更多的争吵，但是长期来看这是利大于弊的。</p><h4 id="6-月-24-日-追求更好"><a href="#6-月-24-日-追求更好" class="headerlink" title="6 月 24 日 - 追求更好"></a>6 月 24 日 - 追求更好</h4><p>今天看了一篇 Figma CEO <a href="https://www.linkedin.com/in/dylanfield/">Dylan Field</a> 的一篇<a href="https://www.linkedin.com/pulse/figmas-story-part-1-my-thiel-fellowship-application-2011-dylan-field/">文章</a>，其中有他 2011 年申请 Thiel Fellowship 的申请书，当时他才 20 不到吧，真的被震动到，那时候就能有这样的经历以及思考，而且写出这样的文字也完全让人看不出这是一个 20 岁不到的小孩写的。只能说人和人的差距真的太大了，我 20 岁的时候大概还在忙着看小说、玩游戏吧。不过天外有天，如果陷入和他人比较的漩涡之中，那么这世上绝大多数人都会失去生存下去的意义吧。</p><p>我们阅读名人传记也好，或者看这些厉害的人分享的经历也好，都是为了丰富自己的见识，学习他们的思考方式，从中得到启发，然后再去寻找自己生命中同样重要的东西，理想或者追求，或者只是过上自己想要的生活，这些都是要付出努力的。我的目标是努力成为更好的人，然后争取让这个世界也变得更好一点，哪怕这个「好」仅限于很小很小的一个范围。</p><h4 id="6-月-25-日-主动以及热情"><a href="#6-月-25-日-主动以及热情" class="headerlink" title="6 月 25 日 - 主动以及热情"></a>6 月 25 日 - 主动以及热情</h4><p>晚上躺床上有些失眠，有点焦虑，觉得自己为什么已经 25 岁了但还是没有任何可以交心的朋友，怀疑自己是不是在与人交往方面的能力是不是有什么缺陷。但是说起来，道理似乎都懂：待人要热情，认识新朋友后要尽量展现真实的自己，坦诚地沟通，帮助他人不求回报等等。也许是自己的执行能力不够吧。如果对自己的同事、室友都觉得没话可聊，那要怎么对陌生人发生兴趣呢？</p><p>一定要对他人保持兴趣。就算你们不是同一类型的人，一样可以在沟通中获得有用的信息，更重要的是能通过一步步的互动建立起一种<strong>有意义的人际关系</strong>。</p><h4 id="6-月-26-日-放下手机，学会与自己相处"><a href="#6-月-26-日-放下手机，学会与自己相处" class="headerlink" title="6 月 26 日 - 放下手机，学会与自己相处"></a>6 月 26 日 - 放下手机，学会与自己相处</h4><p>我们每天花大量的时间接收各种各样的信息，但是其中多少信息是真正有用的呢？再比如利用碎片时间学习真的有用吗？如果可能的话，尽量还是要抽出一整块的时间用来学习、消化新知识，那样效率才是最高的。而且我们也要小心落入信息陷阱。我觉得目前大多数人都需要面对的问题是，如何控制自己的注意力？能够让我们分心的事情太多了，有时候甚至会一不小心就在某块屏幕上花去了几个小时的时间，事后又会觉得懊恼。</p><p>其实很多时候我们这么做都是因为不知道如何与自己相处，太害怕无聊。我们需要学会观察自己，审视自己的内心，了解自己，反省自己，思考最本质的问题：哪些东西对自己来说是最重要的，又是哪些东西定义了自己，自己最大的弱点是什么，又有哪些优点，等等。不要逃避，因为这些问题我们迟早都要面对，思考之后你会对自己工作和生活的目标有更清晰的认识。如果觉得太沮丧的话，可以尝试用第三者视角，作为局外人观察自己，你会看得更清楚一些。</p><h4 id="6-月-27-日-储蓄精神力量"><a href="#6-月-27-日-储蓄精神力量" class="headerlink" title="6 月 27 日 - 储蓄精神力量"></a>6 月 27 日 - 储蓄精神力量</h4><p>If your life is not going well, perhaps it is your current knowledge that is insufficient, not life itself. –Jordan B. Peterson</p><p>当我们生活处于顺境的时候，一般对未来的态度会更乐观一些，而只有在遭遇人生低谷的时候，才会开始更多地反思自己。但是如果我们能够在精神方面『未雨绸缪』，提前储备一些精神和心理力量，那么当我们真正面对困境的时候，也许能恢复得更快一些。阅读、运动、学习新知识、保持良好的生活习惯、维护自己的社交圈，都能帮助我们更好地抵御即将到来的种种困难以及挑战。</p><h4 id="6-月-28-日-练习感恩与传递善意"><a href="#6-月-28-日-练习感恩与传递善意" class="headerlink" title="6 月 28 日 - 练习感恩与传递善意"></a>6 月 28 日 - 练习感恩与传递善意</h4><p>你需要与未知为友，在行动的同时保持自我觉察。你需要先处理好自己的痛苦，再去担心他人。这样你才能够强化自己，承担起存在的重担，使生活重新焕发活力。–《人生十二法则》</p><p>每个人都有自己需要面对和解决的难题，不要小看他人为之付出的努力。另外，珍惜你所拥有的东西，学会感恩，真诚地感谢他人的帮助，然后传递善意给身边的其他人，长此以往，你的生活和人际关系会变得越来越友善和轻松。</p><h4 id="6-月-29-日-失败是因为战斗过"><a href="#6-月-29-日-失败是因为战斗过" class="headerlink" title="6 月 29 日 - 失败是因为战斗过"></a>6 月 29 日 - 失败是因为战斗过</h4><p>完结是因为开始过，<strong>失败是因为战斗过</strong>，分手是因为相遇过。–《百元之恋》</p><p>我们都只是普通人，不要对自己有太高的期待，只要开始了就值得鼓励，<strong>至少你战胜了心中的怯懦感</strong>。</p><h4 id="6-月-30-日-揣摩他人和分享感受"><a href="#6-月-30-日-揣摩他人和分享感受" class="headerlink" title="6 月 30 日 - 揣摩他人和分享感受"></a>6 月 30 日 - 揣摩他人和分享感受</h4><p>The core of love is the willingness to interpret another’s behavior. – Alain de Botton</p><p>大多数人都习惯高估他人对自己的了解，而且喜欢让他人揣摩自己的意图，但是一般只有你在对方眼里的地位特别高时，对方才会愿意这么做。所以，正确的做法是：主动告诉别人你想要什么，多分享自己的感受。尤其是对你喜欢的人。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎碎念与写作</title>
      <link href="/2020-5/"/>
      <url>/2020-5/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/rgv_c2xF2zk" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br/><blockquote><p>新增了一个碎碎念的分类，用来发布自己日常的一些碎碎念。碎碎念不像日记那么私密，但也不是流水账，算是个人日常生活中的一些思考。</p></blockquote><p>我们每天都会产生许许多多的想法，如果不去刻意记录下来的话，这其中的大部分都会被遗忘掉。但是，我觉得一些有意思的想法是值得捕捉、记录下来供日后翻看的。也许对其他人没有意义，但是对我们自己却很有意义。不仅仅是为了记录自己当下的生活状态、所思所想，也是为了帮助我们理清思绪，发现对自己来说真正重要的东西，以及锻炼通过写作表达自己观点的能力。</p><p>另外，作为一枚程序员，虽然我们可能一整天都说不了几句话，但是却免不了在大脑中与自己进行对话。不过，人的思维常常是跳脱且无序的，文字可以帮我们理清其中的逻辑，而且把一些创意和想法变成有条理的文字记录下来，未来说不定能给我们带来更多的启发。再者，我们在日常生活中难免会有一些心情低落或者感到烦闷的时候，通过碎碎念的形式也能帮助自己排解掉一部分消极情绪，从而用更积极的心态开启新一天的生活。</p><p>写作是这个时代下每个人都应该具有的能力，但是，写作是一个反「<a href="https://fs.blog/2018/11/entropy/">熵</a>」的过程，一开始可能会有点难，不过养成习惯之后，它会给我们今后的人生带来许多正面的影响。希望我的记录和分享也能启发到更多的人。</p><span id="more"></span><h4 id="5-月-1-日-C’est-la-vie"><a href="#5-月-1-日-C’est-la-vie" class="headerlink" title="5 月 1 日 - C’est la vie"></a>5 月 1 日 - C’est la vie</h4><p>今天晚上去外婆家坐了下，好久没看到他们了，一切好像什么都没变，但是又觉得好像什么都变了，有种说不出的感觉，我们都在成长，随着新一代的降生，每个人渐渐地添了很多新的身份，关注的焦点也慢慢转移到这些新的小生命以及日常琐碎上了。这就是生活吧。</p><h4 id="5-月-2-日-积累和机遇"><a href="#5-月-2-日-积累和机遇" class="headerlink" title="5 月 2 日 - 积累和机遇"></a>5 月 2 日 - 积累和机遇</h4><p>下午坐顺风车回到小区，司机为了避开堵车路段走了一条小路，然后发现了一条不错的跑步路线，有溪流，有柳树，有农田，听司机说之前还被选为马拉松路线，下次可以带上滑板来这边刷街。</p><p>晚上看了个老罗采访一加刘作虎的视频，听他俩聊了创业路上的种种经历还有一些背后的故事，十分认同刘的「做出好产品才是赢得用户的核心」的观点。后来洗澡的时候在想，如果换个人不是刘作虎我们现在是否还能用上一加手机？我觉得还是会的。的确，一加的诞生离不开他个人的努力以及前期的积累，让他有足够的经验并且有足够的资源去做出会受用户喜爱的产品，但是更重要的是他抓住了机遇，在正确的时间出现在了正确的地点。</p><p>对普通人来说，我们也许没法像这些牛X的人一样，也很难遇上这样难得的机遇，但是我们一生中总归会遇到几次那种决定自己未来的时刻，遇上了把握住，那么我们的未来就会完全被改变。不过也不用太着急，每天做好自己的事，多观察总结他人的经验，等到机会来临的时候，其实一切也都是水到渠成的事，也许事后我们才能意识到，这个事居然是影响自己能发展到目前地步的决定性事件。</p><h4 id="5-月-3-日-不服输"><a href="#5-月-3-日-不服输" class="headerlink" title="5 月 3 日 - 不服输"></a>5 月 3 日 - 不服输</h4><p>有时候会发现自己的情绪在「老天好不公平」和「你已经很幸运了」之间摇摆，觉得为什么有的人可以拥有那样好的条件，而我却总是诸事不顺？但是转念又觉得比起那些遭遇了各种人生苦难的人来说，我这点苦恼根本不值一提，我应该感恩自己现在所拥有的一切。</p><p>事实上，自己在绝大部分时间里都偏向于是后一种心态，但是现在觉得前一种心态同样重要，因为它可以激励我们不断向上：没有好的条件，那就去靠自己的双手创造条件啊。现实世界中的种种不如意会让我们更加有斗志去挑战并改变现状，尤其是帮助我们培养起「不服输」的性格。每个人的人生经历不同，但是只要能从自己独特的经历中，不断归纳总结出经验，一样可以走出属于自己的路。</p><h4 id="5-月-4-日-专注和理性"><a href="#5-月-4-日-专注和理性" class="headerlink" title="5 月 4 日 - 专注和理性"></a>5 月 4 日 - 专注和理性</h4><p>今天看到几篇点评「后浪」视频的公众号文章，情绪有点被带跑偏，觉得 B 站的年轻人怎么成这样了？甚至还生出了「看来以后还是得想办法移民」这种负气的想法。冷静下来之后觉得，谁年轻的时候不傻逼？正因为年轻所以缺乏理性，容易被激情控制大脑，回想自己年轻时候有的一些想法，我也脸红啊。况且就我生活中接触到的大多数 95 后、00 后，基本都是普通的正常人而已，没有特别左或者像在网络上见到的那样有非常明显的政治倾向。我们在网络上看到的世界不一定反映的就是真实的世界，通常来说都是被网络上的一些媒体放大了。</p><p>另外，现在的讯息太泛滥了，即使像我这样佛系的人（不刷朋友圈、微博、抖音等），还是会发现自己每天会花费大量的时间阅读一些没有必要去阅读的信息，而且很多时候还会被那些新闻中的负面情绪所影响。所以一定要学会控制自己的时间和注意力，适时屏蔽掉外界的噪音，专注（Focus）做好自己应该做的事。</p><p>摘抄陈兴杰老师的一句话：没有理性的激情，很快就会冷却，变得毫无意义。要保持理性，就得宽容异己，尊重不同意见——这就需要年轻人保有自由精神。</p><h4 id="5-月-5-日-慎重做决定和主动引导自己的未来"><a href="#5-月-5-日-慎重做决定和主动引导自己的未来" class="headerlink" title="5 月 5 日 - 慎重做决定和主动引导自己的未来"></a>5 月 5 日 - 慎重做决定和主动引导自己的未来</h4><p>大多数人在日常生活中所做的选择都是随机的，对于那些小事，随机选择倒无所谓，比如晚饭吃什么、周末怎么过、去超市买什么牌子的日用品等，为这些琐事耗费太多意志力不值得。但是对于那些会影响到自己未来的事，真的应该在<strong>搜集足够的数据和慎重思考</strong>后再做决定，比如大学学什么专业、毕业后找什么样的工作、和什么样的人结婚等等。别看每个人在做重大决定前好像已经花了很多时间准备，但是有多少时间是真正有效的呢？我们应该问问自己花了多少时间、精力搜集资料，是否真的了解了所有必要的信息，能否自信满满地说出『我已经摸透这整个事情的来龙去脉』或者『我已经足够了解这个人的方方面面了』？</p><p>另外，除了在做重大决定前要花足够的时间和精力搜集数据之外，我们还应该学会<strong>主动引导自己的未来。</strong>比如当下做的哪些事对我未来达成某个目标有利？为了获得某个领域的竞争优势，我现在应该做哪些准备？我对自己身上某些方面不满意，为了在一段时间内改变这点，我应该设立怎样的计划？有意识地引导、塑造自己的未来，才是避免做出随机选择的关键。</p><h4 id="5-月-6-日-勇敢表达出自己的观点"><a href="#5-月-6-日-勇敢表达出自己的观点" class="headerlink" title="5 月 6 日 - 勇敢表达出自己的观点"></a>5 月 6 日 - 勇敢表达出自己的观点</h4><p>今天下班路上听 Hidden Brain 播客的时候，听到一个有趣的观点，那就是大多数人都觉得自己的审美是特殊的，比如让一个人随便挑选一双鞋子，然后让他对自己穿上这双鞋子后他人会怎样评价进行预计，结果和实际他人给出的评价往往相差很大。联想到自己经常会觉得自己是独一无二的，比如听歌的品味等，然而现实情况是无论我们自以为多么独特、小众，始终有很多人和我们有相似的想法和兴趣爱好。</p><p>另外，似乎人天生就有追求自我的独特性需求，当被评价为小众的时候心里总归会有点不一样的感觉。我猜想这种心态和文化有关，人是唯一有阶层意识和自尊需求的动物，被关注意味着你要么属于精英阶层，要么有特别杰出的能力、特质，因此我们需要证明自己的独特性，才能感到自己值得被尊重、被关注。当然也有的人能够摆脱这种心态，他们不需要根据外界的评价来判断自己的价值。这种人活得会更开心吧。</p><p>我自己一直是属于前一种人，有时候会特别在意他人对自己的评价，这样真的活得很累。有时候明明有很多东西想要表达，但是又怕自己说的话在旁人那里听起来会很蠢，所以干脆保持沉默。不过现在能从文字开始，表达出自己的想法，也算有所改变吧。</p><h4 id="5-月-7-日-心流状态"><a href="#5-月-7-日-心流状态" class="headerlink" title="5 月 7 日 - 心流状态"></a>5 月 7 日 - 心流状态</h4><p>今晚头一次熬夜写代码，虽然明天还是得 7 点起来，心里会觉得有点亏欠自己，但是好久没有进入过这样的心流状态了，这种完全专注、沉浸在完成一件事上的感觉真好，希望以后可以不熬夜也能体会到这种状态。</p><h4 id="5-月-8-日-开源-TagGroup"><a href="#5-月-8-日-开源-TagGroup" class="headerlink" title="5 月 8 日 - 开源 TagGroup"></a>5 月 8 日 - 开源 TagGroup</h4><p>晚上发布了 TagGroup v1.0.1，这应该是我开源的第一个完整的 npm 项目，虽然只是一个简单的 RN 组件，但是还是成就感满满。开源是一种分享也是一种检验自己能力的方式，而且我从开源社区真的学到太多东西，这也算是对社区的一种回馈吧，希望可以把这种分享传递给更多的人。</p><h4 id="5-月-9-日-利用渴望培养「我要做」的能力"><a href="#5-月-9-日-利用渴望培养「我要做」的能力" class="headerlink" title="5 月 9 日 - 利用渴望培养「我要做」的能力"></a>5 月 9 日 - 利用渴望培养「我要做」的能力</h4><p>游戏的魅力为什么那么大？原因之一就是可以帮助我们快速摆脱无聊，人脑总是追求刺激，每当接收到新的刺激的时候总会渴望更多。玩游戏的时候其实并没有产生快感，只不过大脑通过分泌激素告诉我们，只要继续玩下去，达成目标的时候会很快乐，于是时间就这样一分一秒地过去。《自控力》中说过，我们可以利用大脑的这种激励机制培养『我要做』的能力，利用奖励承诺或者一些刺激欲望的东西，和我们喜欢拖延的事情联系起来，这样我们达成目标的动力会更足。当然这种手段只是帮助我们培养起习惯，要想长期坚持还是得去挖掘出自己真正感兴趣的事情，还得看你有多想达成这个目标。</p><h4 id="5-月-10-日-天赋与勤奋"><a href="#5-月-10-日-天赋与勤奋" class="headerlink" title="5 月 10 日 - 天赋与勤奋"></a>5 月 10 日 - 天赋与勤奋</h4><p>晚上看了一个视频，关于一个去日本学习岩彩画的艺术家，节目介绍的很短，只能简单了解到她现在的生活，对于她之前 7、8 年漫长的付出积累只是一笔带过。没有谁是容易的，哪怕是那些看起来很有天赋的人。这是我看完视频最大的一个感触，说多了好像都是鸡汤，但是普通人的确只有靠老老实实勤奋努力下去才有可能取得一点成就，天才在人类历史上都是少数，而且能够真正让人记住的天才不外乎就那几个，哪个是仅仅靠自己的天赋就成功的？</p><h4 id="5-月-11-日-管理需求"><a href="#5-月-11-日-管理需求" class="headerlink" title="5 月 11 日 - 管理需求"></a>5 月 11 日 - 管理需求</h4><p>每次因为需求或者接口变动导致需要大量重复性工作的时候，都会觉得自己工作没意义，但是又没办法不改，毕竟老板付钱给你是让你来干活的，总归会有一些让你不满意的时候。这种时候其实就要看你的心态了，正确的做法应该是想办法避免这种状况的再次出现，比如通过一些工程化的手段，比如对有可能频繁出现业务变动的代码逻辑的粒度进行调整，还有就是管理需求，对某些需求背后的原因进行提问，然后看真实的需求应该是什么。当然最终极的解决方案是，找一个不会频繁改需求的公司，通常来说，更难。</p><h4 id="5-月-12-日-新技术与基础"><a href="#5-月-12-日-新技术与基础" class="headerlink" title="5 月 12 日 - 新技术与基础"></a>5 月 12 日 - 新技术与基础</h4><p>越来越觉得现在安卓和前端技术发展得太快了，新东西层出不穷，有些「新」技术还没学会，没过多久就又有更新更好玩的东西出来了，想要不被淘汰就得不停学习下去。这也充分说明了基础很重要，只有掌握那些最本质的东西，才能比别人学得更快、更好。</p><h4 id="5-月-13-日-整理癖"><a href="#5-月-13-日-整理癖" class="headerlink" title="5 月 13 日 - 整理癖"></a>5 月 13 日 - 整理癖</h4><p>定期整理自己的文档和书签算是我的一个奇怪的癖好，有时候觉得自己工作效率低下、也不想看文章的时候，就挺适合做这种不需要用脑子、无意识就能完成的工作的。</p><h4 id="5-月-14-日-怪梦"><a href="#5-月-14-日-怪梦" class="headerlink" title="5 月 14 日 - 怪梦"></a>5 月 14 日 - 怪梦</h4><p>看了下早上写的日记觉得有些好笑，其实没什么大不了的吧，虽然有些尴尬，但是做梦又不是我们的错。网上搜了下，大致从心理上来说，可能说明自己和母亲的关系不太健康，虽然成人了，但是心理上还没有脱离母子关系的链条，而且可能会影响我们和其它女性发展出正常的浪漫关系。这个需要我们自己去调整，回忆下是不是成长过程中母子之间过于依赖彼此了，通常这种关系较多出现于父亲角色缺失的情况下。对我来说，可能更多是因为从小和老爸关系不怎么好吧，妈妈在我心中的地位要远远高于爸爸。</p><p>这个要怎么解决呢？多和老爸敞开心扉地聊聊天？好像蛮难的，因为一直以来和老爸好像说不了几句话，总觉得和他聊天像是在被训斥一样，不怎么舒服，所以我也总是用防备和抵触的心态。也许是我需要改变态度吧，别太把他的一些话放在心上，听到不爱听的就当没听到或者打个哈哈就过去了，和长辈聊天不都是这样吗？</p><h4 id="5-月-15-日-自由职业者与远程工作"><a href="#5-月-15-日-自由职业者与远程工作" class="headerlink" title="5 月 15 日 - 自由职业者与远程工作"></a>5 月 15 日 - 自由职业者与远程工作</h4><p>晚上看了很多杂七杂八的文章，然而并没有什么卵用，很多文章都是有「保质期」的，只能在看完之后的十几分钟或几个小时之内给我们带来一些新的思考，但是第二天却被我们忘的一干二净，所以只阅读但是没有记录、复盘或者输出的话，大多数都会成为无用功。而且很多时候当我们自己的层级还没到那个地步的时候，看完后收获也会比较小，所以还是要先专注做好眼前的事吧。</p><p>虽然如此，但是尽量多阅读，了解其它领域一些专业人士的见解、长长见识，还是很有好处的。比如今天看的这篇 David Perell 的 <a href="https://www.perell.com/blog/new-american-dream">The New American Dream</a> 就挺有意思的，从 10 年前到现在，大多数年轻人毕业后都想进入硅谷科技公司，但是最近开始一直到未来一段时间，随着互联网发展进入「应用」阶段，会有越来越多的年轻人选择创业做自己的小项目，并且现在个人通过软件开发盈利的例子就已经越来越多，未来还会有更多人选择这种没有雇主、工作地点不限的方式来 do business。</p><p>所以也许未来远程工作以及自由职业者会越来越多，小公司只要瞄准一块利基市场然后提供好服务就能生存下来。这和之前常听人说的这是个『个体崛起』的时代的观点类似。但是另一方面，对于那些不擅长利用互联网为自己获得影响力，或者习惯了按部就班的职场工作的人来说，他们与前者的差距也会越拉越大。不过无论如何，对于那些能够持续学习的人来说，这些都不是事儿。</p><h4 id="5-月-16-日-三篇公众号文章"><a href="#5-月-16-日-三篇公众号文章" class="headerlink" title="5 月 16 日 - 三篇公众号文章"></a>5 月 16 日 - 三篇公众号文章</h4><p>早上看了几篇公众号的文章，一个是 36 岁传统媒体行业的从业者，被新媒体运营方式不适应导致迷茫痛苦想要离职却又害怕找不到更好的工作。还有关于张是之老师分享的他曾经遇到过的医疗骗局，用一个毫无科学依据的检测仪器测试过敏原。然后是连岳的荐书，关于亨利福特，年轻时一心研究汽车发动机，虽不被看好，但是坚信它能改变世界，后来终于制作出 T 型车，让普通人也能消费得起汽车，最后中年时期发明流水线，降低了工人们的操作难度。</p><p>有几点感想。首先是，庆幸自己选择了软件开发这个行业，它算是目前比较新的技术工种，暂时不需要担心找不到工作的问题。第二，还是因为现在的职业，让我有能力更有效地检索信息，而且信息源更广，不用怕遇到那些由于信息不对称导致的损失。第三，感谢我们所处的这个时代，这是个最好的时代，普通人可以将自己的价值最大化，100 年前像福特这样的人可能改变一个时代，但是现在我们是站在这些前人的肩膀上，商业变得越来越简单，工作也变得越来越多样，我们可以获取任何信息，学习任何想要学习的技能，这是时代给我们的红利。</p><h4 id="5-月-17-日-关于「成功」和职业规划"><a href="#5-月-17-日-关于「成功」和职业规划" class="headerlink" title="5 月 17 日 - 关于「成功」和职业规划"></a>5 月 17 日 - 关于「成功」和职业规划</h4><p>早上看连岳文章，回复的是一个初中生的来信，很成熟的一个孩子，觉得学习好对自己来说不算「成功」，所以想知道什么才是「成功」。连岳的回答是他也不知道什么是成功，但是就算是那些看起来已经很成功的人，也还是会有低潮、不顺的时候，但是他们只是把这种困难视为一种挑战，并且能通过自己的努力去渡过这段时期，而不是去抱怨其它人或者环境。所以虽然成功很难定义，但是只要尽力去做了，在每个阶段都完成好自己的任务，然后在一点点实践的过程中才能知道自己到底喜欢什么、擅长什么，并且能够帮助到越来越多的人，这样差不多就算是「成功」了吧。</p><p>然后是曹大的一篇文章，关于年轻人入职场要关注哪些问题。成长是第一位的。我其实一开始入行的时候是没考虑那么多的，因为没得选。当开始有的选的时候也踩了坑，太关注薪资待遇，导致后来自己的工作态度和心态都有了转变。最核心的还是得对自己的职场有规划，定好自己未来几年的发展方向和目标，慢慢发现自己喜欢、擅长且热爱的东西，然后去找这方面的工作。</p><p>说起来简单，但是实践起来真的很难。我到现在都不清楚自己到底喜欢什么。大致的目标是希望有天能够做出自己的产品吧，给尽量多的人提供有价值的服务，我觉得这是种很有成就感的事。现在作为一个程序员，算是在为这个目标做一些积累，通过帮别人做产品然后从中学习。了解用户需求和使用场景，确定功能，理清业务逻辑，设计，建模，技术预研，确定实现方案，技术架构，功能实现，测试…最后不断迭代和维护。</p><p>一点点积累吧，不要怕难或者觉得做不到，可能做着做着目标就越来越清晰了。</p><h4 id="5-月-18-日-为爸妈科普轻断食"><a href="#5-月-18-日-为爸妈科普轻断食" class="headerlink" title="5 月 18 日 - 为爸妈科普轻断食"></a>5 月 18 日 - 为爸妈科普轻断食</h4><p>昨晚跑完步和老妈聊完天，觉得真的有必要认真告诉他们我现在的饮食方式是怎么样的，有哪些科学依据，所以晚上回来搜了下科普轻断食的文章和视频。但是视频大多是英文的，所以打算花时间自己翻译制作字幕然后给他们科普。也许他们最终还是不会看，但是，至少我尽力了。虽说他们的看法不会影响我选择什么样的饮食习惯，但是如果能得到家人的理解和支持会简单一些吧，心里也会好过一些。</p><h4 id="5-月-20-日-虚假希望综合征"><a href="#5-月-20-日-虚假希望综合征" class="headerlink" title="5 月 20 日 - 虚假希望综合征"></a>5 月 20 日 - 虚假希望综合征</h4><p>晚上看《自控力》，其中提到一个「虚假希望综合征」，指很多人在面对挫折或者没能达到预期时，就会变得失望、自暴自弃，然后从中「醒悟」，发誓作出改变，于是再次拥有希望。但是仅仅是「承诺改变」就能骗过我们的大脑，让我们感觉良好，实际上我们什么都没有做，所以最终还是什么都没能改变。很多人就这么一次次循环着这个过程。</p><p>回顾自己，的确也时常被这种「改变的承诺」所欺骗，如果没有行动，那些目标永远不可能达成，只能伴随着自己的羞愧、自责与懊悔，一次次在年终总结里重复着自我批判。我们需要反省：促使自己想要改变的真正原因是什么，接着为了达成目标，列出具体可行的计划，然后再一点点执行。比如我选择尝试轻断食，目标是控制自己的身形，变得更加健康，以及节约出多余的时间用于阅读和学习。那么我要做的就是尝试多种方案，然后选择适合自己的一种（4/20 轻断食）并坚持下去，一段时间之后再回过头来评估自己的执行状况以及是否需要进行调整。</p><p>一旦做出改变的承诺，就要想起这个<strong>虚假希望综合征</strong>，提醒自己<strong>一定要行动</strong>，否则改变不可能发生。</p><h4 id="5-月-21-日-婚姻与靠谱的人"><a href="#5-月-21-日-婚姻与靠谱的人" class="headerlink" title="5 月 21 日 - 婚姻与靠谱的人"></a>5 月 21 日 - 婚姻与靠谱的人</h4><p>早上起来刷朋友圈，看到一个大学同学领证了，觉得有点不可思议，才 25 岁啊，为啥要这么早领证？如果是我，我是绝对没办法说服自己的，因为才这么年轻，我还不知道什么样的人适合一起生活一辈子。我觉得两个人至少要一起生活 1 年以上，才能算是对彼此有比较好的了解了吧。而且因为婚姻是排他性的，所以我们必须确认彼此足够相爱，而且双方都已经认真准备好和对方共渡一生了，或者说就算不能一起走下去，我们也能确信对方无论怎样也能选择和平分手，而不是把彼此的生活搞得一地鸡毛。简单来说，就是得确定对方是个靠谱的人。这，真的很难。</p><h4 id="5-月-22-日-Ollie-窍门与坚持练习"><a href="#5-月-22-日-Ollie-窍门与坚持练习" class="headerlink" title="5 月 22 日 - Ollie 窍门与坚持练习"></a>5 月 22 日 - Ollie 窍门与坚持练习</h4><p>今天发现一个 Ollie 的诀窍，双脚脚尖踩板并翘一点点脚后跟，这样 Ollie 成功的概率大很多。有种自己终于学会 Ollie 的感觉，开心好久，因此也多练了一会儿。不过行进中的 Ollie 还需要再练一段时间，希望再用 1-2 周熟练掌握。 有时候觉得学滑板最大的魅力就是，你对自己的身体越来越自信。掌控自己的身体其实很简单，只要不停练习，哪怕一开始会觉得困难重重，但是时间一长，那些困难就会烟消云散。其它事情也一样，只要不放弃，坚持下去，大部分事情都能做好。</p><h4 id="5-月-23-日-未来的自己以及身边的榜样"><a href="#5-月-23-日-未来的自己以及身边的榜样" class="headerlink" title="5 月 23 日 - 未来的自己以及身边的榜样"></a>5 月 23 日 - 未来的自己以及身边的榜样</h4><p>我们每个人的意志力都是有限的，所以不要在那些琐碎的小事上浪费自己的意志力，对于一些每天不得不做但是又抗拒去做的事，可以设定时间定时去做，养成习惯之后做起来就毫无阻力了。这是「我要做」的力量。</p><p>另外今天看《自控力》的时候，还发现两个不错的建议，一是要定期想象未来的自己，可以尝试给未来的自己录一段话、写信等等，这样当我们觉得自己无法坚持目标，或者放纵自己的时候，就会想到当下的一些行为会对未来的自己造成什么样的影响。还有要树立一个日常的榜样，最好是自己身边比较亲近同时又让自己觉得佩服、意志力坚定的人，这样每当我们快要失去「我不要」的力量的时候，想到这些榜样同样可以帮助我们挺过「难关」。</p><h4 id="5-月-24-日-好奇心与早餐店"><a href="#5-月-24-日-好奇心与早餐店" class="headerlink" title="5 月 24 日 - 好奇心与早餐店"></a>5 月 24 日 - 好奇心与早餐店</h4><p>早上想到一个问题，自己似乎总是习惯被动，比如吃早饭这件事，我几乎只去那一两家早餐店，包括小区门口的早餐店，每天都经过，但是只买过一两次，理由是之前刚来的时候室友说不好吃，我也就没去了，现在常去的店也基本都是之前室友喜欢买的早餐店。还有楼下的温州黄牛肉饭馆，之前也是搬家过来快一年了都没进去吃过，后来有天不知怎么走进去吃了一次，然后觉得还挺好吃的，于是就天天去那吃了。是什么导致自己如此不热爱探索，自己去发掘出真正的喜好，却喜欢先听别人怎么说？</p><p>也许有点夸张了。我总觉得自己虽然老是嘴上说要有好奇心，而且也喜欢那些好奇心强烈、追求新奇事物的人，但是实际行动上却没有任何的体现，甚至有点墨守成规。一方面是我自己的性格问题，比较内敛，不喜欢主动，另一方面，也与自己从小到大接受的教育观有关，总是被告诉不要做出头的那个人，要和其他人看齐。但其实想要改变这点也不难，多点好奇心，多多探索，不要一味接受既定、已有的观念，敢于出头，敢于和他人不一样。可以从简单的地方着手，比如今早去一家没去过的早餐店吃早餐开始。</p><h4 id="5-月-25-日-被讨厌的勇气"><a href="#5-月-25-日-被讨厌的勇气" class="headerlink" title="5 月 25 日 - 被讨厌的勇气"></a>5 月 25 日 - 被讨厌的勇气</h4><p>晚上看完了《被讨厌的勇气》，我在豆瓣上对这本书的一句话短评是：能看到这本书的人都是幸运的人。真的觉得再怎么评价这本书都不为过，太喜欢这本书了，但是关键还是得把书中提到的点给应用起来吧，也许需要很长时间才能完全领悟，但是越早开始越好，我已经算是幸运的了。</p><h4 id="5-月-26-日-关于决定论以及选择如何解读他人"><a href="#5-月-26-日-关于决定论以及选择如何解读他人" class="headerlink" title="5 月 26 日 - 关于决定论以及选择如何解读他人"></a>5 月 26 日 - 关于决定论以及选择如何解读他人</h4><p>早上起来看到排班被排错了，立马觉得很生气，然后转念一想：为什么要生气？因为我觉得负责排班的同事是故意针对自己。她为什么要针对自己？因为我经常对她态度比较差。我为什么对她态度差？因为我不喜欢她，觉得她笨，不喜欢她说的话、做的事。问题到这里就迎刃而解了，其实正是因为我不喜欢她，才会觉得她针对自己。阿德勒心理学中采取目的论，也就是说我们都是出于某种目的而主动去选择某种信念或者行为。其实她可能根本没想过我到底要什么样的排班，所以只是按照默认而又不会出错的方式去排了。但是因为我选择了这种敌对的方式去解读，所以她的做法在我眼里就是在「针对」自己。</p><p>想到这里，发现我对很多人际关系的处理其实都是有问题的，比如别人一个动作或者一句话，有时候在我这里都会被放大很多倍，觉得他们别有用意，但其实是我自己主动选择了用这种方式去解释他人的行为而已。最根本的原因是：**我害怕他人不喜欢自己，所以主动选择了这种倾向于将他人的行为解释为「是在对我表达不满」的思考方式，这样就强迫他人和自己或者自己主动和他人保持距离，这样我就不用担心不被他人喜欢了。</p><p>看清问题之后难免有点沮丧，原来一直都是自己的问题。所以，开始改变自己吧，从用更积极的方式解读他人的行为开始。</p><h4 id="5-月-27-日-阿德勒心理学"><a href="#5-月-27-日-阿德勒心理学" class="headerlink" title="5 月 27 日 - 阿德勒心理学"></a>5 月 27 日 - 阿德勒心理学</h4><p>昨晚开始看阿德勒的《超越自卑》，原书名叫 <em>What Life Could Mean to You</em>，这本书很早就想看了，但是一直没有好的契机，直到最近看了《被讨厌的勇气》才意识到是时候开始看这本书了。老实说，这本书的语言还是有点晦涩的，有些时候一句话可能要反复阅读好几遍才能看懂，还有一些玩笑话可能要读第三遍的时候才能 get 到点。虽然如此，我还是觉得应该把这本书仔细看完，因为《被讨厌的勇气》虽然很棒，语言浅显易懂，但是它更适合作为了解阿德勒心理学的入门书籍，想要更深入了解的话还是得看阿德勒自己的书，作为一种补充和完善。但是不得不说《被讨厌的勇气》写得真的很棒，如果只是想要了解阿德勒心理学的其实看它也已经足够了，而且看完一定有收获。</p><h4 id="5-月-28-日-学会与他人合作"><a href="#5-月-28-日-学会与他人合作" class="headerlink" title="5 月 28 日 - 学会与他人合作"></a>5 月 28 日 - 学会与他人合作</h4><p>今晚依旧在看《超越自卑》，关于儿童教育、婚姻、梦境，还有一摞摞的案例。然后也忍不住思考自己成长过程中观察到的一些现象，很多都一一印证了作者的观点，有些也很有启发，可能未来会用到。作者多次谈到我们的生活离不开与他人的合作，所以对于儿童的教育最重要的还是要培养起他们乐于与他人合作的态度。</p><p>回想自己，似乎一直都比较不擅长和他人合作，这个也是导致自己身边一直没什么朋友，也不擅长和异性相处的原因。如何改变呢？书中也有一些建议，比如加强对他人的兴趣、好奇心等等，但是对于像我这样已经习惯自己一个人玩的人，想要改变谈何容易。啊，又开始为自己找借口了，这恰恰说明了目的论的正确性，其实是我自己不想改变而已，想要通过这种不主动的方式表明自己的「优越性」。另一方面，也说明自己的不自信，害怕处理不好人际关系，不想背负维护关系的压力，也不想为他人付出。</p><p>意识到问题是第一步，接下来就是通过行动一点点改变。</p><h4 id="5-月-29-日-被宠坏的小孩"><a href="#5-月-29-日-被宠坏的小孩" class="headerlink" title="5 月 29 日 - 被宠坏的小孩"></a>5 月 29 日 - 被宠坏的小孩</h4><p>今天晚上坐老姐的车回家，在路上看完了《超越自卑》，很多收获，对比自己的过去，觉得自己似乎挺符合书中描述的「被宠坏的小孩」这一类人的。从小到大一直在老妈的「细心呵护」下长大，而且也没有和老爸建立起良好的互动关系，导致自己一直期望受到更多关注，而忽视了如何与他人进行良好的合作，选择了「竞争」而不是「合作」模式，而且待人处事常常以自我为中心。当然，还没有达到那种完全无法与他人合作而影响到工作和生活的地步，只不过不擅长、也不会主动去建立与他人的联系。意识到这点并不是为了推卸责任，而是想找到了可能的根源之后，去适当地做出调整和改变，然后也能避免自己或身边的其他人再犯同样的错误。</p><p>我们活在这个小小的星球上，从出生到死亡，没有人能够独立生存下来，始终离不开他人的帮助，所以必须要学会如何与他人（不仅仅是亲人）之间的合作，真心诚意地为他人（朋友、爱人甚至陌生人）做出贡献，只有这样，我们自己的处境才有可能变好。「帮助别人就是帮助自己」不是一句空话，我们的人格因此而变得更加健全，我们的价值感也全部来自于此。所以，对他人更感兴趣，学会与人合作，以及让更多人意识到这一点，这就是在为整个人类进步做贡献了。</p><h4 id="5-月-30-日-关心他人"><a href="#5-月-30-日-关心他人" class="headerlink" title="5 月 30 日 - 关心他人"></a>5 月 30 日 - 关心他人</h4><p>改变真的很难。今天下午回家的路上碰到领居遇到点麻烦事，本来应该上去帮个忙的，但是最后还是什么都没有做。明明前一晚才下决心说要多关心他人，学会与他人合作，但是实际生活中却依旧迈不出一步。心里有种挫败感。</p><p>但是转念一想，如果是以前，可能自己根本就意识不到这件事，所以从这个角度看这已经是一种转变了。不过，还是应该反省，因为回想自己一开始的初衷，我想要帮邻居的时候也不是纯粹的，而是带着目的的，比如会想如果帮了她对我有什么好处，然后犹豫片刻，觉得还是算了吧，最终导致我没有主动走上前去帮她。</p><p>所以还引出了一个目的性的问题：我们能否培养起自己那种打从心底里的、真诚关心他人的能力，既不是为了获得某种利益，也不是为了满足自己的优越感，而是我们想要为他人付出，是真心在关爱自己的同类。如果能培养起这种能力，我们会觉得身边的所有人都值得关注和感兴趣，同时我们也更容易和他人建立起联系。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Journal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个支持单选和多选的文字标签组件</title>
      <link href="/react-native-tag-group/"/>
      <url>/react-native-tag-group/</url>
      
        <content type="html"><![CDATA[<img src='/assets/2020-05-09/octocat-coffee.png' width='80%'><p>文字标签算是最常用的组件之一了，很多项目中都会使用到，但是同时支持单选和多选的文字标签好像比较少。目前在做的一个项目中，有比较多的地方会用到多标签选择，还有用标签对选项进行切换，于是自己封装了一个 <code>TagGroup</code> 组件，觉得挺好用的，帮我节省了不少时间，所以开源出来希望给更多的人使用。</p><p>项目地址：<a href="https://github.com/aJIEw/react-native-tag-group">react-native-tag-group</a></p><span id="more"></span><h3 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h3><p>主要分为两种模式，默认为多选模式，在回调方法 <code>onSelectedTagChange</code> 中会得到选中的标签数组：</p><img src='../assets/2020-05-09/multiple-selection.gif' width='40%' /><p>另一种是单选模式，通过设置 <code>singleChoiceMode</code> 开启，此时回调方法 <code>onSelectedTagChange</code> 中的参数为选中标签的值和对应的下标：</p><img src='../assets/2020-05-09/single-selection.gif' width='40%' /><p>从上面的动图中可以看到，我们还可以通过 <code>TagGroup</code> 的 <code>select(index)</code> 和 <code>unselect(index)</code> 方法选中或者解选标签。除此之外，<code>TagGroup</code> 中还有一个 <code>getSelectedIndex()</code> 方法，用于获取当前选中的标签数组的下标。</p><p>更多用法请查看项目 <a href="https://github.com/aJIEw/react-native-tag-group/blob/master/README.md">README</a>。</p><h3 id="一点心得"><a href="#一点心得" class="headerlink" title="一点心得"></a>一点心得</h3><p>这是我开源的第一个 RN 组件，虽然功能很简单，但是这也让我意识到开源其实并不难，只要你愿意动手去做，每个人都可以创造出一些东西。而且开源也比较容易得到正反馈，比如如果你造的轮子特别好用，受到了比较多的关注，你的成就感会特别高。这和我们平时工作中获得的成就感还不太一样，因为工作有明确的目的性，而开源则完全是一种自我驱动的行为，并不能直接给我们带来任何实际的利益，但是却能给我们带来满足感。另外这也是一种交流和学习的方式，你只有不断进步，才能得到更多人的认可。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识自己</title>
      <link href="/know-thyself/"/>
      <url>/know-thyself/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2020-04-30/know-thyself.jpg" alt="Know Thyself"></p><p>过去的几个月，和所有人一起经历了（其实还没完全结束）一起人类历史上前所未有的事件：新冠病毒（COVID-19），它让大家再次感受到人类在自然面前的渺小。当然，比起人类之前所经历过的瘟疫，这次病毒给我们造成的直接伤害明显有限得多，更多的还是经济上以及心理上的伤害。为了阻止病毒进一步传播，大多数人被迫待在家中，商业活动因此停止运行，经济陷入停滞。目前，国内正在慢慢从这种停摆中逐渐恢复，而国外不少国家的医疗系统依旧在与肆虐的病毒奋力对抗中，短期之内整个世界似乎还没有完全恢复到病毒爆发之前的状态的期望。</p><p>我觉得从普通人的角度，其实也能从这次事件里发现有益的一面（没错，我就是辣么的乐观），病毒给了大家一个机会<strong>停下来思考</strong>，无论是被动的还是主动的。这是每次灾难发生之后带来的副作用，就算你不去思考，总会有人去帮你分析总结，这个事件发生的前因后果，带给我们的震动，一些发生在普通人身上的事情，以及作为个体，能从这次事件中收获什么。这次病毒对于我来说最大的一个契机是：重新认识自己。</p><p>认识自己是个挺大的话题，我先从自己过去这几个月的经历说起吧。</p><span id="more"></span><h4 id="待在家的一个月"><a href="#待在家的一个月" class="headerlink" title="待在家的一个月"></a>待在家的一个月</h4><p>我是 1 月 22 号回到家中，那时候「武汉病毒」已经是挺大的一个话题了，推特上「肉翻」相关的话题也渐渐多了起来，而且没想到几天之后就会迎来第一次打破传统：在家过年、不走亲访友。然后是连续两次收到延迟开工的通知，直到 2 月 22 号才确认可以回去上班。</p><p>这次是结结实实在家待了一个月的时间，无法出门，每天在家上上网、看电影、玩手机等，其实刚开始的第一周觉得还是挺惬意的，这样的生活不就是我们平时想要的吗？但是等到第二个星期，人就开始慢慢感到有点无聊了，继而就是焦虑。每天起来对着电脑、手机，除了吃饭、睡觉，感觉什么都没干，这样的自己和废物有什么区别？开始怀疑自己存在的价值。刚好在家隔离前一两周看完了《人类简史》，书中作者预测未来社会可能出现很多『没用的人』，因为科技高度发达，社会的运行已经不需要这些多余的人力了，而他们也已经无法产出任何价值，对社会无任何用处，唯一的意义就是维持自身的生存以及娱乐消遣。但是通过这几周的经历，开始怀疑真的有人愿意过这样的生活吗？</p><p>在家隔离的最后一个礼拜，天气已经开始暖和起来，于是开始每天带着滑板外出。作为一名死宅，第一次觉得能不待在家里、外出走走可真好啊。于是开始迎来自己的第二个思考：如果不用考虑生存问题，<strong>我最想做什么？</strong></p><h4 id="恢复工作后的两个月"><a href="#恢复工作后的两个月" class="headerlink" title="恢复工作后的两个月"></a>恢复工作后的两个月</h4><p>一开始当然还是有点兴奋的，重新见到同事，回到了熟悉的工位。不过差不多一周之后，原有的厌倦感就又回来了。其实年前就打算要在年后找新的工作机会并跳槽的，但是没想到会遇到新冠病毒这个黑天鹅。不过我们无法预测这种突发事件的发生，所以也只能先走一步看一步。慢慢地开始一点点更新简历，复习算法、面试知识点，一边尝试实现年前就在准备的一个 Side Project，一个合我自己口味的 Github 客户端。</p><p>然后在 3 月底的时候，突然接到一个之前就听说过而且我也感兴趣的公司的面试邀请，兴奋不已，投了简历之后约好电面时间就开始提前一天的准备了。因为我知道自己不擅长向陌生人介绍自己，所以大部分时间都花在了自我介绍上面。但是我忘了一个重要的前提：自我介绍的作用是为了给面试官留下一个好的<strong>第一印象</strong>，但是面试<em><strong>最重要</strong></em> 的部分是你要传达给面试官<strong>你就是他们想要找的人</strong>的这个信息。如果你的能力不能通过短短的 30 分钟的面试很好地体现出来，或者面试官觉得你不具备他们想要找的人的特征，那么结局显而易见：你是无法通过面试的。</p><p>这次面试给我的冲击很大，可以说是有点受打击了吧，一方面对自己面试时的表现非常失望，另一方面开始意识到，过去我对自己的看法是片面且一厢情愿的，于是我开始认真反省自己目前的状态。</p><p>人对自己能力的认识总是会超过实际的情况，就像 90% 的司机都认为自己的开车水平在平均线之上。我以前一直觉得自己的能力在同事中至少处于中上游，但是实际情况真的是这样吗？我们都倾向于只看到他人身上不足的一面，而忽略了自己曾经犯过的错、做过的蠢事，于是觉得自己好像胜人一筹。所以，有人说「哪怕不跳槽，每年出去面试一次也是有好处的」。这句话是有道理的，面试的过程就是帮你认识自己，让你意识到自己的不足之处，学会反省，避免对自己能力预判太高的陷阱，而且这还是一个检验你真实能力的机会。</p><h4 id="个人发展的一个终极问题"><a href="#个人发展的一个终极问题" class="headerlink" title="个人发展的一个终极问题"></a>个人发展的一个终极问题</h4><p>通过这次机会我也意识到，这次疫情给社会整体带来的是一次人才重新流动的机会。许多原本混吃等死（抱歉用这么负面的词）的人都会被淘汰掉，虽然大多数岗位将会面临更加激烈的竞争，但是真正有能力的人会有机会得到那些抢手的、优质的岗位。</p><p>不过大多数人应该都像我一样，处于平均线的水平，既不是大牛，也不算太差劲，属于基本能做事的人。我们这样的人应该利用这次危机，好好思考下自己应该往哪个方向发展，比如是进一步精进自己现有的技能，同时巩固基础，往深处纵向发展？还是放宽眼界，寻求往周边领域发展，做一个万金油式的人才？毕竟市场对后者也有比较大的需求空间，而且竞争相对而言（似乎？）没有那么激烈。</p><p>过去一周以来，我又开始问自己这个终极问题：我到底想要做什么？从刚工作开始，每当生活或工作上遇到挑战、出现迷茫的时候，我都会不由自主地想起这个问题，但是每次基本都是通过某种变相逃避的方式来面对。不过逃避终究是没用的，只有正视它并且不断提起它、思考它才能慢慢地找到问题的答案。</p><p><strong>我适合做什么？我有没有特别想做的事？它有没有价值？我是否愿意尽全力、全情投入地去做这件事？</strong>（<a href="https://archive.is/7doGB">谈谈工作和学习中，所谓的主动性</a>）</p><p>能够回答这些问题的人是我羡慕的人，然而事实是目前的自己并没有找到这样的事情。我虽然有能力也有热情做好现在的工作，但是如果没有工资报酬的激励，我还会选择继续做现在的工作吗？虽然也知道大多数人从事的工作都是为了养家糊口，但是现在的我并没有养家糊口的压力，按理说应该花更多的时间去追寻自己喜欢并且有潜力在未来创造出巨大价值的事情才对。</p><p>也许是我想太多了吧。也许我应该在目前领域继续精进下去，等到能够解决遇到的大多数问题，答案也许就显而易见了。但是现在看来，自己的确还是没法很好地给出一个令自己满意的答案。不过没关系，有问题了才好，这样才会积极地想办法去解决它。希望五年、十年之后，当我回过头来重新想起这些问题的时候，那时的自己可以用行动给出一个更好的答案。</p><h4 id="离真正认识自己有多远"><a href="#离真正认识自己有多远" class="headerlink" title="离真正认识自己有多远"></a>离真正认识自己有多远</h4><p>回到开头的那个问题，认识自己是个持续一生的过程。我们从一出生时认为自己是世界的中心到随着慢慢成长后，意识到自己只不过是茫茫宇宙中凑巧出现在这个时空中的一团原子的组合。从古至今无数伟人先贤分享着他们眼中的世界，向我们解释这个世界的运行方式，但是无论我们的知识如何增长，终究还是要回到『认识自己』这个话题上。我在这个世界的位置是什么？我能够做什么？擅长什么？想要什么？我能够为他人和这个世界提供哪些价值？也许要花上一生去不断地尝试并寻找出答案，但这也正是人生的有趣之处吧，一点点接近答案直到我们走向衰老和死亡。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reviews </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑板入门指南</title>
      <link href="/skateboard-tips-for-beginners/"/>
      <url>/skateboard-tips-for-beginners/</url>
      
        <content type="html"><![CDATA[<img src='/assets/2020-01-18/skateboarding.jpg' width=100%/><p>学会滑板是我在去年初定下的新年计划之一，但是一直到去年十一的时候我才终于买了人生第一块滑板，到现在过去 3 个多月了，差不多算是入门了吧，所以写篇博客记录下自己的一些心得体会。希望这篇博客能给那些不怎么了解滑板的人普及到一些关于滑板的基础知识，以及给刚开始学习滑板的新人一点 tips 作为参考。</p><span id="more"></span><h3 id="了解滑板"><a href="#了解滑板" class="headerlink" title="了解滑板"></a>了解滑板</h3><p>滑板最开始是由 50 年代加州的冲浪爱好者为了在岸上练习冲浪制作出来的，后来在街头受到越来越多小孩子的青睐，慢慢地开始有公司专门生产滑板，又经过多年工业上的演化与工艺改进，才发展成现在的样子。</p><img src='../assets/2020-01-18/skateboard_parts.jpg'><h4 id="滑板基本组成"><a href="#滑板基本组成" class="headerlink" title="滑板基本组成"></a>滑板基本组成</h4><p>虽说现在我们买的滑板基本都是整块组装好的，但是我觉得作为一名初学者学习一下滑板的基本组成部分还是很有必要的（比如和人聊天的时候能听懂别人在说啥(-_-)ゞ゛）。看上面这张图，我们可以对滑板的有一个大致的了解。从下到上，依次是：</p><ul><li>  <strong>Wheel</strong>，<em>轮子</em>。应该是初学者首先需要了解的部分了，不同的轮子决定了你能在什么路面上玩滑板，以及你的速度，滑行时轮子与地面摩擦产生的噪音等等。推荐看下这篇文章：<a href="https://zhuanlan.zhihu.com/p/34070546">如何选择适合你的滑板轮子？</a></li><li>  <strong>Truck</strong>，<em>桥</em> 或者<em>支架</em>。桥是连接板面和轮子的部分，传递了从板面到轮子的重量。通常来说，桥的质量的好坏决定了一块滑板的使用寿命。<a href="https://zhuanlan.zhihu.com/p/34003315">如何选择合适的滑板桥？</a></li><li>  <strong>Bearing</strong>，<em>轴承</em>。轴承是把轮子固定在桥上的金属固件，轴承也会影响滑板的使用寿命以及轮子的转速。</li><li>  <strong>Riser Pad</strong>，<em>贴边</em>。相比贴边，我觉得一般更需要了解的是 PU 桥垫。比如如果你的双翘板装了公路轮，那么就需要更换桥垫，因为公路轮直径更大，需要用更高的桥垫把板面和轮子的距离垫高，否则很容易发生轮子触板的刺激画面，轻则摔破相，重则车祸。所以，玩滑板安全才是第一位的。</li><li>  <strong>Deck</strong>，<em>板面</em>。早期的滑板（Old-school board）板面都比较宽，有的可能还带有弧度，所以做动作特别难，而现在的滑板，宽度、长度基本都差不多（20cmx80cm），材料也大同小异（一般 7 层枫木），只要不是太不爱护，比如经常弄湿或者暴晒、人为破坏等等，板的使用寿命还是很长的。所以挑板面的话只要看颜值就可以了。</li><li>  <strong>Hardware</strong>，<em>桥钉</em>和<em>螺帽</em>。用于固定板面以及桥，一般只有换砂纸的时候才会需要拆开它们。</li><li>  <strong>Griptape</strong>，<em>砂纸</em>。主要用于增加鞋底和板的摩擦力。砂纸其实有利有弊，利是增大摩擦力做动作更容易了，弊是对鞋子伤害大，费鞋。玩滑板一段时间后，尤其是开始练动作之后，相信你会更有体会。</li></ul><p>好了，说了这么一大堆，如果你没耐心看完也没关系，只要知道滑板大概有这么些东西就可以了，更详细的资料我也懒得去搜了。其实别看滑板这么简单的东西，关于每个构件都可以写出好几篇文章，而且某些部件也是需要高精细的制作工艺才能制作出来的（比如轴承），这也是为什么许多好的滑板都是国外进口的品牌 。当然，市场也是一个因素，国内玩滑板的人少生产厂家也少，不过正因如此，才需要有人去介绍、推广这项运动呀(๑•͈ᴗ•͈)。</p><div style="text-align:center">Bearing parts ↓</div><img src='../assets/2020-01-18/skateboard_bearings.png' width=50%><div style="text-align:center">Truck parts ↓</div><img src='../assets/2020-01-18/skateboard_truck_diagram.jpg' width=40%><h4 id="滑板种类"><a href="#滑板种类" class="headerlink" title="滑板种类"></a>滑板种类</h4><p>一般来说，滑板可以分为三个大类：鱼板、双翘、长板。</p><h5 id="鱼板"><a href="#鱼板" class="headerlink" title="鱼板"></a>鱼板</h5><p>鱼板也就是人们常说的 Cruiser，是比较适合初学者练习的滑板，它的特点是轮子比双翘大，而且只有板尾是翘起的（有些可能还没有板尾），但是比较适合滑行。</p><p>鱼板一般分为小鱼板和大鱼板，他们之间唯一的区别只是体积大小的不同。小鱼板中有一些是塑料板，很轻，价格也比较便宜，但是我觉得并不适合初学者。相比小鱼，我更推荐大鱼板，因为它的上板难度更低。板面面积大，不用怕脚没地方放，而且通常来说也更稳当一点。另外，大鱼板也非常适合刷街代步，更容易体会到滑行的乐趣。</p><p>大鱼板入门推荐指数：★★★★</p><div style="text-align:center">大鱼板 ↓</div><img src='../assets/2020-01-18/cruiser.jpg' width=40%/><div style="text-align:center">Penny Board ↓</div><img src='../assets/2020-01-18/penny_board.png' width=40%/><h5 id="双翘"><a href="#双翘" class="headerlink" title="双翘"></a>双翘</h5><p>当我们谈论滑板时，大多数人指的都是双翘。它既可以滑行，也可以做出你在电视、视频中看到的各种炫酷的动作。你可以自己购买各种部件组装出自己喜欢的双翘板，不过对于初学者来说推荐直接购买整板就可以了。双翘上手难度适中，对于初次接触滑板的人来说，算是一个还不错的选择。</p><p>双翘入门推荐指数：★★★</p><img src='../assets/2020-01-18/skateboard.jpg' width=50%/><h5 id="长板"><a href="#长板" class="headerlink" title="长板"></a>长板</h5><p>长板的最大的特点就是<em>长</em>（笑），其次是轮子更大、更软，所以速度更快，滑行时间也更长，比较适合玩速降，最能享受到滑行的乐趣，常常可以看到小姐姐在长板上通过踩板做一些或简单或复杂的动作，而且玩法也主要围绕在滑行上。所以，如果<strong>只是</strong>想要学会滑行的话，长板无疑是最佳的选择。但是长板的缺点也很明显，那就是不方便携带，而且想要玩得爽的话就必须寻找人少且长的路段，最好还要带一点坡度。而如果是鱼板或者双翘的话，只要找个小广场就可以玩得很开心了，如果是双翘练动作的话更是小区里随便找块光滑的场地就可以了。</p><p>长板入门推荐指数：★★★★★</p><img src='../assets/2020-01-18/longboard.png' width=60%/><h4 id="哪种滑板适合我？"><a href="#哪种滑板适合我？" class="headerlink" title="哪种滑板适合我？"></a>哪种滑板适合我？</h4><p>相信经过上面的介绍就不难发现，每种滑板其实都有自己的优劣势，我们可以根据自己的需要以及不同的使用场景来进行选择。从上手难度来看，由难到易：双翘&gt;大鱼&gt;长板；从滑行能力上看，长板&gt;大鱼&gt;双翘；从价格上来看，由高到低：长板&gt;双翘&gt;大鱼；从可玩性来看，三者各有各的玩法，各有各的优势。</p><p>综合来看，我比较推荐初学者从大鱼板入手，大鱼是综合能力比较不错的滑板，无论是滑行还是做一些简单的 trick 都没问题。不过如果你住的附近有滑板店，最好还是去店里试试。当然要是不差钱，可以三种板都买一块，用长板学习滑行，用鱼板出门刷街，等滑得不错了再用双翘练动作。</p><p>对于大多数人而言，直接买新的板就可以了，不需要自己去组装，因为老实说只要质量过关，各个品牌之间的差别很小很小，滑板最重要的是你要自己去感受、去玩，只要能玩得开心就可以了。推荐看下这个视频：<a href="https://www.youtube.com/watch?v=mVKt2VBy6Ew">Do These 10 Things Make A Difference In Skateboarding?</a></p><h3 id="开始前的准备"><a href="#开始前的准备" class="headerlink" title="开始前的准备"></a>开始前的准备</h3><h4 id="为什么学习滑板？"><a href="#为什么学习滑板？" class="headerlink" title="为什么学习滑板？"></a>为什么学习滑板？</h4><p>在学习滑板之前，首先要确定你学习滑板的目的是什么。</p><p>因为它很酷？No, no, no! 仅凭这一点你是很难坚持下去的，很可能连基本的滑行都没学好就中途放弃了。</p><p>因为觉得好玩？嗯…这一点倒是必须的，但是我觉得还不够。如果你能通过玩滑板获得一些实际的『好处』，你才更能坚持下去。最常见的好处是，以滑板作为代步工具，比如你是大学生的话，可以尝试滑滑板去上课，如果你已经工作了就用滑板去其它以前需要步行的地方，比如用滑板代步去小区附近的电影院。总之给自己一个足够强烈的理由，让自己能够坚持下来。</p><p>其实学其他东西也一样，如果我们没有强烈的愿望，那么即使方法再好，我们也很难学会。当然，除了愿望和方法之外，勤奋练习也同样重要。</p><p>如果你觉得以上对你来说都 OK，那么请继续往下阅读。</p><h4 id="场地的选择"><a href="#场地的选择" class="headerlink" title="场地的选择"></a>场地的选择</h4><p>对于初学者来说，我推荐最好选择一个人少的广场，这样当你练习滑行的时候不用担心会撞到别人，而且摔跤的时候也不会觉得太丢脸（一开始摔跤肯定会觉得有点丢脸但是等摔习惯之后就好了😆）。除此之外，还需要观察下地面是否平整，如果是坑坑洼洼或者地面有很多裂缝的那种就不太适合练习了。一般情况下，场地表面越光滑越好，但是也不能太光滑，因为如果你的轮子硬度比较高，在这种地板上很容易打滑，尤其是地面上有水的时候。</p><h4 id="佩戴护具"><a href="#佩戴护具" class="headerlink" title="佩戴护具"></a>佩戴护具</h4><p>不要觉得戴护具会显得自己很菜，一开始菜不是很正常吗？作为初学者最要命的就是逞强以及太自信，戴好护具可以帮我们避免很多不必要的受伤。还有，在学习滑板的过程中一定是会摔跤的，摔跤可以说是学习滑板的第一课，而护具则是你摔完跤之后还能拍拍屁股站起来继续练习的保证。</p><p>护具还能帮助你学会如何正确地摔跤。没错，即使是摔跤也是需要学习的，推荐看下这两个视频：</p><ul><li><a href="https://www.youtube.com/watch?v=KSQ-q7F8e2o">How to fall without getting hurt?</a></li><li><a href="https://www.youtube.com/watch?v=Hundbrub8iQ">How to correctly fall in skateboarding?</a></li></ul><p>正如视频里说的，最好的滑板高手同时也是最擅长摔跤的。在练新动作的时候，你必须学会如何在摔跤的时候保护好自己的关键部位，尽可能降低因为突然停下时的身体动能给自己造成的伤害，学会分散冲击力到身体的各个部位，然后形成摔跤时的肌肉记忆，这样在不同场景下，你的身体会自动选择最佳的摔倒姿势（比如翻滚等）来保护自己。肌肉记忆这个词接下来可能还会被提及多次，因为滑板中所有的技巧、动作都是靠我们的肌肉记忆完成的。</p><h3 id="滑板基础"><a href="#滑板基础" class="headerlink" title="滑板基础"></a>滑板基础</h3><p>和学习其它运动一样，玩滑板同样需要先打好基础，滑板中最基本的动作是<strong>滑行</strong>、<strong>荡板</strong>以及<strong>刹车</strong>。</p><h4 id="滑行"><a href="#滑行" class="headerlink" title="滑行"></a>滑行</h4><p>滑行是滑板基础中的基础。很多人一上来就想学动作，然后经常摔跤最后觉得滑板太难就放弃了。其实如果能稍微有点常识，了解下学习曲线就不会吃这种亏了。</p><ol><li> 确定惯用脚</li></ol><p>在开始练习滑行前，首先要确定你的惯用脚，人有左撇子和右撇子，对于玩滑板的人来说同样如此。最简单的确认方法是身体面向前方倒下，你的身体会自然迈出一只脚阻止倒下，首先迈出的那只脚就是你的惯用脚，或者你也可以想象自己在冰面上，然后跑动一段距离再迈出一只脚利用惯性向前滑行停下，看自己哪只脚在前，在前面的那只脚就是你的惯用脚。如果你的左脚是惯用脚那你就是 regular，否则就是 goofy。滑板里 regular 和 goofy 都比较常见，民间的说法是 60% 是 regular，40% 是 goofy。</p><ol start="2"><li> 慢速滑行</li></ol><p>确定了你的惯用脚之后就可以开始练习滑行了。首先要确定自己脚的位置，一般把脚放在四颗桥钉处，最远不超过第一排桥钉的位置。如下图（请原谅我的神仙画技）。</p><img src='../assets/2020-01-18/skateboard_deck.jpg' width=50%/><p>这样，你的身体重心就自然地落在了滑板的前半部分，这点对于初学者来说特别重要，因为掌握了重心的位置你才能保持平衡。让重心保持在前，也能让你的另一只脚更容易发力向前滑行，而且即使你觉得自己要摔倒了，因为重心在前，你可以很自然的下板然后利用惯性向前跑动一段距离，从而避免摔跤。如果重心在后，一旦你的身体失去平衡，你很难保证自己不摔跤。这点可以自己慢慢体会。简单来说，向前滑行的时候，保持<strong>重心在前</strong>。</p><img src='../assets/2020-01-18/skateboard_deck_one_foot.jpg' width=80%/><p>另外，一开始滑行的时候，速度不要太快，保持和走路的速度差不多，前脚在板上尽量<strong>弯曲膝盖</strong>，让自己的身体的重心降低。然后后脚慢慢踩地面发力，可以一点点踩，感受身体随着滑板向前一点点移动的那种感觉。</p><p>学会单脚慢速滑行并不难，一般 1~2 天就够了，平衡感好的人可能半个小时就能学会。</p><ol start="3"><li> 两种脚位</li></ol><p>等你适应了一只脚在板上滑行之后就可以尝试另一种脚位了，那就是双脚平行的站姿。因为我们只有加速的时候才会一只脚在板上，当不加速的时候，另一只脚需要上板休息，这时我们就需要改变站姿，改成双脚平行的站姿（也叫 Cruising Position），这样我们才能轻松在板上保持平衡。</p><img src='../assets/2020-01-18/skateboard_deck_cruising_position.jpg' width=80%/><p>同样地，一开始你可能根本就不敢两只脚同时上板，所以推荐最好先在墙边或者找根柱子，扶着墙或者柱子熟悉一下双脚站在板上的感觉，然后再以这种站姿尝试慢慢向前滑行，等到差不多熟悉这种感觉了，再尝试在滑行中上板，然后<strong>切换脚位</strong>，也就是从加速脚位切换到滑行脚位。切换脚位看似简单，但是也是需要不少时间练习的。</p><ol start="4"><li> 转向</li></ol><p>滑板中转向反而是最简单的部分，只要通过向一边施力，滑板就会向那边慢慢转过去，当然如果是新的滑板，由于螺母转得比较紧所以可能转的角度比较小，但是等滑板使用一段时间之后 bushing 松了，转向就会变得越来越容易。我们也可以自己把螺母调松，但是不推荐初学者这么做。</p><p>另一种转向方式是 kick turn，也就是通过踩板尾然后翘起板头转向，这种转向方式适合场地较小转向空间不足的时候。Kick turn 对于初学者来说并不推荐，等到学会荡板之后自然就会 kick turn 了。</p><p>当你能够自如切换脚位以及转向之后，基本就算是学会滑行了。滑行的练习真的特别特别重要，它可以帮助你学会在滑板上保持平衡，学会如何控制自己的身体、利用惯性等等。掌握这部分所需要的时间也因人而异，因为涉及到平衡感、自信心（特别重要）等因素，一般可能需要 3~4 天吧。</p><h4 id="荡板-Tic-Tac"><a href="#荡板-Tic-Tac" class="headerlink" title="荡板 (Tic Tac)"></a>荡板 (Tic Tac)</h4><p>荡板应该是初学者最最需要花时间练习的技能，它看似无用，但是所有技巧都始于它。荡板说来简单，就是通过不停左右转向从而获得向前进的动力（有人说是通过左右压板，但其实原理都差不多，都是为了获得向前的 momentum），但是想要完全掌握可能需要很长的时间，我前后可能花了一个多月（虽然不是每天都练）才算是学会了荡板。这部分我觉得真没什么诀窍，自己看几个视频然后<strong>多练、多练、多练</strong>。只要每天都花点时间练习，重复重复再重复，形成腿部的肌肉记忆，到后面荡板就会像走路一样自然了。</p><h4 id="刹车"><a href="#刹车" class="headerlink" title="刹车"></a>刹车</h4><p>对于初学者来说，一开始的刹车方式无非两种，一种是用后脚戳地，一般戳个几次就停下了，另一种是直接从板上跳下来。这两种方式都是凭直觉的，但是为了应付复杂的场景还有保护自己和滑板，我们就需要学习一些更好的减速以及刹车的技巧。</p><ol><li><h5 id="脚刹"><a href="#脚刹" class="headerlink" title="脚刹"></a>脚刹</h5></li></ol><p>这应该是最实用的刹车方式了。简单来说，就是一只脚保持在板上（切换成单脚向前的站姿），然后后脚悬空用脚后跟摩擦地面，然后慢慢加大力度使得速度逐渐减慢，最后再踩实停下来。这种方式既可以用于刹车也可以用于减速。</p><p>使用这种方式刹车或者减速的前提是，你必须熟练掌握<strong>单脚滑行</strong>的技巧。当你可以单脚在板上滑行 4、5 秒，再开始练习这种刹车方式就事半功倍了。单脚滑行的诀窍同样是保持重心在前方，然后身体前倾，膝盖弯曲，后脚悬空放在身后或者贴近身体，利用后脚或者不断调整身体姿势保持平衡，还有觉得不稳的时候尽量往前倒（不要怕会脸刹，正常人基本下意识的都会保护自己的脸的，往后倒才是真的可怕╭(°A°`)╮。</p><ol start="2"><li><h5 id="尾刹"><a href="#尾刹" class="headerlink" title="尾刹"></a>尾刹</h5></li></ol><p>尾刹通过将滑板前端（板鼻）翘起，利用滑板的尾部或者将后脚探出一部分（前脚掌或后脚跟）摩擦地面来进行刹车。尾刹相对脚刹来说难上很多，建议至少先学会荡板后再来练习尾刹，因为尾刹更考验身体的平衡性以及你对滑板的控制能力。初学者对滑板的操控能力没那么强，如果一上来就开始学尾刹，会摔得很惨。</p><p>虽然如此，但是还是想分享一些我练习尾刹时摔跤好多次才总结出来的经验。</p><h6 id="先练习荡板"><a href="#先练习荡板" class="headerlink" title="先练习荡板"></a>先练习荡板</h6><p>荡板好像和尾刹没什么关系，但是从我的经验来看，如果当初学会荡板再来练习尾刹，一切会简单很多很多倍。因为尾刹其实靠的是你后脚踩板尾控制板尾接触地面的力度：不能一下踩实，因为反方向加速度太大你会往后仰然后摔倒；也不能踩的太少，因为这样就成了 manual。而且一开始你根本做不了 manual，很可能就做成了翘一下板鼻而已。所以，练好荡板就很重要，可以让你学会精准控制踩板尾的力度。荡板一般要练到可以轻松上 10 几度的坡才算过关。</p><h6 id="练习原地-180-度转"><a href="#练习原地-180-度转" class="headerlink" title="练习原地 180 度转"></a>练习原地 180 度转</h6><p>当我们使用尾刹时，大多数时候是想要转向，所以会做出旋转 180 度并画圆弧的动作。为了适应这种动作，我们最好先熟悉原地 180 度转。练这个动作的前提是你对荡板掌握得很好，而且一开始学习的时候一定要佩戴好护具，因为第一次练习这个动作很容易摔跤。</p><p>首先练习荡板，找找感觉，然后站在板上，膝盖微曲，展开双手与肩膀成直线，与板面平行，然后开始做转肩膀的动作，重心稍微偏向轴心一侧（假设右脚在板鼻，左脚在板尾，同时向左转 180 度，则重心稍微偏向左脚），转肩膀的同时目光定位到需要将板转过来的位置，然后利用肩膀带动腰部转动，最后只要依靠腰部的惯性带动右脚把板转到目标位置就可以了（此时你的肩膀应该已经转过来了），整个过程你的右脚几乎不需要发力。</p><p>描述起来好像有很多动作，其实整套动作是一气呵成的。一开始练习的时候，你可能只能旋转 45 度角，但是不用担心，随着练习次数的增加你会越来越熟练，角度也会转得越来越大，甚至连转 360 度都可以轻轻松松。</p><h6 id="用前脚尖接触地面画圆弧"><a href="#用前脚尖接触地面画圆弧" class="headerlink" title="用前脚尖接触地面画圆弧"></a>用前脚尖接触地面画圆弧</h6><p>这个应该不算经验，应该是大多数人用前脚掌做尾刹时（不讨论后脚根尾刹，因为会难上很多）自然而然做出的动作。因为板尾刹车会让我们的身体重心偏向一方（向左或者向右），此时滑板就会以板尾一侧为轴心做旋转。而如果仅凭板尾接触地面，由于板尾比较光滑，摩擦力较小，所以旋转幅度就比较难控制，但是如果我们探出前脚尖，就可以利用鞋底摩擦地面来增加摩擦力，而且用脚底踩地面的力度比用板尾摩擦地面的力度更容易控制一些，另外这也可以保护板尾。</p><p>一开始你可能会对这种脚位感觉很不熟悉、很别扭，导致不敢探出前脚掌，那么可以先尝试<strong>探出 1/3 鞋尖到板尾外，同时使用后脚根作为发力点</strong>。然后以这种站姿先练习原地转 180，等到熟悉之后，再尝试速度比较慢的情况下小角度用脚尖轻点地面进行转弯。一开始可能需要轻轻点两三次才能转成一个 180 度的弯，但是等到熟悉了这种感觉之后，就可以尝试探出半个前脚掌轻轻摩擦地面，在转弯的同时，在地面上画出一道漂亮的弧线。</p><p>另外还有一个要注意的点是前脚（板鼻位置的那只脚）的站位，最好只是用脚掌轻轻压着板面，而不是将整只脚踩在板上。为什么要这样？因为通常来说，我们的<em>脚掌</em> 对力度的控制更精细一些。在使用尾刹的时候，后脚的脚掌需要摩擦地面，前脚的脚掌则负责控制抬板鼻的高度，不能抬太多否则后脚容易踩实然后摔倒，也不能抬太少否则你很难保持身体的平衡。所以一定要熟悉这种<strong>后脚的脚掌露出板尾一部分、前脚的脚掌轻轻贴着板面控制方向</strong>的站姿。最好的做法是，反复练习使用这种站姿去荡板、原地转 180、小速度转向，等熟悉之后再去练脚刹就会有种「脚」到擒来的感觉了😂。</p><p>最后说下为什么要<strong>后脚跟发力</strong>，其实道理很简单，当你使用脚掌发力的时候，虽然更容易控制力度，但是时间长了很容易累（脚掌肌肉长时间保持紧绷、僵直了的缘故），而用后脚跟则不会有这个问题。只要熟悉了控制后脚跟往下压的力度，再配合前脚抬板鼻的高度，你会发现这样省力很多。不信你可以试试先用脚掌作为发力点，荡板走直线，一直荡到脚有点酸为止，然后返回的时候再用后脚跟荡板，你会发现自己回到出发点后却依旧不觉得脚酸。但是，这种站姿下前脚还是会容易感到累，所以还有一个技巧是<strong>前脚的位置尽量靠近板中间</strong>。不过这样做的前提是，你已经非常熟悉使用脚跟荡板、转向了，否则你会觉得这样很难掌握身体的平衡，而且很容易脱板。</p><h6 id="保持双肩和板面平行"><a href="#保持双肩和板面平行" class="headerlink" title="保持双肩和板面平行"></a>保持双肩和板面平行</h6><p>也就是胸口要面向板的一侧（其实准确来说，应该是朝向重心的一侧，比如如果你是往左侧画弧，则重心偏向左侧，那么胸口自然也应该朝左侧，这样比较容易保持平衡）。这算是一个小 tip 吧，我一开始练荡板的时候，养成了脸朝前看的坏习惯，然后练习尾刹的时候，每次抬板鼻都会习惯性地脸朝前、转肩膀，这种姿势在尾刹的时候是很难在板上保持平衡的，如果速度比较快，一旦板尾或前脚掌接触地面身体就会失去平衡，好在我后来通过不断看自己的视频发现了这个问题。</p><div style="text-align:center">正确姿势  ↓</div><img src='../assets/2020-01-18/skating-to-cruise-along.jpg' width=60%/><p>虽然一开始看别人的教学视频也听到要如何如何，但是只有等自己真正实际去试的时候才会发现：原来他说的是这个意思啊。所以，如果我这里给出的技巧和建议你也只是看看而已，那么并不会有什么卵用，只有在实践中去验证一遍，你才能真正体会到我说的是什么意思。</p><ol start="3"><li><h5 id="横刹"><a href="#横刹" class="headerlink" title="横刹"></a>横刹</h5></li></ol><p>脚刹和尾刹一般只适用于滑行速度不是太快的情况下，尤其是尾刹，如果速度很快还用尾刹无异于自杀。当速度比较快的时候一般就只能靠横刹减速了。所谓横刹就是在滑动过程中后脚搓板尾，将滑板横过来，使轮子横向摩擦地面从而达到减速的目的。教学视频可以看下这个：<a href="https://www.bilibili.com/video/av27445168/">横刹</a>。</p><p>横刹我目前也还没学会所以就不多说了，而且初学者滑行的速度一般不会太快所以也用不到横刹。</p><p>更多关于其它类型的刹车方式，可以看下这个视频：<a href="https://www.youtube.com/watch?v=bTd4Ta5wTUM">10 Ways to Stop on your Skateboard.</a></p><h3 id="进阶地图"><a href="#进阶地图" class="headerlink" title="进阶地图"></a>进阶地图</h3><p>等你学会滑行、荡板、刹车之后，恭喜你，你已经算是入门级滑板选手了！接下来就可以练习更多诸如 Manual、Pop shove it 甚至是 Kickflip 等花式动作了。相信如果能走到这一步，你也应该已经喜欢上玩滑板了，所以请继续练习，并且把它推广给身边更多的人，让他们也能加入并且爱上这项运动。</p><p>目前我也才刚刚达到 Ollie 的水平，所以无法给出更进一步的建议，这里只能先列出一个大致的进阶地图，希望和大家一起不断进步~ (•̀ᴗ•́)و ̑̑！</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm">└─Shove <span class="hljs-keyword">it</span><br>  └─*The Ollie*<br>    └──Frontside <span class="hljs-number">180</span><br>       └──Backside <span class="hljs-number">180</span><br>          └──<span class="hljs-keyword">Pop</span> Shove <span class="hljs-keyword">it</span><br>             └──Frontside Shove <span class="hljs-keyword">it</span><br>                └──Heelflip<br>                   └──Kickflip<br></code></pre></td></tr></table></figure><p>还有诸如 Manual、Slide、Rail Stands 等等小技巧，可以在学习以上这些动作时同步进行练习。</p><h3 id="视频资料"><a href="#视频资料" class="headerlink" title="视频资料"></a>视频资料</h3><p>对于初学者，推荐先看下这篇博客，我当初也是看了它才打算写一篇博客来为初学者科普的：<a href="https://www.liveabout.com/essential-beginner-skateboard-gear-and-skills-4686956">The Beginner’s Guide to Skateboarding</a>。网上的视频资料很多， YouTube 以及 Bilibili 上都有很多视频博主分享的优质的学习滑板的视频，这里我就推荐一些我觉得比较好的 YouTube 频道吧：</p><ul><li>  <a href="https://www.youtube.com/user/sprocker7">Braille Skateboarding</a>，比较出名的滑板教学品牌了，著名的滑板「传教士」Aaron Kyro 也是其中的一员。</li><li>  <a href="https://www.youtube.com/user/xxblackoctoberxx">VLSkate</a>，我很喜欢看他的视频，看他教的一些有趣的小技巧，虽然并学不会ㄟ( ▔, ▔ )ㄏ。</li><li>  <a href="https://www.youtube.com/channel/UCB6hdydB90yEVv5mpkjv2CA">Skateboard Bruh</a>，除了教学之外，也会讲一些滑板周边的话题，我很喜欢最近的这个关于滑板界一些现状的视频（不要吐槽这个令人尴尬的标题´͈ ᵕ `͈）：<a href="https://www.youtube.com/watch?v=g-rYrzmeVyY">26 Skateboarding Facts You Didn’t Know</a></li><li>  <a href="https://www.youtube.com/channel/UCEvzv3C8BR8d6r2VRqqsA_A">John Hill</a>，同样很喜欢他出的教学视频，语言比较通俗易懂。</li><li>  <a href="https://www.youtube.com/channel/UCAT-5O052XL8KRN1GtS13Ag">openSource(skateboards);</a>，该频道除了教滑板技巧，还教你如何设计和制作自己的滑板，酷到没朋友。</li></ul><p>另外，还有一些我很喜欢的玩长板的频道：</p><ul><li>  <a href="https://www.youtube.com/channel/UCc1YJYc2a9ly99NjimmjIEQ">Alternative Longboards</a>，主要是长板速降，他们的视频背景都很美，比如<a href="https://www.youtube.com/watch?v=temztHasP2A&list=PUc1YJYc2a9ly99NjimmjIEQ&index=2">这个</a>。</li><li>  <a href="https://www.youtube.com/channel/UCvPcP6K4OEqvrkzvJ3rnHWg">Juan Rayos</a>，这个频道有一组女孩在全世界各处玩长板+旅游的视频，太让人羡慕了。</li><li>  <a href="https://www.youtube.com/channel/UC5FOkD_OiUjgCOawXaK0wCg">고효주HyojooKo</a>，国内也很出名的人称长板女神的高孝周的 YouTube 频道，看她玩长板会让人心情明亮起来~(❁´‿`❁)<em>✲ﾟ</em></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Skateboard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的日常使用工具清单</title>
      <link href="/software-list/"/>
      <url>/software-list/</url>
      
        <content type="html"><![CDATA[<img src='/assets/2020-01-14/workshop.jpg'/><p>工欲善其事，必先利其器。拥有一个好的工具集可以极大地提高我们的生产力，因此，在这里整理一下我觉得必备的工具，作为记录和分享。</p><p>我知道某些工具可能有不少替代品，但是出于个人喜好、使用习惯等原因一直没有切换，所以，如果你觉得有更好的推荐，欢迎留言分享。</p><p>我会根据平台和功能来整理，如果某个工具支持多个平台，那么就不再在另一平台下重复列出了。链接我尽量使用该软件的官方网站，如果没有官网，则用该软件所在平台的主流发布渠道的链接替代。</p><span id="more"></span><h2 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h2><h3 id="基础工具"><a href="#基础工具" class="headerlink" title="基础工具"></a>基础工具</h3><table><thead><tr><th>名称</th><th>功能</th><th>是否全平台支持</th><th>是否开源</th></tr></thead><tbody><tr><td><a href="https://www.google.com/chrome/">Google Chrome</a></td><td>浏览器</td><td>全平台支持</td><td><a href="https://www.chromium.org/Home">部分</a>开源</td></tr><tr><td><a href="https://www.dropbox.com/">Dropbox</a></td><td>云盘</td><td>全平台支持</td><td>否</td></tr><tr><td><a href="https://owncloud.com/">ownCloud</a></td><td>私有云盘</td><td>全平台支持</td><td><a href="https://github.com/owncloud">是</a></td></tr><tr><td><a href="https://www.raycast.com/">Raycast</a></td><td>启动器</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.u.tools/">uTools</a></td><td>生产力工具集</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.typora.io/">Typora</a></td><td>MarkDown 编辑器</td><td>桌面端</td><td>否</td></tr><tr><td><a href="https://obsidian.md/">Obsidian</a></td><td>知识管理工具</td><td>桌面端</td><td>否</td></tr><tr><td><a href="https://iterm2.com/">iTerm 2</a></td><td>命令行终端</td><td>否</td><td><a href="https://github.com/gnachman/iTerm2">iTerm2</a></td></tr><tr><td><a href="https://fig.io/">Fig</a></td><td>终端命令补全</td><td>否</td><td><a href="https://github.com/withfig/autocomplete">autocomplete</a></td></tr><tr><td><a href="https://slack.com/">Slack</a></td><td>IM 协作工具</td><td>全平台支持</td><td>否</td></tr><tr><td><a href="https://telegram.org/">Telegram</a></td><td>IM</td><td>全平台支持</td><td><a href="https://github.com/overtake/TelegramSwift">macOS</a> / <a href="https://github.com/telegramdesktop/tdesktop">Windows</a> / <a href="https://github.com/DrKLO/Telegram">Android</a> / <a href="https://github.com/TelegramMessenger/Telegram-iOS">iOS</a></td></tr><tr><td><a href="https://www.teamviewer.com/">TeamViewer</a></td><td>远程控制</td><td>全平台支持</td><td>否</td></tr><tr><td><a href="https://iina.io/">IINA</a></td><td>视频播放器</td><td>否</td><td><a href="https://github.com/iina/iina">iina</a></td></tr><tr><td><a href="http://www.splayer.org/en/">SPlayer</a></td><td>射手影音播放器</td><td>桌面端</td><td>否</td></tr><tr><td><a href="https://theunarchiver.com/">The Unarchiver</a></td><td>文件解压</td><td>否</td><td>否</td></tr><tr><td><a href="https://unclutterapp.com/">Unclutter</a></td><td>效率</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.better365.cn/bab.html">BetterAndBetter</a></td><td>效率</td><td>否</td><td>否</td></tr><tr><td><a href="https://en.toolinbox.net/iPaste/">iPaste</a></td><td>剪贴板管理</td><td>macOS / iOS</td><td>否</td></tr><tr><td><a href="https://www.better365.cn/ishot.html">iShot</a></td><td>截图工具</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.eudic.net/v4/en/app/eudic">欧路词典</a></td><td>中英翻译</td><td>否</td><td>否</td></tr><tr><td><a href="https://lemon.qq.com/">Tencent Lemon Lite</a></td><td>磁盘空间清理</td><td>否</td><td>否</td></tr><tr><td><a href="https://freemacsoft.net/appcleaner/">AppCleaner</a></td><td>应用清理</td><td>否</td><td>否</td></tr><tr><td><a href="https://github.com/Ji4n1ng/OpenInTerminal/blob/master/Resources/README-Lite-zh.md">OpenInTerminal</a></td><td>辅助工具</td><td>否</td><td><a href="https://github.com/Ji4n1ng/OpenInTerminal">是</a></td></tr><tr><td><a href="https://support-en.wd.com/app/products/product-detail/p/1378#WD_downloads">NTFS Driver for Mac</a></td><td>辅助工具</td><td>否</td><td>否</td></tr><tr><td><a href="https://github.com/dwarvesf/hidden">Hidden Bar</a></td><td>辅助工具</td><td>否</td><td>是</td></tr><tr><td><a href="https://www.ortisoft.de/en/accessmenubarapps/">AccessMenubarApps</a></td><td>辅助工具</td><td>否</td><td>否</td></tr><tr><td><a href="https://github.com/dteoh/SlowQuitApps/releases/tag/v0.8.0">SlowQuitApps v0.8.0</a></td><td>辅助工具</td><td>否</td><td><a href="https://github.com/dteoh/SlowQuitApps">SlowQuitApps</a></td></tr><tr><td><a href="https://alt-tab-macos.netlify.app/">AltTab</a></td><td>辅助工具</td><td>否</td><td><a href="https://github.com/lwouis/alt-tab-macos">alt-tab-macos</a></td></tr><tr><td><a href="https://www.android.com/filetransfer/">Android File Transfer</a></td><td>辅助工具</td><td>否</td><td><a href="https://github.com/Ji4n1ng/OpenInTerminal">OpenInTerminal</a></td></tr><tr><td><a href="https://karabiner-elements.pqrs.org/">Karabiner-Elements</a></td><td>辅助工具</td><td>否</td><td><a href="https://github.com/pqrs-org/Karabiner-Elements">Karabiner-Elements</a></td></tr><tr><td><a href="https://rogueamoeba.com/airfoil/mac/">Airfoil</a></td><td>辅助工具</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.irradiatedsoftware.com/sizeup/">SizeUp</a></td><td>辅助工具</td><td>否</td><td>否</td></tr><tr><td><a href="https://sindresorhus.com/one-thing">One Thing</a></td><td>辅助工具</td><td>否</td><td>否</td></tr><tr><td><a href="https://intelliscapesolutions.com/apps/caffeine">Caffeine</a></td><td>防止休眠</td><td>否</td><td>否</td></tr><tr><td><a href="http://www.miidii.tech/portfolio/items/839266">Take a Break</a></td><td>休息提醒</td><td>否</td><td>否</td></tr><tr><td><a href="https://sindresorhus.com/dato">Dato</a></td><td>状态栏日历</td><td>否</td><td>否</td></tr><tr><td><a href="https://gfycat.com/gifbrewery">GIF Brewery 3</a></td><td>视频转 GIF</td><td>否</td><td>否</td></tr><tr><td><a href="https://evernote.com/products/skitch">Skitch</a></td><td>图片标注</td><td>否</td><td>否</td></tr><tr><td><a href="https://imageoptim.com/mac">ImageOptim</a></td><td>图片压缩</td><td>否</td><td><a href="https://github.com/ImageOptim/ImageOptim">ImageOptim</a></td></tr><tr><td><a href="https://www.gimp.org/">Gimp</a></td><td>图片处理</td><td>桌面端</td><td><a href="https://gitlab.gnome.org/GNOME/gimp/">是</a></td></tr><tr><td><a href="https://xournalpp.github.io/">Xournal++</a></td><td>手写笔记</td><td>是</td><td><a href="https://github.com/xournalpp/xournalpp/">xournalpp</a></td></tr><tr><td><a href="https://www.vmware.com/products/fusion.html">VMware Fusion</a></td><td>虚拟机</td><td>否</td><td>否</td></tr></tbody></table><div style="text-align: right"><sup>这里的全平台指的是 macOS / Windows / Linux / Android / iOS，桌面端指的是 macOS / Windows，下同</sup></div><h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><p>Chrome 应该是我日常使用频率最高的一个工具了，如何把 Chrome 打造得更好用是我一直在探索的事情，所以这里把它单独拎出来。</p><p>Chrome 目前虽然已经更新到 80+ 了，但是有一些核心的功能却还是缺失的，所以只能通过安装 Extension 来解决。</p><h4 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h4><table><thead><tr><th>名称</th><th>功能</th><th>是否开源</th></tr></thead><tbody><tr><td><a href="https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco">Extension Manager</a></td><td>插件管理</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/workona/ailcmbgekjpnablpdkmaaccecekgdhlh">Workona</a></td><td>标签页+项目管理</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/download-plus/gokgophibdidjjpildcdbfpmcahilaaf">Download Plus</a></td><td>文件下载管理</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb">Google Translate</a></td><td>中文翻译</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D-%E8%81%9A%E5%90%88%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg/reviews?hl=en">Saladict</a></td><td>多词源翻译</td><td>否</td></tr><tr><td><a href="https://burningvocabulary.com/">Burning Vocabulary</a></td><td>单词高亮</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/grammarly-for-chrome/kbfnbcaeplbcioakkpcpgfkobkghlhen">Grammarly for Chrome</a></td><td>错别字、语法检查</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/notion-web-clipper/knheggckgoiihginacbkhaalnibhilkk">Notion Web Clipper</a></td><td>Notion 网页拾取</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/spotify-web-player-hotkey/pdcbjjmgfakcbbchppeemlfpfgkdmjji">Spotify Web Player Hotkeys</a></td><td>给 Spotify 网页播放器设置快捷键</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/color-by-fardos/iibpgpkhpfggipbacjfeijkloidhmiei">Color by Fardos - Color Picker</a></td><td>取色器</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/pushbullet/chlffgpmiacpedhhbkiomidkjlcfhogd">Pushbullet</a></td><td>文件、通知同步</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/rss-feed-reader/pnjaodmkngahhkoihejjehlcdlnohgmp">RSS Feed Reader</a></td><td>RSS 阅读器</td><td>否</td></tr><tr><td><a href="https://add0n.com/chrome-reader-view.html">Reader View</a></td><td>阅读模式</td><td><a href="https://github.com/rNeomy/reader-view">reader-view</a></td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/mix/pakcjidblmfebhbgoggdgbjkpjhefpgh">Mix</a></td><td>发现新网站、推荐文章</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/block-site-website-blocke/eiimnmioipafcokbfikbljfdeojpcgbh">Block Site</a></td><td>设定工作模式，屏蔽网站</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/ublacklist/pncfbmialoiaghdehhbnbhkkgmjanfhe">uBlacklist</a></td><td>过滤搜索引擎结果</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/redirector/pajiegeliagebegjdhebejdlknciafen">Redirector</a></td><td>网址重定向</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb">Adblock Plus</a></td><td>广告过滤</td><td>否</td></tr><tr><td><a href="https://github.com/iamadamdev/bypass-paywalls-chrome">Bypass Paywalls</a></td><td>绕过付费墙</td><td>是</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/quick-qr-code-generator/afpbjjgbdimpioenaedcjgkaigggcdpp">Quick QR Code Generator</a></td><td>二维码生成器</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/bookmark-sidebar/jdbnofccmhefkmjbkkdkfiicjkgofkdh">Bookmark Sidebar</a></td><td>侧边栏书签</td><td><a href="https://github.com/Kiuryy/Bookmark_Sidebar">Bookmark_Sidebar</a></td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall">OneTab</a></td><td>标签页合并、管理</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">Vimium</a></td><td>类 Vim 风格操作快捷键</td><td><a href="https://github.com/philc/vimium">vimium</a></td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh">JSON Viewer</a></td><td>美化 JSON 数据</td><td><a href="https://github.com/tulios/json-viewer">json-viewer</a></td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/octo-mate/baggcehellihkglakjnmnhpnjmkbmpkf">Octo Mate</a></td><td>Github 辅助功能</td><td><a href="https://github.com/camsong/chrome-github-mate">chrome-github-mate</a></td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/refined-github/hlepfoohegkhhmjieoechaddaejaokhf">refined-github</a></td><td>Github 辅助功能</td><td><a href="https://github.com/sindresorhus/refined-github">refined-github</a></td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc">Octotree</a></td><td>Github 侧边栏</td><td><a href="https://github.com/ovity/octotree">octotree</a></td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien">Isometric Contributions</a></td><td>美化代码提交日历</td><td><a href="https://github.com/jasonlong/isometric-contributions">isometric-contributions</a></td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/sourcegraph/dgjhfomjieaadpoljlnidmbgkdffpack">Sourcegraph</a></td><td>代码浏览、智能跳转等</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/picture-in-picture-extens/hkgfoiooedgoejojocmhlaklaeopbecg">Picture-in-Picture Extension</a> (by Google)</td><td>YouTube 视频悬浮播放</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/goodreads-ratings-for-ama/fkkcefhhadenobhjnngfdahhlodolkjg">Goodreads ratings for Amazon</a></td><td>亚马逊买书看评分</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/similarweb-traffic-rank-w/hoklmmgfnpapgjgcpechhaamimifchmp">SimilarWeb</a></td><td>网站流量排名</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/seoquake/akdgnmcogleenhbclghghlkkdndkjdjc">SEOquake</a></td><td>SEO 辅助工具</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/ie-tab/hehijbfgiekmjfkfjpbkbammjbdenadd">IE Tab</a></td><td>模拟 IE 环境</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/shared-clipboard/nmemiplfpjallomblhoapiajlgpnjloi">Shared Clipboard</a></td><td>剪贴板同步</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/reggy/pnneajlgffpejnabhionnhdfhibijihe">Reggy</a></td><td>自动生成信息注册账号</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/url-shortener/oodfdmglhbbkkcngodjjagblikmoegpa">Url Shortener</a></td><td>网址缩短</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/hide-my-ip-vpn/keodbianoliadkoelloecbhllnpiocoi">Hide My IP</a></td><td>模拟 IP 地址</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/super-simple-highlighter/hhlhjgianpocpoppaiihmlpgcoehlhio">Super Simple Highlighter</a></td><td>网页文字高亮</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/clear-cache/cppjkneekbjaeellbfkmgnhonkkjfpdn">Clear Cache</a></td><td>清除缓存</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/whatfont/jabopobgcpjmedljpbcaablpmlmfcogm">WhatFont</a></td><td>查看网页字体</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/enable-right-click/hhojmcideegachlhfgfdhailpfhgknjm">Enable right click</a></td><td>关闭禁用右键网页</td><td><a href="https://github.com/kyo-ago/enable-right-click">是</a></td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/dont-fuck-with-paste/nkgllhigpcljnhoakjkgaieabnkmgdkb">Don’t Fuck With Paste</a></td><td>关闭禁用输入框复制/粘贴</td><td><a href="https://github.com/jswanner/DontFuckWithPaste">是</a></td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/pablo/gfpibnlcombjoeejlongmihndgkpnjjo">Pablo</a></td><td>制作社交网站分享图片</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/flowshare-how-to-guides-f/lfegkcljaabalcnccemlmakgligfjnml">Flowshare</a></td><td>制作用户引导指南</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo">Tampermonkey</a></td><td>脚本管理器</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/puppeteer-recorder/djeegiggegleadkkbgopoonhjimgehda">Headless Recorder</a></td><td>浏览器操作录制成脚本</td><td><a href="https://checklyhq.com/docs/">Docs</a></td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/%E5%A3%B9%E4%BC%B4-%C2%B7-%E5%B0%8F%E6%8F%92%E4%BB%B6/ibefaeehajgcpooopoegkifhgecigeeg">壹伴 · 小插件</a></td><td>公众号功能加强工具</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/%E8%B4%AD%E7%89%A9%E5%85%9A%E8%87%AA%E5%8A%A8%E6%AF%94%E4%BB%B7%E5%B7%A5%E5%85%B7/jgphnjokjhjlcnnajmfjlacjnjkhleah">购物党自动比价工具</a></td><td>自动查询历史价格</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/earth-view-from-google-ea/bhloflhklmhfpedakmangadcdofhnnoh">Earth View from Google Earth</a></td><td>新标签页主题</td><td>否</td></tr><tr><td><a href="http://chrome.google.com/webstore/detail/dream-afar-new-tab/mnamhmcgcfflfjafflanbhbfffpmkmmm">Dream Afar New Tab</a></td><td>新标签页主题</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/markdown-new-tab/demppioeofcekpjcnlkmdjbabifjnokj">Markdown New Tab</a></td><td>新标签页主题</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca">Momentum</a></td><td>新标签页主题</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/google-arts-culture/akimgimeeoiognljlfchpbkpfbmeapkh">Google Arts &amp; Culture</a></td><td>新标签页主题</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb">Web Server for Chrome</a> (Application)</td><td>本地文件 HTTP 服务器</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/marxico/kidnkfckhbdkfgbicccmdggmpgogehop">Marxico</a> (Application)</td><td>Markdown 编辑器</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/chromeadb/fhdoijgfljahinnpbolfdimpcfoicmnm">ChromeADB</a> (Application)</td><td>ADB GUI 工具</td><td>否</td></tr><tr><td><a href="https://chrome.google.com/webstore/detail/biodigital-human/meefjekipolcgabfgaclcpdkbghhmoah">BioDigital Human</a> (Application)</td><td>3D 人体结构浏览器</td><td>否</td></tr></tbody></table><h4 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h4><p>这里介绍一下部分插件的使用。</p><h5 id="Bypass-Paywalls"><a href="#Bypass-Paywalls" class="headerlink" title="Bypass Paywalls"></a>Bypass Paywalls</h5><p>用于绕过付费墙的限制。由于版权问题，只能通过 <a href="https://github.com/iamadamdev/bypass-paywalls-chrome/releases">github</a> 下载。</p><h5 id="Color-by-Fardos-Color-Picker"><a href="#Color-by-Fardos-Color-Picker" class="headerlink" title="Color by Fardos - Color Picker"></a>Color by Fardos - Color Picker</h5><p>用于网页取色。可以在 <a href="chrome://extensions/shortcuts">shortcuts</a> 中设置快捷键：</p><ul><li>Pick colors from site: <kbd>shift</kbd> + <kbd>option</kbd> + <kbd>C</kbd></li></ul><h5 id="QR-Code-Generator"><a href="#QR-Code-Generator" class="headerlink" title="QR Code Generator"></a>QR Code Generator</h5><p>用于生成当前网站或者任意内容的二维码。可以在 <a href="chrome://extensions/shortcuts">shortcuts</a> 中设置快捷键：</p><ul><li>Activate the extension: <kbd>option</kbd> + <kbd>Q</kbd></li></ul><h5 id="Octo-Mate"><a href="#Octo-Mate" class="headerlink" title="Octo Mate"></a><a href="https://github.com/camsong/chrome-github-mate">Octo Mate</a></h5><p>用于提升 GitHub 的使用体验，比如添加侧边栏等。该插件目前无法通过 Chrome Web Store 下载，我上传了一个<a href="https://drive.google.com/file/d/1zq-OFZZNDXv-YrcrsGb3gBc8IaT1lZaa/view">备份</a>，可以通过 Developer mode 加载该插件。</p><h5 id="Reader-View"><a href="#Reader-View" class="headerlink" title="Reader View"></a>Reader View</h5><p>进入阅读模式，使网站内容更易阅读。可以在 <a href="chrome://extensions/shortcuts">shortcuts</a> 中设置快捷键：</p><ul><li>Toggle the Reader View: <kbd>shift</kbd> + <kbd>option</kbd> + <kbd>R</kbd></li></ul><h5 id="Rediretor"><a href="#Rediretor" class="headerlink" title="Rediretor"></a>Rediretor</h5><p>用于重定向网页，通过正则匹配网址。比如，将移动端 Wikipedia 网址替换为桌面端网址：</p><ul><li>^https://(.<em>?).m.wikipedia.org/(.</em>) -&gt; https://$1.wikipedia.org/$2</li></ul><h5 id="Super-Simple-Highlighter"><a href="#Super-Simple-Highlighter" class="headerlink" title="Super Simple Highlighter"></a>Super Simple Highlighter</h5><p>用于高亮网页内容。可以在 <a href="chrome://extensions/shortcuts">shortcuts</a> 中设置快捷键：</p><ul><li>highlight 1: <kbd>shift</kbd> + <kbd>option</kbd> + <kbd>A</kbd></li></ul><h5 id="uBlacklist"><a href="#uBlacklist" class="headerlink" title="uBlacklist"></a>uBlacklist</h5><p>用于屏蔽网站。可以添加订阅 <a href="https://github.com/cobaltdisco/Google-Chinese-Results-Blocklist/">Google-Chinese-Results-Blocklist</a> 的屏蔽规则：</p><ul><li>精确匹配：<a href="https://raw.githubusercontent.com/cobaltdisco/Google-Chinese-Results-Blocklist/master/uBlacklist_subscription.txt">https://raw.githubusercontent.com/cobaltdisco/Google-Chinese-Results-Blocklist/master/uBlacklist_subscription.txt</a></li><li>模糊匹配：<a href="https://raw.githubusercontent.com/cobaltdisco/Google-Chinese-Results-Blocklist/master/uBlacklist_match_patterns.txt">https://raw.githubusercontent.com/cobaltdisco/Google-Chinese-Results-Blocklist/master/uBlacklist_match_patterns.txt</a></li></ul><h4 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h4><p>一些实验性的功能 (Eexperimental Features) 默认可能是关闭的，只能通过 <a href="chrome://flags/">chrome://flags/</a> 手动打开。下面是我使用最多的一些实验性功能，有些功能未来可能会在更新后默认开启，而有些可能会被移除。请谨慎使用，切勿依赖。</p><h5 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h5><table><thead><tr><th>名称</th><th>功能介绍</th></tr></thead><tbody><tr><td>Parallel downloading</td><td>多线程下载，可提升多个文件时的下载速度</td></tr><tr><td>Enables the remote copy feature to receive messages</td><td>剪贴板共享发送端</td></tr><tr><td>Enable shared clipboard feature signals to be handled</td><td>剪贴板共享接收端</td></tr><tr><td>Experimental QUIC protocol</td><td>使用基于 UDP 的 QUIC 协议，可以提升连接速度、降低延迟，看视频时体验更流畅</td></tr><tr><td>Back-forward cache</td><td>前进后退缓存，提升页面加载速度</td></tr></tbody></table><div style="text-align: right"><sup>注：最新版本的 Chrome 中已去除剪贴板分享，如需继续使用需要安装老版本，比如 v90.0.4430，并且禁用更新</sup></div><h5 id="桌面端"><a href="#桌面端" class="headerlink" title="桌面端"></a>桌面端</h5><table><thead><tr><th>名称</th><th>功能介绍</th></tr></thead><tbody><tr><td>Tab Groups</td><td>标签页分组控制</td></tr><tr><td>Global Media Controls</td><td>媒体播放全局控制，可以在工具栏中统一控制标签页中音乐或视频的播放</td></tr></tbody></table><h5 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h5><table><thead><tr><th>名称</th><th>功能介绍</th></tr></thead><tbody><tr><td>Chrome Duet</td><td>操作栏位于底部，在大屏手机上特别实用（重启浏览器后如果没效果可以尝试从最近列表中杀死应用再重新进入）</td></tr><tr><td>Tab Grid Layout</td><td>标签页网格排列</td></tr><tr><td>Share Usage Stats with Digital Wellbeing</td><td>分享网页使用数据给 Digital Wellbeing，并且可以限制网页使用时长</td></tr></tbody></table><p>另外，通过 <a href="chrome://extensions/shortcuts">chrome://extensions/shortcuts</a> 给一些常用的扩展设置快捷键也能带来不少便利，但是小心不要和 vimium 的快捷键冲突了。</p><h3 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h3><ul><li><a href="https://www.jetbrains.com/products.html">JetBrains</a>: <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> / <a href="https://www.jetbrains.com/pycharm/">PyCharm</a></li><li><a href="https://code.visualstudio.com/">Visual Code Studio</a></li><li><a href="https://www.sublimetext.com/">Sublime Text</a></li><li><a href="https://www.getpostman.com/">Postman</a> &amp; <a href="https://postwoman.io/">Postwomen</a></li><li><a href="https://github.com/jhen0409/react-native-debugger">React Native Debugger</a></li><li><a href="https://github.com/infinitered/reactotron">Reactotron</a></li><li><a href="https://fbflipper.com/">Flipper</a></li><li><a href="https://www.mysql.com/products/workbench/">MySQL Workbench</a></li><li><a href="https://www.sqlitepro.com/">SQLPro for SQLite</a></li><li><a href="https://www.sourcetreeapp.com/">SourceTree</a></li><li><a href="https://www.charlesproxy.com/">Charles</a></li><li><a href="http://staruml.io/">StarUML</a></li><li><a href="https://www.xmind.net/zen/">XMind ZEN</a></li></ul><h4 id="Android-Studio-Plugin"><a href="#Android-Studio-Plugin" class="headerlink" title="Android Studio Plugin"></a><a href="https://developer.android.com/studio">Android Studio</a> Plugin</h4><ul><li>.ignore</li><li>Add to gitignore</li><li><a href="https://github.com/winterDroid/android-drawable-importer-intellij-plugin">Android Drawable Importer</a></li><li><a href="https://github.com/mcharmas/android-parcelable-intellij-plugin">Android Parcelable code generator</a></li><li>CodeGlance</li><li>Codota</li><li>Exynap</li><li>Flutter<ul><li>Dart</li><li>Flutter Enhancement Suite</li><li>Flutter Snippets (Lemon)</li><li>FlutterAssetAutoCompletion</li><li><a href="https://plugins.jetbrains.com/plugin/12562-jsontodart-json-to-dart-">JsonToDart</a></li><li><a href="https://github.com/YangLang116/iFlutter">iFlutter</a></li></ul></li><li>IdeaVim</li><li><a href="https://github.com/wuseal/JsonToKotlinClass">JSON To Kotlin Class</a></li><li><a href="https://github.com/shuzijun/leetcode-editor">Leetcode Editor</a></li><li><a href="https://github.com/KikiManjaro/MarioProgressBar">Mario Progress Bar</a></li><li><a href="https://github.com/sburlyaev/IDEA-Native-Terminal-Plugin">Native Terminal</a></li><li><a href="https://github.com/izhangzhihao/intellij-rainbow-brackets">Rainbow Brackets</a></li><li>GenerateSerialVersionUID</li><li>Genymotion</li><li><a href="https://github.com/Madrapps/eventbus-plugin">GreenRobot Eventbus</a></li><li>Key Promoter X</li></ul><h4 id="Visual-Studio-Code-Plugins"><a href="#Visual-Studio-Code-Plugins" class="headerlink" title="Visual Studio Code Plugins"></a><a href="https://code.visualstudio.com/">Visual Studio Code</a> Plugins</h4><h5 id="General"><a href="#General" class="headerlink" title="General"></a>General</h5><ul><li>Code Runner</li><li>Git History</li><li>GitLens</li><li>IntelliCode</li><li>IntelliJ IDEA Keybindings</li><li>Rainbow Brackets</li><li>SVG</li><li>TODO Highlight</li></ul><h5 id="Front-End"><a href="#Front-End" class="headerlink" title="Front End"></a>Front End</h5><ul><li>Auto Complete Tag = Auto Close Tag + Auto Rename Tag</li><li>Auto Import - ES6, TS, JSX, TSX</li><li>ESLint</li><li>Path Intellisense</li></ul><h5 id="Back-End"><a href="#Back-End" class="headerlink" title="Back End"></a>Back End</h5><ul><li>Extension Pack for Java</li><li>Java Language Support</li><li>Gradle for Java</li></ul><h5 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h5><ul><li>Flutter &amp; Dart Utilities</li><li>Json to Dart Model</li></ul><h5 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h5><ul><li>React-Native/React/Redux snippets for es6/es7</li><li>Reactjs code snippets</li></ul><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><ul><li>Python Extension Pack</li><li>Python Indent</li><li>Python Path</li></ul><h3 id="终端工具"><a href="#终端工具" class="headerlink" title="终端工具"></a>终端工具</h3><ul><li><a href="https://www.vim.org/">Vim</a></li><li><a href="https://brew.sh/">brew</a></li><li><a href="https://www.gnu.org/software/sed/manual/sed.html">sed</a> (GNU) - 文件操作</li><li><a href="https://github.com/Canop/broot">broot</a> - 文件目录浏览及搜索</li><li><a href="https://github.com/chubin/cheat.sh">cheat.sh</a> - 命令查询</li><li><a href="https://github.com/piuccio/cowsay">cowsay</a> - 公牛说，终端输出文字</li><li><a href="https://github.com/so-fancy/diff-so-fancy">diff-so-fancy</a> - 升级版 diff</li><li><a href="https://github.com/cesarferreira/dryrun">dryrun</a> (gem) - 快速运行 Android 项目</li><li><a href="https://github.com/timvisee/ffsend">ffsend</a> - 上传文件并生成下载连接</li><li><a href="https://github.com/nvbn/thefuck">fuck</a> - 命令纠错</li><li><a href="https://github.com/skylot/jadx">jadx</a> - 应用反编译</li><li><a href="https://github.com/bwasti/jott">jott</a> - 文字分享，支持 Web 端</li><li><a href="https://github.com/mas-cli/mas">mas</a> - 命令行安装 Mac App Store 应用</li><li><a href="https://www.npmjs.com/package/n">n</a> (npm) - node 版本管理</li><li><a href="https://github.com/TejasQ/add-gitignore">npx add-gitignore</a> - 添加 <code>.gitignore</code> 文件</li><li><a href="https://github.com/o2sh/onefetch">onefetch</a> - 获取 git 仓库信息</li><li><a href="https://github.com/sindresorhus/one-thing">one-thing</a> - <a href="https://sindresorhus.com/one-thing">One Thing</a> 的命令行控制器</li><li><a href="https://github.com/jgm/pandoc">pandoc</a> - 文件格式转换</li><li><a href="https://github.com/elsesiy/qrgo">qrgo</a> - 二维码生成</li><li><a href="https://github.com/ranger/ranger">ranger</a> - 终端文件管理器</li><li><a href="https://github.com/Genymobile/scrcpy">scrcpy</a> - Android 投屏</li><li><a href="https://github.com/KittyKatt/screenFetch">screenfetch</a> - 获取系统信息</li><li><a href="https://github.com/sivel/speedtest-cli">speedtest-cli</a> - 网速测试</li><li><a href="https://github.com/splash-cli/splash-cli">splash</a> - 设置随机桌面背景</li><li><a href="https://github.com/Haixiang6123/wtf-cli">wtf</a> (npm) - 查看缩写含义</li><li><a href="https://github.com/mptre/yank">yank</a> - 分割输出及选择性复制</li><li><a href="https://github.com/ytdl-org/youtube-dl">youtube-dl</a> - YouTube 视频下载</li></ul><h4 id="Oh-My-Zsh-常用插件"><a href="#Oh-My-Zsh-常用插件" class="headerlink" title="Oh My Zsh - 常用插件"></a><a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a> - 常用<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins">插件</a></h4><ul><li>adb</li><li><a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/autojump">autojump</a> - 需要先 <code>brew install autojump</code> 然后在 <code>.zshrc</code> 中开启</li><li>copyfile</li><li>copypath</li><li>fancy-ctrl-z</li><li>flutter</li><li>git</li><li><a href="https://github.com/paulirish/git-open#oh-my-zsh">git-open</a></li><li>gradle</li><li>macos</li><li>dirhistory</li><li><a href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md#oh-my-zsh">ash-autosuggestions</a></li><li><a href="https://github.com/marlonrichert/zsh-hist">zsh-hist</a> - 编辑 zsh 历史命令</li><li><a href="https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md#oh-my-zsh">zsh-syntax-highlighting</a></li></ul><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="基础工具-1"><a href="#基础工具-1" class="headerlink" title="基础工具"></a>基础工具</h3><table><thead><tr><th>名称</th><th>功能</th><th>是否全平台支持</th><th>是否开源</th></tr></thead><tbody><tr><td><a href="http://en.ejie.me/">Clover v3.2</a></td><td>Chrome 风格的文件浏览器</td><td>否</td><td>否</td></tr><tr><td><a href="http://qttabbar.wikidot.com/">QTTabBar</a></td><td>文件浏览器多页签和文件预览</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.rainmeter.net/">Rainmeter</a></td><td>桌面美化</td><td>否</td><td><a href="https://docs.rainmeter.net/developers/">Rainmeter Developers</a></td></tr><tr><td><a href="https://www.listary.com/">Listary</a></td><td>文件搜索</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.faststone.org/FSCaptureDetail.htm">FastStone Capture</a></td><td>截屏工具</td><td>否</td><td>否</td></tr><tr><td><a href="https://entropy6.com/xmeters/">XMeters</a></td><td>状态栏插件</td><td>否</td><td>否</td></tr><tr><td><a href="https://geekuninstaller.com/">Geek Uninstaller</a></td><td>软件卸载</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.ccleaner.com/">CClearner</a></td><td>磁盘清理</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.chuyu.me/">Dism++</a></td><td>系统清理</td><td>否</td><td><a href="https://github.com/Chuyu-Team">Chuyu Team</a></td></tr><tr><td><a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html">VMware Workstation Pro</a></td><td>虚拟机</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.win-rar.com/start.html">Win RAR</a></td><td>文件压缩/解压</td><td>否</td><td>否</td></tr><tr><td><a href="https://ditto-cp.sourceforge.io/">Ditto</a></td><td>剪贴板管理</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.fadetop.com/">FadeTop</a></td><td>休息提醒</td><td>否</td><td>否</td></tr><tr><td><a href="https://airdroid.com/">Airdroid</a></td><td>文件传送等</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.foxitsoftware.com/pdf-reader/">Foxit Reader</a></td><td>PDF 浏览器</td><td>全平台支持</td><td>否</td></tr><tr><td><a href="https://www.google.com/earth/versions/#earth-pro">Google Earth</a></td><td>谷歌地球</td><td>全平台支持</td><td>否</td></tr><tr><td><a href="http://www.worldwidetelescope.org/">WorldWide Telescope</a></td><td>太阳系以及其它星系探索</td><td>否</td><td><a href="https://github.com/WorldWideTelescope">WorldWide Telescope</a></td></tr><tr><td><a href="http://spaceengine.org/">SpaceEngine</a></td><td>宇宙模拟器（宇宙沙盒）</td><td>否</td><td>否</td></tr><tr><td><a href="https://store.steampowered.com/">Steam</a></td><td>游戏收集工具</td><td>桌面端</td><td>否</td></tr><tr><td><a href="http://www.eagleget.com/">EagleGet</a></td><td>下载工具</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.internetdownloadmanager.com/">Internet Download Manager</a> (IDM)</td><td>下载工具</td><td>否</td><td>否</td></tr><tr><td><a href="https://evernote.com/">Evernote</a></td><td>云笔记</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.voidtools.com/">Everything</a></td><td>文件搜索</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.cpuid.com/softwares/cpu-z.html">CPU-Z</a></td><td>统计系统硬件信息</td><td><a href="https://www.cpuid.com/softwares/cpu-z.html">Windows</a> / <a href="https://www.cpuid.com/softwares/cpu-z-android.html">Android</a></td><td>否</td></tr><tr><td><a href="https://www.cpuid.com/softwares/hwmonitor.html">HWMonitor</a></td><td>系统硬件运行状态</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.alex-is.de/PHP/fusion/news_cats.php?cat_id=2">AS SSD Benchmark</a></td><td>SSD 测速</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.hdtune.com/">HDTune</a></td><td>硬盘检测工具</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.wagnardsoft.com/">Display Driver Uninstaller</a></td><td>卸载显卡驱动</td><td>否</td><td>否</td></tr><tr><td><a href="http://www.dependencywalker.com/">Dependency Walker</a></td><td>查看模块依赖</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.nirsoft.net/utils/hash_my_files.html">HashMyFile</a></td><td>MD5/SHA1 生成工具</td><td>否</td><td>否</td></tr><tr><td><a href="http://www.bisystemslab.com/">Hronos</a></td><td>软件使用时间统计</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.pendrivelinux.com/universal-usb-installer-easy-as-1-2-3/">Universal USB Installer</a></td><td>创建 Linux USB 启动盘</td><td>否</td><td>源码见官网</td></tr><tr><td><a href="https://notepad-plus-plus.org/">Notepad++</a></td><td>文本编辑器</td><td>否</td><td><a href="https://github.com/notepad-plus-plus/notepad-plus-plus">notepad-plus-plus</a></td></tr><tr><td><a href="https://potplayer.daum.net/">PotPlayer</a></td><td>视频播放器</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.stremio.com/">Stremio</a></td><td>视频聚合播放器</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.proxifier.com/">Proxifier</a></td><td>自定义代理规则</td><td>桌面端</td><td>否</td></tr><tr><td><a href="https://www.torproject.org/download/">Tor Browser</a></td><td>保护个人隐私的浏览器</td><td>全平台支持</td><td>否</td></tr><tr><td><a href="https://music.163.com/">网易云音乐</a></td><td>音乐播放器</td><td>除 Linux 之外</td><td>否</td></tr><tr><td><a href="https://shurufa.baidu.com/">百度输入法</a></td><td>中文输入法</td><td>除 Linux 之外</td><td>否</td></tr><tr><td><a href="https://cidian.youdao.com/index.html">有道词典</a></td><td>词典</td><td>全平台支持</td><td>否</td></tr><tr><td><a href="https://clipber.com/">快贴</a></td><td>云剪贴板</td><td>全平台支持</td><td>否</td></tr><tr><td><a href="https://www.xunlei.com/">迅雷</a></td><td>下载器</td><td>桌面端</td><td>否</td></tr><tr><td><a href="http://www.pcgeshi.com/">格式工厂</a></td><td>文件格式转换、合并等</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.disktool.cn/backup/easy-backup.html">轻松备份</a></td><td>系统备份</td><td>否</td><td>否</td></tr><tr><td><a href="http://www.aiqisoft.com/lrc.html">艾奇 LRC 歌词制作器</a></td><td>歌词编辑器</td><td>否</td><td>否</td></tr></tbody></table><h3 id="开发者工具-1"><a href="#开发者工具-1" class="headerlink" title="开发者工具"></a>开发者工具</h3><table><thead><tr><th>名称</th><th>功能</th><th>是否全平台支持</th><th>是否开源</th></tr></thead><tbody><tr><td><a href="https://balsamiq.com/wireframes/desktop/">Balsamiq Mockups</a></td><td>App 原型制作工具</td><td>桌面端</td><td>否</td></tr><tr><td><a href="https://dbeaver.io/">DBeaver</a></td><td>MySQL 客户端</td><td>桌面端</td><td><a href="https://github.com/dbeaver/dbeaver"> dbeaver</a></td></tr><tr><td><a href="https://sqlitebrowser.org/">DB Browser for SQLite</a></td><td>SQLite 客户端</td><td>桌面端</td><td><a href="https://github.com/sqlitebrowser/sqlitebrowser">sqlitebrowser</a></td></tr><tr><td><a href="https://robomongo.org/">Robo 3T</a></td><td>Mongo DB 客户端</td><td>桌面端</td><td>否</td></tr><tr><td><a href="https://www.telerik.com/fiddler">Fiddler</a></td><td>网络调试工具</td><td>否</td><td>否</td></tr><tr><td><a href="https://www.putty.org/">Putty</a></td><td>SSH 客户端</td><td>否</td><td><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">源码下载</a></td></tr><tr><td><a href="https://winscp.net/eng/index.php">WinSCP</a></td><td>FTP 客户端</td><td>否</td><td>否</td></tr><tr><td><a href="https://hyper.is/">Hyper</a></td><td>命令行终端</td><td>桌面端</td><td><a href="https://github.com/zeit/hyper">hyper</a></td></tr><tr><td><a href="https://github.com/nushell/nushell">nushell</a></td><td>命令行终端</td><td>桌面端</td><td><a href="https://github.com/nushell/nushell">nushell</a></td></tr><tr><td><a href="https://m2team.github.io/NSudo/">NSudo</a></td><td>提升权限</td><td>否</td><td><a href="https://github.com/M2Team/NSudo">NSudo</a></td></tr></tbody></table><h3 id="终端工具-1"><a href="#终端工具-1" class="headerlink" title="终端工具"></a>终端工具</h3><ul><li><a href="https://github.com/microsoft/terminal">terminal</a> - 微软开源的新 Windows 终端</li><li><a href="https://www.cygwin.com/">Cygwin</a> - 集成了 Linux 上常用的命令（都 202x 年了，不再推荐使用了）</li><li><a href="https://github.com/lukesampson/scoop">scoop</a> - 包管理器</li><li><a href="https://chocolatey.org/">Chocolatey</a> - 另一个包管理器</li></ul><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>移动端的应用比桌面端多太多了，所以我只挑了部分我比较喜欢的应用，大部分都能在 Play Store 上找到，有些应用名字可能与其它应用重复，为了防止混淆我标出了链接。</p><h3 id="阅读类"><a href="#阅读类" class="headerlink" title="阅读类"></a>阅读类</h3><ul><li>Quora</li><li>wikiHow</li><li><a href="https://play.google.com/store/apps/details?id=com.leavjenn.hews">Hews</a></li><li><a href="http://wufazhuce.com/">一个</a></li><li>湾区日报</li><li>微信读书</li></ul><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li><a href="https://apkpure.com/wechat/com.tencent.mm/variant/7.0.12-APK">WeChat v7.0.12</a> - 在这之后的版本无法关闭 X5 内核😂</li><li>Google Chrome v79.0.3945.136 - 为了使用 Duet 模式，而版本 v84.0 之后已经移除 Duet 模式了😂</li><li><a href="https://apkpure.com/wordup-vocabulary/co.wordupapp.app/variant/2.7.0-APK">WordUp v2.7.0</a> - 新版本无法跳过广告，必须看够 5 秒才能继续复习下一个单词😂</li><li>Digital Wellbeing - 记录屏幕使用时间</li><li>Bluecoins - 记账工具，支持备份到 Dropbox</li><li>Merriam-Webster Dictionary &amp; Thesaurus - 英英词典</li><li>AnkiDroid - 生词卡片</li><li>ColorfulClouds Lite - 彩云天气，支持实时地区天气刷新</li><li>AirBattery - 查看 AirPods 电量</li><li>Google Photos - Android 上最好用的图片管理工具</li><li>Google Lens - 图像、文字识别</li><li>Google Tasks - GTD，记愿望清单</li><li>Keep Notes - 便签+随手记，简单好用</li><li>WaterMinder - 提醒自己喝水</li><li>Ten Percent - 练习冥想</li><li>Calmaria - 随时随地练习呼吸、提升集中注意力的能力</li><li><a href="https://play.google.com/store/apps/details?id=com.pomodrone.app">Pomodoro Timer</a> - 极简番茄钟 App</li><li>换算一下 - 各种单位的换算</li><li>锤子便签 - 文字转图片</li><li>Root Explorer - 文件浏览器</li><li>Office - Word/Excel/PDF 等合而为一</li><li><a href="https://play.google.com/store/apps/details?id=com.appxy.tinyscanner&hl=en_US">Tiny Scanner</a> - 照片扫描成文件工具</li><li>Barcode Scanner - 二维码扫描</li><li><a href="https://play.google.com/store/apps/details?id=com.google.tango.measure">Measure</a> - AR 尺子</li><li><a href="http://play.google.com/store/apps/details?id=com.eyewind.phototext">PhotoText</a> - 给照片添加文字、相框等</li><li>Just a Line - 利用 AR 在拍照时添加涂改线条等</li><li>Pixolor - 屏幕取色</li><li><a href="https://play.google.com/store/apps/details?id=net.androgames.compass&hl=en_US">Compass</a> - 指南针</li><li>Touch Protector - 防止屏幕误触</li><li>RnIntentClean - 过滤掉不需要的应用 Intent（长按、分享、浏览等）</li><li><a href="https://play.google.com/store/apps/details?id=decemberpei.gmail.adskipper">AdSkipper</a> - 跳过应用开屏页广告</li><li>Airfoil Satellite - Airfoil 接收端和远程控制端</li><li>TagInfo &amp; TagWriter - 恩智浦 NFC 信息读取和写入工具</li><li>Fake GPS - GPS 模拟位置</li><li>Greenify - 管理后台应用</li><li>Nevolution - 通知栏增强工具</li><li>fooView - 悬浮工具栏+手势控制（慎用，有隐私泄露风险）</li><li>BifrostV - 同时支持 VMess 和 SS 的客户端</li><li><a href="https://github.com/Mygod/VPNHotspot">VPN Hotspot</a> - 通过热点共享手机端 VPN 给其它设备使用</li><li>Magisk - Magsik Manager（推荐插件：<a href="https://github.com/eritpchy/FingerprintPay">Riru - 指纹支付 - 微信</a>）</li><li>QR Code Generator</li><li>Pixel Icon Pack</li></ul><h3 id="音视频类"><a href="#音视频类" class="headerlink" title="音视频类"></a>音视频类</h3><ul><li>Spotify - 曲库比较全</li><li>豆瓣FM - 私人电台推荐的歌很合我口味</li><li><a href="https://apkpure.com/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/com.netease.cloudmusic/download">网易云音乐 v4.3.1</a> - Play Store 下架前的最后一个版本，永不升级的应用之一</li><li><a href="https://play.google.com/store/apps/details?id=com.google.android.apps.podcasts&hl=en_US">Google Podcasts</a> - 目前用得最多的播客应用</li><li>Radio Garden - 可以收听世界各地的电台节目</li><li>doubleTwtist - 本地音乐播放器，极客专用</li><li><a href="https://play.google.com/store/apps/details?id=org.videolan.vlc&hl=en_US">VLC</a> - 本地视频播放器</li><li>TED - 用于看最新的 TED 视频</li></ul><h3 id="游戏类"><a href="#游戏类" class="headerlink" title="游戏类"></a>游戏类</h3><ul><li>Call of Duty - 刚出的时候追过两个 Season，还不错，没玩过的推荐尝试下</li><li>Asphalt 9 - 最爱的竞速类手游 No.1</li><li>Asphalt Xtreme  - 最爱的竞速类手游 No.2</li><li><a href="https://play.google.com/store/apps/details?id=com.netease.eve.en&hl=en_US">EVE Echoes</a> - 社交聊天软件搬到手机端啦~</li><li>Chilly Snow - 简单但却考验耐心</li><li>Avicii | Gravity HD - 音乐类手游</li><li><a href="https://langrensha.163.com/wanfa/guize/index.html">狼人杀</a> - 玩了一年依旧玩不转，需要你学会猜测他人的心理，适合练习逻辑推理和临场表达能力</li><li>Toontastic - 用于陪学龄前小朋友学讲故事的工具</li></ul><h3 id="程序员专用"><a href="#程序员专用" class="headerlink" title="程序员专用"></a>程序员专用</h3><h4 id="学习资讯类"><a href="#学习资讯类" class="headerlink" title="学习资讯类"></a>学习资讯类</h4><ul><li><a href="https://github.com/k0shk0sh/FastHub">Fasthub</a></li><li>Guide To Linux</li><li>Vim Quick Reference</li><li>ECMA Script</li><li>Vue.js Documentation</li><li>Flutter UI Challenges</li><li>Flutter Explorer</li><li>Flutter Gallery</li><li>React Native Exploerer with code</li></ul><h4 id="工具类-1"><a href="#工具类-1" class="headerlink" title="工具类"></a>工具类</h4><ul><li>Shortcut Maker - 创建应用启动器，查看应用的 Activity</li><li>Current Activity - 查看当前显示的 Activity 名</li><li>Display Info - 屏幕基本信息</li><li>Device Info HW - 查看手机硬件信息</li><li><a href="https://github.com/tytydraco/LADB">LADB</a> - 本地 adb shell</li><li><a href="https://github.com/majido/clipper">Clipper</a> - 通过 adb 和系统剪贴板进行交互，比如获取和设置剪贴板内容</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://github.com/kickstarter/android-oss">Kickstarter</a> - 寻找创意、灵感</li><li><a href="https://play.google.com/store/apps/details?id=com.google.vr.expeditions&hl=en_US">Expeditions</a> - AR &amp; VR</li><li>Daydream - VR（需要手机支持）</li><li>Slowly - 和世界各地的人做笔友</li><li>ASL Signs - 学习美式手语</li></ul><hr><p>更多开源软件可以看我整理的个人 Star 的项目：<a href="https://github.com/aJIEw/GithubStars#software">GithubStars#software</a></p><p>欢迎补充！(٭°̧̧̧ω°̧̧̧٭)</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Tools </tag>
            
            <tag> Softwares </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发艺术探索学习笔记（六）</title>
      <link href="/notes-on-android-art-part-6/"/>
      <url>/notes-on-android-art-part-6/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2020-01-07/android-logo.jpg"></p><blockquote><p>  结合 <a href="https://developer.android.com/guide">官方文档</a> 阅读《Android 开发艺术探索》时所做的学习笔记。本篇记录第 13~15 章。</p></blockquote><h2 id="综合技术"><a href="#综合技术" class="headerlink" title="综合技术"></a>综合技术</h2><h3 id="使用-UncaughtExceptionHandler-收集崩溃信息"><a href="#使用-UncaughtExceptionHandler-收集崩溃信息" class="headerlink" title="使用 UncaughtExceptionHandler 收集崩溃信息"></a>使用 UncaughtExceptionHandler 收集崩溃信息</h3><p>当应用崩溃的时候会弹出一个『App has stopped』的弹窗，同时我们的应用也会被杀死。我们可以通过替代系统默认的 UncaughtExceptionHandler 来改变这种行为，也可以对崩溃信息进行收集。</p><p>UncaughtExceptionHandler 是 Thread 中的一个静态接口，当抛出未被捕获的异常时会回调这个接口中的方法，我们只要实现其中的 <code>uncaughtException(Thread t, Throwable e)</code> 方法，然后再用它替代默认的 handler 就可以了。如下：</p><span id="more"></span><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CrashHandler</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> context: Context) : Thread.UncaughtExceptionHandler &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> debug = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mDefaultCrashHandler: Thread.UncaughtExceptionHandler<br>            = Thread.getDefaultUncaughtExceptionHandler()<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        Thread.setDefaultUncaughtExceptionHandler(<span class="hljs-keyword">this</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">uncaughtException</span><span class="hljs-params">(t: <span class="hljs-type">Thread</span>?, ex: <span class="hljs-type">Throwable</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (!handleException(ex)) &#123;<br>            <span class="hljs-comment">// 由系统处理</span><br>            mDefaultCrashHandler.uncaughtException(t, ex)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>)<br>            &#125; <span class="hljs-keyword">catch</span> (e: InterruptedException) &#123;<br>                e.printStackTrace()<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (!debug) &#123;<br><span class="hljs-comment">//                val intent = Intent(context, MainActivity::class.java)</span><br><span class="hljs-comment">//                val mgr = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager</span><br><span class="hljs-comment">//                val pendingIntent = PendingIntent.getActivity(context,</span><br><span class="hljs-comment">//                        0, intent, PendingIntent.FLAG_ONE_SHOT)</span><br><span class="hljs-comment">//                mgr[AlarmManager.RTC, System.currentTimeMillis() + 100] = pendingIntent</span><br><br>                <span class="hljs-comment">// 使用 killProcess() 在某些情况下会使应用重启</span><br>                Process.killProcess(Process.myPid())<br><span class="hljs-comment">//                exitProcess(1) // 效果与上面相同</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleException</span><span class="hljs-params">(ex: <span class="hljs-type">Throwable</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">if</span> (ex == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br><br>        <span class="hljs-comment">// 展示 Toast 提醒</span><br>        <span class="hljs-keyword">object</span> : HandlerThread(<span class="hljs-string">&quot;ShowToast&quot;</span>) &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLooperPrepared</span><span class="hljs-params">()</span></span> &#123;<br>                Toast.makeText(context,<br>                        <span class="hljs-string">&quot;很抱歉，程序出现异常，即将退出。&quot;</span>,<br>                        Toast.LENGTH_LONG).show()<br>            &#125;<br>        &#125;.start()<br><br>        <span class="hljs-comment">/* 保存出错日志、用户机型、操作记录等信息 */</span><br>        dumpExceptionToSDCard(ex)<br><br>        <span class="hljs-comment">/* 上传服务器 */</span><br>        uploadExceptionToServer()<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dumpExceptionToSDCard</span><span class="hljs-params">(ex: <span class="hljs-type">Throwable</span>?)</span></span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">uploadExceptionToServer</span><span class="hljs-params">()</span></span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，我们也可以利用它自定义发生崩溃时的 UI 显示。比如这个三方库：<a href="https://github.com/Ereza/CustomActivityOnCrash">CustomActivityOnCrash</a>，可以看到该库在 <a href="https://github.com/Ereza/CustomActivityOnCrash/blob/master/library/src/main/java/cat/ereza/customactivityoncrash/CustomActivityOnCrash.java#L106">install()</a> 方法中创建了一个 Thread.UncaughtExceptionHandler，并在其中启动默认的或者开发者自定义的 crash activity。</p><h3 id="使用-multidex-解决方法数越界"><a href="#使用-multidex-解决方法数越界" class="headerlink" title="使用 multidex 解决方法数越界"></a>使用 multidex 解决方法数越界</h3><p>65536 应该是每个 Android 开发都熟悉的数字，因为单个 dex 文件所能包含的最大方法数为 65536。官方的解决方案是：添加 multidex 支持。</p><p>关于如何配置见：<a href="https://developer.android.com/studio/build/multidex#mdex-gradle">Configure your app for multidex</a></p><p>关于 multidex 的缺点见：<a href="https://developer.android.com/studio/build/multidex#limitations">Limitations of the multidex support library</a></p><p>好消息是 Android 5.0 以上默认就开启了 multidex，所以随着时间的推移，也许以后就不需要担心这个问题了。</p><h3 id="Android-的动态加载技术"><a href="#Android-的动态加载技术" class="headerlink" title="Android 的动态加载技术"></a>Android 的动态加载技术</h3><p>随着项目越来越庞大，动态加载技术（插件化技术）也越来越频繁地出现在我们的视线中，比如 <a href="https://github.com/didi/VirtualAPK">VirtualAPK</a> 和 <a href="https://github.com/alibaba/atlas">atlas</a> 等库，插件化技术的使用也越来越简便，我们可以通过插件化减少内存和 CPU 的占用，另外，它的热插拔效果在某些业务场景下也算是比较实用。尽管目前来看，插件化不再像过去两年那么受到追捧了，但是其中的技术依旧值得我们研究。</p><p>插件化 App 分为宿主 App 和插件，一般将插件打包处理成 apk（也可以是 dex）。另外还需要用到一个代理 Activity，用于启动插件中的 Activity。一个插件化方案的实现至少要解决三个问题：资源访问、Activity 生命周期的管理、插件 ClassLoader 的管理。</p><ol><li> 资源访问</li></ol><p>主要利用 AssetManager 中的 addAssetPath 方法，加载指定位置的 apk 即我们的插件。这是一个 hidden 方法，所以我们需要通过反射来调用。</p><p>具体见：<a href="https://github.com/singwhatiwanna/dynamic-load-apk/blob/bbd3bfa84c3a26cc89615a7539aef3ac4e9491e5/DynamicLoadApk/lib/src/com/ryg/dynamicload/internal/DLPluginManager.java#L171">DLPluginManager#createAssetManager</a></p><ol start="2"><li> Activity 生命周期的管理</li></ol><p>一般通过将 Activity 的生命周期方法提取出来作为接口，然后再在代理 Activity 方法中调用对应的周期方法。相比使用反射，这种方法较为简单，节省性能开销。</p><p>具体见：<a href="https://github.com/singwhatiwanna/dynamic-load-apk/blob/master/DynamicLoadApk/lib/src/com/ryg/dynamicload/DLProxyActivity.java">DLProxyActivity.java</a></p><ol start="3"><li> 插件 ClassLoader 的管理</li></ol><p>我们需要对插件的 DexClassLoader 进行管理，从而避免多个 ClassLoader 加载同一个类发生类型转换错误。比如，我们可以将多个 ClassLoader 用 HashMap 保存并管理。</p><p>具体见：<a href="https://github.com/singwhatiwanna/dynamic-load-apk/blob/master/DynamicLoadApk/lib/src/com/ryg/dynamicload/internal/DLPluginManager.java">DLPluginManager.java</a></p><h3 id="反编译入门"><a href="#反编译入门" class="headerlink" title="反编译入门"></a>反编译入门</h3><p>这里部分主要是介绍工具，而工具很容易过时 (<a href="https://github.com/iBotPeaches/Apktool">Apktool</a>, <a href="https://github.com/pxb1988/dex2jar">dex2jar</a>, <a href="http://java-decompiler.github.io/">JD-GUI</a>)，关于这些旧工具的使用方法推荐看看郭霖的文章：</p><ul><li>  <a href="https://blog.csdn.net/guolin_blog/article/details/49738023">Android 安全攻防战，反编译与混淆技术完全解析（上）</a></li><li>  <a href="http://blog.csdn.net/guolin_blog/article/details/50451259">Android 安全攻防战，反编译与混淆技术完全解析（下）</a></li></ul><p>下面介绍下目前我觉得更好用的反编译工具吧。</p><ol><li> <strong><a href="https://github.com/skylot/jadx">jadx</a></strong></li></ol><p>支持命令行和 GUI 的 dex 和 apk 反编译工具。</p><p>使用介绍可以看这篇文章：<a href="https://segmentfault.com/a/1190000012180752">Android 反编译利器，jadx 的高级技巧</a></p><ol start="2"><li> <strong><a href="https://www.pnfsoftware.com/">JEB Decompiler</a></strong></li></ol><p>功能强大的支持查看 Smali 代码的 Dalvik 反编译工具，逆向必备。</p><p>使用介绍：<a href="http://www.droidsec.cn/tag/jeb/">Android 反编绎工具JEB简介及下载</a></p><ol start="3"><li> <strong><a href="https://github.com/vaibhavpandeyvpz/apkstudio">apkstudio</a></strong></li></ol><p>基于 QT 的反编译工具，功能和 jadx 差不多。</p><h2 id="JNI-和-NDK-编程"><a href="#JNI-和-NDK-编程" class="headerlink" title="JNI 和 NDK 编程"></a>JNI 和 NDK 编程</h2><p>JNI 即 Java Native Interface，提供了一种直接和 native 代码（C、C++）进行交互的方式。NDK 是 Android SDK 的一部分，它是提供了一系列工具帮助我们管理 native 代码，以及访问系统底层的能力。我们可以利用 NDK 把 native 代码编译成本地 so 库，然后再通过 JNI 去调用它们。</p><h3 id="JNI-开发流程"><a href="#JNI-开发流程" class="headerlink" title="JNI 开发流程"></a>JNI 开发流程</h3><ol><li> 在 Java 类中声明 native 方法</li></ol><p>除了声明方法之外，一般在静态代码块中使用 <a href="https://developer.android.com/reference/java/lang/System.html#loadLibrary(java.lang.String)"><code>System.loadLibrary</code></a> 加载 so 库，也可以使用 <a href="https://github.com/KeepSafe/ReLinker">ReLinker</a>。</p><p>详情见：<a href="https://developer.android.com/training/articles/perf-jni#native-libraries">Native libraries</a></p><ol start="2"><li> 编译 Java 文件类，再将 class 文件导出 JNI 头文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">javac java/file/path/JniClass.java<br>javah java.file.path.JniClass<br></code></pre></td></tr></table></figure><p>之后生成一个头文件 java_file_path_JniClass.h，其中包含我们定义的 native 方法声明，其方法名遵循格式如 Java_PackageName_ClassName_MethodName。</p><ol start="3"><li> 实现 JNI 方法</li></ol><p>我们需要将头文件复制到 jni 目录下，然后创建 .cpp 和 .c 文件并在其中实现 JNI 方法。</p><ol start="4"><li> 编译 so 库并在 Java 中使用</li></ol><p>我们可以使用 gcc 进行编译生成 so 库，然后再使用 java 命令进行调用。</p><h4 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h4><ul><li>  <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html">Java Native Interface Specification</a></li></ul><h3 id="NDK-开发流程"><a href="#NDK-开发流程" class="headerlink" title="NDK 开发流程"></a>NDK 开发流程</h3><p>使用 NDK 具有以下好处：</p><ul><li>  提高代码安全性，因为 so 库反编译更困难。</li><li>  可以使用已有的 C/C++ 开源库，比如 FFmpeg。</li><li>  便于平台间的移植，比如 Dropbox 移动应用早期就是主要使用 C/C++ 来实现平台间代码共享的，不过由于维护成本较高后来被放弃了。其博客文章：<a href="https://blogs.dropbox.com/tech/2019/08/the-not-so-hidden-cost-of-sharing-code-between-ios-and-android/">The (not so) hidden cost of sharing code between iOS and Android</a></li><li>  提高应用程序在某些场景下的执行效率，常见的比如 3D 图形、音视频等。</li></ul><p>使用 NDK 所需的工具有：</p><ul><li>  NDK：基本工具集</li><li>  CMake：配合 gradle 使用，用于构建 native 代码库，一些老项目可能还在使用 ndk-build (.mk)</li><li>  LLDB：用于 debug native 代码</li></ul><p>关于使用方式的介绍：<a href="https://developer.android.com/ndk/guides/concepts#hiw">How it Works?</a>，这里的例子还是使用 ndk-build 的，推荐使用 <a href="https://developer.android.com/ndk/guides/cmake">CMake</a> 进行构建。</p><p>Sample 见：<a href="https://github.com/android/ndk-samples">ndk-sample</a></p><h3 id="JNI-的数据类型和描述符"><a href="#JNI-的数据类型和描述符" class="headerlink" title="JNI 的数据类型和描述符"></a>JNI 的数据类型和描述符</h3><h4 id="JNI-基本数据类型与-Java-对应关系"><a href="#JNI-基本数据类型与-Java-对应关系" class="headerlink" title="JNI 基本数据类型与 Java 对应关系"></a>JNI 基本数据类型与 Java 对应关系</h4><table><thead><tr><th>Java Type</th><th>Native Type</th><th>Description</th></tr></thead><tbody><tr><td>boolean</td><td>jboolean</td><td>unsigned 8 bits</td></tr><tr><td>byte</td><td>jbyte</td><td>signed 8 bits</td></tr><tr><td>char</td><td>jchar</td><td>unsigned 16 bits</td></tr><tr><td>short</td><td>jshort</td><td>signed 16 bits</td></tr><tr><td>int</td><td>jint</td><td>signed 32 bits</td></tr><tr><td>long</td><td>jlong</td><td>signed 64 bits</td></tr><tr><td>float</td><td>jfloat</td><td>32 bits</td></tr><tr><td>double</td><td>jdouble</td><td>64 bits</td></tr><tr><td>void</td><td>void</td><td>N/A</td></tr></tbody></table><h4 id="JNI-引用类型"><a href="#JNI-引用类型" class="headerlink" title="JNI 引用类型"></a>JNI 引用类型</h4><ul><li>jobject<ul><li>  <code>jclass</code> (<code>java.lang.Class</code> objects)</li><li>  <code>jstring</code> (<code>java.lang.String</code> objects)</li><li><code>jarray</code> (arrays)<ul><li><code>jobjectArray</code> (object arrays)</li><li><code>jbooleanArray</code> (<code>boolean</code> arrays)</li><li><code>jbyteArray</code> (<code>byte</code> arrays)</li><li><code>jcharArray</code> (<code>char</code> arrays)</li><li><code>jshortArray</code> (<code>short</code> arrays)</li><li><code>jintArray</code> (<code>int</code> arrays)</li><li><code>jlongArray</code> (<code>long</code> arrays)</li><li><code>jfloatArray</code> (<code>float</code> arrays)</li><li><code>jdoubleArray</code> (<code>double</code> arrays)</li></ul></li><li>  <code>jthrowable</code> (<code>java.lang.Throwable</code> objects)</li></ul></li></ul><h4 id="类型签名"><a href="#类型签名" class="headerlink" title="类型签名"></a>类型签名</h4><table><thead><tr><th>Type Signature</th><th>Java Type</th></tr></thead><tbody><tr><td>Z</td><td>boolean</td></tr><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>S</td><td>short</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>F</td><td>float</td></tr><tr><td>D</td><td>double</td></tr><tr><td>L fully-qualified-class ; (注意『;』是必需的)</td><td>fully-qualified-class</td></tr><tr><td>[ type</td><td>type[]</td></tr><tr><td>( arg-types ) return-type</td><td>method type</td></tr></tbody></table><p>比如一个 Java 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">f</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, String s, <span class="hljs-keyword">int</span>[] arr)</span></span>;<br></code></pre></td></tr></table></figure><p>其类型签名为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">(ILjava<span class="hljs-regexp">/lang/</span>String;[I)J<br></code></pre></td></tr></table></figure><p>参见：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/types.html">JNI Types and Data Structures</a></p><h3 id="JNI-调用-Java-方法的流程"><a href="#JNI-调用-Java-方法的流程" class="headerlink" title="JNI 调用 Java 方法的流程"></a>JNI 调用 Java 方法的流程</h3><p>简单来说，对于静态方法，首先通过类名找到类 (<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#FindClass">FindClass</a>)，然后再通过方法名找到方法 ID (<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#GetStaticMethodID">GetStaticMethodID</a>)，最后构建参数并对方法进行调用。如果是非静态方法，则需要先创建对象，然后再通过对象获取方法 ID (<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#GetMethodID">GetMethodID</a>)，两者流程类似。</p><h4 id="推荐阅读-1"><a href="#推荐阅读-1" class="headerlink" title="推荐阅读"></a>推荐阅读</h4><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/types.html">JNI Functions</a>（JNI 和 NDK 接触不多，以后使用到再慢慢研究）</p><h2 id="Android-性能优化"><a href="#Android-性能优化" class="headerlink" title="Android 性能优化"></a>Android 性能优化</h2><h3 id="Android-性能优化方法"><a href="#Android-性能优化方法" class="headerlink" title="Android 性能优化方法"></a>Android 性能优化方法</h3><h4 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h4><p>布局的层级越复杂，Android 所需要的绘制时间就越长。优化布局首先我们要删除布局中无用的控件和嵌套，一般 lint 都会有提醒，但是某些情况下可能 lint 识别不了，就需要我们在开发过程中注意了。可以使用 <a href="https://developer.android.com/studio/profile/hierarchy-viewer.html">Hierarchy Viewer</a> 来对布局进行<a href="https://developer.android.com/training/improving-layouts/optimizing-layout">检测和优化</a>。另外，善用 <a href="https://developer.android.com/training/improving-layouts/reusing-layouts">include, merge</a> 和 <a href="https://developer.android.com/training/improving-layouts/loading-ondemand">ViewStub</a>，让布局尽量清晰和易于管理。</p><p>对于简单布局尽量用 FrameLayout 和 LinearLayout，对于需要嵌套的布局，尽量使用单个 RelativeLayout 替代，而对于某些复杂的布局，需要嵌套很多层的那种，考虑是否可以通过使用 <a href="https://developer.android.com/training/constraint-layout">ContraintLayout</a> 来减少嵌套层数。</p><h5 id="推荐阅读：Improving-Layout-Performance"><a href="#推荐阅读：Improving-Layout-Performance" class="headerlink" title="推荐阅读：Improving Layout Performance"></a>推荐阅读：<a href="https://developer.android.com/training/improving-layouts">Improving Layout Performance</a></h5><h4 id="绘制优化"><a href="#绘制优化" class="headerlink" title="绘制优化"></a>绘制优化</h4><p>避免在 <code>onDraw()</code> 方法中执行大量操作，主要表现在两个方面：</p><ol><li> 避免创建局部对象</li></ol><p>因为 <code>onDraw()</code> 可能被频繁调用，意味着临时会创建出大量的局部对象，此时如果内存不足，有可能引发 GC 从而造成界面卡顿。</p><ol start="2"><li> 避免做耗时操作</li></ol><p>同样因为 <code>onDraw()</code> 会被多次调用，如果有耗时操作，则绘制流程变慢从而造成卡顿。View 的绘制帧率应该保持在 60 FPS，意味着每帧耗时要不超过 1000/60=16 毫秒。</p><h5 id="推荐阅读：Slow-rendering"><a href="#推荐阅读：Slow-rendering" class="headerlink" title="推荐阅读：Slow rendering"></a>推荐阅读：<a href="https://developer.android.com/topic/performance/vitals/render">Slow rendering</a></h5><h4 id="内存泄露优化"><a href="#内存泄露优化" class="headerlink" title="内存泄露优化"></a>内存泄露优化</h4><h5 id="内存泄露的场景"><a href="#内存泄露的场景" class="headerlink" title="内存泄露的场景"></a>内存泄露的场景</h5><ol><li> <strong>静态变量导致的内存泄露</strong></li></ol><p>比如静态的 Context 或者 View/Drawable 的引用被其他对象持有，导致 GC 始终无法回收 Activity 或者 Fragment。</p><p><em>解决方案：</em>避免使用静态 Context 或者 View/Drawable 等。</p><ol start="2"><li> <strong>非静态内部类持有 Activity 的引用</strong></li></ol><p><em>解决方案：</em></p><ul><li>  不使用内部类或者使用静态内部类</li><li>  如果必须引用 Context 或者 View，使用 <a href="https://developer.android.com/reference/java/lang/ref/WeakReference">WeakReference</a>，这样垃圾回收器就可以在其不再使用时将其回收</li></ul><ol start="3"><li> <strong>内部类广播创建并注册后没有在 onStop() 中解注册</strong></li></ol><p><em>解决方案：</em>记得在 onStop() 解注册广播。</p><ol start="4"><li> <strong>单例类持有 Activity 后没有及时销毁，导致 Activity 无法被回收</strong></li></ol><p><em>解决方案：</em></p><ul><li>记得在 activity 销毁后同时也销毁单例类中的引用</li><li>不使用 Activity 的 Context 而是使用 ApplicationContext</li></ul><ol start="5"><li> <strong>无限循环的属性动画没有及时停止</strong></li></ol><p><em>解决方案：</em>在 onDestroy() 中及时 cancel 动画。</p><ol start="6"><li> <strong>AsyncTask 的错误使用</strong></li></ol><p>比如直接在 Activity 中使用内部类实现 AsyncTask；在 Activity 销毁后没有及时 cancel AsyncTask；在 AsyncTask 中直接访问持有了 View 的引用。</p><p><em>解决方案：</em></p><ul><li>  使用静态内部类</li><li>  在 onDestroy() 中及时<a href="https://developer.android.com/reference/android/os/AsyncTask#cancelling-a-task">取消 AsyncTask</a></li><li>  使用 WeakReference 来访问 View 的引用</li></ul><ol start="7"><li> <strong>Handler 的错误使用</strong></li></ol><p>与 AsyncTask 类似，我们不能直接创建 handler 然后利用其 postXXX 方法（创建匿名内部类 Runnable），因为 Message 或者 runnable 会持有 handler 的引用。</p><p><em>解决方案：</em>使用静态内部类并且使用 WeakReference</p><ol start="8"><li> <strong>Thread 的错误使用</strong></li></ol><p><em>解决方案：</em>使用静态内部类和弱引用，以及在 onDestroy() 中调用 <code>interrupt()</code> 中止线程。</p><ol start="9"><li> <strong>TimerTask 的错误使用</strong></li></ol><p><em>解决方案：</em>和上面类似，使用静态内部类和弱引用并在 onDestroy() 中 <code>cancel()</code>。</p><h5 id="推荐阅读-2"><a href="#推荐阅读-2" class="headerlink" title="推荐阅读"></a>推荐阅读</h5><ul><li>  <a href="https://developer.android.com/topic/performance/memory">Manage your app’s memory</a></li><li>  <a href="https://developer.android.com/studio/profile/memory-profiler">View the Java heap and memory allocations with Memory Profiler</a></li><li>  <a href="https://android.jlelse.eu/9-ways-to-avoid-memory-leaks-in-android-b6d81648e35e">9 ways to avoid memory leaks in Android</a></li></ul><h4 id="响应速度优化和-ANR-日志分析"><a href="#响应速度优化和-ANR-日志分析" class="headerlink" title="响应速度优化和 ANR 日志分析"></a>响应速度优化和 ANR 日志分析</h4><p>我们应该避免在主线程中做耗时操作，Android 系统如果检测到 Activity 超过 5 秒钟没有响应屏幕触摸事件或者键盘输入，就会报 ANR，另外 BroadcastReceiver 如果 10 秒钟之内还没执行完操作也会报 ANR。</p><p>发生 ANR 后，我们可以从 /data/anr/ 目录导出日志文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">adb root<br>adb shell ls <span class="hljs-regexp">/data/</span>anr<br>adb pull <span class="hljs-regexp">/data/</span>anr/&lt;filename&gt;<br></code></pre></td></tr></table></figure><p>老系统用的文件名可能是 /data/anr/traces.txt，新系统 (8.0 以上) 可能用的多个 /data/anr/anr_{date_time_id} 文件。</p><p>我们可以根据时间找到需要的文件，打开搜索 main，找到发生 ANR 的方法调用信息，然后利用这些信息分析造成 ANR 的原因。</p><h5 id="推荐阅读：ANRs"><a href="#推荐阅读：ANRs" class="headerlink" title="推荐阅读：ANRs"></a>推荐阅读：<a href="https://developer.android.com/topic/performance/vitals/anr">ANRs</a></h5><h4 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h4><p>采用线程池代替直接创建线程，从而更好地重用线程以及减少线程频繁创建和销毁带来的性能开销，根据不同场景使用合适的线程池从而避免出现线程阻塞的出现。</p><h5 id="推荐阅读-3"><a href="#推荐阅读-3" class="headerlink" title="推荐阅读"></a>推荐阅读</h5><ul><li>  <a href="https://developer.android.com/guide/components/processes-and-threads">Processes and threads overview</a></li><li>  <a href="https://developer.android.com/topic/performance/threads">Better performance through threading</a></li></ul><h4 id="其它性能优化建议"><a href="#其它性能优化建议" class="headerlink" title="其它性能优化建议"></a>其它性能优化建议</h4><ul><li>  避免在 Activity 或者 Fragment 中创建过多的对象</li><li>  使用 Android 提供的一些数据结构，比如 <a href="https://developer.android.com/reference/android/util/SparseArray">SparseArray</a> 和 <a href="https://developer.android.com/reference/android/util/Pair">Pair</a> 等，它们拥有更好的性能</li><li>  适当采用<a href="https://developer.android.com/reference/java/lang/ref/SoftReference">软引用</a>和<a href="https://developer.android.com/reference/java/lang/ref/WeakReference">弱引用</a></li><li>  如果必须使用内部类，尽量使用静态内部类，可以避免我们犯错而导致的内存泄露</li><li>  使用内存缓存和磁盘缓存</li><li>  不要过多使用枚举类，因为它比 int 类更占内存</li></ul><h5 id="推荐阅读：Performance-tips"><a href="#推荐阅读：Performance-tips" class="headerlink" title="推荐阅读：Performance tips"></a>推荐阅读：<a href="https://developer.android.com/training/articles/perf-tips">Performance tips</a></h5><h5 id="推荐视频：Android-Performance-Patterns"><a href="#推荐视频：Android-Performance-Patterns" class="headerlink" title="推荐视频：Android Performance Patterns"></a>推荐视频：<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android Performance Patterns</a></h5><h3 id="内存泄露分析工具"><a href="#内存泄露分析工具" class="headerlink" title="内存泄露分析工具"></a>内存泄露分析工具</h3><p>这部分是工具推荐，同样会因为时间推移而有更好的工具出现，所以就跳过不看了。目前我们有更好的工具可以使用，比如 <a href="https://github.com/square/leakcanary">LeakCanary</a> 和 <a href="https://developer.android.com/studio/profile/memory-profiler">Memory Profiler</a>。</p><h3 id="提高程序的可维护性"><a href="#提高程序的可维护性" class="headerlink" title="提高程序的可维护性"></a>提高程序的可维护性</h3><p>我们在软件开发过程中，功能开发可能只占很小一部分，大部分的时间都花在了维护上，所以代码的可维护性就显得特别重要了。可维护性体现在两个方面：可读性和可扩展性。想要让代码可读性好就需要我们遵循良好的代码风格以及养成良好的编码习惯。</p><ul><li>  <a href="https://github.com/Blankj/AndroidStandardDevelop">Android 开发规范</a></li><li>  <a href="https://github.com/ribot/android-guidelines/blob/master/project_and_code_guidelines.md">Android Guidelines</a></li></ul><p>除此之外，要注意一些细节，比如：</p><ul><li>  命名简单易懂，不要用复杂的单词</li><li>  注意一行代码的长度，以及代码的排列和对齐方式</li><li>  适当使用 region 合并代码组</li><li>  规范注释，不写无用的注释</li><li>  减少复制粘贴，如果复制两次以上，就可以考虑提取成公共的函数（重构的时候）</li></ul><p>能否写出可扩展性强的代码与开发者的经验有关，一般来说，需要灵活使用<a href="https://github.com/youlookwhat/DesignPattern">设计模式</a>，懂得<a href="https://book.douban.com/subject/4262627/">重构</a>，另外还需要对业务有较好的理解，从而能够预判各种可能的变化。这是一个长期积累的过程。</p><hr><h2 id="系列小结"><a href="#系列小结" class="headerlink" title="系列小结"></a>系列小结</h2><p>都说《Android 开发艺术探索》是迈向中高级开发的第一步，此刻看完这本书，心里觉得，其实要学的东西还有很多呐。尤其是对照着本书看官方文档的时候，现在的 Android 官方文档比之前做的好多了，归类更合理，但是内容似乎也变多了（原来的 Training 和 Guide 被合并到了一起），所以以后还是想花点时间把文档完整地看一遍。</p><p>另外，我跳过了第 9 章，四大组件的工作过程，因为这章太重要了，涉及到的知识也太多了，需要你融汇贯通本书中的所有核心知识才能阅读，而且这章大部分内容都是源码解析，最佳的阅读方式是自己对照源码结合本书然后再借助搜索引擎来阅读。以后我会慢慢把自己的阅读过程以及心得总结成博客发在这里。</p><h3 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h3><ul><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-1/">Android 开发艺术探索学习笔记（一）</a> - 第 1 章：生命周期和启动模式</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-2/">Android 开发艺术探索学习笔记（二）</a> - 第 2 章：IPC 机制</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-3/">Android 开发艺术探索学习笔记（三）</a> - 第 3~5 章：View 事件机制等</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-4/">Android 开发艺术探索学习笔记（四）</a> - 第 6, 7, 12 章：Drawable，动画，Bitmap</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-5/">Android 开发艺术探索学习笔记（五）</a> - 第 8, 10, 11 章：Window，线程和线程池，消息机制</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-6/">Android 开发艺术探索学习笔记（六）</a> - 第 13~15 章：综合技术，JNI 和 NDK，性能优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发艺术探索学习笔记（五）</title>
      <link href="/notes-on-android-art-part-5/"/>
      <url>/notes-on-android-art-part-5/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2020-01-04/android-logo.jpg"></p><blockquote><p>  结合 <a href="https://developer.android.com/guide">官方文档</a> 阅读《Android 开发艺术探索》时所做的学习笔记。本篇记录第 8、10、11 章：<strong>Window</strong>、<strong>线程和线程池</strong>、<strong>消息机制</strong> 相关。</p></blockquote><h2 id="理解-Window-和-WindowManager"><a href="#理解-Window-和-WindowManager" class="headerlink" title="理解 Window 和 WindowManager"></a>理解 Window 和 WindowManager</h2><h3 id="Quick-Facts"><a href="#Quick-Facts" class="headerlink" title="Quick Facts"></a><em>Quick Facts</em></h3><ul><li>  Window 是一个抽象类，它的具体实现是 PhoneWindow。</li><li>  我们可以使用 WindowManager 创建一个 Window，WindowManager 是外界访问 Window 的入口。</li><li>  Window 的实现位于系统的 WindowManagerService 中，所以 WindowManager 和 WindowManagerService 的交互是一个 IPC 过程。</li><li>  Android 中所有的 View 都是通过 Window 来呈现的，不管是 Activity、Dialog 还是 Toast，它们的 View 都是附加在 Window 上的，Window 是 View 的直接管理者。点击事件也是通过 Window 传递给 DecorView 再传递给我们的 View，setContentView 本质也是通过 Window 来添加我们的 View 到 DecorView 上。</li></ul><span id="more"></span><h3 id="Window-amp-WindowManager"><a href="#Window-amp-WindowManager" class="headerlink" title="Window &amp; WindowManager"></a>Window &amp; WindowManager</h3><p>通过 WindowManager 添加 Window：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">windowManager.addView(View view, ViewGroup.LayoutParams params)<br></code></pre></td></tr></table></figure><p>这里的 LayoutParams 有两个重要的参数： <code>flags</code> 和 <code>type</code>。</p><p><code>type</code> 表示 Window 的类型，Window 分为三种类型，最基本的是 application window，层级范围是 1~99，表示普通应用的 Window；第二层是 sub-window，子 Window 的层级范围是 1000~1999，必须依附于父 Window 才能存在，比如常见的 Dialog；最后是 system window，层级范围 2000~2999，表示系统级别的 Window，比如 状态栏、导航栏、系统提醒、Toast 等。层级高的 Window 总是会覆盖层级低的。</p><p>如果我们想要显示系统级别弹窗，只要指定 <code>type</code> 为 <code>TYPE_APPLICATION_OVERLAY</code> 就可以了，不过使用系统级别 Window 需要额外申请 <code>android.permission.SYSTEM_ALERT_WINDOW</code> 权限。</p><p><code>flags</code> 表示 Window 的属性，通过组合使用这些属性，我们可以定制 Window 的显示方式。常用的有：</p><ul><li>  <strong>FLAG_NOT_TOUCH_MODAL</strong>，只处理 Window 所在 View 区域内的点击事件，之外的事件会被传递给下一层的 Window。</li><li>  <strong>FLAG_NOT_FOCUSABLE</strong>，表示 Window 不需要获取焦点，也不需要接收输入事件。默认会开启 FLAG_NOT_TOUCH_MODAL。</li><li>  <strong>FLAG_SHOW_WHEN_LOCKED</strong>，显示在锁屏界面之上。</li></ul><p>其他的 <code>flags</code> 见：<a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams">WindowManager.LayoutParams</a></p><p>除了 <code>addView</code> 之外，常用的方法<a href="https://developer.android.com/reference/android/view/ViewManager">还有</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateViewLayout</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeView</span><span class="hljs-params">(View view)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="Window-的内部机制"><a href="#Window-的内部机制" class="headerlink" title="Window 的内部机制"></a>Window 的内部机制</h3><p>Window 是一个抽象的概念，每一个 Window 对应一个 View 和一个 ViewRootImpl，Window 和 View 通过 ViewRootImpl 来建立联系，因此 Window 实际并不存在，它是以 View 的形式存在的。</p><p>WindowManagerImpl 并没有直接实现 Window 的三大操作，而是交给 <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/WindowManagerGlobal.java?q=WindowManagerGlobal">WindowManagerGlobal</a> 处理。</p><h3 id="Window-的创建过程"><a href="#Window-的创建过程" class="headerlink" title="Window 的创建过程"></a>Window 的创建过程</h3><p>前面说到过所有的 View 都是通过 Window 来呈现的，Window 是 View 的直接管理者，例如 Activity、Dialog、Toast 等的 View 都对应着一个 Window，所以理解 Window 的创建过程也就十分重要。</p><p>&lt;待补充&gt;</p><h2 id="Android-的线程和线程池"><a href="#Android-的线程和线程池" class="headerlink" title="Android 的线程和线程池"></a>Android 的线程和线程池</h2><p>Android 中的线程分为主线程和子线程，主线程也叫 UI 线程，主要用于处理用户输入以及界面交互，主线程中不能进行任何耗时操作，比如网络请求等，只能放到子线程中处理，而子线程中也不能进行更新 UI 的操作。</p><p>Android 中可以扮演子线程的角色有很多，比如 AynscTask 和 IntentService，它们底层依赖的都是线程或线程池，另外 HandlerThread 也是一种特殊的线程。</p><h3 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h3><p>主线程指当前进程所拥有的线程，Java 中默认情况下一个进程只有一个线程，那就是主线程 (<code>main()</code> 方法所在的线程)，除了主线程之外的其他线程都是子线程，也叫工作线程。我们一般只在工作线程中执行耗时操作。</p><p>Android 沿用了 Java 的线程模型，也分为主线程和子线程，在主线程或者叫 UI 线程中运行四大组件以及处理用户界面的交互，在子线程中执行网络请求、I/O 等耗时操作。</p><h3 id="Android-中的线程形态"><a href="#Android-中的线程形态" class="headerlink" title="Android 中的线程形态"></a>Android 中的线程形态</h3><h4 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h4><p>AsyncTask 是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和结果传递给主线程并更新 UI。从实现上看，AsyncTask 封装了 Thread 和 Handler，<a href="https://developer.android.com/reference/android/os/AsyncTask">Reference</a> 中也指出它不适合执行特别耗时的后台任务（最长不超过几秒钟）。</p><p>使用 AsyncTask 时需要注意以下一些问题：</p><ul><li>  AsyncTask 类必须在主线程中加载，AsyncTask 对象必须在主线程中创建，execute 方法必须在主线程中调用；</li><li>  不能在程序中直接调用 <code>onPreExecute()</code>, <code>onProgressUpdate()</code>, <code>doInBackground()</code>, <code>onPostExecute()</code> 方法；</li><li>  一个 AsyncTask 只能执行一次 <code>execute()</code> 方法；</li><li>  AsyncTask 默认是串行执行的，我们可以使用 AsyncTask 的 <code>executeOnExecutor()</code> 来并行执行；</li><li>  AsyncTask 未来会被弃用，所以不再推荐使用，对于一些简单的后台任务可以使用 <code>java.util.concurrent</code> 包下提供的类替代，例子见：<a href="https://stackoverflow.com/a/58767934/4837812">What are the alternatives?</a></li></ul><p>推荐阅读：<a href="https://developer.android.com/guide/components/processes-and-threads#AsyncTask">Using AsyncTask</a></p><h4 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h4><p><strong><a href="https://developer.android.com/reference/android/os/HandlerThread.html">HandlerThread</a></strong> 顾名思义就是一种可以使用 Handler 的 Thread，它的实现很简单，就是在 <code>run()</code> 方法中通过 <code>Looper.prepare()</code> 创建消息队列，并通过 <code>Looper.loop()</code> 开启消息循环，这样就可以在当前线程中使用 Handler 了。HandlerThread 的具体使用场景是 IntentService。</p><h4 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h4><p>IntentService 是常用的执行后台任务的 Service，一般我们只要继承并实现 <code>onHandleIntent()</code> 方法就可以了。而且 IntentService 会在任务执行完毕后自动停止。</p><p>具体而言，每当我们调用一次 <code>startService()</code> 的时候，<code>onHandleIntent()</code> 都会被调用，只有当所有的任务都结束了，该 IntentService 才会调用 <code>stopSelf()</code> 停止服务。另外，因为它是 Service，所以优先级比一般的子线程高很多。</p><h3 id="Android-中的线程池"><a href="#Android-中的线程池" class="headerlink" title="Android 中的线程池"></a>Android 中的线程池</h3><p>线程池具有以下优点：</p><ul><li>  线程重用，避免线程的频繁创建与销毁带来的额外开销；</li><li>  能有效控制最大并发数，避免大量线程间相互抢占资源带来的阻塞；</li><li>  能对线程进行管理，比如定时执行、指定间隔循环执行等。</li></ul><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><a href="https://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor">ThreadPoolExecutor</a> 实现了 Executor，我们可以通过它来配置和管理线程池（虽然我们一般使用 <a href="https://developer.android.com/reference/java/util/concurrent/Executors.html">Executors</a> 工厂方法来创建）。它的构造方法提供了很多的配置参数以及回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize, <span class="hljs-keyword">int</span> maximumPoolSize, <br>                   <span class="hljs-keyword">long</span> keepAliveTime, TimeUnit unit, <br>                   BlockingQueue&lt;Runnable&gt; workQueue, <br>                   ThreadFactory threadFactory, <br>                   RejectedExecutionHandler handler)<br></code></pre></td></tr></table></figure><ul><li>  corePoolSize: 核心线程数，线程池会自动调整线程数量。例如，当新的任务创建时，线程池中的线程少于核心线程数，那么，即使有线程处于闲置状态，线程池依旧会创建新线程去处理任务；注意这个参数和 maximumPoolSize 的区别，当线程数量达到最大线程数时，后续新任务会被阻塞。</li><li>  keepAliveTime: 非核心线程的闲置时长，超过时长的非核心线程会被回收。我们可以使用 <a href="https://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#allowCoreThreadTimeOut(boolean)"><code>allowCoreThreadTimeOut(true)</code></a> 来回收核心线程。</li><li>  unit: keepAliveTime 的时间参数 <a href="https://developer.android.com/reference/java/util/concurrent/TimeUnit.html">TimeUnit</a>。</li><li>  workQueue: 线程池中的任务队列，即通过 <code>execute()</code> 方法提交的 Runnable 对象，根据情景使用不同类型的 <a href="https://developer.android.com/reference/java/util/concurrent/BlockingQueue.html">BlockingQueue</a>。</li><li>  threadFactory: 为线程池提供新线程，它是一个接口，只需要实现 <code>Thread newThread(Runnable r)</code> 方法。</li><li>  handler: 当线程池无法执行新任务时，ThreadPoolExecutor 会调用此 handler 的 <code>rejectedException()</code> 方法来通知调用者，它有几个可选值：AbortPolicy、CallerRunsPolicy、DiscardPolicy 和 DiscardOldestPolicy，其中，AbortPolicy 是默认值，它会抛出 RejectedExecutionException。</li></ul><h4 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h4><h5 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h5><p>它是一种线程数量固定的线程池，只有<strong>核心</strong>线程，而且核心线程不会被回收，也没有超时机制，任务队列也没有大小限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>使用场景：它适用于需要快速响应请求的任务。</p><h5 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h5><p>它是一种线程数量不定的线程池，只有<strong>非核心</strong>线程，线程数量近乎无限大 (Integer.MAX_VALUE)，意味着不需要任务队列，因为任何新的任务都会立即被处理（要么被闲置线程处理要么会创建新线程处理），并且对于闲置线程有超时机制，时长 60 秒。当所有线程都因为闲置而被停止时，线程池几乎不占用系统资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>使用场景：它适用于执行大量的、耗时较少的任务。</p><h5 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h5><p>它是一种核心线程数量固定而非核心线程数量没有限制的线程池，非核心线程闲置时会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);<br>&#125;<br><br><span class="hljs-function">ScheduledThreadPoolExecutor extends ThreadPoolExecutor</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE,<br>          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<br>          <span class="hljs-keyword">new</span> DelayedWorkQueue());<br>&#125;<br></code></pre></td></tr></table></figure><p>使用场景：它适用于执行定时任务以及具有固定周期的重复性任务。</p><h5 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h5><p>它只有一个核心线程的线程池，它确保所有任务都在同一个线程中按顺序执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>      (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                             <span class="hljs-number">0L</span>,TimeUnit.MILLISECONDS,<br>                             <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><p>使用场景：它适用于任务之间不需要线程同步的任务。</p><h2 id="Android-的消息机制"><a href="#Android-的消息机制" class="headerlink" title="Android 的消息机制"></a>Android 的消息机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Android 消息机制主要指 Handler 及其所依赖的 MessageQueue 和 Looper 的工作过程。前面说过，Android 中不允许在子线程中访问 UI（通过 ViewRootImpl 的 <code>checkThread()</code> 方法），所以我们有时会通过 Handler 更新 UI。</p><p>至于为什么不允许在子线程中访问 UI，主要是因为 UI 控件不是线程安全的，而且也无法为所有 UI 控件加上锁机制，因为加锁后存在两个主要的缺点：1、UI 的访问逻辑会变复杂；2、降低执行效率，容易引起卡顿。</p><h3 id="Android-消息机制的分析"><a href="#Android-消息机制的分析" class="headerlink" title="Android 消息机制的分析"></a>Android 消息机制的分析</h3><p>Handler 的工作流程是这样的：</p><ul><li>  首先，Handler 在创建之后，会利用当前线程的 Looper 来构建内部的消息循环系统（UI 线程即 <em>ActivityThread</em> 在创建时就会初始化 Looper，所以可以直接使用 Handler）。如果当前线程不存在 Looper 则会抛出异常。</li><li>  然后我们可以通过 Handler 的 <code>sendXXX()</code> 方法发送 Message，Message 会被添加到 MessageQueue 中，Looper 会不断从 MessageQueue 中取出 Message 并处理。也可以通过 <code>postXXX()</code> 方法将一个 Runnable 投递到 Looper 中处理（Runnable 会被转换成 Message 中的 callback，然后添加到 MessageQueue 中，过程和 <code>sendXXX()</code> 方法一样）。</li><li>  最终，Message 中的 Runnable 或者 <code>handleMessage()</code> 方法会被调用。</li></ul><p>这里我们可以<strong>从下往上</strong>依次看消息机制中各个组成部分的原理。</p><h4 id="ThreadLocal-的工作原理"><a href="#ThreadLocal-的工作原理" class="headerlink" title="ThreadLocal 的工作原理"></a>ThreadLocal 的工作原理</h4><p><a href="https://developer.android.com/reference/java/lang/ThreadLocal">ThreadLocal</a> 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储之后，只有在指定的线程中才可以获取到存储的数据。也就是说，它可以在多个线程中互不干扰地存储和修改数据。</p><p>简单来说，当我们调用 ThreadLocal 的 set 和 get 方法时，它们所操作的对象都是当前线程的 localValues 对象的 table 数组，因此在不同线程访问同一个 ThreadLocal 的 set 和 get 方法时，它们对 ThreadLocal 所做的读写操作都仅限于各自线程的内部，所以各线程可以互不干扰。</p><p>关于细节请阅读 <a href="https://cs.android.com/android/platform/superproject/+/master:libcore/ojluni/src/main/java/java/lang/ThreadLocal.java?q=threadlocal">ThreadLocal</a> 源码。</p><h4 id="MessageQueue-的工作原理"><a href="#MessageQueue-的工作原理" class="headerlink" title="MessageQueue 的工作原理"></a>MessageQueue 的工作原理</h4><p><a href="https://developer.android.com/reference/android/os/MessageQueue">MessageQueue</a> 主要包含两种操作，插入 (<code>enqueueMessage</code>) 和读取 (<code>next</code>) Message。它虽然叫 Queue，但内部其实是一个单链表的结构，我们知道链表在插入和删除上比较有优势。</p><p>具体实现请看源码：<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/os/MessageQueue.java;bpv=1;bpt=1;l=550">enqueueMessage()</a> 和 <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/os/MessageQueue.java;bpv=1;bpt=1;l=320">next()</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 简化了细节 */</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        Message p = mMessages; <span class="hljs-comment">// Head node</span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) &#123;<br>            msg.next = p;<br>            mMessages = msg;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Message prev;<br>            <span class="hljs-comment">// 插入到尾部节点</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                prev = p;<br>                p = p.next;<br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            msg.next = p;<br>            prev.next = msg;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 简化了细节 */</span><br><span class="hljs-function">Message <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>          Message msg = mMessages; <span class="hljs-comment">// Head node</span><br>          <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;<br>              mMessages = msg.next;<br>              msg.next = <span class="hljs-keyword">null</span>;<br>              <span class="hljs-keyword">return</span> msg;<br>          &#125;<br>          <span class="hljs-comment">// 当调用 quit() 方法 mQuiting 被设为 true 后，next() 方法才会退出</span><br>          <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            dispose();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>          &#125;<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 next() 方法是一个死循环，当有新消息进入的时候，next() 方法会返回该消息并从链表中移除，当没有消息时，会一直阻塞直到收到新消息。</p><h4 id="Looper-的工作原理"><a href="#Looper-的工作原理" class="headerlink" title="Looper 的工作原理"></a>Looper 的工作原理</h4><p><a href="https://developer.android.com/reference/android/os/Looper">Looper</a> 主要用于消息循环，它会不停查看 MessageQueue 中是否有新消息，有则处理，没有则一直阻塞。</p><p>当调用 <code>Looper.prepare()</code> 之后，它内部会创建一个新的 MessageQueue，然后获取当前线程并保存在的 ThreadLocal 中，然后当我们调用 <code>Looper.loop()</code> 方法后，该 Looper 就会开始不停地从 MessageQueue 中读取 Message。它是一个死循环，除非 MessageQueue 的 <code>next()</code> 方法返回 null，否则就不会跳出循环。</p><p>当 MessageQueue 返回了新消息，Looper 就会通过调用 <code>msg.target.dispatchMessage(msg)</code> 处理这条消息。这里的 <code>msg.target</code> 是一个 Handler 对象，所不同的是，这里的 <code>dispatchMessage()</code> 方法是在创建 Handler 所使用的 Looper 中执行的，所以就成功将代码逻辑切换到指定的线程中去执行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">()</span> </span>&#123;<br>    prepare(<span class="hljs-keyword">true</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> quitAllowed)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>    &#125;<br>    sThreadLocal.set(<span class="hljs-keyword">new</span> Looper(quitAllowed));<br>&#125;<br><br><span class="hljs-comment">/* 简化了细节 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Looper me = myLooper();<br>    <span class="hljs-keyword">final</span> MessageQueue queue = me.mQueue;<br>  <br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Message msg = queue.next(); <span class="hljs-comment">// might block</span><br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// No message indicates that the message queue is quitting.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        msg.target.dispatchMessage(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于细节请阅读 <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/os/Looper.java">Looper</a> 源码。</p><p>另外，需要注意的是，Looper 在被创建后，我们应该调用 <code>quit()</code> 或者 <code>quitSafely()</code> 退出，否则，该子线程就会一直处于等待状态。当然也有一些特殊情况，比如如果该线程如果存在期和应用存在期一样，而且也不持有 View 的强引用，那就没必要退出。这种情况下的 Looper 所在的线程一般用作多用途的 HandlerThread，比如用于处理一些需要后台运行的任务。而除此之外的其他情况，如果线程持有 View，那么就应该及时退出关闭 looper，否则会造成内存泄露。详见：<a href="https://stackoverflow.com/a/20134464/4837812">where to quit looper?</a></p><h4 id="Handler-的工作原理"><a href="#Handler-的工作原理" class="headerlink" title="Handler 的工作原理"></a>Handler 的工作原理</h4><p>Handler 的主要职责是发送和接收 Message。消息的发送主要通过一系列 <code>postXXX()</code> 方法或 <code>sendXXX()</code> 方法，最终都是通过 <code>enqueueMessage()</code> 向 MessageQueue 中添加一条消息，最终 Looper 循环到消息后再交由 Handler 的 <code>dispatchMessage()</code> 方法中处理，再在其中调用 Callback 或者我们实现的 <code>handleMessage()</code> 方法。</p><img src="../assets/2020-01-04/handler_workflow.png" width=50%/><p>另外，当我们用默认构造函数创建 Handler 时，它会调用以下构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(Callback callback, <span class="hljs-keyword">boolean</span> async)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    mLooper = Looper.myLooper();<br>    <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>            <span class="hljs-string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()<br>                    + <span class="hljs-string">&quot; that has not called Looper.prepare()&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这就是为什么如果我们没有调用 Looper.prepare() 而直接使用 Handler 会报错了。</p><p>关于细节请阅读 <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/os/Handler.java">Handler</a> 源码。</p><h3 id="主线程的消息循环"><a href="#主线程的消息循环" class="headerlink" title="主线程的消息循环"></a>主线程的消息循环</h3><p>在消息机制的分析一节提到过，Android 的主线程就是 <em>ActivityThread</em>，其入口方法是 <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/ActivityThread.java;l=7350">main()</a> 方法，它会调用 <code>Looper.prepareMainLooper()</code> 将当前线程标记为主线程，并创建 Looper 和 MessageQueue，因此我们在主线程中直接就可以创建 Handler。随后，主线程的 Looper 开始循环了之后，<em>ActivityThread</em> 的内部还维护了一个 Handler 的子类 <strong>H</strong> 用来和 MessageQueue 进行交互，主要用于基本组件的启动和停止等过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ActivityThread.java</span><br><br><span class="hljs-keyword">final</span> H mH = <span class="hljs-keyword">new</span> H();<br><span class="hljs-comment">// ActivityThread 中的 Handler 其实就是由 H 实现的</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Handler sMainThreadHandler;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    Looper.prepareMainLooper();<br>    ActivityThread thread = <span class="hljs-keyword">new</span> ActivityThread();<br>    <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-keyword">null</span>) &#123;<br>        sMainThreadHandler = thread.getHandler();<br>    &#125;<br>    Looper.loop();<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> Handler <span class="hljs-title">getHandler</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mH;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BIND_APPLICATION        = <span class="hljs-number">110</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> EXIT_APPLICATION        = <span class="hljs-number">111</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RECEIVER                = <span class="hljs-number">113</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CREATE_SERVICE          = <span class="hljs-number">114</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SERVICE_ARGS            = <span class="hljs-number">115</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP_SERVICE            = <span class="hljs-number">116</span>;<br>  <br>  <span class="hljs-comment">// ...</span><br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IApplicationThread</span>.<span class="hljs-title">Stub</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其工作过程如下：ActivityThread 通过 ApplicationThread 和 AMS 进行 IPC，AMS 处理完请求后通过回调 ApplicationThread 中的 Binder 方法，然后 ApplicationThread 会通过 <strong>H</strong> 发送消息，<strong>H</strong> 接收到消息后再将返回的数据放到 ActivityThread 中执行后续的操作。</p><hr><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-1/">Android 开发艺术探索学习笔记（一）</a> - 第 1 章：生命周期和启动模式</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-2/">Android 开发艺术探索学习笔记（二）</a> - 第 2 章：IPC 机制</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-3/">Android 开发艺术探索学习笔记（三）</a> - 第 3~5 章：View 事件机制等</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-4/">Android 开发艺术探索学习笔记（四）</a> - 第 6, 7, 12 章：Drawable，动画，Bitmap</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-5/">Android 开发艺术探索学习笔记（五）</a> - 第 8, 10, 11 章：Window，线程和线程池，消息机制</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-6/">Android 开发艺术探索学习笔记（六）</a> - 第 13~15 章：综合技术，JNI 和 NDK，性能优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Am I ready for 2020?</title>
      <link href="/2019/"/>
      <url>/2019/</url>
      
        <content type="html"><![CDATA[<div><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/wccRif2DaGs" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></div><br /><p>最近一段时间在看《Android 开发艺术探索》，但是效率奇低，原本计划一个月之内看完（之前看过前半部分），结果越拖越久，索性趁这段时间好好回顾下过去的这一年。</p><p>说来这应该是我第三次写年终总结了，而今年也已经是我毕业之后的第三个春节了。回想自己这两年多的工作、生活，觉得自己身上似乎发生了不少变化，但又好像什么都没变。可能每个人或多或少都会在某个阶段有这样的想法吧。一方面，环境一直在变，我们被推着不停往前走，新的人新的事总会在我们身上留下点痕迹；另一方面，如果自己稍微懒散、不思进取一点，就会觉得好像一直在原地踏步。</p><p>怎么改变这种状态呢？除了自律，我觉得最重要的一点就是主动改变。第一步先改变自己，从思维（想法、态度、观念、信仰），到行动（不断的自我教育、养成积极的行为习惯等），第二步再慢慢尝试改变环境，这里的改变既可以指用自己的行动去影响周围人，也可以是指更换自己的环境，寻找和你有相似想法的人、圈子。总之，给自己制造一点压力，让自己处于一个需要稍微努力踮着脚才能够到的位置，从而慢慢地扩大舒适圈。</p><p>改变也许很难，但是我从未见谁说过不值得。——《终身成长》</p><span id="more"></span><hr><p>看了<a href="https://ajiew.github.io/2018/">去年</a>写的年终总结，发现新年计划里制定的都是比较 general 的、不怎么具体的目标，所以也没办法衡量自己过去这一年到底过得怎么样，但是单从执行上来看应该还算不错。</p><p>工作上，几个项目基本都进入了稳定期，物流 App 从 8 月开始基本就没更新了，崩溃率目前稳定在 0.1-0.2% 之间，相比之前最高时候的 4% 好了不少，当然主要是重新写了电话录音的功能。收银机目前也比较稳定了，新加的功能一直在小范围内测中，等切换到商米的系统之后可能各方面监控会更容易一些。C 端 ReactNative 的项目发布了 4.0 UI 改版，接下来商城可能还会继续改版吧。国庆回来后还用 RN 开发了一款商家用的 App，切换到 RN 最新版本，一开始着实折腾了不少时间，不过花了两个月时间，功能也基本 OK 了，小程序版本已经发布在用了，App 还没收到需要发布上线的通知。</p><p>其他方面，今年的跑步里程只有 280 多公里，时间主要集中在 4~7 月、 9 月，太热或者太冷就坚持不下去了；另外下半年中秋出国旅游一次；国庆之后开始学习滑板（目前还处于苦练 Ollie 阶段）；3 月份开始基金定投，到目前收益率稳定在 6% 左右。</p><p>不太满意的方面主要是心智、个人情感、家人、社会关系和个人成长。断断续续翻了几本书，但是完整看完的好像没有；依旧单身吃狗粮；没有多花时间陪爸妈；没有积极参加社交活动认识新面孔；学了 Flutter，但是浅尝辄止，原有的技能似乎也开始退化了；另外花了太多时间在娱乐上。</p><p>年初去了西藏，回来后懒散了好长一段时间才调整过来，所以人真的不能安逸下来，不然习惯安逸之后又得花双倍的时间才能把原来养成的好习惯给捡回来。另一方面，上半年工作上的确比较闲，所以也看了不少好电影和一直想看的美剧，现在依旧印象深刻的有：调音师、摔跤吧！爸爸、小偷家族、被嫌弃的松子的一生、老男孩、美国工厂、何以为家、奇迹男孩、骡子、人生七年8、末代皇帝、星运里的错、心竞技、启示、波希米亚狂想曲、寄生虫；美剧：爱，死亡机器人、权游最终季、性爱自修室、了不起的麦瑟尔夫人第三季、曼达洛人，以及最近在看的苍穹浩瀚。</p><p>庆幸现在还能有时间看这么多电影和美剧，以后可能会怀念这些时光吧。不过虽然是娱乐消遣，但我也把它看作是一种增长见识的手段，毕竟一部好电影或者好剧可以带给你一种全新的体验，或者让你了解一段（艺术化的）历史，或者让你看到另一种你没有见识过的生活方式（过去的、现在的甚至是未来的）。</p><p>尽管如此，接下来一年还是要稍微克制下自己看剧、看电影的欲望，毕竟现实和剧本还是有差距的，好故事听得再多但是生活过得一团糟也不合适。多数人的生活是平淡的，这是现实。我们应该追求的，是把平淡生活过得幸福和美好。对我来说，花时间提升自己，继续打磨自己的技能才是现阶段最要紧的事。</p><p>具体而言，主要想给自己定下以下一些目标：</p><ol><li> 继续为 OSS 贡献自己的力量</li></ol><p>除了继续开源自己个人项目的代码之外，多阅读自己常用的项目的源码，在力所能及的范围内，帮助解决一些 issue，修复 bug 等。</p><ol start="2"><li> 继续深耕 Android</li></ol><p>掌握常用的几种架构模式，学习 Android Architecture Component (AAC)，以及花更多的时间阅读源码，包括各种常用的开源库以及 Android 源码，把笔记总结成博客。</p><ol start="3"><li> 克服社交恐惧</li></ol><p>做到可以和任意一个陌生人搭讪并且能聊上天（不怕丢脸和被拒绝、勇气、自信心、知识储备）；多认识新面孔，尤其是多接触异性，克服害羞。</p><ol start="4"><li> 养成一些好习惯</li></ol><p>少看手机，每天的手机使用时间控制在 2 小时之内；每个月阅读 2~3 本书并且写读书笔记；每周锻炼 2 次以上（腹肌撕裂者、跑步，勉强算上滑板吧）；每日冥想，早睡（每天<a href="https://www.youtube.com/watch?v=5MuIMqhT8DM">睡足 8 小时</a>），早起（7 点之前）；每天睡前写下自己当天的一些新想法、灵感等；每天花一点时间学习英语（尽量多看英语资料）。</p><p>除此之外，加上之前立下的 flag，一年的时间内，争取尽量把多完成一些吧。</p><p>生活充满变数，我们无法时刻做好应对一切的准备，再周密的计划也会遇到意外，我们会措手不及，会感到丧气，会受伤、会难过，但是这些经历都是生活的一部分。你永远不知道明天会发生什么，好的或者坏的，但是只要我们不断更新自己，丰富自己的阅历，拥有健康的身体，所有的意外都会是惊喜，成为我们未来的宝贵回忆。</p><p>就像猫鼠游戏的原型人物 Frank Abagnale 分享的<a href="https://www.youtube.com/watch?v=vsMydMDi3rI">他的经历</a>，他只是把自己看作一个曾经犯过错的小孩，然后误打误撞地获得了一次重生的机会，并且又足够幸运地遇到了他的妻子，才能够成为现在的自己。</p><p>拥有健康的身体，照顾好自己的家人，然后再去追求实现自己的价值，这样的人生对我来说就算是一个美满的人生了。（不过自己现在毕竟还年轻，未来能达到什么高度真说不准，没准成了亿万富翁，到时候想法可能就又不一样了呢😂）</p><hr><p>新的一年，可能会迎来一些变化，心里有些害怕。面对未知的时候，害怕是人的本能，我们该做的，是克服自己的恐惧，然后满怀期待地去拥抱不确定。</p><p>毕竟，作为一个乐观主义者，我始终相信<em><strong>未来会更好</strong></em>。</p><p><em>Yes, I’m ready.</em></p><p>　</p><p>链接：</p><ul><li>  <a href="https://www.youtube.com/watch?v=5MuIMqhT8DM">Sleep is your superpower | Matt Walker</a></li><li>  <a href="https://www.youtube.com/watch?v=vsMydMDi3rI">Frank Abagnale: “Catch Me If You Can” | Talks at Google</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
            <tag> Reviews </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发艺术探索学习笔记（四）</title>
      <link href="/notes-on-android-art-part-4/"/>
      <url>/notes-on-android-art-part-4/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2019-12-27/android-logo.jpg"></p><blockquote><p>结合 <a href="https://developer.android.com/guide">官方文档</a> 阅读《Android 开发艺术探索》时所做的学习笔记。本篇记录第 6、7、12 章：<strong>Drawable</strong>、<strong>动画</strong>、<strong>Bitmap</strong> 相关。</p></blockquote><h2 id="Drawable"><a href="#Drawable" class="headerlink" title="Drawable"></a>Drawable</h2><p>Drawable 是一种抽象的概念，表示一种可以在屏幕上进行绘制 (Draw) 的图像，常见的颜色和图片都可以是 Drawable。</p><p>Drawable 一般没有大小的概念，当作为 View 的 background 的时候，它会被拉伸至 View 同等大小。不过它有两个参数，<code>getIntrinsicWidth</code> 和 <code>getIntrinsicHeight</code> 表示内在的宽高，可以理解为默认宽高，比如显示一张图片时，这个值所对应的宽高就是当前图片的宽高，当作为 ColorDrawable 的时候该值则为 -1。</p><span id="more"></span><h3 id="Drawable-的分类"><a href="#Drawable-的分类" class="headerlink" title="Drawable 的分类"></a>Drawable 的分类</h3><p><a href="https://developer.android.com/guide/topics/resources/drawable-resource">Drawable</a> 类型比较多，而且也没必要记住所有属性，需要时查文档就可以了：</p><ul><li>  <a href="https://developer.android.com/guide/topics/resources/drawable-resource#Bitmap">BitmapDrawable</a></li><li>  <a href="https://developer.android.com/guide/topics/resources/drawable-resource#NinePatch">NinePatchDrawable</a></li><li>  <a href="https://developer.android.com/guide/topics/resources/drawable-resource#Shape">ShapeDrawable</a></li><li>  <a href="https://developer.android.com/guide/topics/resources/drawable-resource#LayerList">LayerDrawable</a></li><li>  <a href="https://developer.android.com/guide/topics/resources/drawable-resource#StateList">StateListDrawable</a></li><li>  <a href="https://developer.android.com/guide/topics/resources/drawable-resource#LevelList">LevelListDrawable</a></li><li>  <a href="https://developer.android.com/guide/topics/resources/drawable-resource#Transition">TransitionDrawable</a></li><li>  <a href="https://developer.android.com/guide/topics/resources/drawable-resource#Inset">InsetDrawable</a></li><li>  <a href="https://developer.android.com/guide/topics/resources/drawable-resource#Clip">ClipDrawable</a></li><li>  <a href="https://developer.android.com/guide/topics/resources/drawable-resource#Scale">ScaleDrawable</a></li></ul><h3 id="自定义-Drawable"><a href="#自定义-Drawable" class="headerlink" title="自定义 Drawable"></a>自定义 Drawable</h3><p>只要重写 draw() 方法就可以了，例子见：<a href="https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_6/src/com/ryg/chapter_6/ui/CustomDrawable.java">android-art-res / Chapter_6</a></p><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ul><li>  <a href="https://developer.android.com/guide/topics/graphics/drawables">Drawables</a></li><li>  <a href="https://developer.android.com/guide/topics/graphics/vector-drawable-resources">Vector drawables</a></li><li>  <a href="https://developer.android.com/guide/topics/resources/color-list-resource">Color state list</a></li></ul><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><p><a href="https://developer.android.com/guide/topics/resources/animation-resource">动画</a>可以分为属性动画 (Property Animation) 和 View 动画。View 动画通过对图像做各种变换（平移、旋转、缩放、透明度）从而产生动画效果，而属性动画则通过动态修改对象的属性来达到动画效果。推荐优先使用属性动画。</p><h3 id="View-动画"><a href="#View-动画" class="headerlink" title="View 动画"></a>View 动画</h3><h4 id="Tween-animation"><a href="#Tween-animation" class="headerlink" title="Tween animation"></a>Tween animation</h4><p><a href="https://developer.android.com/guide/topics/resources/animation-resource#Tween">补间动画</a>分为平移动画、缩放动画、旋转动画和透明度动画，它们既可以通过 XML 定义也可以通过代码动态创建。xml 文件一般放在 res/anim 目录下。</p><img src="../assets/2019-12-27/tween-animation.png" width=100%/><h4 id="Frame-Animation"><a href="#Frame-Animation" class="headerlink" title="Frame Animation"></a>Frame Animation</h4><p><a href="https://developer.android.com/guide/topics/resources/animation-resource#Frame">帧动画</a>其实就是一组预先定义好的图片，然后逐帧显示。使用帧动画如果图片过大，可能会导致 OOM，所以需要注意图片尺寸的问题。xml 文件一般放在 res/drawable 目录下。</p><h4 id="特殊的-Tween-Animation"><a href="#特殊的-Tween-Animation" class="headerlink" title="特殊的 Tween Animation"></a>特殊的 Tween Animation</h4><h5 id="LayoutAnimation"><a href="#LayoutAnimation" class="headerlink" title="LayoutAnimation"></a>LayoutAnimation</h5><p>主要用于 ViewGroup，使用后子元素出场时会显示该动画，比如用于 ListView 或者 RecyclerView，为 item 设置进入时的从左往右进入，或者先变大然后恢复的动效。</p><p>扩展阅读：<a href="https://developer.android.com/training/animation/layout">Auto animate layout updates</a></p><h5 id="Activity-切换效果"><a href="#Activity-切换效果" class="headerlink" title="Activity 切换效果"></a>Activity 切换效果</h5><p>我们可以通过在 activity 启动以及结束前使用 <code>overridePendingTransition(enterAnimId, exitAnimId)</code> 或者 <code>ActivityOptions.makeCustomAnimation(context, enterAnimId, exitAnimId)</code> 来指定 Activity 的切换效果。</p><p>另外，Android 5.0 之后还支持共享元素的过渡效果，具体请阅读：<a href="https://developer.android.com/training/transitions/start-activity">Start an activity using an animation</a></p><h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><p><a href="https://developer.android.com/guide/topics/resources/animation-resource#Property">属性动画</a>与 View 动画不同，它对作用对象进行了扩展，因此可以对任何对象做动画，甚至可以没有对象，而且实现的效果也更加丰富多样。</p><h4 id="属性动画的使用"><a href="#属性动画的使用" class="headerlink" title="属性动画的使用"></a>属性动画的使用</h4><p>常用的类有 <a href="https://developer.android.com/reference/android/animation/ValueAnimator.html"><code>ValueAnimator</code></a>，<code>ObjectAnimator</code> 和 <a href="https://developer.android.com/reference/android/animation/ObjectAnimator.html"><code>AnimatorSet</code></a>。其中 <code>ObjectAnimator</code> 继承自 <code>ValueAnimator</code>，<a href="https://developer.android.com/reference/android/animation/AnimatorSet.html"><code>AnimatorSet</code></a> 是一组动画集合。对应的 xml 标签分别是 &lt;objectAnimator&gt; &lt;animator&gt; &lt;set&gt;，xml 文件一般放在 res/animator 目录下。</p><p>不过属性动画使用<a href="https://developer.android.com/guide/topics/graphics/prop-animation#object-animator">代码</a>进行操作更为简便，比如垂直平移一个 View 只要这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ObjectAnimator.ofFloat(view, <span class="hljs-string">&quot;translationY&quot;</span>, <span class="hljs-number">100f</span>).start()<br></code></pre></td></tr></table></figure><h4 id="插值器和估值器"><a href="#插值器和估值器" class="headerlink" title="插值器和估值器"></a>插值器和估值器</h4><p>插值器我理解为动画的变化方式（速率等），而估值器表示某一个时间节点下的变化的值。系统自带的插值器有：<code>TimeInterpolator</code> / <code>LinearInterpolator</code> / <code>AccelerateDecelerateInterpolator</code> 等，如果我们想要自定义动画效果，一般需要实现 <a href="https://developer.android.com/guide/topics/graphics/prop-animation#interpolators">Interpolator</a> 和 <a href="https://developer.android.com/guide/topics/graphics/prop-animation#type-evaluator">TypeEvaluator</a>。</p><h4 id="属性动画的监听器"><a href="#属性动画的监听器" class="headerlink" title="属性动画的监听器"></a>属性动画的监听器</h4><p>我们可以实现对动画播放过程的<a href="https://developer.android.com/guide/topics/graphics/prop-animation#listeners">监听</a>，主要通过 <code>Animator.AnimatorListener</code>，可以监听动画的开始、结束、取消、重新播放。 <code>ValueAnimator.AnimatorUpdateListener</code>，可以监听动画的更新，通过 <a href="https://developer.android.com/reference/android/animation/ValueAnimator.html#getAnimatedValue()">ValueAnimator.getAnimatedValue()</a> 获取变化值，我们还可以利用这个方法自定义出一些特殊效果。</p><h4 id="属性动画的工作原理"><a href="#属性动画的工作原理" class="headerlink" title="属性动画的工作原理"></a>属性动画的工作原理</h4><p>通过获取 View 上的该属性的初始值（如果没有提供初始值则调用属性的 get 方法）和最终值（即我们 set 进去的值，xml 中的 <code>toValue</code>），然后以动画的效果，多次调用其 set 方法，直到达到最终值。源码解析就不贴了。</p><p>对于某些属性，即使提供了 set get 方法，但是对其做属性动画依旧没效果，原因是该属性不会带来 UI 显示上的变化，自然看上去就像没有效果了，比如 TextView 的 setWidth 和 getWidth，这个方法指定的是最大宽度，而不是实际显示的宽度，所以对它做属性动画不会有效果。</p><p>我们可以通过两种方式来改变这种状况，一种是通过包装原始对象，并为其提供 set 和 get 方法。另一种是通过上面提到的 <code>ValueAnimator.AnimtorUpdateListener</code> 加上估值器，手动修改对应的属性来实现效果。例子见：<a href="https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_7/src/com/ryg/chapter_7/DemoActivity_1.java">android-art-res / Chapter_7</a>。推荐使用第一种，因为更容易复用。</p><h4 id="扩展阅读-1"><a href="#扩展阅读-1" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><ul><li>  <a href="https://developer.android.com/training/animation">Animations and transitions</a></li></ul><h2 id="Bitmap-的加载和缓存"><a href="#Bitmap-的加载和缓存" class="headerlink" title="Bitmap 的加载和缓存"></a>Bitmap 的加载和缓存</h2><h3 id="Bitmap-的高效加载"><a href="#Bitmap-的高效加载" class="headerlink" title="Bitmap 的高效加载"></a>Bitmap 的高效加载</h3><p>我们通过 Bitmap 加载图片的时候，一般都需要考虑图片大小的问题，图片越大占用的内存也就越多，一不小心还有可能造成 OOM，所以对于大图来说一般会做缩放后再显示。</p><p>核心思想是，首先通过为 <code>BitmapFactory.Options</code> 的 <code>inJustDecodeBounds</code> 设置 true，对图片进行采样获取到宽高（不会为图片像素点分配内存，因此不会消耗太大），然后再根据实际需要显示的宽高，计算出合理的缩放倍数，然后再对图片进行真正的加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateInSampleSize</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            BitmapFactory.Options options, <span class="hljs-keyword">int</span> reqWidth, <span class="hljs-keyword">int</span> reqHeight)</span> </span>&#123;<br>    <span class="hljs-comment">// Raw height and width of image</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height = options.outHeight;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width = options.outWidth;<br>    <span class="hljs-keyword">int</span> inSampleSize = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> halfHeight = height / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> halfWidth = width / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// Calculate the largest inSampleSize value that is a power of 2 and keeps both</span><br>        <span class="hljs-comment">// height and width larger than the requested height and width.</span><br>        <span class="hljs-keyword">while</span> ((halfHeight / inSampleSize) &gt;= reqHeight<br>                &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) &#123;<br>            inSampleSize *= <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> inSampleSize;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">decodeSampledBitmapFromResource</span><span class="hljs-params">(Resources res, <span class="hljs-keyword">int</span> resId,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">int</span> reqWidth, <span class="hljs-keyword">int</span> reqHeight)</span> </span>&#123;<br><br>    <span class="hljs-comment">// First decode with inJustDecodeBounds=true to check dimensions</span><br>    <span class="hljs-keyword">final</span> BitmapFactory.Options options = <span class="hljs-keyword">new</span> BitmapFactory.Options();<br>    options.inJustDecodeBounds = <span class="hljs-keyword">true</span>;<br>    BitmapFactory.decodeResource(res, resId, options);<br><br>    <span class="hljs-comment">// Calculate inSampleSize</span><br>    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);<br><br>    <span class="hljs-comment">// Decode bitmap with inSampleSize set</span><br>    options.inJustDecodeBounds = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> BitmapFactory.decodeResource(res, resId, options);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>BitmapFactory</code> 除了 <code>decodeResource()</code> 这一从资源中读取 Bitmap 的方式外，还可以使用 <code>decodeFile()</code>、<code>decodeStream()</code>、<code>decodeByteArray()</code> 这几种方式，分别表示从文件、字节流、Byte 数组中读取并加载 Bitmap，这些方法最终调用的都是 native 方法，由 Android 底层实现。</p><h4 id="扩展阅读-2"><a href="#扩展阅读-2" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><ul><li>  <a href="https://developer.android.com/topic/performance/graphics/load-bitmap">Loading Large Bitmaps Efficiently</a></li></ul><h3 id="内存缓存和磁盘缓存"><a href="#内存缓存和磁盘缓存" class="headerlink" title="内存缓存和磁盘缓存"></a>内存缓存和磁盘缓存</h3><p>在 RecyclerView 或者 ViewPager 中加载大量图片时，如果不做特殊处理，由于 View 的复用以及垃圾回收机制的存在，屏幕之外的图片很快会被回收掉，所以为了让页面保持流畅（不出现白屏也不会因为重复加载图片导致卡顿），我们就需要使用缓存来加速图片的恢复加载。</p><h4 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h4><p>通过内存缓存（<a href="https://developer.android.com/reference/android/util/LruCache.html">LruCache</a>），我们可以将 Bitmap 缓存在应用内存中来提升加载速度。<code>LruCache</code> 中使用一个 <code>LinkedHashMap</code> 保存最近引用过的对象，当引用数量超出容量限制的时候就会将<strong>最近最少使用</strong>的对象移除。</p><p>使用 <code>LruCache</code> 缓存图片的时候需要考虑以下问题：</p><ul><li>  图片大小多少，占用多少内存？</li><li>  一屏加载多少图片？有多少是需要预加载的？</li><li>  你的 activity 除了图片之外，其他部分耗内存吗？</li><li>  有哪些图片是频繁访问的？如果有特定图片是频繁访问的，可以选择常驻到内存缓存中。另外，如果有确定的访问频率不一致的图片组，可以考虑使用多个 <code>LruCache</code>。</li><li>  如果是特别大的图片，可以考虑使用多种清晰度的图片，先加载低清晰度图片，然后再使用后台任务加载高清度的图片。</li><li>  如果是本地图片，需要考虑在不同屏幕大小和屏幕密度上设备是否表现一致。</li></ul><p>使用 LruCache 加载 Bitmap 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> LruCache&lt;String, Bitmap&gt; memoryCache;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// Get max available VM memory, exceeding this amount will throw an</span><br>    <span class="hljs-comment">// OutOfMemory exception. Stored in kilobytes as LruCache takes an</span><br>    <span class="hljs-comment">// int in its constructor.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxMemory = (<span class="hljs-keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span>);<br><br>    <span class="hljs-comment">// Use 1/8th of the available memory for this memory cache.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> cacheSize = maxMemory / <span class="hljs-number">8</span>;<br><br>    memoryCache = <span class="hljs-keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sizeOf</span><span class="hljs-params">(String key, Bitmap bitmap)</span> </span>&#123;<br>            <span class="hljs-comment">// The cache size will be measured in kilobytes rather than</span><br>            <span class="hljs-comment">// number of items.</span><br>            <span class="hljs-keyword">return</span> bitmap.getByteCount() / <span class="hljs-number">1024</span>;<br>        &#125;<br>    &#125;;<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBitmapToMemoryCache</span><span class="hljs-params">(String key, Bitmap bitmap)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (getBitmapFromMemCache(key) == <span class="hljs-keyword">null</span>) &#123;<br>        memoryCache.put(key, bitmap);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Bitmap <span class="hljs-title">getBitmapFromMemCache</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> memoryCache.get(key);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BitmapWorkerTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AsyncTask</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">Void</span>, <span class="hljs-title">Bitmap</span>&gt; </span>&#123;<br>    ...<br>    <span class="hljs-comment">// Decode image in background.</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Bitmap <span class="hljs-title">doInBackground</span><span class="hljs-params">(Integer... params)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Bitmap bitmap = decodeSampledBitmapFromResource(<br>                getResources(), params[<span class="hljs-number">0</span>], <span class="hljs-number">100</span>, <span class="hljs-number">100</span>));<br>        addBitmapToMemoryCache(String.valueOf(params[<span class="hljs-number">0</span>]), bitmap);<br>        <span class="hljs-keyword">return</span> bitmap;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>加载 Bitmap 前先判断是否有缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBitmap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resId, ImageView imageView)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> String imageKey = String.valueOf(resId);<br><br>    <span class="hljs-keyword">final</span> Bitmap bitmap = getBitmapFromMemCache(imageKey);<br>    <span class="hljs-keyword">if</span> (bitmap != <span class="hljs-keyword">null</span>) &#123;<br>        mImageView.setImageBitmap(bitmap);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mImageView.setImageResource(R.drawable.image_placeholder);<br>        BitmapWorkerTask task = <span class="hljs-keyword">new</span> BitmapWorkerTask(mImageView);<br>        task.execute(resId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h4><p>内存缓存虽然速度快，但是我们也不能完全只依赖它，因为用户手机可能内存很小，应用随时可能被杀死（用户离开一段时间或者有更高优先级的任务占用了内存等等），当用户重新打开你的页面的时候，又要重新加载图片。</p><p><code>DiskLruCache</code> 可以帮我们把加载过的 Bitmap 持久化到存储空间中从而减少用户重新加载的等待时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> DiskLruCache diskLruCache;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object diskCacheLock = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> diskCacheStarting = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DISK_CACHE_SIZE = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>; <span class="hljs-comment">// 10MB</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DISK_CACHE_SUBDIR = <span class="hljs-string">&quot;thumbnails&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> APP_VERSION = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> VALUE_COUNT = <span class="hljs-number">1</span>;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// Initialize memory cache</span><br>    ...<br>    <span class="hljs-comment">// Initialize disk cache on background thread</span><br>    File cacheDir = getDiskCacheDir(<span class="hljs-keyword">this</span>, DISK_CACHE_SUBDIR);<br>    <span class="hljs-keyword">new</span> InitDiskCacheTask().execute(cacheDir);<br>    ...<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InitDiskCacheTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AsyncTask</span>&lt;<span class="hljs-title">File</span>, <span class="hljs-title">Void</span>, <span class="hljs-title">Void</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Void <span class="hljs-title">doInBackground</span><span class="hljs-params">(File... params)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (diskCacheLock) &#123;<br>            File cacheDir = params[<span class="hljs-number">0</span>];<br>            diskLruCache = DiskLruCache.open(<br>              cacheDir, APP_VERSION, VALUE_COUNT, DISK_CACHE_SIZE);<br>            diskCacheStarting = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Finished initialization</span><br>            diskCacheLock.notifyAll(); <span class="hljs-comment">// Wake any waiting threads</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BitmapWorkerTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AsyncTask</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">Void</span>, <span class="hljs-title">Bitmap</span>&gt; </span>&#123;<br>    ...<br>    <span class="hljs-comment">// Decode image in background.</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Bitmap <span class="hljs-title">doInBackground</span><span class="hljs-params">(Integer... params)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> String imageKey = String.valueOf(params[<span class="hljs-number">0</span>]);<br><br>        <span class="hljs-comment">// Check disk cache in background thread</span><br>        Bitmap bitmap = getBitmapFromDiskCache(imageKey);<br><br>        <span class="hljs-keyword">if</span> (bitmap == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Not found in disk cache</span><br>            <span class="hljs-comment">// Process as normal</span><br>            <span class="hljs-keyword">final</span> Bitmap bitmap = decodeSampledBitmapFromResource(<br>                    getResources(), params[<span class="hljs-number">0</span>], <span class="hljs-number">100</span>, <span class="hljs-number">100</span>));<br>        &#125;<br><br>        <span class="hljs-comment">// Add final bitmap to caches</span><br>        addBitmapToCache(imageKey, bitmap);<br><br>        <span class="hljs-keyword">return</span> bitmap;<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBitmapToCache</span><span class="hljs-params">(String key, Bitmap bitmap)</span> </span>&#123;<br>    <span class="hljs-comment">// Add to memory cache as before</span><br>    <span class="hljs-keyword">if</span> (getBitmapFromMemCache(key) == <span class="hljs-keyword">null</span>) &#123;<br>        memoryCache.put(key, bitmap);<br>    &#125;<br><br>    <span class="hljs-comment">// Also add to disk cache</span><br>    <span class="hljs-keyword">synchronized</span> (diskCacheLock) &#123;<br>        <span class="hljs-keyword">if</span> (diskLruCache != <span class="hljs-keyword">null</span> &amp;&amp; diskLruCache.get(key) == <span class="hljs-keyword">null</span>) &#123;<br>            diskLruCache.put(key, bitmap);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Bitmap <span class="hljs-title">getBitmapFromDiskCache</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (diskCacheLock) &#123;<br>        <span class="hljs-comment">// Wait while disk cache is started from background thread</span><br>        <span class="hljs-keyword">while</span> (diskCacheStarting) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                diskCacheLock.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (diskLruCache != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> diskLruCache.get(key);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-comment">// Creates a unique subdirectory of the designated app cache directory. Tries to use external</span><br><span class="hljs-comment">// but if not mounted, falls back on internal storage.</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> File <span class="hljs-title">getDiskCacheDir</span><span class="hljs-params">(Context context, String uniqueName)</span> </span>&#123;<br>    <span class="hljs-comment">// Check if media is mounted or storage is built-in, if so, try and use external cache dir</span><br>    <span class="hljs-comment">// otherwise use internal cache dir</span><br>    <span class="hljs-keyword">final</span> String cachePath =<br>            Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||<br>                    !isExternalStorageRemovable() ? getExternalCacheDir(context).getPath() :<br>                            context.getCacheDir().getPath();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> File(cachePath + File.separator + uniqueName);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为涉及到文件读写，所以速度肯定要慢一点。而且可以看到，上面 <code>DiskLruCache</code> 是在子线程中创建的，所以当添加或者读取的时候，我们需要使用同步锁。</p><h4 id="扩展阅读-3"><a href="#扩展阅读-3" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><ul><li>  <a href="https://developer.android.com/topic/performance/graphics/cache-bitmap">Caching Bitmaps</a></li><li>  <a href="https://developer.android.com/topic/performance/graphics/manage-memory">Managing Bitmap Memory</a></li></ul><h3 id="ImageLoader-的实现与使用"><a href="#ImageLoader-的实现与使用" class="headerlink" title="ImageLoader 的实现与使用"></a><code>ImageLoader</code> 的实现与使用</h3><h4 id="ImageLoader-的实现"><a href="#ImageLoader-的实现" class="headerlink" title="ImageLoader 的实现"></a><code>ImageLoader</code> 的实现</h4><p>一个图片加载框架一般需要考虑：</p><ul><li>  图片的压缩</li><li>  内存缓存与磁盘缓存</li><li>  同步加载、异步加载</li><li>  通过网络加载</li></ul><p>具体实现见：<a href="https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_12/src/com/ryg/chapter_12/loader/ImageLoader.java">android-art-res / Chapter_12</a></p><h4 id="照片墙效果"><a href="#照片墙效果" class="headerlink" title="照片墙效果"></a>照片墙效果</h4><p><a href="https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_12/src/com/ryg/chapter_12/MainActivity.java">MainActivity.java</a></p><h4 id="优化列表卡顿"><a href="#优化列表卡顿" class="headerlink" title="优化列表卡顿"></a>优化列表卡顿</h4><ol><li><p> 不要在 <code>getView()</code> 方法中做耗时操作。比如加载图片是耗时操作，如果在 <code>getView()</code> 中进行加载，那么一定会导致卡顿，所以一般需要异步加载。</p></li><li><p> 控制异步任务的执行频率。当用户快速滑动列表时会产生大量异步任务，随后通知主线程进行大量的 UI 更新操作，此时很容易造成卡顿。所以我们可以为列表设置 <code>OnScrollListener.onScrollStateChanged</code>，并在其中判断是否滑动，禁止在滑动时加载图片。</p></li><li><p> 开启硬件加速。为 activity 设置 <code>android:hardwareAccelerated=&quot;true&quot;</code>，很多莫名的卡顿问题可能都是因为硬件加速没开。</p></li></ol><hr><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-1/">Android 开发艺术探索学习笔记（一）</a> - 第 1 章：生命周期和启动模式</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-2/">Android 开发艺术探索学习笔记（二）</a> - 第 2 章：IPC 机制</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-3/">Android 开发艺术探索学习笔记（三）</a> - 第 3~5 章：View 事件机制等</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-4/">Android 开发艺术探索学习笔记（四）</a> - 第 6, 7, 12 章：Drawable，动画，Bitmap</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-5/">Android 开发艺术探索学习笔记（五）</a> - 第 8, 10, 11 章：Window，线程和线程池，消息机制</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-6/">Android 开发艺术探索学习笔记（六）</a> - 第 13~15 章：综合技术，JNI 和 NDK，性能优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发艺术探索学习笔记（三）</title>
      <link href="/notes-on-android-art-part-3/"/>
      <url>/notes-on-android-art-part-3/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2019-12-14/android-logo.jpg"></p><blockquote><p>结合 <a href="https://developer.android.com/guide">官方文档</a> 阅读《Android 开发艺术探索》时所做的学习笔记。本篇记录第 3~5 章 <strong>View 相关</strong>。</p></blockquote><h2 id="View-的事件体系"><a href="#View-的事件体系" class="headerlink" title="View 的事件体系"></a>View 的事件体系</h2><h3 id="View-基础知识"><a href="#View-基础知识" class="headerlink" title="View 基础知识"></a>View 基础知识</h3><h4 id="什么是-View？"><a href="#什么是-View？" class="headerlink" title="什么是 View？"></a>什么是 View？</h4><p>View 是界面层控件的抽象，代表了一个控件。与 Web 中的 DOM 数类似，在 Android 中所有视图共同形成了一个 View 的树形结构。</p><span id="more"></span><h4 id="View-的位置参数"><a href="#View-的位置参数" class="headerlink" title="View 的位置参数"></a>View 的位置参数</h4><p>View 的初始位置，相对于父容器的坐标。一图胜千言：</p><img src="../assets/2019-12-14/view-position.png" width=50%/><p>另外还有 translationX 和 translationY，表示 View 在 x 轴或者 y 轴上的偏移量，以及 (x,y) 代表当前坐标，可以根据 translationX + left 以及 translationY + top 计算出来。</p><h4 id="MotionEvent-和-TouchSlop"><a href="#MotionEvent-和-TouchSlop" class="headerlink" title="MotionEvent 和 TouchSlop"></a>MotionEvent 和 TouchSlop</h4><p>常用触摸事件，通常是一个事件序列，比如点击的时候是 DOWN+UP，滑动的时候是 DOWN+MOVE(…多个)+UP：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">MotionEvent.ACTION_DOWN<br>MotionEvent.ACTION_MOVE<br>MotionEvent.ACTION_UP<br></code></pre></td></tr></table></figure><p>系统所能识别的最小滑动距离：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> scaledTouchSlop = ViewConfiguration<br>                        .get(getApplicationContext())<br>                        .getScaledTouchSlop();<br></code></pre></td></tr></table></figure><h4 id="VelocityTracker-amp-GestureDetector-amp-Scroller"><a href="#VelocityTracker-amp-GestureDetector-amp-Scroller" class="headerlink" title="VelocityTracker &amp; GestureDetector &amp; Scroller"></a>VelocityTracker &amp; GestureDetector &amp; Scroller</h4><h5 id="Track-velocity"><a href="#Track-velocity" class="headerlink" title="Track velocity"></a><a href="https://developer.android.com/training/gestures/movement#velocity">Track velocity</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouch</span><span class="hljs-params">(View v, MotionEvent event)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = event.getActionIndex();<br>    <span class="hljs-keyword">int</span> action = event.getActionMasked();<br>    <span class="hljs-keyword">int</span> pointerId = event.getPointerId(index);<br>    <span class="hljs-keyword">switch</span> (action) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:<br>            <span class="hljs-keyword">if</span> (mVelocityTracker == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// Retrieve a new VelocityTracker object to watch the</span><br>                <span class="hljs-comment">// velocity of a motion.</span><br>                mVelocityTracker = VelocityTracker.obtain();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Reset the velocity tracker back to its initial state.</span><br>                mVelocityTracker.clear();<br>            &#125;<br>            <span class="hljs-comment">// Add a user&#x27;s movement to the tracker.</span><br>            mVelocityTracker.addMovement(event);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<br>            mVelocityTracker.addMovement(event);<br>            <span class="hljs-comment">// When you want to determine the velocity, call</span><br>            <span class="hljs-comment">// computeCurrentVelocity(). Then call getXVelocity()</span><br>            <span class="hljs-comment">// and getYVelocity() to retrieve the velocity for each pointer ID.</span><br>            mVelocityTracker.computeCurrentVelocity(<span class="hljs-number">1000</span>);<br>            Log.d(ViewEventActivity.class.getSimpleName(), <span class="hljs-string">&quot;X velocity: &quot;</span> + mVelocityTracker.getXVelocity(pointerId));<br>            Log.d(ViewEventActivity.class.getSimpleName(), <span class="hljs-string">&quot;Y velocity: &quot;</span> + mVelocityTracker.getYVelocity(pointerId));<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:<br>            <span class="hljs-comment">// Return a VelocityTracker object back to be re-used by others.</span><br>            mVelocityTracker.recycle();<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Detect-common-gestures"><a href="#Detect-common-gestures" class="headerlink" title="Detect common gestures"></a><a href="https://developer.android.com/training/gestures/detector">Detect common gestures</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java">GestureDetector.OnGestureListener listener = <span class="hljs-keyword">new</span> GestureDetector.SimpleOnGestureListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onSingleTapUp</span><span class="hljs-params">(MotionEvent e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onSingleTapUp(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLongPress</span><span class="hljs-params">(MotionEvent e)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onLongPress(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onScroll</span><span class="hljs-params">(MotionEvent e1, MotionEvent e2, <span class="hljs-keyword">float</span> distanceX, <span class="hljs-keyword">float</span> distanceY)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onScroll(e1, e2, distanceX, distanceY);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onFling</span><span class="hljs-params">(MotionEvent e1, MotionEvent e2, <span class="hljs-keyword">float</span> velocityX, <span class="hljs-keyword">float</span> velocityY)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onFling(e1, e2, velocityX, velocityY);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onShowPress</span><span class="hljs-params">(MotionEvent e)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onShowPress(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onDown</span><span class="hljs-params">(MotionEvent e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onDown(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onDoubleTap</span><span class="hljs-params">(MotionEvent e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onDoubleTap(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onDoubleTapEvent</span><span class="hljs-params">(MotionEvent e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onDoubleTapEvent(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onSingleTapConfirmed</span><span class="hljs-params">(MotionEvent e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onSingleTapConfirmed(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onContextClick</span><span class="hljs-params">(MotionEvent e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onContextClick(e);<br>    &#125;<br>&#125;;<br>GestureDetector gestureDetector = <span class="hljs-keyword">new</span> GestureDetector(<span class="hljs-keyword">this</span>, listener);<br></code></pre></td></tr></table></figure><h5 id="Animate-a-scroll-gesture"><a href="#Animate-a-scroll-gesture" class="headerlink" title="Animate a scroll gesture"></a><a href="https://developer.android.com/training/gestures/scroll">Animate a scroll gesture</a></h5><p>&lt;不贴代码了&gt;</p><h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><p>文档：<a href="https://developer.android.com/guide/input">Touch &amp; input</a></p><h3 id="View-的滑动"><a href="#View-的滑动" class="headerlink" title="View 的滑动"></a>View 的滑动</h3><h4 id="三种类型"><a href="#三种类型" class="headerlink" title="三种类型"></a>三种类型</h4><ul><li>  使用 scrollTo/scrollBy</li><li>  使用动画</li><li>  改变布局参数</li></ul><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul><li>  scrollTo/scrollBy：操作简单，适合对 View 的内容的滑动</li><li>  动画：操作简单，适用于没有交互的 View 和实现复杂动画效果</li><li>  改变布局参数：操作稍复杂，适用于有交互的 View</li></ul><h4 id="扩展阅读-1"><a href="#扩展阅读-1" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><p>文档：<a href="https://developer.android.com/training/gestures">Use touch gestures</a></p><h3 id="弹性滑动"><a href="#弹性滑动" class="headerlink" title="弹性滑动"></a>弹性滑动</h3><p>如果直接滑动，显得比较生硬，所以我们需要实现渐进式滑动也即弹性滑动。</p><ul><li>  使用 Scroller，阅读文档：<a href="https://developer.android.com/training/gestures/scroll">Animate a scroll gesture</a></li><li>  通过动画，阅读文档：<a href="https://developer.android.com/guide/topics/graphics/spring-animation">Animate movement using spring physics</a></li><li>  使用延时策略，也即利用 <a href="https://developer.android.com/reference/android/view/View#postDelayed(java.lang.Runnable,%20long)">View</a> 或者 <a href="https://developer.android.com/reference/android/os/Handler#postDelayed(java.lang.Runnable,%20long)">Handler</a> 的 postDelayed() 方法，例子见：<a href="https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_3/src/com/ryg/chapter_3/TestActivity.java">android-art-res</a></li></ul><h3 id="View-的事件分发"><a href="#View-的事件分发" class="headerlink" title="View 的事件分发"></a>View 的事件分发</h3><h4 id="点击事件的传递规则"><a href="#点击事件的传递规则" class="headerlink" title="点击事件的传递规则"></a><a href="https://developer.android.com/training/gestures/viewgroup.html#intercept">点击事件的传递规则</a></h4><p>简单来说 ViewGroup 用 <code>dispatchTouchEvent(MotionEvent e)</code> 来分发事件，如果 View 能接收触摸事件那么该方法一定会被调用到。该方法中，通过 <code>onInterceptTouchEvent(MotionEvent e)</code> 来判断是否需要拦截触摸事件，如果返回 true 则事件不再继续往下传递，那么你就需要通过实现该 ViewGroup 中的 <code>onTouchEvent(MotionEvent e)</code> 来对触摸事件进行处理。</p><h3 id="View-的滑动冲突"><a href="#View-的滑动冲突" class="headerlink" title="View 的滑动冲突"></a>View 的滑动冲突</h3><p>分为三种情况：</p><ul><li>  外部滑动方向与内部滑动方向不一致</li><li>  外部滑动方向与内部一致</li><li>  以上两种的嵌套</li></ul><img src="../assets/2019-12-14/scroll_conflict.png" width=80% /><p>对于第一种，我们可以根据滑动的方向、角度、距离差、速度差等来判断到底是由内部还是外部的 View 来拦截滑动事件并进行处理。</p><p>对于第二种，则需要根据具体业务来做处理，比如 ScrollView 嵌套一个 RecyclerView，规定当内部的 RecyclerView 滑动到顶部或者底部的时候外部的 ScrollView 就要开始响应滑动事件，我们就可以根据滑动距离以及 Header 是否显示（或者第一个元素是否完全显示）来判断。</p><p>第三种的解决方案和上面两种一样，只不过是多加几种判断并且进行相应地分发给对应的子 View 就可以了。</p><p>具体解决方案：</p><ol><li> 外部拦截法。外部拦截法即所有点击事件都先经过父容器的拦截，父容器中进行判断是否消耗事件或者传递给子元素，需要重写 <code>onInterceptTouchEvent()</code> 方法。</li><li> 内部拦截法。父容器不拦截点击事件，所有事件都传递给子元素，如果子元素需要事件就消耗掉，否则就交给父类处理。需要重写 <code>dispatchTouchEvent()</code> 方法，还需要配合 <code>requestDisallowInterceptTouchEvent()</code> 使用。这种方法与事件分发机制相反，故不推荐使用。</li></ol><h2 id="View-的工作原理"><a href="#View-的工作原理" class="headerlink" title="View 的工作原理"></a>View 的工作原理</h2><h3 id="ViewRoot-和-DecorView"><a href="#ViewRoot-和-DecorView" class="headerlink" title="ViewRoot 和 DecorView"></a>ViewRoot 和 DecorView</h3><p>ViewRoot 是 ViewRootImpl 的基类，后者是连接 WindowManager 和 DecorView 的纽带，View 的三大流程都是通过 ViewRoot 完成的。Activity 创建完成后，会将 DecorView 添加到 Window 中，同时会创建 ViewRootImpl 并将它与 DecorView 建立关联。</p><p>View 的绘制流程从 ViewRoot 的 <code>performTraversals</code> 开始，经过 <strong>measure</strong>（测量 View 的宽高）、<strong>layout</strong>（确定 View 在父容器中的位置）、<strong>draw</strong>（绘制在屏幕上）三个过程完成 View 的绘制。</p><img src="../assets/2019-12-14/view_measue_layout_draw.png" width=80% /><p>DecorView 是顶级 View，内部包含一个 LinearLayout，分为上下两个部分，上面是 TitleBar，下面是 Content，获取我们的 View 可以通过 <code>findViewById(android.R.id.content).getChildAt(0)</code>，如图：</p><img src="../assets/2019-12-14/decorview.png" width=35% /><p>另外，DecorView 是一个 FrameLayout，所有事件都会先经过 DecorView 再传递到我们的 View。</p><h3 id="理解-MeasureSpec"><a href="#理解-MeasureSpec" class="headerlink" title="理解 MeasureSpec"></a>理解 MeasureSpec</h3><h4 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h4><p>MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对象的内存分配。为了方便操作，其提供了打包和解包的方法，SpecMode 和 SpecSize 也是一个 int 值，一组 SpecMode 和 SpecSize 可以打包为一个 MeasureSpec 的 int 值，而一个 MeasureSpec 的 int 值可以通过解包得到原始的 SpecMode 和 SpecSize。</p><p>SpecMode 有三类：</p><ul><li>  <strong>UNSPECIFIED</strong>，父容器不对 View 的大小进行限制，一般用于系统内部，表示测量的状态；</li><li>  <strong>EXACTLY</strong>，父容器已经测得所需的大小，View 的最终大小就是SpecSize 所指定的值。对应于 LayoutParam 中的 match_parent 和具体数值。</li><li>  <strong>AT_MOST</strong>，父容器指定了一个可用大小即 SpecSize，View 的大小不能大于这个值，具体大小根据 View 的实现而有所不同。对应于 LayoutParam 中的 wrap_content。</li></ul><h4 id="MeasureSpec-和-LayoutParam-的关系"><a href="#MeasureSpec-和-LayoutParam-的关系" class="headerlink" title="MeasureSpec 和 LayoutParam 的关系"></a>MeasureSpec 和 LayoutParam 的关系</h4><p>DecorView 和普通 View 的 MeasureSpec 的转换方式不同，DecorView 通过自身的 LayoutParam 就可以确定 MeasureSpec：</p><ul><li>  LayoutParam.MATCH_PARENT: SpecMode is EXACTLY, SpecSize equal to Window size.</li><li>  LayoutParam.WRAP_CONTENT: SpecMode is AT_MOST, SpecSize is not fixed but cannot be larger than the Window size.</li><li>  Fixed size (e.g. 100dp): SpecMode is EXACTLY, SpecSize as specified.</li></ul><p>而普通 View 的 MeasureSpec 则相对复杂一些，除了 LayoutParam 之外，还需要根据父容器的 MeasureSpec 才能决定：</p><img src="../assets/2019-12-14/measurespec_layoutparam.png" width=90% /><h3 id="View-的工作流程"><a href="#View-的工作流程" class="headerlink" title="View 的工作流程"></a>View 的工作流程</h3><p>分为 measure 过程、layout 过程、draw 过程，具体请阅读 <a href="https://developer.android.com/guide/topics/ui/how-android-draws">How Android Draws Views</a> 以及 <a href="https://developer.android.com/training/custom-views/custom-drawing">Custom Drawing</a> 部分。</p><h3 id="自定义-View"><a href="#自定义-View" class="headerlink" title="自定义 View"></a>自定义 View</h3><h4 id="自定义-View-的分类"><a href="#自定义-View-的分类" class="headerlink" title="自定义 View 的分类"></a>自定义 View 的分类</h4><ul><li>  <a href="https://developer.android.com/guide/topics/ui/custom-components">Guide: Custom View Components</a></li><li>  <a href="https://developer.android.com/reference/android/view/View#implementing-a-custom-view">Reference: Implementing a Custom View</a></li></ul><ol><li> 继承 View 重写 <code>onDraw</code> 方法</li></ol><p>这种方法主要用于实现一些不规则的效果，需要支持 wrap_content 并且 padding 也需要自己处理。</p><ol start="2"><li> 继承 ViewGroup 派生特殊 Layout</li></ol><p>用于实现自定义布局，比第一种复杂，需要处理 <code>onMeasure</code> 和 <code>onLayout</code>，还要处理子 View 的 <code>onMeasure</code> 和 <code>onLayout</code></p><ol start="3"><li> 继承特定的 View（比如 TextView）</li></ol><p>较为常见，用于扩展某个 View 的功能，实现起来也较为简单。</p><ol start="4"><li> 继承特定的 ViewGroup（比如 LinearLayout）</li></ol><p>同样较为常见，比如需要实现类似几个 View 组合在一起的效果的时候，不需要自己处理 ViewGroup 的 <code>onMeasure</code> 和 <code>onLayout</code>，方法 2 比这个方法更底层，实现起来更复杂。 </p><h4 id="自定义-View-须知"><a href="#自定义-View-须知" class="headerlink" title="自定义 View 须知"></a>自定义 View 须知</h4><ol><li> 让 View 支持 wrap_content</li><li> 让 View 支持 padding</li><li> 尽量不要使用 Handler，使用 View 自身的 post 方法</li><li> 在 <code>View.onDetachedFromWindow()</code> 中停止动画</li><li> 如果 View 带有滑动嵌套，需要处理好滑动冲突</li></ol><h4 id="自定义-View-示例"><a href="#自定义-View-示例" class="headerlink" title="自定义 View 示例"></a>自定义 View 示例</h4><p>见：<a href="https://github.com/singwhatiwanna/android-art-res/tree/master/Chapter_4/src/com/ryg/chapter_4/ui">android-art-res / Chapter_4</a></p><h2 id="理解-RemoteViews"><a href="#理解-RemoteViews" class="headerlink" title="理解 RemoteViews"></a>理解 RemoteViews</h2><h3 id="RemoteViews-的应用"><a href="#RemoteViews-的应用" class="headerlink" title="RemoteViews 的应用"></a>RemoteViews 的应用</h3><p><a href="https://developer.android.com/reference/android/widget/RemoteViews">RemoteViews</a> 可以在其他进程中显示并更新界面，主要用于通知栏和桌面部件。</p><h4 id="通知栏"><a href="#通知栏" class="headerlink" title="通知栏"></a>通知栏</h4><p>通过 RemoteViews 和 <a href="https://developer.android.com/reference/android/app/NotificationManager">NotificationManager</a> 加载通知栏的<a href="https://developer.android.com/training/notify-user/custom-notification">自定义布局</a>。</p><h4 id="桌面-Widget"><a href="#桌面-Widget" class="headerlink" title="桌面 Widget"></a>桌面 Widget</h4><p>通过 RemoteViews 和 <a href="https://developer.android.com/reference/android/appwidget/AppWidgetProvider">AppWidgetProvider</a> 创建<a href="https://developer.android.com/reference/android/app/NotificationManager">桌面小部件</a>。</p><h4 id="关于-PendingIntent"><a href="#关于-PendingIntent" class="headerlink" title="关于 PendingIntent"></a>关于 PendingIntent</h4><p><a href="https://developer.android.com/reference/android/app/PendingIntent">PendingIntent</a> 在我看来是包含了一个可以稍后执行的 Intent 的容器，我们可以用它启动 Activity、Service 以及发送广播。它由系统执行，意味着即使我们的 app 被杀死了，依旧可以利用它启动我们想要的组件。系统通过 requestCode 和 Intent 区分不同的 PendingIntent，只是更改 Intent 的 extra 不会起作用。如果我们需要启动两个不同的通知，也可以通过使用不同的 notificationId。</p><h3 id="RemoteViews-的内部机制"><a href="#RemoteViews-的内部机制" class="headerlink" title="RemoteViews 的内部机制"></a>RemoteViews 的内部机制</h3><h4 id="支持的-View-类型"><a href="#支持的-View-类型" class="headerlink" title="支持的 View 类型"></a>支持的 View 类型</h4><p>四大 layout, ListView, Button, ImageButton, ImageView, TextView, ProgressBar 等，不支持 EditText，其它具体见文档：<a href="https://developer.android.com/reference/android/widget/RemoteViews#top_of_page">RemoteViews</a>。</p><h4 id="RemoteViews-的工作机制"><a href="#RemoteViews-的工作机制" class="headerlink" title="RemoteViews 的工作机制"></a>RemoteViews 的工作机制</h4><p>由于 RemoteViews 在远程进程显示，所以没法通过 findViewById 来获取 View，只能通过反射实现，即一系列的 setXXX 方法（大部分是通过反射）。</p><p>RemoteViews 实现了 Parcelable 所以可以跨进程传输，首先通过 Binder 传递到 SystemService 进程，然后系统通过 RemoteViews 中的包名信息获取对应的布局文件并加载。</p><p>所以当我们调用一系列的 set 方法其实也都是跨进程的。之所以不直接让 View 支持跨进程，是因为开销太大，毕竟 View 的方法很多，而是巧妙地通过一个 <code>Action</code>（封装了对 View 的操作）来进行 IPC。</p><h3 id="RemoteViews-的意义"><a href="#RemoteViews-的意义" class="headerlink" title="RemoteViews 的意义"></a>RemoteViews 的意义</h3><p>可以利用 RemoteViews 进行跨进程更新 UI（限制比较大，但是挺有趣的）。</p><hr><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-1/">Android 开发艺术探索学习笔记（一）</a> - 第 1 章：生命周期和启动模式</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-2/">Android 开发艺术探索学习笔记（二）</a> - 第 2 章：IPC 机制</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-3/">Android 开发艺术探索学习笔记（三）</a> - 第 3~5 章：View 事件机制等</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-4/">Android 开发艺术探索学习笔记（四）</a> - 第 6, 7, 12 章：Drawable，动画，Bitmap</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-5/">Android 开发艺术探索学习笔记（五）</a> - 第 8, 10, 11 章：Window，线程和线程池，消息机制</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-6/">Android 开发艺术探索学习笔记（六）</a> - 第 13~15 章：综合技术，JNI 和 NDK，性能优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发艺术探索学习笔记（二）</title>
      <link href="/notes-on-android-art-part-2/"/>
      <url>/notes-on-android-art-part-2/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2019-12-07/android-logo.jpg"></p><blockquote><p>结合 <a href="https://developer.android.com/guide">官方文档</a> 阅读《Android 开发艺术探索》时所做的学习笔记。本篇记录第二章：IPC 机制。</p></blockquote><h3 id="What-How-Why"><a href="#What-How-Why" class="headerlink" title="What? How? Why?"></a>What? How? Why?</h3><h4 id="什么是-IPC？"><a href="#什么是-IPC？" class="headerlink" title="什么是 IPC？"></a>什么是 IPC？</h4><p>所谓的 IPC 是指进程间通信（<strong>I</strong>nter<strong>P</strong>rocess <strong>C</strong>ommunication 的缩写），我们知道 Linux 里可以通过管道、signal 等进行重定向、跨进程通信等，Android 中同样如此。一般情况下只要应用中使用了多个进程，那么就会涉及到进程间通信的问题。另外，由于每一个 Android 应用都是一个沙箱，独享一个进程，所以应用间数据共享同样也需要通过 IPC。</p><h4 id="有哪些-IPC-的方式？"><a href="#有哪些-IPC-的方式？" class="headerlink" title="有哪些 IPC 的方式？"></a>有哪些 IPC 的方式？</h4><p>Android 中进程间通信的方式有很多，比如最常见的通过 <a href="https://developer.android.com/reference/android/content/Intent.html#putExtra(java.lang.String,%20android.os.Bundle)">Intent.putExtra</a> 以及 <a href="https://developer.android.com/guide/topics/providers/content-providers">Content Provider</a>，通过文件共享（需要注意并发读/写问题），通过 Socket，以及最重要的一种 IPC 方式，通过 <a href="https://developer.android.com/guide/components/bound-services.html#Creating"><strong>绑定服务</strong></a>，其中最重要的部分是 Binder，<a href="https://developer.android.com/guide/components/bound-services.html#Messenger">Messager</a> 和 <a href="https://developer.android.com/guide/components/aidl.html">AIDL</a> 底层实现也是通过 Binder。</p><span id="more"></span><h4 id="为什么需要-IPC？"><a href="#为什么需要-IPC？" class="headerlink" title="为什么需要 IPC？"></a>为什么需要 <a href="https://developer.android.com/guide/components/processes-and-threads#IPC">IPC</a>？</h4><p>首先，当应用 A 启动的时候，Android 系统会为它单独指定一个进程，分配一个 User ID，于是它只能在这个进程里执行自己的代码，访问自己的数据空间。但是如果我们为应用 A 指定了多个进程，并且想要调用另一个进程中的代码，那么我们是无法直接访问另一个进程中的内存空间的，所以就需要某种方式或者说通过某个桥梁，建立起进程间的连接。这个方式可以称为 remote procedure calls (RPCs)，而借用的桥梁就是 <a href="https://developer.android.com/reference/android/os/Binder">Binder</a>。</p><p>简单来说就是将方法调用以及数据，分解成操作系统能够读取的程度，然后把它从当前进程和地址空间中传送到目标进程和地址空间，重新组合起来之后再进行调用，最后将结果用同样的方式返回给请求发生的进程。</p><h3 id="More-details"><a href="#More-details" class="headerlink" title="More details"></a>More details</h3><h4 id="IPC-基础概念"><a href="#IPC-基础概念" class="headerlink" title="IPC 基础概念"></a>IPC 基础概念</h4><h5 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h5><p>Serializable 接口</p><ul><li>  只要实现 Serializable 接口并提供 <code>serialVersionUID</code>，系统会为我们自动完成序列化的工作。</li><li>  系统通过 <code>servialVersionUID</code> 来标记需要序列化的类，如果我们不提供，系统会为我们默认生成一个，而使用默认生成的 <code>servialVersionUID</code> 的时候，如果序列化类发生改变则 <code>servialVersionUID</code> 也会发生改变，此时反序列化就会失败报错。所以必须手动指定 <code>servialVersionUID</code> 值。</li><li>  可以使用 <code>transient</code> 关键字标记不需要序列化的成员变量。</li></ul><p>Parcelable 接口</p><ul><li>  通过 <code>writeToParcel</code> 完成序列化（一系列的 <code>Parcel.writeXXX</code>）。</li><li>  通过 CREATOR 来标记如何创建序列化对象以及数组，并通过构造方法中的一系列 <code>Parcel.readXXX</code> 完成反序列化。</li><li>  反序列化时，如果存在可序列化的属性，即使用 <code>Pacel.readParcelable</code> 时需要传递当前线程的类加载器，否则会报 ClassNotFound 的错误。</li><li>  一般情况下，<code>discribeContents</code> 都应该返回 0，只有在存在文件描述符时才需要返回 1。</li></ul><h5 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h5><p>Binder 实现了 IBinder 接口，在跨进程通信中，它是客户端与服务端通信的媒介，当绑定服务时，服务端会返回一个 Binder 对象，而客户端正是通过这个 Binder 对象来获取服务端的数据以及进行远程方法调用。</p><p>一般的 Service 如果不涉及进程间通信，那么只要实现 IBinder 接口就可以了，所以我们以最基本的 AIDL 作为例子来解释 Binder 的工作原理。AIDL 实际上是 Android 为我们封装好的接口定义语言，它自动为我们生成 Binder 的实现代码。</p><p>具体而言，一个 Binder 的实现通常需要有以下部分：</p><ul><li>  <code>DESCRIPTOR</code>，该 Binder 的唯一标识。</li><li>  供客户端调用的方法，具体实现交给内部类 Stub。</li><li>  Stub 中的 <code>asBinder()</code> 方法，返回当前 IBinder 对象。</li><li>  Stub 中的 <code>asInterface(IBinder obj)</code> 方法，将 IBinder 转换为客户端实际需要的接口类型（即当前接口）的对象，如果是在同一进程中，则直接返回当前对象，否则就需要创建一个 Proxy 对象并返回，因为需要通过 transact() 方法进行跨进程传递数据、完成方法调用并返回结果。</li><li>  Stub 中的 <code>onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)</code> 方法，实际对客户端跨进程请求进行处理的地方，通过 code 确定请求方法，通过 data 获取参数，向 reply 中写入返回值，如果返回结果为 true 表示请求成功，false 表示无法识别请求 code，我们也可以通过此方法来做权限验证。另外，此方法运行在<strong>服务端的 Binder 线程池</strong>中。</li><li>Proxy 类才是真正 IPC Binder 的实现类，由客户端发起调用。如果是在同一进程中，会直接调用 Stub 中的方法，而如果是跨进程，则需要使用到 Proxy类。具体过程如下：<ul><li>  将输入对象、输出对象、返回值写入 Parcel data；</li><li>  然后发起远程调用，即执行 transact() 方法，当前线程会被挂起；</li><li>  然后再调用服务端的 onTransact() 方法，获取返回结果（如果有的话）后，再从返回值 reply 中读取结果并返回，客户端当前线程得以继续执行。</li></ul></li></ul><p>以上最关键的部分是最后的 Proxy 类以及 onTransact() 方法。</p><p>关于 AIDL 的具体使用方式请看下面的 AIDL 部分。</p><h4 id="IPC-方式介绍"><a href="#IPC-方式介绍" class="headerlink" title="IPC 方式介绍"></a>IPC 方式介绍</h4><h5 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h5><p><a href="https://developer.android.com/reference/android/content/Intent.html#putExtra(java.lang.String,%20android.os.Bundle)">Intent.putExtra(Bundle)</a>，数据必须是可以序列化的，比如原始数据类型，实现 Parcelable 接口或者 Serializable 接口的对象，基本数据类型或者实现了 Parcelable 的 ArrayList/SparceArray 等。</p><h5 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h5><p>对数据格式没有要求，但是需要注意并发读写的问题。</p><p>SharedPreferences 是个特例，它会在内存中保存一份拷贝，使用 apply() 时进行异步提交（先保存到内存然后异步提交保存到文件），而使用 commit() 时会阻塞并返回结果，它是单进程模式下的单例，所以多进程明显就变得非常不可靠。</p><h5 id="Messager"><a href="#Messager" class="headerlink" title="Messager"></a>Messager</h5><p>轻量级的 IPC，底层使用的是 AIDL。</p><ul><li>  服务端创建一个 Service 处理连接请求，创建一个 Handler 对象，对客户端传递过来的信息进行接收处理（通过 <code>what</code> 获取类型，通过 <code>arg1</code>/<code>arg2</code>/<code>Bundle</code> 获取数据，通过 <code>replyTo</code> 获取客户端传递过来的 Messager），再用它创建 Messager 对象（<a href="https://developer.android.com/reference/android/os/Messenger.html#Messenger(android.os.Handler)">new Messager(Handler)</a>），在 onBind 中返回 Messager 的 IBinder。</li><li>  客户端同样需要创建 Messager，只要通过 ServiceConnection 与服务端建立连接，然后获取到 Server 端的 IBinder，然后从消息池（<a href="https://developer.android.com/reference/android/os/Message.html#obtain(android.os.Handler,%20int)">Message.obtain()</a>）中获取 Message，并传递数据 <a href="https://developer.android.com/reference/android/os/Messenger.html#send(android.os.Message)">Messager.send(Message)</a>，传递数据同样可以通过 [arg1, arg2, what, Bundle, replyTo 以及 object]，其中使用 replyTo 传递需要服务端返回的 Messager。</li><li>  Message 支持的数据类型中，object 比较特殊，它在单进程中比较实用，但是跨进程限制就比较大了，只能传递系统中实现了 Parcelable 接口的对象，比如 Rect、Point 等。</li></ul><h5 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h5><p>Messager 适合跨进程传递消息，如果有大量请求或者需要跨进程方法调用，那么可能就需要使用到 AIDL 了。</p><ul><li>  服务端：我们需要创建一个 Service 监听客户端的连接请求，然后在 .aidl 文件中声明需要暴露给客户端的接口，再在 Service 中实现这个接口。</li><li>  客户端：绑定 Service，然后将 IBinder 转换为定义好的 AIDL 接口类型然后调用获取结果。</li></ul><p>具体步骤如下：</p><ol><li> 创建 <code>.aidl</code> 接口</li></ol><p>与创建普通 Java 接口类似，只不过只支持下面一些数据类型：</p><ul><li>  基本数据类型</li><li>  String 和 CharSequence</li><li>  实现了 Parcelable 接口的对象</li><li>  List（具体实际使用的是 ArrayList）和 Map（具体实际使用的是 HashMap），其中的元素必须全都支持 AIDL</li><li>  AIDL 接口，使用时必须显式导入</li></ul><p>另外，使用 AIDL 传递 Parcelable 对象时，还需要我们为该 Parcelable 对象创建一个 <code>.aidl</code> 文件，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> your.<span class="hljs-keyword">package</span>.name<br><br>parcelable YourParcelableClass;<br></code></pre></td></tr></table></figure><p>再之，AIDL 接口方法的参数必须标明方向 <code>in</code> <code>out</code> <code>inout</code>，<code>in</code> 表示输入型参数，<code>out</code> 表示输出型参数，<code>inout</code> 两者皆可，基本数据类型默认为 <code>in</code>。不同参数类型的 Binder 在<em>再编码</em>（<strong>marshall</strong>，不知道如何翻译，将数据序列化、传输、接收、解序列化的过程）时所需的步骤不同，标明类型后，Binder 可以跳过某些步骤从而达到节省开销的目的。具体解释见：<a href="https://stackoverflow.com/questions/4700225/in-out-inout-in-a-aidl-interface-parameter-value">“In/out/inout” in a AIDL interface parameter value?</a></p><p>创建好 AIDL 接口后，gradle sync 后 IDE 会为我们生成对应的 Java 文件。</p><ol start="2"><li> 实现 AIDL 接口（其实是接口中的 Stub 类，即 Binder 真正的实现类）</li></ol><p>在服务端 Service 中，我们需要实现接口中的 Stub 类，然后在 onBind() 方法中返回供客户端调用。需要注意的是：</p><ul><li>  来自客户端的调用，不一定是执行在主线程的，而且有可能多个客户端与服务端同时建立连接，所以需要注意线程安全的问题。</li><li>  默认情况下，远程调用是同步执行的，所以如果客户端在主线程发生 RPC，需要考虑调用是否耗时，否则会造成 ANR，最好在子线程调用。</li><li>  客户端不会接收到服务端抛出的异常。</li></ul><ol start="3"><li> 客户端的实现</li></ol><p>客户端通过 <a href="https://developer.android.com/reference/android/content/Context.html#bindService(android.content.Intent,%20android.content.ServiceConnection,%20int)">bindService()</a> 与服务端建立连接后，通过 <a href="https://developer.android.com/reference/android/content/ServiceConnection.html#onServiceConnected">onServiceConnected()</a> 回调中获取 <code>binder</code> 实例，然后再通过 <code>YourAIDLInterface.Stub.asInterface()</code> 将 <code>binder</code> 实例类型转换为所需要的 AIDL 接口（如果客户端位于不同的应用中，则必须也要保留一份 <code>.aidl</code> 文件，以便生成 AIDL 接口）。</p><p>需要注意的是，如果我们使用了回调的话，会遇到无法解注册的问题，本质是因为回调接口在从客户端传递到服务端的时候，已经不是同一个对象了，想要成功解注册我们需要使用 <a href="https://developer.android.com/reference/android/os/RemoteCallbackList"><code>RemoteCallbackList</code></a>，它是线程安全的（原理：通过遍历所有 Binder 对象–我们的 listener 也是 Binder 对象–然后找到对应的 listener 再删除）。</p><p>另外还要注意 Binder 意外死亡（<a href="https://developer.android.com/reference/android/os/IBinder.DeathRecipient"><code>DeathRecipient</code></a> 或 onServiceDisconnected()，前者在 Binder 线程池中被调用，后者在 UI 线程中调用）以及权限验证（onBind() 或 onTrasact() 中做处理）的问题。具体请查看例子：<a href="https://github.com/singwhatiwanna/android-art-res/blob/b88333cf8ce6e3d035064af6097bec20cf8e15e1/Chapter_2/src/com/ryg/chapter_2/aidl/BookManagerService.java">Chapter_2/aidl</a></p><h5 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h5><p>参考<a href="https://developer.android.com/guide/topics/providers/content-providers">文档</a></p><h5 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h5><p>分为 TCP 套接字（Java 中对应的实现使用 <a href="https://developer.android.com/reference/java/net/ServerSocket"><code>ServerSocket</code></a>）和 UDP 套接字（Java 中对应的实现使用 <a href="https://developer.android.com/reference/java/net/DatagramSocket"><code>DatagramSocket</code></a>），具体例子见：<a href="https://github.com/singwhatiwanna/android-art-res/blob/b88333cf8ce6e3d035064af6097bec20cf8e15e1/Chapter_2/src/com/ryg/chapter_2/socket/TCPClientActivity.java">Chapter_2/socket</a></p><h4 id="Binder-连接池"><a href="#Binder-连接池" class="headerlink" title="Binder 连接池"></a>Binder 连接池</h4><p>Binder 连接池的主要作用是将每个业务模块的 Binder 请求统一转发到远程 Service 中去执行，从而避免重复创建 Service，节省系统资源。</p><p>工作机制：每个模块创建并实现自己的 AIDL 接口，然后向服务端提供自己的唯一标识和对应的 Binder 对象，服务端只是需要一个 Service，然后提供一个 queryBinder 接口，根据业务模块的标识来返回相应的 Binder 对象，然后再由客户端发起远程方法调用。</p><p>具体例子见：<a href="https://github.com/singwhatiwanna/android-art-res/blob/b88333cf8ce6e3d035064af6097bec20cf8e15e1/Chapter_2/src/com/ryg/chapter_2/binderpool/BinderPool.java">Chapter_2/binderpool</a></p><h4 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h4><table><thead><tr><th>名称</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>Bundle</td><td>简单易用</td><td>只能传输 Bundle 支持的数据类型</td><td>四大组件间的进程间通信</td></tr><tr><td>文件共享</td><td>简单易用</td><td>不适合高并发场景，并且无无法做到进程间的即时通信</td><td>无并发访问情形，交换简单的数据，实时性不高的场景</td></tr><tr><td>Messenger</td><td>功能一般，支持一对多串行通信，支持实时通信</td><td>不能很好处理高并发情形，不支持 RPC，数据通过 Message 进行传输，因此只能传输 Bundle 支持的数据类型</td><td>低并发的一对多即时通信，无 RPC 需求，或者不需要返回结果的 RPC 需求</td></tr><tr><td>AIDL</td><td>功能强大，支持一对多并发通信，支持实时通信</td><td>使用稍复杂，需要处理好线程同步</td><td>一对多通信且有 RPC 需求</td></tr><tr><td>Content Provider</td><td>在数据源访问方面功能强大，支持一对多并发数据共享，可通过 Call 方法扩展其他操作</td><td>可以理解为受约束的 AIDL，主要提供数据源的 CRUD 操作</td><td>一对多的进程间的数据共享</td></tr><tr><td>Socket</td><td>功能强大，可以通过网络传输字节流，支持一对多并发实时通信</td><td>实现细节稍微有点烦琐，不支持直接的 RPC</td><td>网络数据交换</td></tr></tbody></table><hr><h3 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h3><ul><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-1/">Android 开发艺术探索学习笔记（一）</a> - 第 1 章：生命周期和启动模式</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-2/">Android 开发艺术探索学习笔记（二）</a> - 第 2 章：IPC 机制</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-3/">Android 开发艺术探索学习笔记（三）</a> - 第 3~5 章：View 事件机制等</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-4/">Android 开发艺术探索学习笔记（四）</a> - 第 6, 7, 12 章：Drawable，动画，Bitmap</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-5/">Android 开发艺术探索学习笔记（五）</a> - 第 8, 10, 11 章：Window，线程和线程池，消息机制</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-6/">Android 开发艺术探索学习笔记（六）</a> - 第 13~15 章：综合技术，JNI 和 NDK，性能优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发艺术探索学习笔记（一）</title>
      <link href="/notes-on-android-art-part-1/"/>
      <url>/notes-on-android-art-part-1/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2019-12-04/android-logo.jpg"></p><blockquote><p>  结合 <a href="https://developer.android.com/guide">官方文档</a> 阅读《Android 开发艺术探索》时所做的学习笔记。本篇记录第一章。</p></blockquote><h3 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a><a href="https://developer.android.com/guide/components/activities/activity-lifecycle">Activity 生命周期</a></h3><ul><li>  新 Activity 启动之前，原栈顶 Activity 的 onPause 会先被调用，所以不要在 onPause 中做耗时操作。</li><li>  <a href="https://developer.android.com/reference/android/app/Activity#onRestoreInstanceState(android.os.Bundle)">onRestoreInstanceState</a> 方法会在 onStart 之后被调用，推荐在这里而不是 onCreate 方法中恢复数据。大部分 View 都会帮我们做一些基本的状态恢复，但是必须为 View 提供 ID，可以查看对应的 View 中的 onRestoreInstanceState 方法了解具体恢复了哪些内容。</li><li>  <a href="https://developer.android.com/reference/android/app/Activity#onSaveInstanceState(android.os.Bundle)">onSaveInstanceState</a> 方法会在 onStop 之后被调用（targetSdkVersion &gt;= 28），可以在这里保存一些轻量的数据。它可以作为生命周期方法的补充，但是有些时候并不会被调用，比如从 A 中启动 B 的时候，如果 A 未被回收那么系统就不会调用 onSaveInstanceState。</li></ul><span id="more"></span><h3 id="Activity-的启动模式"><a href="#Activity-的启动模式" class="headerlink" title="Activity 的启动模式"></a>Activity 的启动模式</h3><h4 id="四种启动模式"><a href="#四种启动模式" class="headerlink" title="四种启动模式"></a><a href="https://developer.android.com/guide/components/activities/tasks-and-back-stack#ManifestForTasks">四种启动模式</a></h4><ul><li>  standard：每次都会在<strong>当前任务栈</strong>中启动一个新的 Activity 实例。使用场景：默认配置，商品详情页。</li><li>  singleTop：栈顶复用，再次启动时会调用 <strong>onNewIntent()</strong> 而不是 onCreate()。使用场景：登录页、通知推送页。</li><li>  singleTask：栈内复用，一般与 <strong>taskAffinity</strong> 结合使用，与 singleTop 类似，如果在请求的目标栈中已有实例存在，则会调用 onNewIntent()。另外，singleTask 启动模式还有 <strong><a href="https://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_CLEAR_TOP">CLEAR_TOP</a></strong> 的效果，比如 A、B 两个 activity 位于同一个任务栈，如果 A 是 singleTask，而且被另一个任务栈的 activity 再次启动，则 B 会出栈。使用场景：App 主页面、WebView 页面、只能出现单一页面的场景。</li><li>  singleInstance：加强的 singleTask，只能单独位于一个任务栈中。使用场景：系统 Launcher、锁屏键、来电显示等系统应用。</li></ul><h4 id="关于-taskAffinity"><a href="#关于-taskAffinity" class="headerlink" title="关于 taskAffinity"></a>关于 <a href="https://developer.android.com/guide/components/activities/tasks-and-back-stack#Affinities"><code>taskAffinity</code></a></h4><ul><li>指定 Activity 在哪个栈中运行，默认使用 applicationId。</li><li>具有相同 taskAffinity 的 activity 会被放入同一个栈中。</li><li>一般需要配合 singleTask 启动模式来使用。</li></ul><h4 id="关于-allowTaskReparenting"><a href="#关于-allowTaskReparenting" class="headerlink" title="关于 allowTaskReparenting"></a>关于 <a href="https://developer.android.com/guide/topics/manifest/application-element.html#reparent"><code>allowTaskReparenting</code></a></h4><ul><li>当启动该 activity 的时候，如果该 activity 存在相同的 taskAffinity 的栈，则会被移动到那个栈里。比如一个浏览器应用 App A 中的 activity A 指定了 allowTaskReparenting，同时与主 activity 位于同一个任务栈中。那么当你在别的应用 App B 中，点击了一个链接打开了 A，然后再返回桌面打开浏览器应用，会直接打开 activity A 而不是主 activity，而当我们返回 App B 的时候，会发现这个 activity A 已经不在了（被移动到了 App A 的任务栈中）。</li><li>我们一般结合 singleTask 并指定单独的栈来使用 allowTaskReparenting。</li></ul><h4 id="关于-Intent-Flags"><a href="#关于-Intent-Flags" class="headerlink" title="关于 Intent Flags"></a>关于 <a href="https://developer.android.com/guide/components/activities/tasks-and-back-stack#IntentFlagsForTasks">Intent Flags</a></h4><ul><li>  <a href="https://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_NEW_TASK">FLAG_ACTIVITY_NEW_TASK</a> 对应启动模式中的 singleTask。</li><li>  <a href="https://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_SINGLE_TOP">FLAG_ACTIVITY_SINGLE_TOP</a> 对应启动模式中的 singleTop。</li><li>  <a href="https://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_CLEAR_TOP">FLAG_ACTIVITY_CLEAR_TOP</a> 具有清除栈中它上面所有 activity 的效果，一般结合 singleTask 使用，可以使得对应任务栈中的 activity 重新响应 intent 以及新传入的数据。</li><li>  <a href="https://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS">FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</a>，不显示在最近活动中</li></ul><h4 id="singleTask-和-singleInstance-的区别"><a href="#singleTask-和-singleInstance-的区别" class="headerlink" title="singleTask 和 singleInstance 的区别"></a>singleTask 和 singleInstance 的区别</h4><ul><li><p>singleTask 启动模式下，当栈和 activity 都不存在的时候，系统会创建一个新的 activity 放入新的栈内，如果栈存在则直接将 activity 入栈，而且除了相同 taskAffinity 的 activity 之外，还<strong>允许</strong>其他 activity (i.e. standard  和 singleTop 的 activity) 入栈。</p></li><li><p>singleInstance 启动模式下的 activity <strong>不允许其他 activity 入栈</strong>，也就是说栈内永远只有这一个 activity。</p></li></ul><h3 id="IntentFilter-的匹配规则"><a href="#IntentFilter-的匹配规则" class="headerlink" title="IntentFilter 的匹配规则"></a>IntentFilter 的匹配规则</h3><h4 id="关于-IntentFilter-的组成"><a href="#关于-IntentFilter-的组成" class="headerlink" title="关于 IntentFilter 的组成"></a>关于 <a href="https://developer.android.com/guide/components/intents-filters#Receiving">IntentFilter 的组成</a></h4><ul><li>  一组 IntentFilter 可以由多个 <code>action</code> <code> category</code> <code>data</code> 组成，必须同时匹配 <code>action</code> <code> category</code> <code>data</code> 才能成功启动对应的组件。</li><li>  如果该组件只能处理特定某几种的 <code>action</code> <code> category</code> <code>data</code> 组合，那么你就必须创建多个对应的 IntentFilter 而不是把他们全都放一起。</li></ul><h4 id="关于-通过匹配测试"><a href="#关于-通过匹配测试" class="headerlink" title="关于 通过匹配测试"></a>关于 <a href="https://developer.android.com/guide/components/intents-filters#Resolution">通过匹配测试</a></h4><ul><li>action：指定接收动作类型，用 <code>android:name</code> 指定，可以有 0 个或者多个。一个 Intent 想要匹配成功，则必须至少匹配上一个 <code>action</code>，intent-filter 中可以指定比 Intent 中更多的 <code>action</code>。另外，<ul><li>  如果 intent-filter 没有指定 action，则所有 Intent 都无法匹配成功；</li><li>  如果 Intent 没有指定 action，那么这个 Intent 会通过所有指定了 action 的 intent-filter。</li></ul></li><li>cateogry：指定接收分类。如果 Intent 中指定了多个 <code>category</code>，那么必须全都匹配上才能匹配成功。其他与 <code>action</code> 相同。<ul><li>  使用隐式 Intent 的时候，系统默认添加上一个 CATEGORY_DEFAULT，所以如果你想要匹配成功就必须添加 <strong>android.intent.category.DEFAULT</strong></li></ul></li><li>data：指定 URI 和 MIME type<ul><li>URI 包括以下属性：<code>scheme</code>, <code>host</code>, <code>port</code>, <code>path</code>，host 有时也称为 authority。<ul><li>  完整格式：<code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code></li><li>  例子：<code>content://com.example.project:200/folder/subfolder/etc</code></li><li>  每个属性都是可选的，但是有先后依赖关系，比如如果没有指定 <code>scheme</code>，那么即使指定了 <code>host</code> 或者 <code>port</code> 或者 <code>path</code> 也是无效的。</li><li>  URI 支持部分匹配。</li></ul></li><li>  完整 MIME type 列表可参考 <a href="http://www.iana.org/assignments/media-types/index.htm">IANA MIME Media Types</a>，不同机型支持的 MIME type 有所不同。</li><li>URI 和 MIME type 匹配有如下规则：<ul><li>  完全匹配，比如如果 Intent 只指定了 MIME type，那么所有只指定了 MIME type 都会通过匹配。</li><li>  如果 intent-filter 指定了 MIME type，那么默认支持 <code>content:</code> or <code>file:</code> URI，即如果 Intent 指定了该 MIME type 同时又指定了 scheme 为 <code>content</code> 或者 <code>file</code> 则可以匹配成功。</li></ul></li><li>  如果要为 Intent 设置完整的 data 和 type，必须调用 setDataAndType，因为 setData 和 setType 会相互消除。</li></ul></li></ul><h4 id="关于-Intent-匹配"><a href="#关于-Intent-匹配" class="headerlink" title="关于 Intent 匹配"></a>关于 <a href="https://developer.android.com/guide/components/intents-filters#imatch">Intent 匹配</a></h4><ul><li>我们可以使用 <code>PackageManager</code> 的 <code>resove...</code> 以及 <code>query...</code> 方法，来确定是否存在可以调用的组件，前者会返回匹配到的最佳组件，后者返回所有匹配到的组件。</li><li>记得使用 MATCH_DEFAULT_ONLY flag 来过滤掉没有声明 android.intent.category.DEFAULT 的组件。</li></ul><hr><h3 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h3><ul><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-1/">Android 开发艺术探索学习笔记（一）</a> - 第 1 章：生命周期和启动模式</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-2/">Android 开发艺术探索学习笔记（二）</a> - 第 2 章：IPC 机制</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-3/">Android 开发艺术探索学习笔记（三）</a> - 第 3~5 章：View 事件机制等</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-4/">Android 开发艺术探索学习笔记（四）</a> - 第 6, 7, 12 章：Drawable，动画，Bitmap</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-5/">Android 开发艺术探索学习笔记（五）</a> - 第 8, 10, 11 章：Window，线程和线程池，消息机制</li><li>  <a href="https://ajiew.github.io/notes-on-android-art-part-6/">Android 开发艺术探索学习笔记（六）</a> - 第 13~15 章：综合技术，JNI 和 NDK，性能优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九月，去菲律宾看海</title>
      <link href="/philippines/"/>
      <url>/philippines/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2019-09-24/9-23-liangzhu-on-the-river.jpg"></p><p>夏天刚开始的时候，和陈斌约好中秋节去菲律宾玩一个礼拜，我们两个差不多讨论了一个夏天，然后订机票、预订酒店和民宿、办签证、学游泳（我是个旱鸭子），等到真要出发的时候才意识到，时间怎么过得这么快。</p><p>因为我们都是第一次出国，没有什么经验，所以行程基本都是在国内提前预订好的。另外也看了不少攻略，希望能在有限的时间和资源之内尽可能玩得开心。现在回想起来，其实还是有很多地方没有做足准备，有点措手不及，不过毕竟是第一次，总的来说，这趟旅行体验还是很不错的，如果满分 10 分，我觉得至少可以打 8 分吧。</p><p>对于出门远游，我个人觉得如果能不跟团就尽量不要跟团，因为体验会差很多很多。另外，决定你这趟旅行体验的一大部分因素是——和你一起出游的伙伴。所以，尽量选择 1~3 个信的过、靠谱的人。我觉得三个人出游是最棒的，既可以相互照应，又可以避免出现意见分歧时的僵持（由第三个人来做最终决定´͈ ᵕ `͈）。</p><span id="more"></span><p>以下是我旅行中记录的一些流水账（是真真正正的流水账）还有拍的一些照片，仅作为个人记录。涉及隐私，我保留版权，请不要传播到其他地方，谢谢~(´▽`ʃƪ)</p><hr><p>2019/9/12 天晴</p><p>今天是出发后的第一天，昨天下午坐动车到虹桥，然后从虹桥坐地铁 2 号线到浦东国际机场，9 点多开始等待 check in 排队，10 点 30 开始 check in，然后 11 点通过安检进入候机大厅。在里面逛了下日上免税店，我没啥要买的，就找了个座位坐着玩了会手机，后来实在有点困，戴着眼罩和旅行枕靠了一会儿，1 点开始登机，在飞机上睡了一小会儿，但是没怎么睡好。</p><p>今天早上 5 点左右到达马尼拉，然后排队写 arrival card，之所以要排队是因为只有一个地方有公用的笔，所以出门还是尽量自己准备好纸笔，以防万一。然后接着排队等待入境，又排了一个多小时。</p><p>7 点多在机场大厅吃完早餐，然后去大厅门口买了张 sim 卡。由于飞机晚点，还有 5 个小时才能乘坐去杜马盖地的飞机，于是听卖卡小哥的建议打算去 Mall of Asia 逛逛。</p><p><img src="../assets/2019-09-24/9-12-manila-church.jpg"></p><p><img src="../assets/2019-09-24/9-12-manila-coast.jpg"></p><p>去了之后才发现那边附近有条海滨大道，由于是清晨，偶尔看到有几个晨跑的人，周边是游乐场，可是没到开放的时间。于是在附近走了走，发现也真没啥可逛的，而且也没有共享单车或者摩托车可以租，商场也还没开门，加上天气闷热还下起了小雨，最终我们决定回机场。</p><p>回去的路上和 Grab 司机聊了聊，不过因为英语水平有限，加上他们的口音（估计他听我的 chinglish 也够费劲），只能大概聊聊，发现他们一个月收入折合人民币差不多只有 5000 多人民币。司机聊天告诉我们附近哪哪是 casino，问我们要不要去玩，我心想我们看起来像是能去得起那种地方的人吗！(´⊙ω⊙`)！</p><p>回到机场的时候还出了一个小插曲，机场安检保安一开始不让我进，说雨伞不能带进去，好说歹说才同意让我去值机柜台问问，到值机柜台那，柜台小姐姐也告诉我雨伞是不能 hand take 的，只能托运，而且托运这种小物件还必须要有个 bag or box 装着才可以，于是又凭着我的自己听都觉得尴尬的口语和对方交涉了半天，最终发现原来用一个环保袋装着就可以了，也真是不容易。</p><p>安检进候机厅的时候又被拦了下来，因为检测到我包里还有电子产品没拿出来，安检小哥仔细翻看了我包里所有的东西，最后来了句 “You’re YouTube vlogger?”。我一开始没搞懂，后来想了想，其实他们应该是很欢迎那种旅行博主的，因为可以帮助宣传发展当地的旅游业嘛，也可能是我想多了吧。</p><p>在马尼拉 T3 航站楼的座位上玩了 2 小时 FIFA mobile，然后和陈斌去吃午饭，算是来这边后的第一顿正餐，我点了一个炒面和一个芒果冰沙，味道都不怎么样，随便扒拉了几口完事。</p><p>终于登机了，机组 crew 都好热情，虽然没坐过几次飞机，但是依然能感觉到和国内比是天壤之别。上了飞机后突然觉得困的不行，睡了一路，醒来就到 Dumaguete 了，这边机场很小，小到只有一条跑道，不过还好没再下雨，开始放晴了，风吹得人暖洋洋的。</p><p><img src="../assets/2019-09-24/9-12-dumaguete-airport.jpg"></p><p>由于做过攻略，出机场后就直奔附近的 Tutu 车停车场，攻略上看到说坐 Tutu 车可以往死里砍价，我们也打算至少砍一半，但是一到现场，我们两个立马就怂了，司机说多少就多少吧。后来才发现我们住的 hotel 其实就在机场附近，那个司机要的价格是正常情况的十倍，不过也认了，谁让我们心软呢ㄟ( ▔, ▔ )ㄏ。</p><p><img src="../assets/2019-09-24/9-12-dumaguete-hotel.jpg"></p><p>入住后把东西整理了下，然后就收拾了下出门预约明天去 Apo 潜水的船。到了后发现那个潜水店叫 Harolds，小武哥的英文名，哈哈。然后去附近小卖部买了点一次性的洗漱用品，又看了美团上的热门推荐去了那家好像口碑很好的餐厅 Mooon Cafe 打卡。第一次吃当地口味的餐厅，感觉…也就一般吧，对我来说菜品稍微有点辣。</p><p>之后去杜马盖地的海滨大道逛了逛，拍照打卡。</p><p><img src="../assets/2019-09-24/9-12-dumaguete-coast-square.jpg"></p><p>晚上回酒店后早早地洗澡上床睡觉了，今天真的是特别累了。</p><hr><p>2019/9/13 阵雨</p><p>今天早上 4 点半就醒了，昨晚 8 点不到就睡了，应该是我这一周以来睡的最舒服的一觉了，突然觉得酒店的床睡的特别踏实，特别舒服。</p><p>整理好背包换好衣服就出发去潜水店了，外面下起了小雨，到了之后发现店门关着，于是先去附近早餐铺里随便买了点早饭吃。再去那边时门口有几个人坐在台阶上，一问才知道所有去 Apo 的船都停开了。最担心的事果然还是发生了。</p><p>难免有点沮丧，即使现在更改行程也不太可行，因为酒店、机票都已经订好，更改太麻烦而且也太费钱，所以我们决定今天就在杜马盖地市区或者附近逛一天。</p><p>回酒店后，陈斌还是没完全死心，又看了攻略，然后提议我们自己坐车去 Malatapay 码头碰碰运气，如果能出船的话就自己租船去 Apo 岛，然后到那边再找人带我们去浮潜。</p><p>说走就走，我们租了一辆 Tutu 车过去，一路上风雨交加，快到码头的时候，天已经开始放晴了。尽管如此，在码头打听了下，这里今天也不开船。于是我们只能在海岸边逛了逛。</p><p><img src="../assets/2019-09-24/9-13-malatapay-coast.jpg"></p><p>这应该是我第一次真正见到大海吧，虽然海滩上的沙子都是黑色的（不是脏，可能是参杂了黑色的矿物质），但是我还是在沙滩上玩了很久，还把人字拖给玩丢了，被浪花冲到不知道哪里去了(」・ω・)」。</p><img src='../assets/2019-09-24/9-13-malatapay-beach.jpg' width=70%><p>回去的时候，Tutu 车司机建议我们去 Dauyin 碰碰运气，不过我们觉得今天这天气阴晴不定的，还是放弃了，决定去机场附近的 Silliman Beach 看看。</p><p>到了那边才发现其实也是黑海滩，而且海滩上都是渔民的渔船，有些一家人就住在海岸边搭的小棚子里。不过更惊讶的是，刚好碰到有飞机降落，这应该是我这辈子第一次这么近距离观察到飞机降落了吧。</p><p><img src="../assets/2019-09-24/9-13-plane-landing.jpg"></p><p>回酒店后换了身衣服（之前穿的沙滩服），然后我走路去附近的商场买了两条毛巾和一双拖鞋。近距离观察了下这边的街道，怎么说呢，给人一种乱糟糟的感觉，而且有点脏乱，可能毕竟小地方吧。</p><p>中午我们决定去 Robinson mall 吃午饭，那边有家 Hukad 餐厅，似乎是当地人比较喜欢去的餐厅。吃了下觉得的确非常棒，有点出乎意料，菜品都不错，而且价格也非常公道，可惜忘记拍菜单了。</p><p>下午去附近的几个景点逛了下，Chinese Bell Church, Siliman University, 杜马盖地塔楼等等。</p><p><img src="../assets/2019-09-24/9-13-silliman-university.jpg"></p><p><img src="../assets/2019-09-24/9-13-silliman-university-church.jpg"></p><img src='../assets/2019-09-24/9-13-dumagaute-tower.jpg' width=70%><img src='../assets/2019-09-24/9-13-chinese-temple.jpg' width=70%><p>然后还在 Siliman 大学遇到一对 CP，难得遇上同胞（后来才发现其实到处都能碰上中国人），和他们聊了聊来的路上的感受，机票、回程路线、景点等等，还加了微信。</p><p>之后回酒店休息了一会儿，晚上决定去杜马盖地海滨大道附近的一家餐馆吃晚饭，是我随便 google 到的。在那看到不少西方面孔的外国人。我和陈斌都喝了一点啤酒，然后他和我分享了追他女友的过程以及一些心得´͈ ᵕ `͈，然后还帮我分析了下为何我目前依旧单身。。。我觉得自己的确有时候做事不够果断，想的太多，有时候太担心结果反而不能好好享受过程。</p><p><img src="../assets/2019-09-24/9-12-dumaguete-coast.jpg"></p><p>晚上回酒店后洗漱完就睡了，因为明天去锡基霍尔要早起坐船。</p><hr><p>2019/9/14 天阴</p><p>今天早上 5 点的闹钟，真的很想多睡一会儿，无奈只能强迫自己起床。洗漱完了人还是迷糊着的，然后就坐上了去码头的 tutu 车，因为时间比较早，所以要 100 比索。</p><p>到了码头发现 fast craft 船被 cancel 了，于是我俩商量了下，我排队去买 roro（轮渡）7 点的票，陈斌去退 ocean jet 的船票。</p><p>上了船之后，我有点兴奋，因为第一次坐这样的轮渡，陈斌教了我怎么用 go pro，然后我不停拍着港口和海面，采访陈斌对这趟旅行到目前为止的感受(｡･ω･｡)。我边上坐了一位同样去 Siquijor 旅游的菲律宾人，忘了问他们是哪里人了，也有可能问了但是我忘记了 (-_-)ゞ゛</p><p><img src="../assets/2019-09-24/9-14-dumaguete-port.jpg"></p><p><img src="../assets/2019-09-24/9-14-dumaguete-port-2.jpg"></p><p><img src="../assets/2019-09-24/9-14-dumaguete-roro-sea.jpg"></p><p>大概两个多小时之后，我们到了 Larena 港口，在那里租了一辆摩托车。其实一开始想租两辆的，可是因为我不怎么会骑，我试骑的样子还被女店员嘲笑了，哦不，不是嘲笑，是捧腹大笑的那种，一点都不遮掩。老板告诉我为了安全起见，还是不要自己骑为好。于是，陈斌骑着摩托车带着我，朝预订好的 Airbnb 海滨民宿出发。</p><p>骑到中午还没到，于是在当地有名的快餐连锁店 Jollibee（我们去的几个岛上到处都能见到，老板好像还是中国人），吃了点东西后继续出发。大概 11 点多才到，发现这个民宿还有一个自己的小沙滩可以供我们玩耍，心中暗喜。</p><p><img src="../assets/2019-09-24/9-14-isla-da-paz-beach-resort.jpg"></p><p><img src="../assets/2019-09-24/9-14-san-juan-airbnb.jpg"></p><p><img src="../assets/2019-09-24/9-14-san-juan-coast.jpg"></p><p><img src="../assets/2019-09-24/9-14-san-juan-beach.jpg"></p><p>在海滩边玩了一会儿沙子，陈斌还下去游了一会儿，然后我们就收拾东西出发开始我们的环岛游了(｡◝‿◜｡)！</p><p>一开始想先去 Cambugahay Falls 的，结果中途照着路标去了一个不知名的小瀑布，名字和 Cambugahay 很像，然后还在那里尝试了人生中第一次 swing jump。虽然我跳水姿势跟个傻子一样，而且也喝了很多口水，但是现在想起来还是觉得挺好玩的。唯一觉得可惜的是忘带浮潜装备，没能尽情地玩水。</p><p>然后又去了 Salagdoong Beach，在那边碰到好多好多中国人。那里有个高台跳水，可是我和陈斌都不敢去试。</p><p><img src="../assets/2019-09-24/9-14-salagdoong-beach.jpg"></p><p><img src="../assets/2019-09-24/9-14-salagdoong-beach-2.jpg"></p><p><img src="../assets/2019-09-24/9-14-salagdoong-beach-3.jpg"></p><p>之后继续我们的环岛游，一路拍了好多照片和视频。</p><p><img src="../assets/2019-09-24/9-14-road-roaming-beach-tree.jpg"></p><p><img src="../assets/2019-09-24/9-14-road-roaming-swing-jump.jpg"></p><p><img src="../assets/2019-09-24/9-14-road-roaming-two-idiots.jpg"></p><p><img src="../assets/2019-09-24/9-14-road-roaming-church.jpg"></p><p>晚上在 Larena Triad 山顶餐厅吃了晚饭，然后开始回程。</p><p><img src="../assets/2019-09-24/9-14-peak-cafe-sea-view.jpg"></p><p><img src="../assets/2019-09-24/9-14-peak-cafe-sunset.jpg"></p><p><img src="../assets/2019-09-24/9-14-peak-cafe-panorama-screenshot.jpg"></p><p>晚上骑摩托车都有点怕怕的，虽然不是我在骑，可是有些地方连路灯都没有啊(´−｀) ﾝｰ。</p><div style="text-align:center">这种算比较好的路段了↓</div><img src='../assets/2019-09-24/9-14-going-back-at-night.jpg' width=60%><p>7 点多回到民宿，在沙滩边的躺椅上吹了好久的海风，躺累了就去吊床上继续躺着。吹着海风，听着一阵阵的海浪声，到 9 点多了才去洗澡。</p><p>此刻的我刚洗完澡，在楼下门廊上写今天的游记。然后心里回忆着过去一周的事情，工作上的，还有来这边之后的这几天。逐渐开始回忆起自己过去这二十几年的人生，以及心里有时候会浮现出的那一个个问题：我到底想要过什么样的生活？我想要成为什么样的人？我做的选择是对的吗？如果当初没这么选会发生什么呢？</p><p>还是想办法把目前的事情做好吧，已经发生的事没有办法改变，未来的事谁又能猜得到呢？</p><p>困了，上去睡了。</p><hr><p>2019/9/15 天晴</p><p>昨晚睡的挺晚的，早上却 5 点多就自然醒了，然后赖在床上到 6 点半才起床。洗漱完，去门口逗主人家的小狗玩了一会儿，虽然好像只是一只土狗，但是很活泼很可爱。此刻正在棕榈树下静静地坐着看海，什么都不用想的感觉真好。</p><img src='../assets/2019-09-24/9-15-under-the-palm-tree.jpg' width=70%><img src='../assets/2019-09-24/9-15-leaving-the-beach-house.jpg' width=70%><p>今天我们继续摩托车环岛游，只不过走的是和昨天相反的方向。</p><p><img src="../assets/2019-09-24/9-15-park-at-the-corner.jpg"></p><p><img src="../assets/2019-09-24/9-15-lunch-by-the-sea.jpg"></p><p>我们最后在锡基霍尔码头买了明天去薄荷岛 Tagbilaran 的船票，还在检票口和偶遇的在当地住了 10 多年的葡萄牙人聊了一会儿，还聊到香港现状，他说香港总有一天会恢复平静的，到时候他会带他家人去香港还有大陆玩。看着他骑摩托车带他妻子（很年轻漂亮的本地人）的样子，我心中突然升起了以后可以来这里生活养老的想法，我猜幸福指数应该也挺高的吧。</p><p>继续环岛，下午2点左右到达 Tulapos 海洋保护区，在这里第一次尝试了浮潜，见到了沙丁鱼一样的鱼群，两个导游说下面还有大海龟，可惜我没有看到。因为第一次下海浮潜，浮潜管里偶尔灌进几滴海水，从来没尝过海水的味道，所以让我非常不习惯，才知道原来海水是这么得咸。</p><p><img src="../assets/2019-09-24/9-15-tulapos-before-snorkeling.jpg"></p><p><img src="../assets/2019-09-24/9-15-tupalos-snurkeling-barracuda.jpg"></p><p>浮潜回来后，在海滩边捡了一些贝壳，滩涂上有个秋千，于是我跑了过去。面前是大海，头顶是蓝天，脚下是浅浅的海水，下面是白色松软发着光的沙子，我在秋千上开心得像个孩子。</p><div style="text-align:center">某人 ↓</div><p><img src="../assets/2019-09-24/9-15-tulapos-chen-bin-posing.jpg"></p><p>离开 Tulapos 之后，原本想再出发去 Cambugahay Falls 的，可惜等我们到那边的时候景点已经关门了，只能明早再来了。</p><div style="text-align:center">觉得这画面特有意境↓</div><img src='../assets/2019-09-24/9-15-going-back.jpg' width=70%><p>回来后洗了个澡，舒服多了，然后和陈斌一起看了下用 Go Pro 拍的视频，我们用了防水套，而防水套外壳有层不透明的膜，拍的视频几乎没法看。</p><p><img src="../assets/2019-09-24/9-15-go-pro-redish.jpg"></p><p>晚上我们去附近的路边餐厅吃了晚餐，餐厅服务员小哥很活泼的一个人，还能和我们聊上几句普通话。餐厅后面有人在唱卡拉 OK，来这边发现好多小卖部或者小饭馆里都有这种唱卡拉 OK 的地方，给我感觉这里民风真的好纯朴。饭后和老妈视频了一会儿，然后回民宿沙滩边躺着吹海风。</p><p>美好的一天结束了，期待明天的行程(❁´▽`❁)<em>✲ﾟ</em>。</p><hr><p>2019/9/16 天晴</p><p>今天照例 4 点半就醒了，然后在床上躺了一会儿才起床去洗漱。整理完东西才 6 点半都不到，此刻在沙滩边等待陈斌洗漱完然后出发去 Cambugahay Falls。</p><img src='../assets/2019-09-24/9-16-on-the-gas-station.jpg' width=60%><p>早上 7 点多到达 Cambugahay Falls，又遇到昨天来的时候碰到的那个小哥，原来他是这儿的导游。下去之后发现这边其实这里所谓的瀑布只是两个挺小的水潭而已，上面最高的落差也不过几米。导游小哥看我们有点失望，于是过来怂恿我们去玩树藤跳水，我原本只是想下水游会儿泳，可是耐不住小哥太热情（他们靠这个吃饭的），还是被拉着去跳了两次，这里跳台比第一天去的那个小瀑布高了不少，胸口皮肤被水面撞的生疼。</p><div style="text-align:center">两米高的瀑布↓</div><p><img src="../assets/2019-09-24/9-16-cambugahay-fall-upper-pool.jpg"></p><div style="text-align:center">跳水花大赛↓</div><img src='../assets/2019-09-24/9-16-cambugahay-fall-swing-jump.jpg' width=60%><p>在那边晒了会儿太阳，然后继续赶路。由于时间充足，于是又去了昨天去过的 Tulapos 海洋保护区，发现涨潮了，滩涂都不见了。在那边晃荡半个小时，然后继续赶路去 Larena 码头，换完座位票、交完 Terminal Fee 后我俩无处可去，于是去附近的超市逛了逛。发现这边超市有点像 Costco，有些区域是专门为大批量采购的人提供的，而的确有不少人是开着皮卡买一大堆东西然后在收银柜台结账。</p><img src='../assets/2019-09-24/9-16-larena-supermaket-selfie-with-sunglasses.jpg' width=60%><p>我们挑了不少零食，有些也看不懂是啥，反正就当午餐了，然后去码头休息室等待开船。</p><p>在休息室的时候，看到各个国家、各种肤色的游客聚集在这里，这么一个小地方能如此开放，吸引到全世界这么多游客来玩，感觉真的挺不容易也挺神奇的。</p><p>船开了之后，大概 1 个小时多一点就到了 Tagbilaran 码头，发现那边码头的保安（或许是警察？）还兼职提供介绍摩托车出租业务，他帮我们打电话联系了摩托车出租店的人来接我们。</p><p>租完车我们就去找民宿酒店了，出发之后明显能感觉到这个城市比 Dumaguete 和 Siquijor 都要更发达一些，道路四通八达，也更拥堵。我们走错路，结果绕了一大圈才找到民宿，挺偏僻的一个地方，离市中心很远。</p><p><img src="../assets/2019-09-24/9-16-arriving-tagbilaran-airbnb.jpg"></p><p>整理完东西安顿好之后差不多就 2 点了，于是我们赶紧出发去 Panglao 岛找明天带我们出海的船只。先是来到 Momo Beach，那边有很多潜水店，并没有找到租船的店。然后又来到 Alona Beach，在一个海滩上方正巧碰到了一个独自坐着休息的人，问了才知道他正巧就是专门接游客出海浮潜生意的船长，我们一开始都不太敢相信自己的好运气。于是我们和他谈好租船的价格以及时间。算下来，我们四个人，去 Balicasag 浮潜三个地方，平均每人也只要 100 人民币左右，还是非常划算的。</p><p>之后，船老大还带我们去看了他的船，大概十来米长，能坐 8、9 个人吧。我们在海岸边和他聊了一会儿天，然后付了定金。又遇到他几个朋友在滩涂上捡海货，过去和她们聊了一会儿，发现他们在捡一种和螺狮差不多的东西，据说炖汤很好吃。</p><p><img src="../assets/2019-09-24/9-16-panglao-beach-ships.jpg"></p><div style="text-align:center">可爱的小螃蟹↓</div><p><img src="../assets/2019-09-24/9-16-panglao-beach-crab-in-a-shell.jpg"></p><p><img src="../assets/2019-09-24/9-16-panglao-beach-sunset.jpg"></p><p>之后我们就离开了海滩，去了附近的一家中国人开的餐馆吃晚饭，名字好像是叫 Molly Restaurant，味道不怎么样还死贵死贵的，而且还要收 5% 的小费，果然只有国人才会坑国人。</p><p>晚上走了岛的东面那条路，来的时候走的西面，心想这样我们就算环 Panglao 岛一圈了，哈哈。</p><video id="video" controls="" preload="none" poster="../assets/2019-09-24/VID_20190916_190334.mp4"><source id="mp4" src="../assets/2019-09-24/VID_20190916_190334.mp4" type="video/mp4"></video><p>回到民宿时已经 8 点了，洗漱一下准备好明天出海时用的东西就准备上床睡了。明早 7 点沙滩上集合，从我们住的民宿到那边摩托车要开 40 多分钟，所以我们 6 点左右就得出发。</p><hr><p>2019/9/17 天晴</p><p>早上 5 点多在鸡叫声中醒来，匆匆收拾下就出门了 。</p><img src='../assets/2019-09-24/9-17-early-in-the-morning.jpg' width=60%><p>到了之后，那对上次在 Silliman 大学认识的朋友已经先到了，于是等船长和他的助手朋友来了之后我们就出海了。</p><p><img src="../assets/2019-09-24/9-17-balicasag-on-the-sea.jpg"></p><p>我们今天要先去 Balicasag 岛上的三个地方浮潜，然后再去 Virgin Island。船开了差不多半个小时就到了 Balicasag 岸边，由于两个小伙伴没吃早餐，于是我们等他们吃完早饭再出发去浮潜。</p><div style="text-align:center">船长↓</div><img src='../assets/2019-09-24/9-17-balicasag-captain.jpg' width=70%><p>出发了，今天阳光很好，甚至有点太晒了，还好我带了长袖沙滩服。</p><p><img src="../assets/2019-09-24/9-17-balicasag-beach.jpg"></p><p><img src="../assets/2019-09-24/9-17-balicasag-before-sailing.jpg"></p><p>浮潜看到各种鱼，还有海龟。但是每个浮潜的地方都有好多船，海面上飘着各种各样的人，场面蔚为壮观ʘ‿ʘ。我们基本在每个地方待半个小时左右吧。</p><img src='../assets/2019-09-24/9-17-balicasag-sail-out.jpg' width=60%><img src='../assets/2019-09-24/9-17-balicasag-before-snorkeling.jpg' width=60%><p><img src="../assets/2019-09-24/9-17-balicasag-snorkeling.jpg"></p><p><img src="../assets/2019-09-24/9-17-balicasag-snorkling-selfie.jpg"></p><div style="text-align:center">有人临场学游泳(´Д｀)ﾉ ↓</div><p><img src="../assets/2019-09-24/9-17-balicasag-she-cannot-swim.jpg"></p><p>到 10 点多，我们开始出发去 Virgin Island 附近的珊瑚礁，其实离得也不远，就在 Balicasag 往北开船 10 多分钟吧。那边水下真的超级美，一大片珊瑚礁，各种颜色的鱼在珊瑚礁附近成群游荡，还有许多巨大的海星。我们在那里浮潜好久，我都不想上船了(◍•ᴗ•◍)❤。</p><p><img src="../assets/2019-09-24/9-17-virgin-island-reef.jpg"></p><p><img src="../assets/2019-09-24/9-17-virgin-island-reef-2.jpg"></p><p><img src="../assets/2019-09-24/9-17-virgin-island-reef-3.jpg"></p><p><img src="../assets/2019-09-24/9-17-virgin-island-reef-sea-turtle.jpg"></p><p>然后船老大带我们去了 Virgin Island，其实就是岛礁比较浅的地方。现在想起来，那边的沙子应该就是珊瑚的『残骸』吧。</p><p>岛上人很多，很多人在这里自拍、合照，『岛』中心还有一个小集市，有一些小贩在售卖当地的一些小吃和椰子，我请船长吃了个烤香蕉，然后还被一个卖“珍珠项链”的贩子给缠住了一会儿，“送给妈妈”，还一路跟着我，直到回到船边，看我坚决不买于是改口让我请他吃个烤香蕉，不过我最终还是拒绝了他。不能助长这种讨要吃喝的行为！</p><p>回到沙滩边已经下午 1 点多了，我和陈斌决定回民宿休息一会，告别了那对 CP（其实我们也只是想一起租船，分摊点费用而已）。我们回去走的是 Panglao 岛中间的那条路，这样 3 条主干道我们就都走过了，不过路边风景好像都差不多，学校、饭店、旅馆、大片空地，建筑也没什么特别的。</p><p>回到民宿已经快下午 3 点，我洗了个澡，然后整理了下东西，差不多就 4 点了，去岛上逛是来不及了，于是我们决定待会儿出去吃个晚饭就直接回来了。</p><p>时间还有点早，去门口小卖部买了瓶可乐，然后小卖部老板聊了一会儿天。了解到这店其实是他哥哥的，他是个海员现在正休假，所以在店里帮忙看会儿店。他说他今年 36 岁，有三个娃，最大的儿子正在上高中，这会儿差不多快要放学回来了。他告诉我他去过很多国家，但是如果有机会的话，他会选择带家人去中国而不是去美国旅游，我问为什么，他说因为中国物价更低，而且也有更多好玩的东西，适合带家人过去玩。我心想这和我们来菲律宾旅游的原因是一样的啊，哈哈。</p><p>晚上去了附近的一家我从 Google 上随便搜到的餐厅，结果等菜上来后发现分量多到惊人，我们两个人根本吃不完。而且也没办法打包回去吃，因为明天就要出发回去了。</p><p>回来后，整理了下东西，然后和家人视频了下，发了个朋友圈就睡了，原本想玩下 FIFA 的，可惜这里网络实在太差了。</p><p>凌晨居然被热醒过来，一看时间才 12 点，把空调温度调低之后还是睡不着，肚子很难受，可能是晚上吃的东西太过油腻，消化得不是很好。于是坐在床上冥想，睡不着，只能打开手机继续记一点自己的旅途流水账。</p><p>再过几个小时就要去码头然后离开这里了，心情有点复杂。闭上眼，感觉到整栋房子都在沉睡中，而我，此刻的我，真的是世界上最孤独的人了。</p><hr><p>2019/9/18 阴天</p><p>早上 2 点多终于能躺下睡一会儿了，睡到 5 点钟醒来，洗漱一下马上就要出发了。再见，Bohol Island : )</p><img src='../assets/2019-09-24/9-18-sea-view-back-to-dumaguete.jpg' width=60%><p>（早上 7 点 30）我们登上回 Dumaguete 的船了，算了下时间，大概9点半到。打算到那边先去做个 SPA，然后再出来逛逛。</p><p>（早上 9 点 30）到达码头，坐 tutu 车去 Harolds 那存了下行李，然后就出发去谷歌搜索到的盲人按摩店，350 就可以做一个全身按摩，还是相当划算的。按摩完感觉身体放松了不少。然后找地方吃午餐，Casabulanka Restaurant，完全是被名字吸引，但其实并不怎么好吃，之后就出发去机场了。</p><p>（中午 12 点 40）坐 tutu 车到杜马盖地机场，门口在装修，一开始都没认出来还不敢走进去。</p><p>在 Check in counter 等到 1 点 20 才开始 check in。进候机室后，听着盲人歌手弹的吉他，小睡了一会儿。这边好多公共场合都有盲人表演者，国内好像挺少看到有这种工作的。</p><p>（下午 5 点）抵达马尼拉，飞机延误了大概 20 分钟，下飞机后去同一航站楼找到宿务航班后排队 check in（排队花了 1 小时），然后在航站楼内吃了碗面，又去逛了下免税店和礼品店，把手头的比索全花完了。</p><p>（晚上 7 点 20）开始登机，在飞机上基本没怎么睡。晚上 11 点 20 到达浦东机场，然后去坐机场大巴到虹桥站，大概凌晨 2 点左右到了虹桥。因为 5 点才开始检票入站，所以我们只能在大厅里等，找了个座位睡了大概一个多小时，睡得手脚都麻了，只能坐着看手机，偶尔起来走动一下。</p><p>到了 5 点，开始检票进站，进了候车大厅后赶紧去楼上买了早餐，豆浆油条锅贴，久违的味道。</p><p>7 点到达杭州东站，然后去坐地铁，发现 4 号线转 2 号线也可以坐，而且换站距离更短。</p><p>早上 8 点，出地铁。</p><p>走回小区的路上，看到来来往往赶着通勤上班的人们，有人经过的时候会不由自主地对我这个背着大包小包的人上下打量一番。而今天的天气出奇得好，秋日的阳光照在身上暖洋洋的，突然间我觉得自己好幸运。</p><p>Life is wonderful.</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Travel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30 分钟创建域名并关联 Github Pages</title>
      <link href="/bind-custom-doman/"/>
      <url>/bind-custom-doman/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2019-09-10/mydomain.jpg" alt="My Domain"></p><blockquote><p>  本篇介绍下如何在 30 分钟内给自己的博客添加一个域名，其实我只花了十分钟左右。So，现在开始计时吧~</p></blockquote><h3 id="开始前的准备"><a href="#开始前的准备" class="headerlink" title="开始前的准备"></a>开始前的准备</h3><ol><li><p>想好需要注册的域名，同时选择一个域名注册服务提供商</p><p>域名注册服务提供商有很多，比如 <a href="https://www.godaddy.com/">GoDaddy</a>，<a href="https://www.namecheap.com/">Namecheap</a>，<a href="https://www.bigrock.in/">BigRock</a>，<a href="https://www.hover.com/">hover</a> 等等。用哪个其实都差不多，因为这几个用的人都还蛮多的，我用的是 GoDaddy，你可以选择你自己喜欢的。</p></li><li><p>注册一个 <a href="https://www.cloudflare.com/">Cloudflare</a> 账户</p><p>Cloudflare 应该是目前最好用的域名解析、托管服务提供商了，它不但支持 HTTPS、自定义浏览缓存策略以及 Page Rules，还能自动帮你缩减静态资源，最关键的是它配置起来足够简单而且<strong>免费</strong>。</p></li></ol><p>如果你以上东西都准备好了，那我们就可以开始了。</p><span id="more"></span><h3 id="第一步：注册域名"><a href="#第一步：注册域名" class="headerlink" title="第一步：注册域名"></a>第一步：注册域名</h3><p>去<a href="https://www.godaddy.com/domainsearch/find">域名搜索页面</a>搜索你想要注册的域名，一般后缀为 <code>.me</code> 或者 <code>.cc</code> 之类的域名价格都不贵，适合做个人博客域名。 挑好域名后添加到购物车，选择支付方式（可以用 AliPay），然后填写好账单信息并支付就 ok 了。</p><h3 id="第二步：在-Cloudflare-上添加你的网站域名"><a href="#第二步：在-Cloudflare-上添加你的网站域名" class="headerlink" title="第二步：在 Cloudflare 上添加你的网站域名"></a>第二步：在 Cloudflare 上添加你的网站域名</h3><p>首先登入 <a href="https://dash.cloudflare.com/">Dashboard</a>，选择右上角的 <strong>Add a Site</strong>，然后输入你的域名并确认添加。</p><p>接下来我们需要添加两条 A 记录，用于指向 Github 服务器的 IP 地址，从而实现通过域名访问我们的 Github 静态页面。参考 <a href="https://help.github.com/en/articles/setting-up-an-apex-domain#configuring-a-records-with-your-dns-provider">Github 帮助页面</a>，添加以下两条 A 记录：</p><ol><li>185.199.109.153</li><li>185.199.110.153</li></ol><p>除了 A 记录之外，我们还需要添加一条 CNAME 记录来为我们的域名设置别名，比如添加 <code>www</code> 的前缀。</p><p>设置完 DNS 之后大概是这样的：</p><p><img src="../assets/2019-09-10/Cloudflare-setup.png" alt="Cloudflare-setup"></p><h3 id="第三步：修改域名服务器"><a href="#第三步：修改域名服务器" class="headerlink" title="第三步：修改域名服务器"></a>第三步：修改域名服务器</h3><p>完成上一步之后还不能直接访问我们的域名，我们会看到 Cloudflare 提示我们需要修改域名服务器：</p><p><img src="../assets/2019-09-10/Cloudflare-nameservers.png" alt="Cloudflare-nameservers"></p><p>首先登录进你注册域名的管理控制台，然后使用自定义的域名，填入 Cloudflare 提供的域名服务器，具体可以参考你的注册商提供的帮助文档：</p><ol><li><a href="https://www.godaddy.com/help/set-custom-nameservers-for-domains-registered-with-godaddy-12317">GoDaddy</a></li><li><a href="https://www.namecheap.com/support/knowledgebase/article.aspx/767/10/how-to-change-dns-for-a-domain">Namecheap</a></li><li><a href="https://manage.bigrock.in/kb/servlet/KBServlet/faq455.html">BigRock</a></li></ol><p><img src="../assets/2019-09-10/update-nameservers.png" alt="update-nameservers"></p><p>修改完成之后大概需要十几分钟到几个小时的时间才能生效，生效之后就可以访问你的域名啦，是不是很简单？</p><h3 id="Cloudflare-的其他配置"><a href="#Cloudflare-的其他配置" class="headerlink" title="Cloudflare 的其他配置"></a>Cloudflare 的其他配置</h3><p>以上只是让我们的网站可以通过域名来访问，仅仅能访问当然是不够的，我们一般还需要考虑如何提高网站的访问速度，使用缓存策略、HTTPS 等等。</p><h4 id="Auto-Minify"><a href="#Auto-Minify" class="headerlink" title="Auto Minify"></a>Auto Minify</h4><p>在 <strong>Speed</strong> 一栏找到  <em>Auto Minify</em>，然后选中所有：JavaScript/CSS/HTML。配置完这个之后可以让 Cloudflare 自动帮你缩减网站上的资源，从而减少浏览器请求资源需要的加载时间。</p><p><img src="../assets/2019-09-10/auto-minify.png" alt="auto-minify"></p><h4 id="Browser-Cache-Expiration"><a href="#Browser-Cache-Expiration" class="headerlink" title="Browser Cache Expiration"></a>Browser Cache Expiration</h4><p>在 <strong>Caching</strong> 一栏找到 <em>Browser Cache Expiration</em>，用来配置用户浏览器中我们网站的缓存要保存多久。这里我设置成 8 天，不建议设置成太长。</p><p><img src="../assets/2019-09-10/browser-cache-expiration.png" alt="browser-cache-expiration"></p><h4 id="配置-Page-Rules"><a href="#配置-Page-Rules" class="headerlink" title="配置 Page Rules"></a>配置 Page Rules</h4><p>Page Rules 可以控制当用户访问我们域名下某个特定的 URL 时触发的一些事件，比如重定向等。</p><p>我们需要配置以下 Page Rules，用于：</p><ol><li>将所有 <a href="http://www.ajiew.me/">www.ajiew.me</a> 下的访问重定向到 ajiew.me 下；</li><li>将所有非 HTTPS 的访问重定向到使用 HTTPS 访问；</li></ol><p>进入 Page Rules 配置栏，选择 Create Page Rule，然后待匹配地址栏填入 <code>www.ajiew.me/*</code>，对应的规则为：Forwarding URL - 301 Permanent Redirect，目标地址为 <code>http://ajiew.me/$1</code>。</p><p><img src="../assets/2019-09-10/page-rules-redirect.png" alt="page-rules-redirect"></p><p>设置完之后点击 Save and Deploy 就可以了。</p><p>然后是默认使用 HTTPS，同样的先创建一条 Page Rule，目标地址为 <code>http://ajiew.me/*</code>，规则选择 Always Use HTTPS，最后 Save and Deploy。</p><p><img src="../assets/2019-09-10/page-rules-https.png" alt="page-rules-https"></p><h4 id="配置-HSTS"><a href="#配置-HSTS" class="headerlink" title="配置 HSTS"></a>配置 <a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HSTS</a></h4><p>HSTS 是一种网站安全策略，用于强制让浏览器使用 HTTPS 与网站进行通信。开启之后，如果用户之前访问过你的网站，那么 TA 之后的访问都将直接通过 HTTPS，而不需要 Page Rules 的转发规则来访问了。这样也能变相加快网站的访问速度。</p><p>但是开启这一项之前，需要先保证你的网站上有已激活的 <em>SSL 证书</em>，在 <strong>SSL/TLS</strong> 中，SSL 显示如下：</p><p><img src="../assets/2019-09-10/ssl-certificate.png" alt="ssl-certificate"></p><p>接下来往下拉到 <strong>Always Use HTTPS</strong> 部分，选择开启。</p><p><img src="../assets/2019-09-10/https-hsts.png" alt="https-hsts"></p><p>然后选择 <strong>Change HSTS Settings</strong>，需要你先同意声明，然后再打开所有选项就 ok 了。</p><img src="../assets/2019-09-10/enable-hsts-settings.png" width="50%"/><p>使用了 HSTS 之后，所有的返回数据中都会添加以下 Header：</p><p><img src="../assets/2019-09-10/hsts-header.png" alt="hsts-header"></p><p>到这里，Cloudflare 的配置就都搞定了。</p><h3 id="配置-Github-Pages"><a href="#配置-Github-Pages" class="headerlink" title="配置 Github Pages"></a>配置 Github Pages</h3><p>最后一步，打开项目的 Settings，在 <strong>Custom domain</strong> 中填入你的域名并保存。</p><p><img src="../assets/2019-09-10/github-pages-settings.png" alt="github-pages-settings"></p><p>如果你也使用 Hexo 发布博客，还要在你的 _config 文件中将 url 也修改为你的自定义域名。另外，记得在 source 目录下添加 CNAME 文件，内容是你的域名，如下：</p><p><img src="../assets/2019-09-10/CNAME.png" alt="CNAME"></p><p>这样，每次发布新博客的时候，Github Pages 就能自动关联上你的域名了。</p><p>搞定啦，发个朋友圈庆祝一下吧~ ٩(•̤̀ᵕ•̤́๑)ᵒᵏᵎᵎᵎᵎ</p><p>Cheers! 🖖</p><hr><p>参考文章：<a href="https://www.freecodecamp.org/news/an-illustrated-guide-for-setting-up-your-website-using-github-cloudflare-5a7a11ca9465/">An Illustrated Guide for Setting Up Your Website Using Github &amp; Cloudflare</a></p>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tricks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>松子：活着时从来没有体验过被爱</title>
      <link href="/memories-of-matsuko/"/>
      <url>/memories-of-matsuko/</url>
      
        <content type="html"><![CDATA[<img src="/assets/2019-09-02/matsuko-poster.jpg" width="50%" align="center"><p>七月底的时候似乎觉得夏天还很长，但是转眼到八月底，下了几场雨天气转凉，才意识到秋天马上要来了。季节变化能加强人对时间的感知。</p><p>不知道为什么喜欢在下雨天看电影。下了班后，拉上窗帘，缩在电脑前，窗外淅淅沥沥，屋内昏暗灯光下的我，随着电影里故事情节，去到另一个时空或者世界的另一个角落，跟着主人公们经历各种各样新奇好玩的事。我觉得这就是电影的魅力吧，在短短一两个小时内就让人获得一份从未有过的体验。</p><span id="more"></span><p>以下内容涉及剧透，如果你没看过这部电影但还是坚持往下看的话…..我也不拦着你。</p><h4 id="《被嫌弃的松子的一生》"><a href="#《被嫌弃的松子的一生》" class="headerlink" title="《被嫌弃的松子的一生》"></a><a href="https://movie.douban.com/subject/1787291/">《被嫌弃的松子的一生》</a></h4><p>这部豆瓣 Top 250 被我标记了有好多年了，之前以为这是一部讲述一个老人的一生的故事，所以一直提不起兴趣，但是看了之后才发现不完全是这样。</p><p>松子有一个多病的妹妹，从小父母所有的关爱都被倾注到妹妹身上，松子总是被忽视的那个，于是她想尽一切办法去获得父亲的关注，甚至因为发现扮鬼脸能让过于操劳照顾多病的妹妹而不苟言笑的父亲发笑，而形成了条件反射，一紧张就会不由自主地扮起了鬼脸。</p><p>工作之后的松子，尽管工作认真负责，但是由于一次误会（其实是想帮助犯错的学生）而被迫辞职，又因为这次事件，她和家人爆发矛盾然后离家而去。这里是松子第二次渴望得到爱而又不得的过程，也是松子未来人生走向灰暗的起点。</p><p>离家之后的松子，人生开始一步步失控。和她相爱的第一个男人因为作品不被认可而迁怒于她，最终在一个雨夜里自杀。而后爱上的第二个男人是个有妇之夫，他是出于嫉妒才故意占有松子让她做自己的情妇，因为她是他嫉妒的那个作家的女人。知道真相后的松子失望至极，选择去做土耳其浴女郎，她和家人关系也因此进一步恶化。</p><p>松子遇上的第三个男人（皮条客）让她的人生彻底无法回头。皮条客不仅利用松子，而且挥霍她存在他那里的钱，在一次争执中，皮条客面目狰狞的脸让松子想起了多年前的那个便利店老板，正是因为老板强迫她交出偷东西的学生，她想代替学生认罪，最终被逼无奈辞职。松子用水果刀刺死了皮条客。</p><p>之后松子计划去太宰治自杀的玉水上川自杀，但是由于当时并非雨季水太浅而没能成功，却意外认识了老实巴交的理发师。理发师外表普通，人也显得十分无趣。不过，此刻的松子明显不再追求虚头巴脑的『爱情』，这种普普通通的生活对她来说就是一根救命稻草。理发师给松子换了个发型，但是毕竟杀了人，没过多久松子就被捕入狱。</p><p>狱中的生活重复单调，但是松子无时不刻幻想着出狱后和理发师过上平淡却甜蜜的生活，所以还是对未来充满希望。结果出狱后迎接她的，却是理发师已经和另一个女人结婚生子的现实。</p><p>看到这里，我深吸一口气，觉得已经不能更同情松子了，但是谁知道后面的剧情更加残忍。</p><p>此时的松子已经彻底否定了自己的价值，也放弃了追求更好的生活。由于在狱中学会理发，她找了一份理发店的工作，并且重遇了狱中相识的姐妹。某天晚上下班后，松子意外碰上了当年那个偷东西不肯承认并且害她被迫辞职的学生。在经历了这一切之后，松子早已麻木，当她听说学生陷害她是因为喜欢她这个老师，她竟然心软了。在一个人寂寞的生活与至少有个人陪伴之中，松子选择了后者。</p><p>现实却依旧残酷。学生阿龙现在是一名黑社会成员，尽管松子多次苦口婆心劝他改变，和她一起过上普通人的生活，但得到的却只是阿龙醉酒后的毒打。某天松子没去理发店上班，狱中相识的姐妹来找她，劝她离开他，因为『和这个人渣在一起不会幸福』，松子却答以『你没有权力这么说，即使是地狱我也愿意跟他在一起』，于是她也不再和松子联系了。而松子最终也放弃了想要改变阿龙的想法，选择做一个『黑道的女人』。</p><p>结局也猜的到，在一次挪用帮会的钱去赌，事情败露之后，他请求松子带上钱和他一起躲避帮会的追杀，最终两人在一家旅馆中走投无路，于是准备一起吃安眠药自杀，可是因为安眠药实在难以下咽，最后选择了报警。</p><p>在阿龙入狱之后，松子生活的希望全部寄托在等他出狱的那一天。但是狱中的他痛苦不堪，意识到自己毁了松子的一生，并且也没有能力给予他人幸福。他决定不再和松子见面。</p><p>出狱的那一天，面对前来迎接他的松子，他一拳将她打倒然后夺路而逃。趴在雪地里的松子，又问出了那句本片中多次出现的台词：为什么？没人能够回答她。</p><p>这个时候的松子已经不再奢望获得爱情，于是她再次回到家乡，祈求至少能够被家人接受，获得稍许慰藉。但是妹妹的死讯让她彻底崩溃，而且弟弟把她送到火车站后，也请她不要再回来了。</p><p>在火车上，松子看到了和家乡的筑后川很像的一条河，于是下了车在河川附近租了一间公寓，从此过上了独居生活。她不和陌生人说话，整日把自己锁在房间，和满屋子垃圾一起生活，像青春期少女一样追星，傍晚有时候她会坐在河边，望着对岸的城市发呆。如此日复一日，以至于某天开始出现幻觉，并在出租屋外的墙上写下了那句著名的话：『生而为人，我很抱歉』。</p><p>某天，在出现为妹妹理发的幻觉之后，她决定重新开始生活。但是就在回去找老友名片的时候，却被一群胡闹的中学生用棒球棍打翻在地。就这样，松子手里攥着老友的名片（象征着新生活），结束了自己不幸的一生。</p><hr><p>松子的一生无疑是很惨的，电影开头就借弟弟之口总结了松子的一生，『她的人生真是没意义』。</p><p>她活着时从来没有体验过被别人爱是什么感觉，尤其是因为缺乏父爱，她的童年过得很艰辛。松子第一次感受到父爱，是在父亲死后的一次回家探望，看到在她离家出走后，父亲日记当中每天结尾的一句话都是『依然没有松子的消息』。那时，她的眼泪汹涌而出。</p><p>尽管如此，成年后松子依然渴望并且主动追寻爱情，但是每一次都以失败告终。我觉得，这一方面是由于她对爱情太过盲目，以及行事鲁莽、懒于思考、做事不过大脑的性格，而且有时太过神经质，但是最核心的原因是，她<em><strong>过于渴望爱</strong></em>，就像溺水之人的非自发性吸气，结果是不停地喝水，而且沉得也越快。</p><p>松子的一生提醒了我们，一个人如果不知道或者学不会如何爱自己，那么他/她也无法得到或者留住他人的爱。</p><p>另外，我也特别希望大家能够对身边像松子这样的人的多一点包容，也许他们在常人眼中有时候表现得像个怪人。他们有性格上或者行为方式上一些与众不同的地方，但是如果我们能多一点耐心，近距离观察了解下他们，会发现其实他们也有可爱的一面。</p><p>因为很多时候，我觉得我自己身体里就住着一个松子。不过还好，每当她想要做鬼脸的时候，我会告诉她：没关系，你有我，我会永远爱你。</p><p>[EOF]</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native 实现无白屏启动页</title>
      <link href="/react-native-splash-screen/"/>
      <url>/react-native-splash-screen/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/08/23/5mfsv7tSWwo6Hhj.png" alt="change-rn-splash-screen.png"></p><p>一个 React Native 应用在启动的时候往往不如原生快，这主要是因为 RN 比原生应用多了一层 JS Bridge，需要的初始化的时间也就更长一些。所以如果不做任何改动的话，我们打开应用的瞬间就会观察到短暂的白屏现象。为了更好的用户体验，我们需要想办法去掉这个讨厌的白屏，使得应用在打开时就显示启动页。</p><p>本文主要讨论如何使用 <a href="https://github.com/crazycodeboy/react-native-splash-screen"><strong>react-native-splash-screen</strong></a> 在 Android 和 iOS 上实现无白屏启动页效果。</p><span id="more"></span><h3 id="Android-上启动页的实现"><a href="#Android-上启动页的实现" class="headerlink" title="Android 上启动页的实现"></a>Android 上启动页的实现</h3><h4 id="现有方案的对比"><a href="#现有方案的对比" class="headerlink" title="现有方案的对比"></a>现有方案的对比</h4><p>通常，在 Android 上，我们会为启动页设置以下 Theme:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppTheme.SplashTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;AppTheme&quot;</span>&gt;</span><span class="xml"></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowBackground&quot;</span>&gt;</span>@drawable/start_page_background<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- or even more --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@android:color/white<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowFullscreen&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowContentOverlay&quot;</span>&gt;</span>@null<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过添加 <code>android:windowBackground</code> 来设置启动页背景图，然后再在 SplashScreenActivity 中做路由跳转。但是这在 RN 中显然行不通，因为 RN 里只有一个 <code>MainActivity</code>。</p><p>网上的文章中，有一种方案是通过自己配置一个启动页 activity，在其中对 <code>ReactRootView</code> 以及 <code>ReactInstanceManager</code> 进行预加载，加载完毕后再跳转到 <code>MainActivity</code>。这种做法会有一些副作用，而且也并非完美的解决方案，需要对 <code>ReactActivityDelegate</code> 和 <code>ReactActivityDelegate</code> 进行改造。</p><p>react-native-splash-screen 的作者提供了<a href="https://www.jianshu.com/p/78571e5435ec">一种思路</a>，只要在根视图上添加一个 dialog 遮盖掉白屏，然后等到合适的时机（JS Bundle 加载并渲染完毕后）再隐藏掉这个 dialog。</p><p>这种方法还是非常巧妙的，因为我们不需要对源码做修改，所以不用担心随着 RN 版本的迭代更新而失效，而且也不会对 RN 组件的生命周期造成影响。</p><h4 id="Android-实现细节"><a href="#Android-实现细节" class="headerlink" title="Android 实现细节"></a>Android 实现细节</h4><p>安装 react-native-splash-screen 之后，我们需要添加一个开屏页的布局 <code>launch_screen.xml</code>，理论上来说可以自由添加任何元素，但是不推荐添加过于复杂的布局，一般来说添加一张图片就足够了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;centerCrop&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/bg_splash_screen&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后我们还可以定制化开屏页的主题，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Base application theme. --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.AppCompat.Light.NoActionBar&quot;</span>&gt;</span><span class="xml"></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- use this to delay app launch from a cold start to eliminate blank space --&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- which is not a best practice in splash screen, not recommended --&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!--&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;--&gt;</span></span><br><span class="xml"></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- use this to specify the status bar color --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/primary_dark<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- use this to replace the blank from a cold start --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowBackground&quot;</span>&gt;</span>@drawable/splash<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里有两种选项，一种是直接跳过冷启动的白屏，另一种是替换默认背景图，推荐使用第二种方式。</p><p>然后将主题应用到开屏页：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactActivity</span> </span>&#123;<br><br><span class="hljs-comment">// other code...</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-comment">// you have to add it before super.onCreate</span><br>        SplashScreen.show(<span class="hljs-keyword">this</span>, R.style.AppTheme);<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我将开屏页的主题和 App 主题设置为同一个，这样状态栏颜色就不会发生变化。因为我发现如果开屏页和 App 主题的状态栏颜色不一致的话，会造成启动时状态栏从 App 主题颜色过渡到启动页状态栏颜色，进入主页面后再过渡到 App 主题，效果不是很好。</p><p>看下效果：</p><img src="https://i.loli.net/2019/08/23/pQ3ITXtCWePM51D.gif" width="30%" /><p>由于设置了背景图，冷启动时会观察到从背景图切换到启动页图的效果。</p><h3 id="iOS-上启动页的实现"><a href="#iOS-上启动页的实现" class="headerlink" title="iOS 上启动页的实现"></a>iOS 上启动页的实现</h3><p>iOS 实现原理与 Android 类似，通过添加一个 Launch Image 或者修改 LaunchScreen.xib 来控制启动屏的显示内容，然后等到 JS Bundle 加载完再显示主页面。</p><p>这里我同样通过添加启动页图片来实现，xCode 中选择 Images.xcassets，然后 + → App Icons &amp; Launch Images → New iOS Launch Image，选中 LaunchImage 并在右侧的 Attribute Inspector 中选择你需要支持的屏幕。最后将准备好的启动页图片拖到对应的型号下就可以了。附上启动页图片大小参照：<a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/launch-screen/">Static Launch Screen Images</a></p><p>添加完启动页图片后，还需要修改以我们新添加的图片作为启动页，在 xCode 中选择 General → App Icons and Launch Images → Launch Images Source → Use Asset Catalog，再选择我们新添加的 LaunchImage 就可以了。注意可能要将 app 卸载后重新安装后，修改的启动页图片才可能生效。</p><p>效果图如下：</p><img src="https://i.loli.net/2019/08/23/AUw3T5sBoXevWCr.gif" width="30%" /><p>可以看到 iOS 上有一点和 Android 不同，由于 iOS 没有冷启动机制，所以不会出现背景图切换的问题。</p><p>代码见：<a href="https://github.com/aJIEw/HeadFirstRN/blob/master/app/redux/router/AppRouter.js">AppRouter</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 第三方服务踩坑记录</title>
      <link href="/android-third-party-service-notes/"/>
      <url>/android-third-party-service-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/08/20/faDm3KF7r5nUwlb.png" alt="Server Error"></p><blockquote><p>  这篇主要记录下自己在使用一些第三方服务时遇到的问题以及解决方法。</p></blockquote><h3 id="高德定位-API"><a href="#高德定位-API" class="headerlink" title="高德定位 API"></a>高德定位 API</h3><p>有天 debug 时突然发现 app 定位功能不能用了，然后看了下 log，发现使用的高德定位 API 有如下报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">debug: uploadlocation W/System: Ignoring header cookie because its value was <span class="hljs-keyword">null</span>.<br>debug: uploadlocation W/onLocationChanged: &#123;<span class="hljs-string">&quot;data&quot;</span>:<span class="hljs-string">&quot;保存成功&quot;</span>,<span class="hljs-string">&quot; status&quot;</span>:<span class="hljs-number">0</span>&#125;<br>debug W/System.err: com.amap.api.services.core.AMapEXception: 用户MD5安全码未通过<br>debug W/System.err: at com.amap.api.col.sl.t.a(CoreUtil.java:<span class="hljs-number">137</span>)<br>debug W/System.err: at com.amap.api.col.sl.t.b(CoreUtil.java:<span class="hljs-number">108</span>)<br>debug W/System.err: at com.amap.api.col.sl.k.a(BasicHandler.java:<span class="hljs-number">107</span>)<br>debug W/System.err: at com.amap.api.coL.sl.k.g(BasicHandler.java:<span class="hljs-number">142</span>)<br>debug W/System.err: at com.amap.api.col.sl.k.a(BasicHandler.java:<span class="hljs-number">116</span>)<br>debug W/System.err: at com.amap.api.col.sl.be.getFromLocation(GeocodeSearchCore.java:<span class="hljs-number">86</span>)<br>debug W/System.err: at com.amap.api.col.sl.be$<span class="hljs-number">1.</span>run(GeocodeSearchCore.java:<span class="hljs-number">144</span>)<br>debug W/System.err: at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="hljs-number">1162</span>)<br>debug W/System.err: at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="hljs-number">636</span>)<br>debug W/System.err: at java.lang.Thread.run(Thread.java:<span class="hljs-number">764</span>)<br></code></pre></td></tr></table></figure><p>经搜索，查询到造成这种错误的原因主要是 API Key 和绑定的应用包名不一致。</p><span id="more"></span><p>然后意识到自己前几天改过 gradle 配置，在 debug 版本中加入了后缀：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">debug &#123;<br>    applicationIdSuffix <span class="hljs-string">&quot;.debug&quot;</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，这就需要为测试版 app 单独添加一个 API Key，然后修改 build.gradle 添加变量 <code>amap_api_key</code>：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle">buildTypes &#123;<br>    release &#123;<br>        minifyEnabled <span class="hljs-keyword">false</span><br>        ...<br>        resValue <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-string">&quot;app_name&quot;</span>, <span class="hljs-string">&quot;@string/app_name_release&quot;</span><br>        resValue <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-string">&quot;amap_api_key&quot;</span>, <span class="hljs-string">&quot;release_api_key&quot;</span><br>    &#125;<br>    debug &#123;<br>        applicationIdSuffix <span class="hljs-string">&quot;.debug&quot;</span><br>        ...<br>        resValue <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-string">&quot;app_name&quot;</span>, <span class="hljs-string">&quot;@string/app_name_debug&quot;</span><br>        resValue <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-string">&quot;amap_api_key&quot;</span>, <span class="hljs-string">&quot;debug_api_key&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在 <code>AndroidManifest.xml</code> 中修改高德地图 API Key 的值：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell">&lt;meta-<span class="hljs-class"><span class="hljs-keyword">data</span></span><br>     android:name=<span class="hljs-string">&quot;com.amap.api.v2.apikey&quot;</span><br>     android:value=<span class="hljs-string">&quot;@string/amap_api_key&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>这样问题就解决了。</p><p>顺便记录下如何修改 debug 版本的图标，在 src 下添加一个 debug 文件夹（和 main 同级），然后添加 res 文件夹，然后修改 debug 图标的命名和 main/res 下一致，再放到对应的文件夹下就可以了。如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">src<br>|—debug<br>|———res<br>|————mipmap-XXX<br>|—————ic_launcer.png<br>|—main<br>|———res<br>|————mipmap-XXX<br>|—————ic_launcer.png<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一加 7 Pro 解锁 Daydream 教程</title>
      <link href="/enable-daydream-on-oneplus-7-pro/"/>
      <url>/enable-daydream-on-oneplus-7-pro/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/08/04/uybqvoR9G3U5aVh.png" alt="Google Daydream"></p><blockquote><p>  2019/10/15 更新：Google 在 Pixel 4 发布时宣布不再支持 Daydream 平台， 现有的 Daydream 用户可以继续使用。相关新闻：<a href="https://www.techtimes.com/articles/245730/20191018/google-ends-daydream-vr-experiment.htm">Google Ends Daydream VR Experiment</a>: “There hasn’t been the broad consumer or developer adoption we had hoped, and we’ve seen decreasing usage over time of the Daydream View headset.” Who’s fault is that?</p></blockquote><p>一加系列手机大多都支持 Daydream 平台，只不过 Google 做了限制，使得除了 Pixel 系列以及和 Google 有合作的手机厂商之外的手机，都被标识为『不兼容』，所以为了使用 Daydream，我们就需要用一些特殊的手段绕过这种限制。</p><p>这篇文章主要参考了 <a href="https://forum.xda-developers.com/mobile-vr/google-daydream-vr/magisk-daydream-cardboard-enabler-nfc-t3917601">Daydream Enabler + NFC Workaround + Controller [Magisk]</a>，如果英文不错的话建议直接阅读原文。</p><p>我们主要通过一个 <a href="https://github.com/topjohnwu/Magisk">Magisk</a> 模块来使一加 7 Pro 伪装成 Pixel 手机，从而解锁 Daydream，所以首先需要先安装好 Magisk。</p><span id="more"></span><h2 id="第一步：安装-Magisk"><a href="#第一步：安装-Magisk" class="headerlink" title="第一步：安装 Magisk"></a>第一步：安装 Magisk</h2><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>如果你的手机还没解锁的话，那么要先解锁。第一次解锁会清除你手机上<em><strong>所有的数据</strong></em>，所以记得做好备份。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入 bootloader</span><br>adb reboot bootloader<br><span class="hljs-comment"># 解锁</span><br>fastboot oem unlock<br></code></pre></td></tr></table></figure><p>使用音量键选择最下面的 <code>unlock the bootloader</code>，然后等待重启完毕。</p><h3 id="刷入-Twrp"><a href="#刷入-Twrp" class="headerlink" title="刷入 Twrp"></a>刷入 Twrp</h3><p>Twrp 是一个常见的第三方 recovery，有了它我们就可以随心所欲地刷机了。</p><p>解锁重启手机之后，先去 <a href="https://twrp.me/oneplus/oneplus7pro.html">twrp</a> 官网下载对应版本的 twrp 镜像和 zip 包，这里欧版和美版没啥区别，我用的是欧版。</p><p>然后将 zip 包放到 download 目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb push twrp-installer-3.3.1-4-guacamole /sdcard/downlaod/<br></code></pre></td></tr></table></figure><p>刷入 twrp 镜像（单次有效）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fastboot boot twrp-3.3.1-4-guacamole\ 00.05.25.img<br></code></pre></td></tr></table></figure><p>然后在 twrp 中找到 zip 包刷入 twrp (永久有效，twrp 成为手机默认 recovery)。</p><h3 id="刷入-Magisk"><a href="#刷入-Magisk" class="headerlink" title="刷入 Magisk"></a>刷入 Magisk</h3><p>下载 <a href="https://github.com/topjohnwu/Magisk/releases">Magisk</a> (在 Magisk Manager 下面) 后放入 sd 卡。目前 (2019/8/4)，最新的 Magisk 版本为 v19.3，Magisk Mangaer 最新版本为 v7.3.2。然后重启进入 twrp：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">adb reboot recovery</span><br></code></pre></td></tr></table></figure><p>同样的，在 download 中找到 Magisk 的 zip 安装包后，右滑刷入并重启。</p><p>进入系统后使用 <code>adb shell</code> 和 <code>su</code> 来验证 root 是否成功。</p><h2 id="第二步：安装-Daydream-和-Daydream-Enabler"><a href="#第二步：安装-Daydream-和-Daydream-Enabler" class="headerlink" title="第二步：安装 Daydream 和 Daydream Enabler"></a>第二步：安装 Daydream 和 Daydream Enabler</h2><h3 id="Daydream"><a href="#Daydream" class="headerlink" title="Daydream"></a>Daydream</h3><p>首先安装 <a href="https://www.apkmirror.com/apk/google-inc/daydream-daydream/">Daydream</a>：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">adb install com<span class="hljs-selector-class">.google</span><span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.vr</span><span class="hljs-selector-class">.home_xxx</span>.apk<br></code></pre></td></tr></table></figure><p>之后打开 Daydream app，跟着引导完成基本设置后，这时会看到手机黑屏，同时听到鸟鸣声等，说明进入了 Daydream 初次进入时的欢迎页面。</p><p>然后杀掉 App &gt; 重新打开 &gt; 点击右下角按钮进入 VR 模式，出现提醒 “Daydream is not compatible with your phone”。到这里 Daydream 的配置完毕，我们可以开始安装 Daydream Enabler 了。</p><h3 id="Daydream-Enabler"><a href="#Daydream-Enabler" class="headerlink" title="Daydream Enabler"></a>Daydream Enabler</h3><p>安装 <a href="https://github.com/topjohnwu/Magisk/releases">Magisk Manager</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb install MagiskManager-v7.3.2.apk<br></code></pre></td></tr></table></figure><p>然后下载 @<a href="https://forum.xda-developers.com/member.php?u=7325575">jigs4wkiller</a> 提供的 <a href="https://drive.google.com/drive/folders/1cQ9e4F38Nz125tcNCVZ0cBoOBkVzVqDn">Daydream Enabler</a>，一加7 Pro 的分辨率是 3120x1440，所以选择最接近的版本 2960x1440，然后把 zip 包放到 sd 卡中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb push DayDream-enabler-PXL3_XL.zip /sdcard/downlaod/<br></code></pre></td></tr></table></figure><p>打开 Magisk Manager，在 Modules 中选择添加按钮，找到并选择 DayDream-enabler，等待刷入 Module，完成后会重启手机。</p><p>重启之后，你的手机就伪装成 Pixl 3 XL 了，再次打开 Daydream 就可以成功进入 VR 模式了。</p><p>尽情享受 Daydream 吧！</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>安装了 Daydream Enabler 之后，一加 7 Pro 就接收不到 OTA 升级提醒了，所以每次升级都会稍微麻烦一点：</p><ol><li> 首先在 Magisk Manager 中取消勾选 Daydream enabler</li><li> 重启手机，然后在设置中检查系统更新</li><li> 下载并安装系统更新，安装完成后<strong>不要</strong>点重启</li><li> 打开 Magisk Manager，选择 Install Magisk - Install - Install to Inactive Slot (After OTA)</li><li> 重启手机</li></ol><p>而且除此之外，Daydream 在一加 7 Pro 上只能使用 60 Hz 的屏幕刷新率，这对一加 7 Pro 来说也是种限制以及对性能的浪费。</p><p>当然如果你不常使用 Daydream 的话，随时可以关闭 Daydream enabler 然后设置回 90 Hz 的屏幕刷新率。</p><p>最后我想说，谷歌对 Daydream 平台的使用限制的确让人挺不爽的，这种做法当然可以用适配问题、监管问题来解释，但是如果能够开放 Daydream 平台，让更多的用户可以参与进来，无论是对平台还是对开发者来说都是一件好事，未来 Daydream 平台也能更好地发展。而不是像现在这样死死把着入口，这既不能取悦用户，也不能提升来自开发者的好感。</p><p>希望有一天这篇教程可以失去价值(๑•͈ᴗ•͈)。</p>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tricks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 年中盘点</title>
      <link href="/2019-half/"/>
      <url>/2019-half/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/08/25/j3KWUuV4tNMTzvy.jpg" alt="IMG_20190701_183502.jpg"></p><p>去年写了一次<a href="https://ajiew.github.io/2018-half/">年中小结</a>，觉得写总结这件事，其实并没有多大意义，更多的是一种仪式感吧，用来敦促、提醒自己：时间过得很快，与其白白浪费掉不如抓紧点做点事情出来。</p><p>看了下自己这半年来的 git 提交日志，没啥亮点，基本都是一些琐碎的东西：</p><p><strong>物流：</strong></p><ul><li>  添加一些小功能、优化 UI、修改 Bug</li></ul><p><em>非业务方面：</em></p><ul><li>  通知与权限适配</li><li>  启动优化、App 瘦身等</li><li>  多个 WebSocket 连接的问题</li><li>  通话录音 (AAC)</li><li>  添加埋点统计</li></ul><p><strong>收银机：</strong></p><ul><li>  添加一些小功能、优化 UI、修改 Bug</li></ul><p><em>非业务方面：</em></p><ul><li>  Fragment 中数据、状态的保存与恢复</li><li>  性能优化（解决内存泄露，Presentation 加载的问题）</li></ul><p><strong>C 端 App：</strong></p><ul><li>  添加一些小功能、优化 UI、修改 Bug</li></ul><p>真的非常平淡无奇，但是相比去年，我觉得现在的自己最大的变化是变得更加自信了吧，两个 Android 项目基本上所有的细节都修改过一遍了，优化了 80% 以上的代码。至于 C 端 React-Native 项目，目前正着手修改做 4.0 版本，相信最终也会修改至少 80% 以上的代码。</p><p>另外，现在的自己，无论是做功能还是修改 bug 都比较得心应手了，因为项目功能和大部分细节都已多次修改，相关的一些比较 tricky 的点心里也都有数了，哪怕是比较难解决的问题，多花点时间基本也都可以搞定。</p><p>所以，此刻的自己又开始不安分起来：下一步是不是该考虑换个平台了呢？也许吧，但是未来半年大概率还是会继续做下去，把各个功能细节完善优化好，然后继续提升自己的技术<strong>深度</strong>和广度。</p><p>毕竟自己还是很清楚自己的劣势在哪里的，技术深度不够，基础也不怎么好，像算法和网络基础都不是很好，只是空有一些肤浅的项目经验应该很快就会进入技术瓶颈期。况且自己目前的确也没有什么能拿的出手的、值得引以为自豪的项目出来，所以还是得先积累一段时间吧。</p><p>认清现实，理清逻辑，然后好好努力，剩下的只要交给时间就可以了。</p><hr><p>回过头去看了看年初写的新年计划，很多都还没真正开始实施，已经在执行的计划也随着时间的推移，慢慢变得松懈下来了，主要还是自己期望太高而执行的能力又太弱吧。</p><p>接下来半年会继续按之前确定的方向前进，希望自己少偷懒，多回顾，强化身上的优点，补足缺点。</p><p>不期望自己年底的时候能完成多少目标，只求能变得更加自律、强大，不至于被那时的自己看扁吧。共勉！</p><p>　</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reviews </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apple 开发者账户及应用迁移记录</title>
      <link href="/apple-developer-account-transfer/"/>
      <url>/apple-developer-account-transfer/</url>
      
        <content type="html"><![CDATA[<img align="center" src="https://i.loli.net/2019/07/22/5d35d0cdaa93671993.jpg" /><h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>最近接到一个迁移 Apple 开发者账号的任务，其实一开始只是想把原有的个人开发者账户升级成企业版，但是后来发现升级比较麻烦，需要创始人或者联合创始人申请，然后客服再通过电话联系确认后才能处理，遂放弃。</p><p>我们的需求是将个人账号下的 App 转移到一个企业账号下。由于公司原本没有注册过企业账户，所以可以直接以公司的名义注册一个新的账号，然后将申请的邓白氏码绑定到这个账号上并开通企业版开发者账号，再将原有的 App 迁移过来，最后再申请新的证书等，替换掉原有项目中的旧证书。</p><span id="more"></span><h4 id="转移流程"><a href="#转移流程" class="headerlink" title="转移流程"></a>转移流程</h4><p>首先去<a href="https://appleid.apple.com/account#!&page=create">苹果官网</a>注册一个新账号，比较耗时间的是申请邓白氏码，提出申请后华夏邓白氏公司会发送邮件到你的工作邮箱让你确认并填写公司的一些信息，然后就是等待审核通过了，可能需要几天甚至一周的时间。具体如何操作，可以参考<a href="https://www.jianshu.com/p/a71709ddcedc">这篇</a>文章。</p><p>收到邓白氏码之后，就可以申请开发者账号了，可以参考<a href="https://www.jianshu.com/p/9216b99695c9">这篇</a>文章，企业类型的开发者账号年费比个人开发者要稍微高一点点。</p><p>创建完开发者账号后就可以开始转移 App 了，登入旧账号的 Apple Store Connect，然后进入 App Store 的 App Information，拉到最下面，然后找到 Transfer App，需要满足所有条件才可以开始转移。一般可能会遇到 “TestFlight Beta Testing” 这一项不符合，只要把 TestFlight 下所有的 Build 都删除掉就可以了，stackoverflow 上有相似的<a href="https://stackoverflow.com/questions/32906771/itunesconnect-cannot-transfer-app-because-of-you-must-turn-off-testflight-beta">解决方案</a>。完整的转移流程可以参考<a href="https://www.jianshu.com/p/a38c0ef96f2e">这篇</a>文章</p><p>转移完成之后，App Store 上大概要过几个小时才会显示为新注册账号的公司名称。</p><h4 id="申请新证书和-Profiles"><a href="#申请新证书和-Profiles" class="headerlink" title="申请新证书和 Profiles"></a>申请新证书和 Profiles</h4><p>由于账号转移了，所以我们需要申请新的证书和 Profiles，首先创建一个新的 Certificate Signing Request，不会的看<a href="https://www.jianshu.com/p/f20caf82938d">这里</a>。之后需要分别创建新的 iOS Development 和 iOS Distribution 类型的证书。</p><p>开发环境下的证书推荐直接使用 xCode 创建，只要使用同一个账号在 xCode 中登录就可以直接创建并同步到开发者控制台。如果使用到推送的话，还需要生成推送的证书。如下：</p><p><img src="https://i.loli.net/2019/06/18/5d08e66d0f2d396330.png" alt="Certificates"></p><p>创建完证书就可以创建 Profiles 了，一般至少需要创建三种 Profile，正式环境、开发环境、开发环境带测试设备 (Ad hoc)。创建 Profiles 也需要使用到 CertificateSigningRequest。</p><p><img src="https://i.loli.net/2019/06/18/5d08e66ca7cd144521.png" alt="Provisioning Profiles"></p><p>创建完之后，把 Profiles 下载下来，然后在 xCode 的 Signing 中导入开发和正式环境 Provisioning Profile，也可以通过 xCode 登入同一个账号同步下来。</p><p>然后还要把新创建的证书也都下载下来，双击导入到 Keychain 中，再找到 xCode 中的 Build Settings - Code Signing Identity，把 Debug 和 Release 的证书都修改为刚刚导入到 Keychain 中的证书。</p><p>至于 APNs 的证书，由于在创建的时候就已经将应用 ID 和 Provisioning Profile 绑定在一起了，所以无需另外配置，而且也不用担心使用新的推送证书后，使用旧版本的应用能否收到推送的问题，因为苹果兼容做的很好，旧版本的推送证书依旧有效，可以收到推送。</p><p>关于 Provisioning Profile 的工作原理可以参考我之前写的文章：<a href="https://ajiew.github.io/learning-about-provisioning-profile/">关于 iOS 中 Provisioning Profile 的一些小问题</a>。</p><p>到这里整个迁移流程就结束了，可以开始正常的开发工作啦。</p><p>有问题欢迎私信我~</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native - 踩坑纪录</title>
      <link href="/react-native-dev-notes/"/>
      <url>/react-native-dev-notes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录下自己在 RN 开发中遇到的一些问题。</p></blockquote><h3 id="RN-组件相关"><a href="#RN-组件相关" class="headerlink" title="RN 组件相关"></a>RN 组件相关</h3><h4 id="TextInput"><a href="#TextInput" class="headerlink" title="TextInput"></a>TextInput</h4><ol><li><h5 id="Android-文字对齐问题"><a href="#Android-文字对齐问题" class="headerlink" title="Android 文字对齐问题"></a>Android 文字对齐问题</h5></li></ol><p>当 TextInput 高度超过一行文本时，发现文字显示在 iOS 上是顶端对齐，而在 Android 上则是垂直居中，如下图：</p><p><img src="https://i.loli.net/2019/07/22/5d35cef054aa433553.png" alt="text_input_differ"></p><p>解决方法是通过为 TextInput 设置 <code>textAlignVertical: &quot;top&quot;</code> 属性，相关 issue 见：<a href="https://github.com/facebook/react-native/issues/13897">Render Multiline Text at start instead of center</a></p><span id="more"></span><ol start="2"><li><h5 id="Android-上-TextInput-接收获得焦点之后键盘无法自动收起"><a href="#Android-上-TextInput-接收获得焦点之后键盘无法自动收起" class="headerlink" title="Android 上 TextInput 接收获得焦点之后键盘无法自动收起"></a>Android 上 TextInput 接收获得焦点之后键盘无法自动收起</h5></li></ol><p>这时候我们可以给根布局设置接收触摸事件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">onStartShouldSetResponder</span>=&#123;() =&gt; <span class="hljs-literal">true</span>&#125;<br><span class="hljs-attr">onResponderRelease</span>=&#123;() =&gt; Keyboard.dismiss()&#125;<br></code></pre></td></tr></table></figure><p>这样当输入焦点之外区域触摸后，通过调用 Keyboard.dismiss() 方法强制收起键盘，曲线救国。</p><ol start="3"><li><h5 id="iOS-上无法清除文字"><a href="#iOS-上无法清除文字" class="headerlink" title="iOS 上无法清除文字"></a>iOS 上无法清除文字</h5></li></ol><p>这个问题只出现在 RN 版本 0.55.x，如果不升级的话只能用下面比较不优雅的<a href="https://github.com/facebook/react-native/issues/18272#issuecomment-393250020">方式</a>来解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs react">clear() &#123;<br>  if (Platform.OS === &#x27;ios&#x27;) &#123;<br>    this.input.setNativeProps(&#123; text: &#x27; &#x27; &#125;);<br>  &#125;<br><br>  setTimeout(() =&gt; &#123;<br>    this.input.setNativeProps(&#123; text: &#x27;&#x27; &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>相关 issue 见：<a href="https://github.com/facebook/react-native/issues/18272">issues/18272</a></p><h4 id="KeyboardAvoidingView"><a href="#KeyboardAvoidingView" class="headerlink" title="KeyboardAvoidingView"></a>KeyboardAvoidingView</h4><ol><li><h5 id="behavior-相关"><a href="#behavior-相关" class="headerlink" title="behavior 相关"></a><code>behavior</code> 相关</h5></li></ol><p>该组件在 Android 和 iOS 上的表现有区别，所以我们会区分平台使用不同的 behavior，比如下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;KeyboardAvoidingView<br>  behavior=&#123;Platform.OS === &#x27;android&#x27; ? null : &#x27;padding&#x27;&#125;<br>  keyboardVerticalOffset=&#123;64&#125;&gt;<br>  ...<br>&lt;/KeyboardAvoidingView&gt;<br></code></pre></td></tr></table></figure><p><code>padding</code> 模式下，当键盘弹起的时候，你的 view 会向上弹起并被压缩。使用 <code>padding</code> 作为 behavior 的时候，在 iOS 上表现比较好，而在 Android 上则不设置 behavior 比较好。</p><p><code>position</code> 模式下，view 整体会向上滑动。这种模式 Android 和 iOS 上表现一致，但是前提是此时 <code>KeyboardAvoidingView</code> 是根 view。同时这也会造成一个问题，那就是键盘弹出后，输入组件会一直占有焦点，这在安卓上还好，可以通过返回键关闭键盘，而在 iOS 设备上就会造成键盘无法被关闭的尴尬。解决这一问题的方法是通过在 <code>KeyboardAvoidingView</code> 设置接收触摸事件，当在输入焦点之外获得点击时收起键盘：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;KeyboardAvoidingView <br>  behavior=&#123;&#x27;position&#x27;&#125;<br>  onStartShouldSetResponder=&#123;(evt) =&gt; true&#125;<br>  onResponderRelease=&#123;() =&gt; Keyboard.dismiss()&#125;<br>/&gt;<br></code></pre></td></tr></table></figure><h4 id="ImageBackground"><a href="#ImageBackground" class="headerlink" title="ImageBackground"></a>ImageBackground</h4><ol><li><h5 id="imageStyle-属性"><a href="#imageStyle-属性" class="headerlink" title="imageStyle 属性"></a><code>imageStyle</code> 属性</h5></li></ol><p>有没有发现给 ImageBackground 设置 <code>style</code> 的时候，其中某些属性似乎不起作用？比如设置 <code>border</code> 似乎没有效果。其实看下<a href="https://github.com/facebook/react-native/blob/master/Libraries/Image/ImageBackground.js#L82">源码</a>就可以发现，原来 <code>style</code> 属性里面还有个 <code>imageStyle</code> 属性，类似 <code>border</code> 和 <code>borderRadius</code> 这样的属性要设置到 <code>imageStyle</code> 上才有效。</p><h4 id="FlatList-SectionList"><a href="#FlatList-SectionList" class="headerlink" title="FlatList/SectionList"></a>FlatList/SectionList</h4><ol><li><h5 id="contentContainerStyle-属性"><a href="#contentContainerStyle-属性" class="headerlink" title="contentContainerStyle 属性"></a><code>contentContainerStyle</code> 属性</h5></li></ol><p>与 ImageBackground 类似，在给 FlatList 设置 paddingBottom 的时候，发现不起作用，后来在这个 <a href="https://github.com/facebook/react-native/issues/15707#issuecomment-340759872">issue</a> 下找到了解决办法：FlastList/SectionList 中有个 <code>contentContainerStyle</code> 属性，代表 list 中的 content 容器的 style 属性。所以如果想要为 list 设置 paddingBottom，在这个属性上设置才能起作用。</p><ol start="2"><li><h5 id="加载时的性能问题"><a href="#加载时的性能问题" class="headerlink" title="加载时的性能问题"></a>加载时的性能问题</h5></li></ol><p>我们知道在 Android 中加载大量列表数据时，RecyclerView 的性能是比较好的，因为它可以复用 view，而在 RN 中如果你用 FlatList 直接加载成百上千的数据的时候，你会发现整个界面会变得非常卡，所以这种情况下我们就需要懒加载。FlatList 本身是支持增量加载的，只不过需要一些额外的处理。</p><p>首先，FlatList 中有一个 <code>initialNumToRender</code> 属性，用于指定初始加载的数据，我们可以设置为 10，这个看你的需求了，一般根据 item 的高度来定。然后 FlatList 还有一个 <code>onEndReached</code> 属性，我们可以在这里定义一个方法，用于指定当列表滑动到底部的时候触发的事件。有了这两个属性，我们就可以对 FlatList 中的数据进行懒加载了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;FlatList<br>  style=&#123;styles.productListStyle&#125;<br>  data=&#123;this.state.productList&#125;<br>  renderItem=&#123;(&#123;item, index&#125;) =&gt; &lt;ProductItem /&gt;&#125;<br>  initialNumToRender=&#123;10&#125;<br>  numColumns=&#123;2&#125;<br>  onEndReached=&#123;() =&gt; this.lazyLoadProducts()&#125;<br>  onEndReachedThreshold=&#123;0.5&#125;<br>  ListHeaderComponent=&#123;this.props.ListHeaderComponent&#125;<br>  ListFooterComponent=&#123;(this.state.productList.length !== this.props.productList.length) ? &lt;ActivityIndicator style=&#123;styles.activityIndicator&#125; size=&#x27;large&#x27;/&gt; : undefined&#125;<br>/&gt;<br></code></pre></td></tr></table></figure><p>可以看到，FlatList 中数据源来自 <code>this.state.productList</code>，然后在 <code>onEndReached</code> 中调用了一个 <code>lazyLoadProducts</code> 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs react">lazyLoadProducts() &#123;<br>  if (this.state.productList.length === this.props.productList.length) &#123;<br>    return;<br>  &#125;<br>  this.setState(state =&gt; (&#123;<br>    productList: state.productList.concat(<br>      this.props.productList.slice(state.productList.length, this.state.productList.length + 10)<br>        .map(item =&gt; (&#123;...item, key: item.id&#125;)))<br>    &#125;));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们首先将完整的数据保存在 props 中，然后在 <code>onEndReached</code> 中每次多加载 10 条新数据。</p><p>可以看到上面的 <code>FlatList</code> 中还定义了一个 <code>onEndReachedThreshold</code> 属性，表示 <code>FlatList</code> 可见部分离底部多远的时候会触发 <code>onEndReached</code> 方法。比如我们定义为 0.5，则如果可见部分为 10 条数据，那么当我们向下滑动 5 条数据的时候，就会去加载另外 5 条新数据。</p><h4 id="PanResponder"><a href="#PanResponder" class="headerlink" title="PanResponder"></a>PanResponder</h4><ol><li><code>onPanResponderMove</code> 和 <code>Animated.event()</code> 的结合使用</li></ol><p>利用 PanResponder 做了一个拖动调节图标位置的功能，网上找的方法是在 <code>onPanResponderMove</code> 中使用 <code>Animated.event()</code> 来对 View 进行移动。实现效果不错，但是发现一旦在 <code>onPanResponderMove </code> 中使用了 lambda 表达式后，就不起作用了。后来网上找到这个 <a href="https://github.com/facebook/react-native/issues/15880">issue</a>，发现原来 <code>Animated.event()</code> 会返回一个方法，并且接收 <a href="https://facebook.github.io/react-native/docs/panresponder">event</a> 和 gestureState 作为参数，所以我们只要去调用一下这个方法即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs react">onPanResponderMove: (evt, gestureState) =&gt; &#123;<br>  return Animated.event([null, &#123;<br>    dx: this.state.pan.x,<br>    dy: this.state.pan.y,<br>  &#125;])(evt, gestureState)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="UIManager"><a href="#UIManager" class="headerlink" title="UIManager"></a>UIManager</h4><p>我们可以使用 UIManager 来测量某个 view 的位置，这个在一些特殊的场合非常有用。</p><p>测量某个 view 的位置前，我们首先需要获得该 view 的引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;YourView<br>  ref=&#123;component =&gt; this.myView = component&#125;/&gt;<br></code></pre></td></tr></table></figure><p>获得 view 的引用后，就可以通过 view 获得 <code>nodeHandle</code> 去测量 view 的位置了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs react">measurePosition() &#123;<br>  let nodeHandle = findNodeHandle(this.myView);<br>  if (nodeHandle) &#123;<br>    UIManager.measure(nodeHandle, (x, y, width, height, pageX, pageY) =&gt; &#123;<br>      // measure success, do something with the data<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从示例代码中可以看到，在测量方法中，我们定义了一个测量成功的回调，我们可以在这里获得测量到的当前 view 的中心点坐标，高度，宽度，距离页面顶端的 x 坐标，y 坐标。</p><h4 id="其他-Tips"><a href="#其他-Tips" class="headerlink" title="其他 Tips"></a>其他 Tips</h4><ol><li> <code>diplay: none</code> 在 Android 上失效的问题</li></ol><p>这个一般是由于和 <code>position</code> 混用造成的，只要在需要使用 <code>display: none</code> 的组件外添加一个 <View> 用于控制 <code>absolute</code> 位置即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;View style=&#123;&#123;position: &#x27;absolute&#x27;&#125;&#125;&gt;<br>  &lt;View style=&#123;&#123;display: &#x27;none&#x27;&#125;&#125; /&gt;<br>&lt;/View&gt;<br></code></pre></td></tr></table></figure><p>更进一步，为了防止你隐藏掉的 View 阻挡被覆盖的其他 View 的点击事件，以及在需要隐藏的 View 里存在可点击的组件，则还需要使用到 View 的 <a href="https://facebook.github.io/react-native/docs/view#pointerevents">pointerEvents</a> 属性做以下设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;View style=&#123;&#123;position: &#x27;absolute&#x27;&#125;&#125; pointerEvents=&#123;this.props.show ? &#x27;auto&#x27; : &#x27;none&#x27;&#125;&gt;<br>  &lt;View style=&#123;&#123;display: &#x27;none&#x27;&#125;&#125; /&gt;<br>&lt;/View&gt;<br></code></pre></td></tr></table></figure><p>当展示出来的时候才可点击，如果隐藏则不接收点击事件。</p><ol start="2"><li> 组件循环更新的问题</li></ol><p>有一种常见的场景是，当有一个组件 A 使用外部组件 B 的 state 作为 prop，并且组件 A 通过回调方法来传送数据（setState）给外部组件时，此时如果外部组件 B 在回调方法中也调用了 setState 方法，那么就会造成内部组件的 state 循环更新的问题。</p><p>一种解决方法是在组件 A 中的每一个需要传送数据到外部组件中的方法（setState）中添加一个标记，然后在 <code>componentDidUpdate</code> 中根据该标记来判断是否应该对回调方法进行调用。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs react">// region 内部组件<br>componentDidUpdate(prevProps, prevState) &#123;<br>  // flag 为 true 时才进行回调<br>  if (this.state.stateUpdateFlag) &#123;<br>    // 通过回调传递数据给外部组件<br>    this.props.callback(_.omit(this.state, [&#x27;stateUpdateFlag&#x27;]));<br>    this.setState(&#123;stateUpdateFlag: false&#125;);<br>  &#125;<br>&#125;<br><br>_updateContent(data) &#123;<br>  // ... 其它代码<br>  this.setState(&#123;<br>      data,<br>      stateUpdateFlag: true<br>    &#125;);<br>  <br>  // 外部组件的回调方法中如果调用了 setState 方法，则用会造成内部组件 state 循环更新<br>  // this.props.callback(data);<br>&#125;<br>// endregion<br><br>// region 外部组件<br>render() &#123;<br>return &lt;InnerComonent<br>  innerData=&#123;this.state.formData&#125;<br>  callback=&#123;(data) =&gt; this.setState(&#123;formData: data&#125;)&#125;/&gt;<br>&#125;<br>// endregion<br></code></pre></td></tr></table></figure><ol start="2"><li> 屏幕闪动的问题</li></ol><p>在 RN 0.62 以上的版本，如果为图片添加 <code>flex: 1</code> 的 style 就会出现页面闪动的情况，去除之后就能解决。</p><h3 id="三方库相关"><a href="#三方库相关" class="headerlink" title="三方库相关"></a>三方库相关</h3><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ol><li><p>三方库无法下载，卡在 <code>checking installable status</code></p><p> 这种情况大概率是你之前下载过，导致机子本地 npm 缓存与三方库冲突。此种情况，我一般通过全局安装，然后使用 <a href="https://docs.npmjs.com/cli/link"><code>npm link</code></a> 来解决。</p></li><li><p>依赖未正确 link 导致的报错</p><p> 很多时候安装三方库之后都会遇到各种各样的报错，这种时候不要慌，先对照三方库 README 检查下是不是缺了某些步骤，如果还是无法解决就去翻翻 issue，然后再使用谷歌搜索关键字。不要急着求助，因为 99.99% 的情况下，你遇到的问题别人早就已经遇到过了。</p><p> 实在不行就把依赖删了然后重新安装并一步步检查 link 步骤有没有漏掉。</p></li><li><p> 重启电脑可以解决大部分令人原地爆炸的奇怪问题。</p></li></ol><h4 id="ant-design-react-native"><a href="#ant-design-react-native" class="headerlink" title="@ant-design/react-native"></a><a href="https://github.com/ant-design/ant-design-mobile">@ant-design/react-native</a></h4><ol><li> 3.x 版本一些组件 bug 很多，比如 Modal 等，还有使用的 ViewPager 版本过旧，如果造成 “register two views with the same name RNCViewPager” 的问题可以尝试删除 @ant-design/react-native/node-module 下的 @react-native-community/viewpager。</li></ol><h4 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a><a href="https://github.com/reduxjs/react-redux">react-redux</a></h4><ol><li>action 名字尽量不要和 reducer 的名字一样，这样会导致调用 action 的时候报 “xxx is not a function 的错误”。<br> 关于如何使用可以看我之前写的文章：<a href="https://ajiew.github.io/rn-redux-introduction/">React Native - Redux 入门</a> 和 <a href="https://ajiew.github.io/dive-into-rn-redux/">React Native - 从 Redux 进阶谈起</a></li></ol><h4 id="react-native-scrollable-tab-view"><a href="#react-native-scrollable-tab-view" class="headerlink" title="react-native-scrollable-tab-view"></a><a href="https://github.com/ptomasroos/react-native-scrollable-tab-view">react-native-scrollable-tab-view</a></h4><p>在 Android 中，如果在该库的核心组件 <code>ScrollableTabView</code> 外嵌套使用了 <code>ScrollView</code> 的话，就会出现在 <code>ScrollableTabView</code> 中的内容无法显示的问题，在 iOS 上却又没有这个问题。</p><p>找了很多解决方案，但是都不太可用，比如为 <code>ScrollView</code> 的 <code>contentContainerStyle</code> 设置 <code>&#123;flex: 1&#125;</code>。但是这样一来整个 <code>ScrollView</code> 就无法滚动了，所以摸索出一个可行的解决方案是为 <code>contentContainerStyle</code> 设置高度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;ScrollView contentContainerStyle=&#123;Platform.OS === &#x27;android&#x27; ? &#123;height: 2000&#125; : null&#125;&gt;<br>  &lt;ScrollableTabView&gt;<br>    &lt;TabOne/&gt;<br>    &lt;TabTwo/&gt;<br>  &lt;/ScrollableTabView&gt;<br>&lt;/ScrollView&gt;<br></code></pre></td></tr></table></figure><p>这种方法只能算是一个 hack 吧，即使是通过测量 view 的高度也不是很好，因为如果 tab 是很长的一个 list，会造成比较大的性能开销，而如果动态增加 ScrollView 的高度的话，要是 tab 里面包含长图也会需要做额外的处理。所以还是不推荐嵌套 ScrollView 使用。</p><h4 id="react-native-puti-pay"><a href="#react-native-puti-pay" class="headerlink" title="react-native-puti-pay"></a><a href="https://github.com/puti94/react-native-puti-pay">react-native-puti-pay</a></h4><p>这是一个微信和支付宝支付库，如果集成该库的同时也集成了 <a href="https://github.com/yorkie/react-native-wechat">react-native-wechat</a>，则会造成冲突：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">duplicate</span> symbol _OBJC_CLASS_$_WechatAuthSDK.xx<br><span class="hljs-keyword">duplicate</span> symbol _OBJC_IVAR_$_WechatAuthSDK.xx<br>...<br></code></pre></td></tr></table></figure><p>上面只列出了两种冲突项，全部的冲突项可能达几十个，主要是因为这两个库同时引用了 <code>libWeChatSDK.a</code>，所以只要删除其中一个库中的该引用即可。</p><h4 id="react-native-debugger"><a href="#react-native-debugger" class="headerlink" title="react-native-debugger"></a><a href="https://github.com/jhen0409/react-native-debugger">react-native-debugger</a></h4><p>配合 redux 使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs react">import &#123;applyMiddleware, combineReducers, compose, createStore&#125; from &#x27;redux&#x27;;<br><br>const allReducers = combineReducers(&#123;...&#125;);<br><br>// 开启 REDUX DEVTOOLS 支持<br>const composeEnhancers =<br>  typeof window === &#x27;object&#x27; &amp;&amp;<br>  window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?<br>    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;<br>      // Specify extension’s options like name, actionsBlacklist, actionsCreators, serialize...<br>    &#125;) : compose;<br><br>// 通过 reducer生成 store (封装中间件)<br>let store = createStore(allReducers, composeEnhancers(applyMiddleware(thunkMiddleware)));<br><br>export default store;<br></code></pre></td></tr></table></figure><p>在 console 中获取 AsyncStorage 中的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">showAsyncStorageContentInDev()<br></code></pre></td></tr></table></figure><h4 id="react-native-router-flux"><a href="#react-native-router-flux" class="headerlink" title="react-native-router-flux"></a><a href="https://github.com/aksonov/react-native-router-flux">react-native-router-flux</a></h4><ol><li><h5 id="实现-Android-上连续点击两次返回键退出"><a href="#实现-Android-上连续点击两次返回键退出" class="headerlink" title="实现 Android 上连续点击两次返回键退出"></a>实现 Android 上连续点击两次返回键退出</h5></li></ol><p>这个在安卓上是比较常见的操作，但是在 RN 中结合 react-native-router-flux 使用却折腾了好长时间，这里记录下自己的实现方式。</p><p>首先，react-native-router-flux 原生就支持，我们不需要通过自己去添加 BackHandler 监听器来实现。当我们使用 react-native-router-flux 时，我们一般用 <code>Router</code> 作为根节点，所以我们通过 <code>Router</code> 为其设置 <code>backAndroidHandler</code> 属性即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs react">let lastBackPressed = Date.now();<br>const onExitApp = () =&gt; &#123;<br>  if (Actions.currentScene !== &#x27;home&#x27;) &#123;<br>    Actions.pop();<br>    return true<br>  &#125;<br>  if (lastBackPressed &amp;&amp; Date.now() &lt; lastBackPressed + 2000) &#123;<br>    BackHandler.exitApp();<br>    return false;<br>  &#125;<br>  ToastAndroid.show(&#x27;再按一次退出应用&#x27;, ToastAndroid.SHORT);<br>  lastBackPressed = Date.now();<br>  return true;<br>&#125;;<br><br>class AppRouter extends Component &#123;<br><br>  render() &#123;<br>      return &lt;Router backAndroidHandler=&#123;onExitApp&#125;&gt;<br>      &lt;Scene key=&#x27;home&#x27; ...&gt;<br>      &#123;/* other code */&#125;<br>      &lt;/Router&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里定义了一个 <code>onExitApp</code> 方法并且设置到了 <code>backAndroidHandler</code> 属性上，该属性会根据返回值来决定是否退出应用（<strong>false 时退出应用</strong>）。</p><p>在 <code>onExitApp</code> 中，我们首先判断当前应用是否处于根页面（可以通过 react-native-router-flux 中的 <code>Actions.currentScene</code> 获取当前 Scene），如果不是根页面则作为普通的返回键处理（弹出一页），否则判断是否在指定时间内连续点击，连续点击才退出应用，否则弹出 Toast 提醒。</p><ol start="2"><li><h5 id="在-Android-上点击返回键时使-WebView-后退一页"><a href="#在-Android-上点击返回键时使-WebView-后退一页" class="headerlink" title="在 Android 上点击返回键时使 WebView 后退一页"></a>在 Android 上点击返回键时使 WebView 后退一页</h5></li></ol><p>假如有这样一个需求，某个页面下有一个 WebView 组件，我们需要控制当在该页面按下返回键时后退一页（相当于从网页的历史记录中后退），而如果没有历史记录时则直接退出。这个要怎么实现呢？</p><p>注意到，WebView 中有一个 <code>onNavigationStateChange</code> 方法，当新的页面加载或退出时该方法会被调用。因此一种可行的方法是，在该方法中监听页面变化并读取页面加载后的数据。以下是该方法中的部分数据：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">canGoBack:</span> <span class="hljs-literal">true</span><br><span class="hljs-symbol">canGoForward:</span> <span class="hljs-literal">true</span><br><span class="hljs-symbol">loading:</span> <span class="hljs-literal">false</span><br><span class="hljs-symbol">navigationType:</span> <span class="hljs-string">&quot;other&quot;</span><br><span class="hljs-symbol">target:</span> <span class="hljs-number">187</span><br><span class="hljs-symbol">title:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">url:</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>因此，可以通过事件中传回的 <code>canGoBack</code> 值判断此时 WebView 是否可以返回，如果可以则使用 WebView 的 ref 去调用 <code>goBack()</code> 返回上一页，否则使用 <code>Actions.pop()</code> 退出当前页面。</p><p>基本代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs react">goBack = () =&gt; &#123;<br>  if (this.state.canGoBack) &#123;<br>    this.refs.webView.goBack();<br>  &#125; else &#123;<br>    Actions.pop();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当然由于返回按钮可能不在当前组件下，如果你使用的是 <code>react-native-router-flux</code> 和 <code>react-redux</code>，则可以定义一个返回按钮的组件，该组件通过全局 state 树接收点击事件的 function，然后设置到 <code>Scene</code> 的 <code>renderLeftButton</code> 属性中，最后，在需要处理 WebView 的地方设置返回事件到返回按钮中即可（注意：<code>react-redux</code> 是可以接收 <code>function</code> 作为属性的，不然就没法设置事件了）。</p><h4 id="react-native-amap3d"><a href="#react-native-amap3d" class="headerlink" title="react-native-amap3d"></a><a href="https://github.com/qiuxiang/react-native-amap3d">react-native-amap3d</a></h4><p>这是一个高德 3D 地图库。</p><ol><li><h5 id="安装失败以及冲突"><a href="#安装失败以及冲突" class="headerlink" title="安装失败以及冲突"></a>安装失败以及冲突</h5></li></ol><p>该库 iOS 部分只能使用 CocoaPods 安装，花了很多时间在安装 <a href="https://github.com/CocoaPods/Specs.git">Specs</a> 依赖上，只要一 <code>pod install</code> 就会卡在 <code>cloning into /Users/xxx/.cocoapods/repo/master</code>。</p><p>尝试了很多国内镜像，发现大多数都已经不能用了，然后也尝试了国内镜像 clone <a href="https://github.com/CocoaPods/Specs.git">Specs</a> 到 <code>~/.cocoapods/repos/master</code> 里，发现也没啥用，因为 install 的时候还是会识别不了（因为太久没更新）。</p><p>后来发现原来这东西的确只能从官方的 Github 上 clone，只不过由于体积比较大（几个G，被限速了），只要耐心等待它 clone 完毕就行了。反正每台电脑只要操作一次就够了，后面的更新基本都很快的。</p><p>花了一晚上 clone 完，然后 install，结果编译还是不通过，老是报依赖找不到（ld: library not found for -lDoubleConversion）。尝试各种方案无果，后来看到一个 stackoverflow 上的<a href="https://stackoverflow.com/questions/50423169/xcode-not-build-my-project">回答</a>才明白，原来使用 cocoapods 的项目要通过 <code>.xcworkspace</code>  打开项目而不是 <code>.xcodeproj</code>。发现真相的我差点眼泪掉下来。</p><p>然后重新打开项目跑了之后，依旧继续报错（duplicate symbol _aes_encrypt_key128 in ios/Pods/AMap3DMap/MAMapKit.framework/MAMapKit）。</p><p>清理了缓存（npm cache clear –force ; watchman watch-del-all ; rm -rf $TMPDIR/react-* ; rm -rf ~/.rncache）重新安装依赖（rm -rf node_modules &amp;&amp; npm install）后，问题依旧存在。</p><p>你以为我要崩溃了吗？不，作为一个程序员怎么能这么容易就崩溃？当然是去玩几把 FIFA 然后回来继续解决问题啊。</p><p>仔细看了下报错信息，发现是 react-native-amap3d 和 react-native-update 中的 libRCTHotUpdate 存在重复 symbol 所以一直编译不过。</p><p>确定问题后解决起来就简单了，搜到了这篇<a href="https://www.meiwen.com.cn/subject/dezqyttx.html">文章</a>。原理很简单，把 react-native-amap3d 中会造成 symbol 重复的内容去掉就可以了（因为只是 x86_64 这一个平台中的重复 symbol，所以影响不大，如果是其他平台，操作也类似），具体步骤如下：</p><ul><li><p>  首先定位到 MAMapKit.framework，<code>project_name/ios/pods/AMap3DMap/MAMapKit.framework</code>，将其中的 <code>MAMapKit</code> 复制出来</p></li><li><p>  将 MAMapKit 中 x86_64 平台的部分提取出来并命名为 MAMapKit.x86_64：</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">lipo -thin x86_64 MAMapKit -output MAMapKit.x86_64<br></code></pre></td></tr></table></figure><ul><li>  将其中包含重复 symbols 的部分查找出来并保存的 symbols 文件中：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">nm -j MAMapKit.x86_64  | grep aes &gt; symbols<br><br><span class="hljs-comment"># symbols 文件内容如下</span><br>_aes_decrypt<br>_aes_decrypt_key128<br>_aes_encrypt<br>_aes_encrypt_key128<br>_dsasozkdgmaesfsvzyll<br></code></pre></td></tr></table></figure><ul><li>  解压 MAMapKit.x86_64：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ar -x MAMapKit.x86_64<br><br><span class="hljs-comment"># 解压后获得三个新文件：</span><br>MAMapKit-x86_64-master.o <span class="hljs-comment"># 存在重复 symbols 的文件</span><br>Pods-MAMapKit-dummy.o<br>__.SYMDEF SORTED <span class="hljs-comment"># ar 命令生成的文件索引</span><br></code></pre></td></tr></table></figure><ul><li>  将 symbols 文件中的符号列表从 MAMapKit-x86_64-master.o 文件中全部删除掉，并生成一个新的文件 MAMapKit-x86_64-master.o.strip</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ld -x -r -unexported_symbols_list symbols MAMapKit-x86_64-master.o -o MAMapKit-x86_64-master.o.strip<br></code></pre></td></tr></table></figure><ul><li>  将去除了重复 symbols 的文件重新打包并命名为 MAMapKit.x86_64_solved：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ar -r MAMapKit.x86_64_solved MAMapKit-x86_64-master.o.strip Pods-MAMapKit-dummy.o<br></code></pre></td></tr></table></figure><ul><li>  使用无重复的 x86_64 平台包替换旧的，然后合成新的 MAMapKit：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">lipo MAMapKit -replace x86_64 MAMapKit.x86_64_solved -output MAMapKitNew<br></code></pre></td></tr></table></figure><ul><li><p>  复制 MAMapKitNew 到 MAMapKit.framework 中，删除原来的 MAMapKit 然后重命名 MAMapKitNew 为 MAMapKit，大功告成！</p></li><li><p>  Xcode 重新编译，编译通过，项目成功运行！</p></li></ul><ol start="2"><li><h5 id="在安卓上存在无法获取地图定位的问题。"><a href="#在安卓上存在无法获取地图定位的问题。" class="headerlink" title="在安卓上存在无法获取地图定位的问题。"></a>在安卓上存在无法获取地图定位的问题。</h5></li></ol><p>尤其是当处于室内的时候，这种情况出现得比较频繁（定位后的回调中数据均为 0）。该库作者目前也没有较好的解决方案，所以最后决定在安卓上自己来定时刷新定位，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;MapView<br>  coordinate=&#123;Platform.select(&#123;<br>    android: this.state.userLocation, // 使用手动定位到的位置作为地图中心点<br>    ios: this.state.centerLocation // 使用地图定位到的位置作为地图中心点<br>  &#125;)&#125;<br>  locationEnabled=&#123;Platform.OS === &#x27;ios&#x27;&#125; // 只有 iOS 上才用地图自带的定位<br>  onLocation=&#123;(&#123;nativeEvent&#125;) =&gt; &#123;<br>    if (Platform.OS === &#x27;ios&#x27;) &#123;<br>      this.setState(&#123;<br>        centerLocation: &#123;<br>          latitude: nativeEvent.latitude,<br>          longitude: nativeEvent.longitude<br>        &#125;<br>      &#125;);<br>    &#125;<br>  &#125;&#125;&gt;<br><br>  &#123;<br>    // 安卓上使用 marker 作为用户位置的标记<br>    Platform.OS === &#x27;android&#x27; ?<br>      &lt;MapView.Marker<br>        draggable=&#123;false&#125;<br>        title=&#x27;您的位置&#x27;<br>        icon=&#123;() =&gt; (<br>          &lt;View style=&#123;styles.customMarker&#125;&gt;<br>            &lt;Image style=&#123;styles.markerImage&#125; resizeMode=&#123;&#x27;contain&#x27;&#125;<br>                   source=&#123;require(&#x27;../../../assets/icon/ic_location_dot.png&#x27;)&#125;/&gt;<br>          &lt;/View&gt;<br>        )&#125;<br>        coordinate=&#123;&#123;<br>          latitude: this.state.userLocation.latitude,<br>          longitude: this.state.userLocation.longitude,<br>        &#125;&#125;<br>      /&gt; : null<br>  &#125;<br>&lt;/MapView&gt;<br></code></pre></td></tr></table></figure><p>我们只在 iOS 上使用地图自带的定位功能，而在安卓上添加一个 marker 作为用户位置，并且自己控制定位频率：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs react">componentDidMount() &#123;<br>  // 进入地图后刷新定位<br>  this.getLocation();<br>  <br>  // 安卓上定时刷新定位<br>  if (Platform.OS === &#x27;android&#x27;) &#123;<br>    this.refershInterval = setInterval(() =&gt; this.getLocation(), 60 * 1000);<br>  &#125;<br>&#125;<br><br>getLocation(refresh) &#123;<br>  Platform.select(&#123;<br>    android: async () =&gt; &#123;<br>      let hasAccess = await PermissionsAndroid.check(<br>          PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION);<br>      if (hasAccess) &#123;<br>        if (refresh) &#123;<br>          ToastAndroid.show(&#x27;刷新定位...&#x27;, ToastAndroid.SHORT);<br>        &#125;<br>        navigator.geolocation.getCurrentPosition(<br>            (position) =&gt; this.geo_success(position), <br>            (e) =&gt; this.geo_error(e), &#123;timeout: 5000&#125;);<br>      &#125; else &#123;<br>        this.requestLocationPermission();<br>      &#125;<br>    &#125;<br>  &#125;)();<br>&#125;<br><br>geo_success(position) &#123;<br>  // 将 GPS 坐标转换为国测局坐标<br>  let gcj02Location = wgs84togcj02(position.coords.longitude, position.coords.latitude);<br><br>  this.setState(&#123;<br>    userLocation: &#123;<br>      latitude: gcj02Location[1],<br>      longitude: gcj02Location[0]<br>    &#125;<br>  &#125;)<br>&#125;<br><br>geo_error() &#123;<br>  ToastAndroid.show(&#x27;获取定位失败，请稍候再试！&#x27;, ToastAndroid.SHORT);<br>&#125;<br><br>async requestLocationPermission() &#123;<br>  const granted = await PermissionsAndroid.request(<br>    PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,<br>  );<br><br>  if (granted === PermissionsAndroid.RESULTS.GRANTED) &#123;<br>    this.getLocation();<br>  &#125; else &#123;<br>    ToastAndroid.show(&#x27;未获得授权，无法显示您的位置！&#x27;, ToastAndroid.SHORT);<br>  &#125;<br>&#125;<br><br>componentWillUnmount() &#123;<br>  // 清除定时器<br>  this.refershInterval &amp;&amp; clearInterval(this.refershInterval);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式唯一的不足就是定位的图标不是动态的了，比如精度范围和方向都无法显示出来。但是为了获取到定位，这也算是一种 trade off 了吧。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h4><ol><li><h5 id="一个花括号-引发的惨案。"><a href="#一个花括号-引发的惨案。" class="headerlink" title="一个花括号 {} 引发的惨案。"></a>一个花括号 <code>&#123;&#125;</code> 引发的惨案。</h5></li></ol><p>你有没有在测试安卓的时候，遇到过这个报错：Cannot add a child that doesn’t have a YogaNode to a parent without a measure function! (Trying to add a ‘RCTRawText [text: }]’ to a ‘RCTView’)</p><img src="https://i.loli.net/2019/07/22/5d35cef0424f839098.png" width="30%" /><p>这么一点点信息，完全让人摸不着头脑对不对？最后折腾半天，发现原来是因为某个角落里躺着一个 <code>&#123;</code> 或者 <code>&#125;</code>，砸电脑的心都有了。</p><p>所以，一定要注意代码规范啊， 不要在代码里乱嵌套代码或者乱写三目运算来判断某个 View 的显示或隐藏等等。</p><h4 id="iOS-相关"><a href="#iOS-相关" class="headerlink" title="iOS 相关"></a>iOS 相关</h4><h5 id="模拟器调试"><a href="#模拟器调试" class="headerlink" title="模拟器调试"></a>模拟器调试</h5><p>大部分情况下，如果在模拟器上跑不起来，只要关掉 Metro Bundler，然后使用 Xcode  Clean 再重新运行就可以解决，有时候在执行了 Clean 之后可能会遇到 React 相关的 Target 构建报错，一般是依赖树没有构建完整，只要多执行几次 Run 等待依赖全部加载完毕就能解决。</p><p>如果还不行可以尝试卸载模拟器上的应用然后重新构建，也能解决很多奇怪的运行不起来的问题。</p><p>实在不行再尝试『全清』大法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 清除依赖，重新安装</span><br>rm -rf node_modules &amp;&amp; npm install<br><br><span class="hljs-comment"># 清除缓存</span><br>react-native start --reset-cache<br><br><span class="hljs-comment"># 清除 npm 和 watchman 缓存</span><br>npm cache clear --force &amp;&amp; watchman watch-del-all<br></code></pre></td></tr></table></figure><p>相关 issue：<a href="https://github.com/facebook/react-native/issues/1924">issues/1924</a>，<a href="https://github.com/facebook/react-native/issues/4968">issues/4968</a></p><h5 id="真机调试"><a href="#真机调试" class="headerlink" title="真机调试"></a>真机调试</h5><p>大部分问题由于项目依赖的运行环境不一样，所以也没有什么统一的解决方案，只能靠自己谷歌慢慢摸索解决，使用上面模拟器中同样的方式有时候也能解决绝大部分问题。</p><p>但是有些问题比较特殊，而且出现次数较多，比如：RN 中 <code>third-party</code> 相关的问题。所以这里顺便记录下。</p><ol><li> <code>Build input file double-conversion cannot be found</code></li></ol><p>出现这个错误一般是没有安装 double-conversion 依赖，只要运行下面的命令就能解决：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> node_modules/react-native/scripts &amp;&amp; ./ios-install-third-party.sh &amp;&amp; <span class="hljs-built_in">cd</span> ../../../<br></code></pre></td></tr></table></figure><ol start="2"><li> <code>ios-configure-glog.sh: line 15: ./configure: No such file or directory</code></li></ol><p>和 1 类似，也是比较常见的错误，解决方案：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ./node_modules/react-native/third-party/glog-0.3.4 &amp;&amp; ../../scripts/ios-install-third-party.sh &amp;&amp; <span class="hljs-built_in">cd</span> ../../../../<br></code></pre></td></tr></table></figure><p>这里出现报错的是 glog-0.3.4，如果你是其他 third-party 依赖或者其他版本也都可以用这种方法解决。</p><ol start="3"><li> <code>&#39;config.h&#39; file not found</code></li></ol><p>一般出现在 1 之后，手动运行一下 configure 脚本就能解决：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> node_modules/react-native/third-party/glog-0.3.4/; ./configure<br></code></pre></td></tr></table></figure><ol start="4"><li> <code>No member named &#39;__rip&#39; in &#39;__darwin_arm_thread_state64</code></li></ol><p>这个问题一般比较少见，但是我遇到过多次，只出现升级到 Xcode 10 之后而且使用的 RN 版本低于 0.57 的情况下。</p><p>造成这种错误一个可能的原因是，由于手动构建 glog，在真机上因为缺乏 arm 平台的相关配置导致出现错误。</p><p>我目前参考的是<a href="https://github.com/facebook/react-native/issues/19839#issuecomment-422390104">这个</a>已经被关闭的 issue 中的 workaround 来解决这个问题的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">// 在 node_modules/react-native/third-party/glog-0.3.4/src/config.h 下搜索：<br><span class="hljs-comment">#define PC_FROM_UCONTEXT uc_mcontext-&gt;__ss.__rip</span><br>// 替换为：<br><span class="hljs-comment">#if defined(__arm__) || defined(__arm64__)</span><br><span class="hljs-comment">#define PC_FROM_UCONTEXT uc_mcontext-&gt;__ss.__pc</span><br><span class="hljs-comment">#else</span><br><span class="hljs-comment">#define PC_FROM_UCONTEXT uc_mcontext-&gt;__ss.__rip</span><br><span class="hljs-comment">#endif</span><br></code></pre></td></tr></table></figure><p>如作者所说，RN 0.57 之后的 glog-0.3.5 脚本已经兼容了 Xcode 10（不能在 RN&lt;0.57 中直接使用这个脚本），这个问题也就不存在了，所以推荐升级来解决，如果不想升级也可以用他提供的方法来解决。相关的 issue：<a href="https://github.com/facebook/react-native/issues/20774">issues/20774</a></p><p>另外，如果是 <code>No member named &#39;__rip&#39; in &#39;__darwin_i386_thread_state64</code>，则可以添加</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#elif defined(__i386__)</span><br><span class="hljs-comment">#define PC_FROM_UCONTEXT uc_mcontext-&gt;__ss.__eip</span><br></code></pre></td></tr></table></figure><p>修改后的内容为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">/* How to access the PC from a struct ucontext */<br><span class="hljs-comment">#if defined(__arm__) || defined(__arm64__)</span><br><span class="hljs-comment">#define PC_FROM_UCONTEXT uc_mcontext-&gt;__ss.__pc</span><br><span class="hljs-comment">#elif defined(__i386__)</span><br><span class="hljs-comment">#define PC_FROM_UCONTEXT uc_mcontext-&gt;__ss.__eip</span><br><span class="hljs-comment">#else</span><br><span class="hljs-comment">#define PC_FROM_UCONTEXT uc_mcontext-&gt;__ss.__rip</span><br><span class="hljs-comment">#endif</span><br></code></pre></td></tr></table></figure><ol start="5"><li> <code>Unknown argument type &#39;**attribute**&#39; in method -[RCTAppState getCurrentappState:error:]</code></li></ol><p>同样只有 rn 0.55.4 或更老的版本才会出现这个问题，相关 issue 见 <a href="https://github.com/facebook/react-native/issues/25138">issues/25138</a>，解决方案在<a href="https://github.com/facebook/react-native/pull/25146/files">这里</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// open at: node_modules/react-native/React/Base/RCTModuleMethod.mm<br>static BOOL RCTParseUnused(const char **input)<br>&#123;<br>  return RCTReadString(input, &quot;__unused&quot;) ||<br>         RCTReadString(input, &quot;__attribute__((__unused__))&quot;) || // add this line<br>         RCTReadString(input, &quot;__attribute__((unused))&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li> <code>Undefined symbols for architecture x86_6: _OBJC_CLASS_xxxxx</code></li></ol><p>这个问题一般是由 CocoaPods 缓存引起的，解决方法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 清除 Xcode 缓存</span><br>rm -rf ~/Library/Developer/Xcode/DerivedData<br><span class="hljs-comment"># 删除依赖</span><br><span class="hljs-built_in">cd</span> ios<br>pod deintegrate &amp;&amp; pod cache clean --all<br><span class="hljs-comment"># 重新安装依赖</span><br>pod update &amp;&amp; pod install<br></code></pre></td></tr></table></figure><p>参考：<a href="https://github.com/invertase/react-native-firebase/issues/321#issuecomment-321232473">相关 issue</a></p><h4 id="Android-相关"><a href="#Android-相关" class="headerlink" title="Android 相关"></a>Android 相关</h4><p><del>Android 不推荐使用真机调试，原因是 hot reload 常常失效（RN 0.60 以上版本似乎体验改善很多了）。</del></p><p>真机上会遇到的问题和 iOS 差不多，这里就记录一些比较常用的命令吧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 推荐添加 ~/Library/Android/sdk/emulator/emulator 到 PATH 中</span><br><span class="hljs-meta">#</span><span class="bash"> 查看所有可用的安卓模拟器</span><br>emulator -list-avds<br><span class="hljs-meta">#</span><span class="bash"> 启动对应的模拟器</span><br>emulator -avd &#x27;avd_name&#x27;<br><span class="hljs-meta">#</span><span class="bash"> 在指定设备上运行</span><br>react-native run-android --deviceId=DEVICE_ID<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 运行并配置端口号（默认为8081，避免占</span><br>react-native run-android --port=8088<br><span class="hljs-meta">#</span><span class="bash"> 运行 release 版本，必须配置 signingConfigs</span><br>react-native run-android --variant=release<br><span class="hljs-meta">#</span><span class="bash"> 唤醒开发者菜单，或者在 Metro 窗口中按 d</span><br>adb shell input keyevent KEYCODE_MENU<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 查看 RN 相关的日志</span><br>adb shell logcat *:S ReactNative:V ReactNativeJS:V<br></code></pre></td></tr></table></figure><p>另外提供 iOS 相关的常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看已安装的 iOS 模拟器列表</span><br>xcrun simctl list --json devices<br><span class="hljs-meta">#</span><span class="bash"> 启动指定的模拟器</span><br>xcrun instruments -w &#x27;iPhone 8 Plus&#x27;<br><span class="hljs-meta">#</span><span class="bash"> 在指定的模拟器上运行</span><br>react-native run-ios --simulator=&quot;iPhone 8 Plus&quot;<br><span class="hljs-meta">#</span><span class="bash"> iOS 模拟器录屏，保存位置为当前路径</span><br>xcrun simctl io booted recordVideo video.mov<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 删除所有的 Provisioning Profile</span><br>rm ~/Library/MobileDevice/Provisioning\ Profiles/*<br><span class="hljs-meta">#</span><span class="bash"> 删除 DerivedData，有时候可以解决一些奇怪的问题</span><br>rm -rf ~/Library/Developer/Xcode/DerivedData<br></code></pre></td></tr></table></figure><h5 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h5><ol><li> 无法连接到 packager server，相关 issue：<a href="https://github.com/facebook/react-native/issues/15388">issue-15388</a>，<a href="https://github.com/facebook/react-native/issues/23380#issuecomment-473871592">issue-23380</a></li></ol><p>通常是由于在 <code>MainApplication</code> 中导入了 <code>BuildConfig</code> 造成的，删除即可，见：<a href="https://stackoverflow.com/questions/46595790/cant-open-developer-menu-on-react-native-debug-build">Can’t open developer menu on react-native debug build</a></p><ol start="2"><li>Attempt to invoke virtual method ‘android.graphics.drawable.Drawable android.graphics.drawable.Drawable$ConstantState.newDrawable(android.content.res.Resources)’ on a null object reference</li></ol><p>算是 Android 上比较令人头疼的一个问题了，目前除了重启 packager 没有更好的解决办法了，相关 issue 见 <a href="https://github.com/facebook/react-native/issues/17530">issue-17530</a>，该 issue 目前仍然处于 open 状态中。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西藏之旅</title>
      <link href="/tibet/"/>
      <url>/tibet/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/08/04/twvBmdhAfyijO17.jpg" alt="potala_palace_distant_view.jpg"></p><p>坐了两天绿皮火车，昨天终于抵达了拉萨。</p><p>一路上，看风景，和陌生人玩桌游，时间过得也快。最大的感触是坐火车一定要带够足够的电源，不然想拍车窗外的牦牛都会担心手机电量不够😅。</p><span id="more"></span><p><img src="https://i.loli.net/2019/08/04/pFGJHNQDtcbwL9P.jpg" alt="远处的牦牛"></p><p>这一路从格尔木到那曲的景色是最美的，雪景草甸山麓也拍了不少，让我觉得这趟火车坐的还是值得的。</p><p><img src="https://i.loli.net/2019/08/04/zkWwKP2RyFYXaer.jpg" alt="雪原、雪山和低沉的云"></p><p>虽说在火车上看风景的时光过得还算惬意，但是这两天的确几乎没怎么睡过一个好觉。一方面是从来没有做过长途火车，内心有点小激动；另一方面，火车上毕竟非常颠簸，很不习惯，想要睡得安稳很难很难。</p><p>无论怎样，总算熬过这两天了。</p><p>昨晚抵达酒店，洗了个澡，睡得也还算不错，补了这两天缺的觉。</p><p>早上 7 点多醒来，外面天还是漆黑一片（拉萨日出在 8 点左右），远处传来藏獒的叫声，昨晚半夜醒来估计也是被这厮的叫声吵醒的。</p><p>今天打算逛四个拉萨市内的景点，布达拉宫、大昭寺、药王山和罗布林卡。早上要早点去布达拉宫排队领票，所以就不多写了。</p><div style="text-align:right">2019年2月3日 清晨 7点30</div>---<p>昨天玩的很嗨，上午逛完了布达拉宫，拍了很多照片。</p><p><img src="https://i.loli.net/2019/08/04/64IXulTDZdP3o1q.jpg" alt="potala_palace_square.jpg"></p><p><img src="https://i.loli.net/2019/08/04/RrUIWp7DiS2c1tA.jpg" alt="potala_palace_foot.jpg"></p><p><img src="https://i.loli.net/2019/08/04/5LzByD61qP4Ob79.jpg" alt="potala_palace_upper_hall.jpg"></p><p>中午去附近一个大商城吃了午饭，然后去八廓街逛了一会儿。下午两点买票进大昭寺逛了下，同样拍了很多照片。但是下午爬药王山的时候，突然感觉呼吸不过来了，然后是胸闷、心悸，高原反应终于开始对我这只小猫咪动了手😫。</p><p><img src="https://i.loli.net/2019/08/04/FKHp37aNV6kzo1J.jpg" alt="jokhang_temple_upstairs.jpg"></p><p><img src="https://i.loli.net/2019/08/04/twvBmdhAfyijO17.jpg" alt="potala_palace_distant_view.jpg"></p><p>在药王山拍完照后，又去布宫广场上逛了一下，看了会儿下鸽子。然后打车去罗布林卡，一开始以为是在山上，来了后才知道，其实只是市区里的一个大公园。里面还有一个动物园，买票在里面稍微逛了一会儿，这里设施很简陋，不过猴子山里的猴子还是挺可爱的。</p><p><img src="https://i.loli.net/2019/08/04/hEDf3wbnBK647Fy.jpg" alt="norbulingka_monkey_mountain.jpg"></p><p>逛完罗布林卡之后，发现高反更严重了，于是打车去布宫广场附近的药店买了高原安和藏红花，期间还发现加湿器被我不知什么时候给弄丢了。</p><p>买完药我们在布宫广场上晒了会儿太阳，然后就前往聚餐点打算和另外两名小伙伴碰面吃晚饭。但是由于我们过去的时间有点早，另外两名小伙伴还有别的安排，于是被他们放了鸽子。</p><p>晚饭我几乎没怎么吃，高反又加重了，出来的时候走在路上感觉人都快晕倒，头晕加头痛，连慢慢走都觉得很吃力，于是和陈斌商量还是先回酒店休息。</p><p>到了晚上，高反症状终于达到了高潮，不但头晕头痛，还伴随着胸闷、心悸和四肢无力。吃了药后睡了差不多两个小时，醒来发现才 10 点，然而仿佛过去了一个世纪。症状并没有因为吃药而缓解，呼吸依旧很费力，不能躺下，也不能大口呼吸，连被子盖久了也会感到难受，有那么一会儿感觉整个人都快要意识模糊。</p><p>失眠，完全无法入睡。靠在床上，一边听歌一边胡思乱想，让意识游离，诅咒人类的基因缺陷，然后又尝试意义疗法。直到 3 点左右，才发现好过一点可以躺下了，也不知道是藏红花还是止痛药起效果了。</p><p>早上陈斌让我多睡一会儿，可还是醒来 3 次，一共睡了不足 5 个小时，奇怪的是并不觉得困。好在每次醒来都觉得高反症状减轻了一些。到最后一次醒来的时候，基本上头晕头痛、呼吸困难的症状都消失了。</p><p>嗯，很开心，总算是熬过去了。</p><p>此刻靠在床上等待小伙伴来接我们。今天就要离开拉萨去日喀则了，希望一路顺风。</p><div style="text-align:right">2019年2月4日（大年三十） 清晨 8点</div>---<p>昨天和小伙伴们见面后就开始往日喀则走，途经羊湖（羊卓雍错），风景很美，拍了很多照片。</p><p><img src="https://i.loli.net/2019/08/04/u76L4jFPSCRYtBi.jpg" alt="mountain_everest_distant_look.jpg"></p><p><img src="https://i.loli.net/2019/08/04/M4xR2D9n7PaFQYZ.jpg" alt="yamdrok_lake.jpg"></p><p>不过由于在路上耗时比较久，到达日喀则的时候时间已经比较晚了，于是四个人走了两条街才找到一家东北饺子馆，吃了点饺子（昨天大年三十），一起抢了会儿红包，然后回酒店睡觉。</p><p>今天早上也比较赶，8 点就向绒布寺出发，一路上风景也是非常的美，尤其是进入珠峰景区之后，随手拍的照片都能当做壁纸。</p><p><img src="https://i.loli.net/2019/08/04/RBFH3oQCAOS5bsx.jpg" alt="mountain_everest_entrance.jpg"></p><p><img src="https://i.loli.net/2019/08/04/YejrkiQL5gWEldc.jpg" alt="everest_mountains.jpg"></p><p><img src="https://i.loli.net/2019/08/04/fzl2stu5LxCnaEV.jpg" alt="everest_mountains2.jpg"></p><p>下午抵达珠峰，海拔 5 千多，很兴奋，不过高反也很强烈，没带氧气包，只能靠吃止痛药来缓解😂。</p><p><img src="https://i.loli.net/2019/08/04/P1DWQ4x3BMuOJbH.jpg" alt="selfie_with_the_stone.jpg"></p><p><img src="https://i.loli.net/2019/08/04/yr1GW7Uz4pcAQOn.jpg" alt="selfie_with_everest.jpg"></p><p>晚上 9 点才返回了定日县。因为附近没有啥吃的，大年初一的晚饭是在宾馆里吃自热米饭度过的😒。不过好在住宿条件还算不错，只是没有热水。</p><div style="text-align:right">2019年2月5日（春节） 晚上10点</div>---<p>今天开始回程去羊湖，中午在吉定镇吃了午饭，在街上随便逛了逛，觉得这应该算是比较富裕的一个镇子了。只不过由于是藏历新年期间（同时也是农历新年），路上都没什么人。</p><p>下午途径满拉水库和卡若拉冰川，景色真的是美到窒息。</p><p><img src="https://i.loli.net/2019/08/04/RfpdouFP3lv1qJk.jpg" alt="mania_ reservoir.jpg"></p><p><img src="https://i.loli.net/2019/08/04/2oqJKkmZSDfFuH1.jpg" alt="karola_glacier.jpg"></p><p><img src="https://i.loli.net/2019/08/04/PiKpmGfYDkCz8Ve.jpg" alt="road_view.jpg"></p><p>一路上风景真的美呆了，一直在拍照，希望把眼前的美景尽可能多的留在记忆中。尤其是到了绵阳饭店后，傍晚的羊湖真的太美了，虽然湖边风很大，但我们几个人还是在湖边呆了很久才回去。</p><p><img src="https://i.loli.net/2019/08/04/jdfIi62oh7pVOC1.jpg" alt="road_view.jpg"></p><p><img src="https://i.loli.net/2019/08/04/CGdqczrtaSbyTmA.jpg" alt="yamdrok_lake_horses.jpg"></p><p><img src="https://i.loli.net/2019/08/04/dLpKZHGq7Jc5Wag.jpg" alt="mirror_like_yamdrok.jpg"></p><p><img src="https://i.loli.net/2019/08/04/32Mef5Kuo6k8lWp.jpg" alt="sunset_at_yamdrok_lakeside.jpg"></p><p><img src="https://i.loli.net/2019/08/04/ypej5IAbZkKYPva.jpg" alt="horizon_at_yamdrok_lakeside.jpg"></p><p>绵阳饭店即是饭店也有住宿，老板是个四川人。晚上我们四个人点了几个家常小炒菜，老板自己烧的，我狼吞虎咽地足足吃了两大碗饭。后来，又来了好几批和我们一样住宿吃饭的游客，老板都快忙不过来了。过年期间，整个饭店的后厨、住宿、服务等等全是老板自己一个人搞定，不由得心生佩服。</p><p>我们快吃完的时候，餐厅门口进来了一个骑行的小哥哥，带着一个大大的登山包，风尘仆仆的，招呼老板点了几个小菜。一问居然是从日喀则一路骑行过来的，我们不约而同地发出”哇、哇”的感叹，敬佩不已。</p><p>今晚的住宿条件非常糟糕，没有地暖也没有空调，只有电热毯，本想使用睡袋，但是由于高反，怕动作大了难受，而且明早收拾起来也麻烦，就没用。而且这边厕所环境也很糟糕，是旱厕，洗漱起来更是不方便。于是随便抹了几把脸就早早上床睡觉了。</p><div style="text-align:right">2019年2月6日 晚上10点</div>---<p>早上赖了会儿床，出发前还和另外两个小伙伴闹了一点小矛盾。由于他们外出拍照走的比较远，正好赶上老板要出门去县上采购，要锁大院门，可是我们车还停在院子里，而车钥匙又在他们那，于是我们两个就只能帮他们收拾好东西，然后就坐着干等。等他们回来后，我对着他们发了点脾气，说了一些不好听的话。之后出发后，在路上也故意冷冷地和他们说话。</p><p>后来想了想觉得其实没有必要，反正我和他们都不是太熟，而且对彼此好像都没啥好感，也没有以后继续做朋友的打算，生气只会破坏自己旅行的心情。</p><p>下午到达普莫雍错，去了号称世界上海拔最高的村庄–推瓦村，从那儿俯瞰整个普莫雍错，景色壮观得不得了，只是风也非常的大，拍了一些照片就赶紧回到车上了。高反实在太难受了。</p><p><img src="https://i.loli.net/2019/08/04/sOirK6pHAyZNlnk.jpg" alt="pumo_yum_tso.jpg"></p><p><img src="https://i.loli.net/2019/08/04/tyLBJ8ouM6GiQkZ.jpg" alt="pumo_yum_tso_hug.jpg"></p><p><img src="https://i.loli.net/2019/08/04/zFSJxUa3pLGoHBQ.jpg" alt="selfie_at_pumo_yum_tso.jpg"></p><p><img src="https://i.loli.net/2019/08/04/B7kvtNsgfIAewmY.jpg" alt="pumo_yum_tso_at_tuiwa_village.jpg"></p><p><img src="https://i.loli.net/2019/08/04/XaduRl4hCiZPzGc.jpg" alt="road_view.jpg"></p><p>回拉萨的路上大家都没什么话，晚上 8 点到市区，入住酒店还出了点小插曲，我们按导航定位过去的如家不是预订的那家如家，名字一样但是隔了好几条街。9 点多入住，实在太累了，洗了个澡吃了个外卖，刷会儿手机就上床睡觉了。</p><div style="text-align:right">2019年2月7日 晚上11点</div>---<p>昨晚应该是来拉萨后睡得最好的一晚了，一觉睡到天亮，而且也没有高反的症状了，早上还赖了会儿床。本来想去拉萨附近的羊八井泡温泉的，但是由于车被另外两个小伙伴开走了，于是我和陈斌两个人决定索性就去逛逛街然后买点特产，算是我们对拉萨以及这次西藏之旅的告别了。</p><p><img src="https://i.loli.net/2019/08/04/IQ8YNt3J5cK6DO4.jpg" alt="barkhor_street_old_ladies.jpg"></p><p><img src="https://i.loli.net/2019/08/04/JXehfArU5W21qpv.jpg" alt="barkhor_street_temple_houses.jpg"></p><p>早上去附近挺有名的店吃了米粉，然后去逛了逛八廓街，中午在陈斌的要求下去吃 KFC，下午去看了场电影，然后回神力时代的大麦超市买了点特产就回酒店了。晚上去乐百隆吃了牦牛排套餐，然后去逛了夜晚的布宫广场。</p><p>夜晚的布宫也很美，而且广场上没什么人。</p><p><img src="https://i.loli.net/2019/08/04/ulr3GiV1Es2oLnT.jpg" alt="selfie_at_putala_palace_square.jpg"></p><p><img src="https://i.loli.net/2019/08/04/Ir6WLXZ4PbSs2FD.jpg" alt="putala_palace_at_night.jpg"></p><p>最后一晚就这样过去了，明天就要回去了，突然有些不舍，不知道下次还有没有机会再来。主要是高反太让人难受了，不然的话这趟旅行的体验会更好。</p><div style="text-align:right">2019年2月8日 晚上11点</div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Travel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goodbye 2018, Hello 2019</title>
      <link href="/2018/"/>
      <url>/2018/</url>
      
        <content type="html"><![CDATA[<img align="center" src="https://i.loli.net/2019/07/22/5d35ce4324b4f19553.png" /><p>算上去年除夕夜写的<a href="https://ajiew.github.io/2017/">年终总结</a>的话，今年应该是我第二次写年终总结与新年计划了。</p><p>回想这一年，对我来说发生的最重大的一件事情当然是年中时候的跳槽了，主动逃离了那个让我觉得太过安逸、舒适的环境。</p><span id="more"></span><p>而通过这一次跳槽，我也收获了一次小小的个人成长。因为自从决定离职后就不得不去思考以及为自己做决定，然后也尝试去理清一些一直以来都模糊不清的想法，比如未来的发展方向（继续深耕安卓，同时拥抱大前端），还有思维方式上（拥抱变化，接受不确定性），以及情感方面的成长（更积极主动、不再害怕丢脸或者把被拒绝看成一件多么大不了的事）。</p><p>我觉得这一次小小的经历对我来说是一件很有意义的事，因为我们最好在年轻的时候，培养起自己做决定的习惯（同时自己承担后果），以及有勇气去改变、主动跳出舒适圈的意识。这样，无论何时我们都将有能力选择自己想要的工作与生活方式。</p><p>另外，这一年里最大的转变是，开始有意识地用更面向未来的眼光来看待当下的一切。只要长期来看对个人发展有益，那么我会告诉自己一定要坚持下去，比如写博客，学英语，保持运动和阅读的习惯等等。</p><h3 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h3><h4 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h4><p>记得半年前，在入职不久后，写过一篇<a href="https://ajiew.github.io/2018-half">年中小结</a>，那个时候立下了一些 flag，现在可以来复盘一下了：</p><ol><li>学习 RN，做到能够独立开发</li></ol><p>在这半年里虽然只写了两篇 RN 相关的文章，但是的确花了不少的时间在学习 RN 上。现在来看，对于一些基本的开发其实已经没有任何问题了，而事实上目前项目也的确主要由我一个人在开发维护了。</p><ol start="2"><li>继续进阶安卓，结合官方文档，学习完《Android 开发艺术探索》和《Android 群英传》</li></ol><p>这一条并没有很好地完成，原因和第一条有关系，学习 RN 的确占用了我很多的时间。另外，《Android 开发艺术探索》虽然看了一部分，但是对我来说很多东西目前还用不到，而且平时开发也有不少新的东西需要学习，所以没能坚持下去。</p><p>虽然如此，这两本书的价值对于 Android 开发者来说是显而易见的，所以今年还是会把他们放到我的安卓进阶学习清单中的第一位。</p><ol start="3"><li>学习 Kotlin</li></ol><p>这条算是基本完成。Kotlin 的学习曲线还是挺友好的，基本上，对照文档学习一周左右就可以入门了。当然，对于一门新语言，想要熟练掌握，尽可能多的练习是少不了的，所以接下来还是会花时间去练习巩固 Kotlin（比如 Demo 都用 Kotlin 写）。</p><ol start="4"><li>每天整理自己的学习笔记，每周写总结与博客</li></ol><p>定这个目标是想逼自己多写博客，老实说一开始的确有效果，但是慢慢地，写的频率变得越来越低，到年底基本上一个月写一篇了。还是没能养成习惯吧，所以顶多算是完成了一半。</p><p>接下来的一年，我还是会把写博客定为每周待办事项之一，因为老实说，作为初级水平的安卓开发，该研究的东西还是很多的，而写成博客是吸收消化新知识的最佳途径。</p><h4 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h4><p>另外还有一些生活方面的 flag：</p><ol><li>保持自律、早睡早起</li></ol><p>算是做到了吧，现在基本不会再熬夜了，最晚 11 点半肯定要上床睡觉了，不过可能因为冬天吧。</p><ol start="2"><li>保持早上冥想与写当日计划的习惯，每天打扫房间卫生</li></ol><p>基本完成。每天洗漱完第一件事是新建行动日志和每日计划；每天都打扫卫生间，每周打扫一次房间、客厅和阳台；冥想的话，很多时候都是用早上静坐深呼吸 5 分钟替代。</p><ol start="3"><li>养成运动的习惯，做腹肌撕裂者，9 月份开始恢复夜跑</li></ol><p>基本完成。入冬以后，腹肌撕裂者做的比较少了，夜跑除非遇上下雨，基本每周一次。</p><ol start="4"><li>养成阅读的习惯，睡前看书 30 分钟</li></ol><p>睡前阅读的习惯没能坚持，因为经常会拖延，然后看到时间有点晚了就直接上床睡觉了。最好的解决办法尽量避免拖延（想要完全改掉这个习惯很难，但是可以一点点来），到点强迫自己放下手中别的事情开始看书，或者提前上床关手机看书。</p><ol start="5"><li>坚持流利说打卡</li></ol><p>完成一半。升到 L8 并且全部课程满星之后，坚持每天打卡的热情就降低了很多。不过接下来也不会花太多时间打卡了，还是把这部分时间挪到其他方面，比如阅读英文原著，周末可以继续流利说打卡，继续练习 L7-L8 的课程。</p><ol start="6"><li>少刷手机，少上 <del>Pornhub</del></li></ol><p>这条基本没做到。每次看行动日志，都可以看到自己从 10 月份开始，每周都有几天，下班后会花掉一大块的时间用来刷手机。现在看来这些时间浪费掉真的挺可惜的，这是接下来第一个需要改正的习惯，无论是恢复流利说打卡还是用来写博客也好，总之一定要利用好时间。珍爱生命，少刷手机。</p><h3 id="未来一年"><a href="#未来一年" class="headerlink" title="未来一年"></a>未来一年</h3><p>偶然间看到 Steve Pavlina 的一篇复盘过去一年的<a href="https://www.stevepavlina.com/blog/2005/01/the-year-in-review/">文章</a>，觉得从这几个方面来复盘、制定计划很不错，于是直接拿来用了。</p><ul><li>Physical</li><li>Mental</li><li>Work/Career</li><li>Financial</li><li>Marriage</li><li>Family</li><li>Emotional</li><li>Spiritual</li><li>Social</li><li>Personal Development</li><li>Fun</li></ul><ol><li>首先是身体健康方面。</li></ol><p>对我来说最重要的是两点，养成良好的饮食习惯以及多锻炼。饮食方面，少吃外卖，多动手自己做饭；少吃高热量的食物，低糖低淀粉少盐（口味清淡一点）；多吃水果和蔬菜，少吃零食；每周日节食一天，或者只吃水果；平时养成多喝水的习惯。</p><p>锻炼方面，继续保持定期跑步的习惯，目标每月 50-80 km；每周至少一次腹肌撕裂者；避免长时间工作，多起身休息，多放松眼睛以及活动身体，或者下楼走走，”绿色锻炼”等；平时多利用休息时间做深蹲，在家的话，做卷腹、平板支撑等。</p><ol start="2"><li>其次是心智方面。</li></ol><p>过去一年里的阅读量还算让自己满意，但是回想起来其实还可以对自己再『严苛』一点，因为有不少书是在比较短的时间内就看完了，而如果能把那些花在刷无用信息上的时间利用起来，其实还可以阅读很多很多好书。</p><p>另外，去年买了一堆书，然而看完的却没多少，有的还没来的及拆封。还有 Kindle 上也下载了不少书，再加上一直在增长的阅读清单，今年真的要更加珍惜时间了。不过这世界上值得看的书那么多，从来就不奢望自己能有时间把所有想看的书都看完，所以只要一本本看下去，不断成长、有收获就好了。</p><ol start="3"><li>工作/事业方面。</li></ol><p>目前入职已经半年了，总的来说工作还是比较顺心的，没有什么大的压力，也不怎么加班，只不过做的东西比较杂。但是，回想自己这半年的经历，有哪些东西是比较拿得出手的呢？好像并没有。除了日常工作，大部分时间自己都还处在摸索阶段。所以，就当这半年是我的缓冲期吧，熟悉公司的业务以及各个项目的细枝末节。</p><p>接下来一年，除了项目日常的功能开发和维护之外，对自己的目标是一定要在至少某一方面做出大的提升，比如应用的性能以及 UI 体验上。</p><ol start="4"><li>财务方面。</li></ol><p>今年开始存钱了，也在考虑是不是应该开始接触一些理财产品。我其实很早就开始关注理财方面的知识了，以前一直以为理财有门槛，需要积累起个人资产才可以理财，但接触理财之后才明白并不是这样，因为理财除了使财富增长这一目的以外，还可以帮助你培养起风险意识。</p><p>不过今年算是寒冬了，从年初比特币的暴跌，到年中大批 P2P 平台的崩盘，还有年底贸易战引发的股灾。庆幸因为没钱入场，这些都被我一一躲过，不然以我的有限的风险管理知识，估计也得被坑。</p><p>老实说，其实我也不懂什么风险管理，只不过最近看到大家都在说股市、基金现在都处于低点，是比较好的入场时机，所以就拿一部分钱出来试试吧，打算先尝试下基金定投，希望能帮助自己培养起储蓄的习惯。</p><ol start="5"><li>个人情感方面。</li></ol><p>自己也老大不小了，但是恋爱经历几乎等于零，这方面的确需要更加重视起来了。其实吧，说身边没有合适的机会都是借口，最根本的原因还是太懒、脸皮太薄。身在大城市，认识异性的机会到处都是，就算性格非常害羞，通过线上的活动或者他人介绍认识也算比较常见了，但是自己却连这种方式都觉得不好意思、开不了口，可以说心理包袱非常重了。所以接下来这一年呢，要多参加一些户外以及年轻人的桌游等社交类的活动，锻炼自己和陌生人搭讪的能力，多和他人分享自己的工作和生活经历。总之，学会更好地与他人进行沟通交流。</p><ol start="6"><li>家人方面。</li></ol><p>虽说离家并不远，平均每月回家一次，但是每次回家都感受到『在爸妈眼里，你永远是他们的孩子』。我们在不停成长，而他们却在慢慢老去，真的要多花时间陪陪他们。虽然我们说的很多东西他们也听不懂，但是他们真的是这个世界上最关心、在乎你的人。</p><p>以后回家，多陪爸爸妈妈聊聊天，哪怕是听他们的唠叨；多帮他们做做家务；多陪他们出门走走。还有，今年一定要给全家人做一顿饭！</p><ol start="7"><li>情绪/精神方面。</li></ol><p>新的一年，继续保持积极乐观的心态，保持好奇心，做到更理性、更豁达、更平和。</p><ol start="8"><li>社会关系方面。</li></ol><p>我不是那种外向、喜欢交朋友类型的人，所以身边人际关系非常简单，而且也很少会去刻意地维护一段关系，更不会主动去寻求连接一段新的关系。这种状态大部分时候都挺好的，因为我知道自己就是这样的性格，而且只要能自得其乐其实也没什么关系。但是，人毕竟是社交动物，有的时候还是需要与别的同类进行交流的。</p><p>由于交际圈的狭小，很多时候你会发现，自己好像一直以来都只能和那几个人见面交往。而且有时候当你迫切需要一个倾诉对象的时候，翻开通讯录却不知道该找谁。所以呢，积极维护起自己的社交圈子是非常重要的，不仅限于沟通交流，还有共同成长以及在必要时给予彼此一些帮助等等。不过，就像查理芒格说的：『想得到一样东西，最可靠的方法是让自己配得上它』。想要获得稳定可靠的人际关系的前提是我们能够给他人提供价值，无论是外表、金钱、能力、忠诚或者别的什么。</p><p>从现在起，开始细心留意身边那些优秀的人，向他们靠拢，走进他们的圈子，然后一点一点打造起属于自己的圈子。慢慢积累，应该不算太晚。</p><ol start="9"><li>个人成长方面。</li></ol><p>目前来看，技术方面的成长对我来说最为重要吧。新的一年，希望自己能稍微逼迫自己一下，回到高中、大学时期那种专注的学习状态，潜下心来钻研技术。深知自己过去落后太多，欠下的债终究是要还的：从算法和数据结构到计算机和网络基础等等，都需要好好从头再学一遍。</p><p>也许很难，可能时不时地还会想要放弃，但是每当觉得坚持不下去的时候，翻看下自己此刻写下的文字吧。到达终点的旅程从不容易，唯有强者才能战胜自己，完成目标。</p><ol start="10"><li>娱乐方面。</li></ol><p>不知道从什么时候开始，好像所有人都立志要做一个有趣的人，但是怎样才算是一个有趣的人呢？在我看来，不在乎外界的条条框框，按照自己的想法去活出自己的人生，应该就算是有趣的人了吧。人生那么短，如果时刻都紧绷着，按别人定的标准去活，多没意思。</p><p>另外，还要学会及时行乐，哪怕只是自娱自乐。接下来这一年，我想要学会一项新的运动，暂定为滑板，因为好像玩滑板的男生都挺酷的。</p><p>Hope we all have fun!</p><hr><p>虽然定下了计划，但是生活充满变数，我们无法时刻都按照计划去生活。但是只要方向没错，每天都有进步，坚持一年下来必定会有收获（至少会收获对自己的满意），同时也不容易陷于焦虑之中。</p><p>祝所有人都能实现自己的新年愿望。新年快乐！</p><p>　</p><p>推荐阅读： <a href="https://www.stevepavlina.com/blog/2005/01/the-year-in-review/">The Year In Review</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
            <tag> Reviews </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fragment 数据懒加载及原理</title>
      <link href="/fragment-lazy-load/"/>
      <url>/fragment-lazy-load/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35c962c25ad56668.png" alt="Blow, Blow Thou Winter Wind - John Everett Millais"></p><blockquote><p>Fragment 的懒加载算是比较常见的功能了，但是之前一直没有仔细研究过，直到最近有这方面的需求，所以就写下这篇文章记录下自己的探索过程。</p></blockquote><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>最近据后台同事反馈说，某些接口调用的频率有点高，而这块业务还没完全开放，照理说很少会用到，于是让我查查怎么回事。</p><p>我看了下日志，把网络请求日志过滤出来，发现的确有问题，每次打开首页后都有许多那块业务相关的网络请求。于是马上联想到可能是因为首页改版之后嵌套使用了 ViewPager，业务未完全开放的那个 fragment 里嵌套了一个 ViewPager，里面有多个 fragment，这样每次打开首页都会去加载该 page，然后是一连串的 fragment 初始化以及网络请求，所以为了解决该问题就不得不使用懒加载。</p><p>最终想要实现的效果是：1) 当 fragment 不可见的时候不加载数据；2) 当数据已经加载过之后，除非手动刷新否则不重新请求数据。</p><span id="more"></span><h3 id="预加载与-setUserVisibleHint"><a href="#预加载与-setUserVisibleHint" class="headerlink" title="预加载与 setUserVisibleHint()"></a>预加载与 setUserVisibleHint()</h3><p>首先，默认情况下，由于 ViewPager 会预加载左右两边相邻的<strong>至少 1 个</strong> fragment，通过 <code>setOffscreenPageLimit()</code> 设置预加载 page 数为 0 并不会起作用，这点从 ViewPager 的源码中可以看到：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> int DEFAULT_OFFSCREEN_PAGES = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">public</span> void setOffscreenPageLimit(int limit) &#123;<br>    <span class="hljs-keyword">if</span> (limit &lt; DEFAULT_OFFSCREEN_PAGES) &#123; <span class="hljs-comment">// &lt;0? 对不起，不可以！</span><br>        Log.w(TAG, <span class="hljs-string">&quot;Requested offscreen page limit &quot;</span> + limit + <span class="hljs-string">&quot; too small; defaulting to &quot;</span><br>                + DEFAULT_OFFSCREEN_PAGES);<br>        limit = DEFAULT_OFFSCREEN_PAGES;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (limit != mOffscreenPageLimit) &#123;<br>        mOffscreenPageLimit = limit;<br>        populate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从以上源码可以看出相邻 fragment 的加载是必然的，但是我们如果可以得知 fragment 可见性，那么就可以在 fragment 可见时才去加载数据。这样虽然不是完全的懒加载，只是数据懒加载，但是同样也可以满足我们的需求了。</p><p>那么 fragment 中有没有可以获取当前 fragment 是否可见的方法呢，当然是有的，它就是 **<code>setUserVisibleHint(boolean isVisibleToUser)</code>**。</p><p>无论你使用的是 FragmentPagerAdapter 还是 FragmentStatePagerAdapter，当它们初始化 fragment 的时候，该方法都会被调用两次。</p><p>一次是在实例化的时候，也就是在 instantioateItem() 方法中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> Object instantiateItem(ViewGroup container, int position) &#123;&#125;<br></code></pre></td></tr></table></figure><p>一次是在用户滑动到当前 fragment 的时候，在 setPrimaryItem() 方法中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> void setPrimaryItem(ViewGroup container, int position, Object <span class="hljs-keyword">object</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>另外，当用户从当前 fragment 滑出的时候，setPrimaryItem() 方法也会被调用。</p><p>来看下 <code>setUserVisibleHint()</code> 的注释：</p><blockquote><p>Set a hint to the system about whether this fragment’s UI is currently visible to the user. This hint defaults to true and is persistent across fragment instance state save and restore.<br>An app may set this to false to indicate that the fragment’s UI is scrolled out of visibility or is otherwise not directly visible to the user. This may be used by the system to prioritize operations such as fragment lifecycle updates or loader ordering behavior.</p></blockquote><p>系统正是通过该方法来判断当前 fragment 的 UI 是否对用户可见，而该方法被暴露出来的主要目的也是让我们可以提醒系统当前 fragment 已经不可见了，是时候重新更新 fragment 的生命周期了。</p><p>不过如果只是实现数据懒加载，我们不需要直接去调用该方法，只要覆写它并实现控制数据加载的逻辑就可以了。</p><p>这里我参考了一种比较简便的做法，原文来自 <a href="https://www.jianshu.com/u/bd3befbe51d0">尹star</a> 的 <a href="https://www.jianshu.com/p/c5d29a0c3f4c">ViewPager+Fragment LazyLoad 最优解</a>。</p><p>实现效果：</p><img src="https://i.loli.net/2019/09/09/GoTrE7uSw6ZJICj.gif" width="40%"/><p>项目地址：<a href="https://github.com/aJIEw/DemoUI/tree/7360c2bc21eed4bb63645fcb2eba46997025b543/app/src/main/java/com/ajiew/demoui/ui/lazyloadfragment">aJIEw/DemoUI-LazyLoadFragment</a></p><p>可以看到只有第一次进入 fragment 的时候才会加载数据，而且也不会主动加载相邻的 fragment 或者已经加载过的数据了。</p><h3 id="如何实现及其原理（Koltin-实现）"><a href="#如何实现及其原理（Koltin-实现）" class="headerlink" title="如何实现及其原理（Koltin 实现）"></a>如何实现及其原理（Koltin 实现）</h3><p>首先，由于 <strong><code>setUserVisibleHint()</code></strong> 会在 fragment 实例化时就先被调用 (在 onAttach() 之前)，所以我们最好在 view 创建完毕之后加载数据，因此需要设置一个 view 是否初始化完毕的标志位。另外，当然也需要一个 view 是否可见的标志位，只有等到 view 可见才允许加载。然后还可以选择保存数据的初始化状态，这样可以控制在 fragment 生命周期中的合适时机重新加载数据。所以，我们需要以下 3 个标志位：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * View 的初始化状态，只有初始化完毕才加载数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isViewInitiated: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * View 是否可见，只有可见时才去加载数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isVisibleToUser: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数据是否已经初始化，避免重复请求数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isDataInitiated: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>然后接下来分为两种情况，一种是 view 初始化完毕但是此时还不可见的情况。很显然，我们只要判断 <code>setUserVisibleHint()</code> 中参数的值就可以了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(isVisibleToUser: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.setUserVisibleHint(isVisibleToUser)<br>    <span class="hljs-keyword">this</span>.isVisibleToUser = isVisibleToUser<br>    prepareFetchData()<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种情况是，如果当前 fragment 是整个 ViewPager 的第一个 fragment，那么 <code>setUserVisibleHint(true)</code> 会在 view 初始化之前就在 <code>setPrimaryItem()</code>中被调用，此时 view 已经可见了，但是我们要等到 view 初始化才加载数据，所以我们要在某个地方判断 view 是否已经初始化并且去加载数据。</p><p>最好的地方是在 onActivityCreated() 中。根据 fragment 生命周期我们知道，onActivityCreated() 会在 onCreateView() 之后调用，此时 view 已经初始化完毕，我们可以在这里将 <code>isViewInitiated</code> 标记为 true，同时在这里为第一个显示的 fragment 加载数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onActivityCreated(savedInstanceState)<br>    isViewInitiated = <span class="hljs-literal">true</span><br>    prepareFetchData()<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们还需要判断下数据是否已经加载过，避免重复加载。</p><p>我们将以上所有判断逻辑写在 prepareFetchData() 中，判断条件为 view 已经初始化、可见且数据未加载：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">prepareFetchData</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (isViewInitiated &amp;&amp; isVisibleToUser &amp;&amp; !isDataInitiated) &#123;<br>        isDataInitiated = <span class="hljs-literal">true</span><br>        fetchData()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后再定义一个抽象方法 fetchData()，让子类去实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在该方法中发起网络请求获取数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>这样一个完整的数据懒加载就实现完毕了。</p><h3 id="验证想法"><a href="#验证想法" class="headerlink" title="验证想法"></a>验证想法</h3><p>我们可以看下以上操作的日志来验证下我们的想法。</p><h4 id="1-首次打开"><a href="#1-首次打开" class="headerlink" title="1. 首次打开"></a>1. 首次打开</h4><p>第一次打开，FirstFragment 作为第一个可见的 fragment 立马被初始化：</p><p><img src="https://i.loli.net/2019/07/22/5d35cdfce7f2152354.png" alt="1.1-FirstFragment_creation.png"></p><p>此时 isVisibleToUser 会在 isViewInitiated 之前设为 true，所以 FirstFragment 会在 onActivityCreated() 中真正开始获取数据。</p><p>另外，由于预加载的存在，SecondFragment 也会被创建，但是此时还不可见：</p><p><img src="https://i.loli.net/2019/07/22/5d35cb257ca6954004.png" alt="1.2-SecondFragment_creation.png"></p><h4 id="2-移动到-SecondFragment"><a href="#2-移动到-SecondFragment" class="headerlink" title="2. 移动到 SecondFragment"></a>2. 移动到 SecondFragment</h4><p>当滑动到 SecondFragment 的时候，SecondFragment 状态变为可见，setUserVisibleHint(true) 被调用，所以开始获取数据：</p><p><img src="https://i.loli.net/2019/07/22/5d35cb256a36494392.png" alt="2.1-SecondFragment_visible.png"></p><p>而此时 FirstFragment 由可见变为不可见：</p><p><img src="https://i.loli.net/2019/07/22/5d35cb252b52141814.png" alt="2.2-FirstFragment_not_visible.png"></p><p>ThirdFragment 则开始第一次被创建，同样此时并不可见：</p><p><img src="https://i.loli.net/2019/07/22/5d35cb254eed164238.png" alt="2.3-ThirdFragment_creation.png"></p><h4 id="3-移动到-ThirdFragment"><a href="#3-移动到-ThirdFragment" class="headerlink" title="3. 移动到 ThirdFragment"></a>3. 移动到 ThirdFragment</h4><p>当滑动到 ThirdFragment 的时候，状态变为可见，所以也就开始获取数据：</p><p><img src="https://i.loli.net/2019/07/22/5d35cb255caec88812.png" alt="3.1-ThirdFragment_visible.png"></p><p>此时 SecondFragment 由可见变为不可见： </p><p><img src="https://i.loli.net/2019/07/22/5d35cb2589c6023546.png" alt="3.2-SecondFragment_not_visible.png"></p><p>而 FirstFragment 由于超出了 ViewPager 可以保存的 Fragment 的数量，所以被销毁：</p><p><img src="https://i.loli.net/2019/07/22/5d35cb259764165004.png" alt="3.3-FirstFragment_destroyed.png"></p><h4 id="4-回到-SecondFragment"><a href="#4-回到-SecondFragment" class="headerlink" title="4. 回到 SecondFragment"></a>4. 回到 SecondFragment</h4><p>此时 SecondFragment 重新变得可见：</p><p><img src="https://i.loli.net/2019/07/22/5d35cb25759f172652.png" alt="4.1-SecondFragment_visible_again.png"></p><p>而 FirstFragment 也开始重新被创建：</p><p><img src="https://i.loli.net/2019/07/22/5d35cb25af55128015.png" alt="4.2-FirstFragment_recreation.png"></p><h4 id="5-回到-FirstFragment"><a href="#5-回到-FirstFragment" class="headerlink" title="5. 回到 FirstFragment"></a>5. 回到 FirstFragment</h4><p>此时 FirstFragment 重新变得可见，虽然 FirstFragment 之前被销毁了，但是由于之前获取的数据会被恢复，所以现在不会重新去获取数据：</p><p><img src="https://i.loli.net/2019/07/22/5d35cb25a20ad73908.png" alt="5.1-FirstFragment_visible_again.png"></p><p>当然我们也可以选择在 onDestroy() 中将 isDataInitiated 置为 false，这样每次 fragment 重新创建都会重新获取数据。当然前提是你使用的是 <code>FragmentStatePagerAdapter</code>，因为如果使用 <code>FragmentPagerAdapter</code>，不会每次都调用 onDestroy()，fragment 实例会被保存。而 SecondFragment 再次变得不可见，ThirdFragment 被销毁，过程与 3 中移动到 ThirdFragment 类似，这里就不截图了。</p><p>通过以上日志，验证了我们的想法是对的。</p><p>另外，如果是 ViewPager 嵌套 ViewPager 其实效果也是一样的，如果不做特殊处理，相邻的 fragment 的会被加载，导致该 fragment 中的 ViewPager 会去加载其中的 fragment。</p><img src='../assets/2018-12-27/nested_viewpager.png' width=80%/>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native - 从 Redux 进阶谈起</title>
      <link href="/dive-into-rn-redux/"/>
      <url>/dive-into-rn-redux/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2018-10-12/reeds_in_the_autumn_wind_by_sunny_2011.jpg" alt="Autumn Wind"></p><blockquote><p>继上次写完 Redux 之后，留下了很多坑，其实这篇也不算是进阶，毕竟只是一些库的使用以及一些小技巧而已，权当是上一篇的填坑了吧。</p></blockquote><h3 id="01-Middleware-amp-Thunk"><a href="#01-Middleware-amp-Thunk" class="headerlink" title="01 Middleware &amp; Thunk"></a>01 Middleware &amp; Thunk</h3><h4 id="What’s-Middlewares"><a href="#What’s-Middlewares" class="headerlink" title="What’s Middlewares?"></a>What’s Middlewares?</h4><p>当我们发送 action 的时候，正常情况下是从 action -&gt; reducer，引入中间件后变为 action -&gt; middlewares -&gt; reducer。为什么要这么做？因为很多时候我们想在 action 传送到 reducer 之前，对数据流进行改变或者进行一些别的什么操作，比如对 action 添加日志，如果一个个去更改 Action Creator 未免太过麻烦，而使用 Middleware 的话就简单很多，可以帮我们省去很多重复代码。最重要的一点，我们可以通过使用 <a href="https://github.com/reduxjs/redux-thunk">Thunk Middleware</a> 来实现异步 action。</p><span id="more"></span><h4 id="What’s-a-thunk"><a href="#What’s-a-thunk" class="headerlink" title="What’s a thunk?"></a>What’s a thunk?</h4><p><a href="https://github.com/reduxjs/redux-thunk#whats-a-thunk">Thunk</a> 就是包装了函数表达式的用于延缓求值的方法。通过下面这个例子可以很好的理解：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即计算求值 1+2</span><br><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// 计算被延迟了，foo 可以在稍后被调用的时候再去计算 1+2，这个时候 foo 方法就是一个 thunk 方法</span><br><span class="hljs-keyword">let</span> foo = <span class="hljs-function">() =&gt;</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>为什么叫 thunk？它是『think』过去式的 <a href="https://en.wikipedia.org/wiki/Thunk#cite_note-1">幽默式表达</a>（意思是已经想好怎么做了，但是就是还没做⸜(ّᶿധّᶿ)⸝）。</p><h4 id="Redux-Thunk"><a href="#Redux-Thunk" class="headerlink" title="Redux Thunk"></a><a href="https://github.com/gaearon/redux-thunk">Redux Thunk</a></h4><p>当我们使用了 middleware 的时候，发出的 action 不会直接被 reducer 处理掉，而是先被 middleware 截获，并且我们可以在 middleware 中发起 <a href="https://redux.js.org/api/store#notes">异步请求</a>。Redux Thunk 就是这样的中间件，允许我们在 Redux 中发起异步请求。</p><h5 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a><a href="https://redux.js.org/api/applymiddleware">applyMiddleware</a></h5><p>在 <a href="https://redux.js.org/api/createstore">createStore()</a> 的时候，我们可以指定 <code>enhancer</code> 参数，最常见的就是 <code>applyMiddleware()</code>，为了在 Redux 中开启对 Redux Thunk 的支持，就需要使用该方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;applyMiddleware, combineReducers, createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span>;<br><span class="hljs-keyword">import</span> thunkMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;<br><span class="hljs-keyword">import</span> textReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./reducers/changeText&quot;</span>;<br><br><span class="hljs-keyword">const</span> allReducers = combineReducers(&#123;textReducer&#125;);<br><span class="hljs-keyword">let</span> store = createStore(allReducers, applyMiddleware(thunkMiddleware));<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><h5 id="Return-a-function"><a href="#Return-a-function" class="headerlink" title="Return a function"></a><a href="https://github.com/reduxjs/redux-thunk#motivation">Return a function</a></h5><p>使用了 Redux Thunk 后，我们可以在 Action Creators 中返回一个方法而不是 action，因此我们可以<strong>延迟</strong> action 的 dispatch 或者在只有<strong>满足条件</strong>的时候才 dispatch。内部返回的方法接收的参数分别是 store 的 <code>dispatch</code> 和 <code>getState</code> 方法。举个发起请求获取数据的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> FETCH_DATA_IN_PROGRESS = <span class="hljs-string">&#x27;FETCH_DATA_IN_PROGRESS&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> FETCH_DATA_SUCCESS = <span class="hljs-string">&#x27;FETCH_DATA_SUCCESS&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> FETCH_DATA_Failure = <span class="hljs-string">&#x27;FETCH_DATA_Failure&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (dispatch, getState) =&gt; &#123;<br>    <br>    <span class="hljs-keyword">let</span> param = getState().getData.param;<br>    <br>    dispatch(&#123;<span class="hljs-attr">type</span>: FETCH_DATA_IN_PROGRESS&#125;);<br><br>    <span class="hljs-comment">// request 是封装的 fetch 请求</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request.post(url, &#123;param&#125;);<br><br>    <span class="hljs-keyword">if</span> (res &amp;&amp; !res.status) &#123;<br>      <span class="hljs-comment">// 请求成功才发送数据</span><br>      dispatch(&#123;<span class="hljs-attr">type</span>: FETCH_DATA_SUCCESS, <span class="hljs-attr">data</span>: res.data&#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      dispatch(&#123;<span class="hljs-attr">type</span>: FETCH_DATA_Failure&#125;);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个就是一个 thunk function，其使用方式与普通的 Action Creators 一样，可以直接作为第二个参数传入 <code>connect()</code> 方法中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(mapStateToProps, &#123;changeText, changeBack, getData&#125;)(Main);<br></code></pre></td></tr></table></figure><p>当然 Redux Thunk 也不是唯一的发送异步 Action 的方式，比如 <a href="https://github.com/yelouafi/redux-saga/">redux-saga</a> 以及 <a href="https://github.com/acdlite/redux-promise">redux-promise</a> 都可以达到相同的目的，Redux 文档上还介绍了一些别的方式：</p><blockquote><p><a href="https://github.com/gaearon/redux-thunk">Thunk middleware</a> isn’t the only way to orchestrate asynchronous actions in Redux:</p><ul><li>You can use <a href="https://github.com/acdlite/redux-promise">redux-promise</a> or <a href="https://github.com/pburtchaell/redux-promise-middleware">redux-promise-middleware</a> to dispatch Promises instead of functions.</li><li>You can use <a href="https://github.com/redux-observable/redux-observable">redux-observable</a> to dispatch Observables.</li><li>You can use the <a href="https://github.com/yelouafi/redux-saga/">redux-saga</a> middleware to build more complex asynchronous actions.</li><li>You can use the <a href="https://github.com/lelandrichardson/redux-pack">redux-pack</a> middleware to dispatch promise-based asynchronous actions.</li><li>You can even write a custom middleware to describe calls to your API, like the <a href="https://redux.js.org/introduction/examples#real-world">real world example</a> does.</li></ul><p>It is up to you to try a few options, choose a convention you like, and follow it, whether with, or without the middleware.</p></blockquote><h3 id="02-Higher-Order-Components"><a href="#02-Higher-Order-Components" class="headerlink" title="02 Higher-Order Components"></a>02 Higher-Order Components</h3><h4 id="What’s-HOC"><a href="#What’s-HOC" class="headerlink" title="What’s HOC?"></a>What’s HOC?</h4><p>HOC 即 Higher-Order Components 高阶组件的简称，从形式上来看，其实就是接收函数作为参数的函数。</p><p>HOC 是 React 中的一种模式，通过 HOC 我们可以方便地在多个组件中注入一些通用的功能，这样就可以避免重复的代码逻辑。一个 HOC 函数接收一个组件作为参数，并且返回一个新的组件，通过 HOC 函数我们可以为组件添加额外的功能或者数据。</p><p>在 RN 中，一种常见的使用方式是通过 HOC 函数作为页面跳转的依据。比如检验有无登录，如果页面需要登录后才能查看，那么用户在未登录的情况下会先跳转登录页。</p><h4 id="How-to-use-it"><a href="#How-to-use-it" class="headerlink" title="How to use it?"></a>How to use it?</h4><p>HOC 的使用方法很简单，形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> hoc = <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HOC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> /&gt;</span></span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> HOC;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的匿名函数接收的参数是 <code>WrappedComponent</code>，即我们需要包装的组件，返回的是我们对包装的组件进行处理之后的新组件。其使用方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myHOC = hoc(MyComponent);<br></code></pre></td></tr></table></figure><p>除此之外，我们也可以结合 React Redux 使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> hoc = <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> connect(mapStateToProps, mapDispatchToProps)(<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HOC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> /&gt;</span></span>;<br>    &#125;<br>  &#125;<br> );<br></code></pre></td></tr></table></figure><p>其实这里的 <code>connect()</code> 方法就是一个 HOC 的例子，通过连接组件和保存在 Store 中的全局 state，同时在组件中可以通过 props 的形式来访问这些全局 state。</p><h3 id="03-Combine-with-react-native-router-flux"><a href="#03-Combine-with-react-native-router-flux" class="headerlink" title="03 Combine with react-native-router-flux"></a>03 Combine with <a href="https://github.com/aksonov/react-native-router-flux">react-native-router-flux</a></h3><p>介绍了 Thunk Middleware 和 HOC，接下来我想用一个例子展示如何在项目中使用他们。这个例子使用到了 React Native Router，这是一个非常好用的页面路由、页面导航以及页面间传递数据的 RN 框架。这里我只用到了其中很小一部分的功能，更多的用法请移步 <a href="https://github.com/RNRF/react-native-router-flux/blob/master/docs/API.md">API 文档</a>。</p><p>照惯例，先看下实现的效果：</p><img src="../assets/2018-10-12/788577-480f5f8b10cc5cfe.gif" style="zoom:40%;" /><p>可以看到，我们在原来的基础上添加了两个新的页面，一个是登录后的页面，一个是登录页，连接它们的是一个 HOC 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> verifyLogin = <span class="hljs-function"><span class="hljs-params">WrappedComponent</span> =&gt;</span> connect(mapStateToProps)(<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.props.authToken) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...this.props</span>&#125; /&gt;</span></span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Login</span>/&gt;</span></span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapStateToProps</span>(<span class="hljs-params">state</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">authToken</span>: state.authInfo.data,<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> verifyLogin;<br></code></pre></td></tr></table></figure><p>在 HOC 中，我们根据 <code>authToken</code> 的状态来决定是直接跳转还是先跳转到登录页。这个例子很好的说明了 HOC 函数的优势，所有需要登录的地方都只要调用这个函数就可以了。这里的 <code>authToken</code> 是从 store 中获取的，因此我们还得写一个模拟登录的 Action Creator 来进行登录获取 <code>token</code>，同时展示下如何使用 Redux Thunk 发起异步请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">login</span>(<span class="hljs-params">info</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (dispatch, getState) =&gt; &#123;<br>    dispatch(&#123;<span class="hljs-attr">type</span>: Request_login_requesting&#125;);<br><br>    <span class="hljs-comment">// 模拟发起请求并获取结果</span><br>    <span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;fakeAuthRequestAndGetResult&#x27;</span>;<br><br>    <span class="hljs-comment">// 根据请求结果发送不同的 action</span><br>    <span class="hljs-keyword">if</span> (res) &#123;<br>      dispatch(&#123;<span class="hljs-attr">type</span>: Request_login_success, <span class="hljs-attr">data</span>: res&#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      dispatch(&#123;<span class="hljs-attr">type</span>: Request_login_failure&#125;);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，还有对应的 <code>reducer</code>，注意，<code>combineReducers()</code> 接收的参数为对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">data</span>(<span class="hljs-params">state = <span class="hljs-string">&#x27;&#x27;</span>, actions</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span>(actions.type)&#123;<br>    <span class="hljs-keyword">case</span> Request_login_success:<br>    <span class="hljs-keyword">case</span> Request_login_failure:<br>      <span class="hljs-keyword">return</span> actions.data;<br>    <span class="hljs-keyword">case</span> Request_logout:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> authInfo = combineReducers(&#123;data&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> authInfo;<br></code></pre></td></tr></table></figure><p>最后，除了两个新页面之外，我们还需要定义一个 router 页，也就是使用 React Native Router 来管理各个页面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppRouter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Stack</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Scene</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#x27;root&#x27;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Main&#125;</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Scene</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#x27;personal&#x27;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Personal&#125;</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Scene</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#x27;login&#x27;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Login&#125;</span> /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Stack</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> AppRouter;<br></code></pre></td></tr></table></figure><p>然后在 App 的入口处使用 <code>AppRouter</code> 替换原来的 <code>Main</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Root</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="hljs-comment">// 第一层包装，连接组件和 store</span><br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">AppRouter</span>/&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>OK，核心代码就是这样了，完整代码：<a href="https://github.com/aJIEw/HeadFirstRN/tree/master/app/redux">aJIEw/Redux</a></p><h3 id="04-Sum-Up"><a href="#04-Sum-Up" class="headerlink" title="04 Sum Up"></a>04 Sum Up</h3><p>这篇写的比较杂，一开始只是想写下 Redux 中的 middleware，后来看了这篇 <a href="https://medium.com/@shoshanarosenfield/redux-thunk-vs-redux-saga-93fe82878b2d">Redux-Thunk vs. Redux-Saga</a>，发现对于大多数场景下，的确使用 Redux-Thunk 就足够了。而 HOC 也是临时想到要写一写的，毕竟也算是 React 中一种常见的模式了吧。最后这个结合 react-native-router 写的例子也比较简单，主要用来说明 Redux-Thunk 发异步请求以及 HOC 的大致用法。</p><p>好了，写完这篇有种『我已经掌握 React Native 开发了』的错觉，但其是内心还是很慌的，因为知道要掌握的东西还有太多。不过一口吃不成个胖子，只能静下心来一步一脚印慢慢往前走了。每天进步一点点，坚持下去，收获就是巨大的。嗯，加油~(•̀ᴗ•́)و ̑̑</p><hr><p>相关文章：<a href="https://ajiew.github.io/rn-redux-introduction/">React Native - Redux 入门</a></p><p>参考文章：</p><ol><li><a href="https://segmentfault.com/a/1190000007843340">React 项目中 Redux 中间件的理解</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">Redux 入门教程（二）：中间件与异步操作</a></li><li><a href="https://juejin.im/post/5b035c0c51882565bd258f12">Redux-Thunk 快速入门</a></li><li><a href="https://medium.com/@gethylgeorge/understanding-how-redux-thunk-works-72de3bdebc50">Understanding how redux-thunk works</a></li><li><a href="https://zhuanlan.zhihu.com/p/27985956">面向初学者的高阶组件教程</a></li><li><a href="https://levelup.gitconnected.com/understanding-react-higher-order-components-by-example-95e8c47c8006">Understanding React Higher-Order Components by Example</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Provisioning Profile 的一些小问题</title>
      <link href="/provisioning-profile/"/>
      <url>/provisioning-profile/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2018-10-09/trees_in_fall.jpeg" alt="Autumn Leaves"></p><blockquote><p>在 iOS 打包发布的时候遇到了一些问题，所以稍微研究了下 iOS 打包时涉及到的一些概念以及打包安装流程，希望能加深下印象。</p></blockquote><h3 id="What’s-Provisioning-Profiles"><a href="#What’s-Provisioning-Profiles" class="headerlink" title="What’s Provisioning Profiles?"></a>What’s Provisioning Profiles?</h3><p>类似于安卓应用必须经过签名才可以安装到手机上，同样的，在 iOS 设备上，只有经过 Apple 认证的应用才能被安装。在开发 iOS 应用时，我们难免需要使用真机测试，为了使测试版应用可以在真机上安装，我们就需要使用 <code>Provisioning Profiles</code>。</p><p>那么，什么是 <code>Provisioning Profiles</code> ?</p><span id="more"></span><p>官方是这么解释的：</p><blockquote><p>A provisioning profile is a collection of digital entities that uniquely ties developers and devices to an authorized <strong>iPhone Development Team</strong> and enables a device to be used for testing. A Development Provisioning Profile must be installed on each device on which you wish to run your application code. Each Development Provisioning Profile will contain a set of <strong>iPhone Development Certificates</strong>, <strong>Unique Device Identifiers</strong> and an <strong>App ID</strong>. Devices specified within the provisioning profile can be used for testing only by those individuals whose iPhone Development Certificates are included in the profile. A single device can contain multiple provisioning profiles.</p></blockquote><p>首先，我们需要有一个开发者账号，这个账号是可以被整个开发团队（也就是 <em>iPhone Development Team</em>）共享的。通过 Apple 认证后，这个开发者账号就可以通过添加 <code>Provisioning Profiles</code> 来关联测试设备了。也就是说 <code>Provisioning Profiles</code> 起到了一个桥梁的作用，它会对应用进行验证，决定应用能否被安装到设备上。另外，只有 <code>Provisioning Profiles</code> 安装到测试设备上之后我们的测试应用才能安装成功，一台测试设备可以有多个 <code>Provisioning Profiles</code>。</p><p><code>Provisioning Profiles</code> 中包含以下三部分内容：</p><ul><li><strong>iPhone Development Certificates</strong>: 开发者证书，用于应用签名。</li><li><strong>Unique Device Identifiers</strong>: 包含一个设备列表，用于确认应用可在哪些设备上运行。</li><li><strong>App ID</strong>: 应用 ID，对应于 xCode 项目中的 <code>bundle identifier</code>。</li></ul><p><img src="../assets/2018-10-09/provisioning_profile.png" alt="一张图看懂 Provisioning Profile"></p><h3 id="How-to-use-it"><a href="#How-to-use-it" class="headerlink" title="How to use it?"></a>How to use it?</h3><p>了解了 <code>Provisioning Profiles</code> 之后，我们就可以学着如何使用它了。</p><p>首先，我们需要登入<a href="https://developer.apple.com/account/">开发者账户</a>，然后进入 <a href="https://developer.apple.com/account/ios/certificate">Certificates, Identifiers &amp; Profiles</a>，接下来我们就可以在这里添加 <code>Provisioning Profiles</code> 了。</p><p><img src="../assets/2018-10-09/certificates-identifiers-profiles.png" alt="Certificates, Identifiers &amp; Profiles"></p><p>除此之外，从上面的截图中可以看出，我们还可以在这里添加：</p><ul><li><strong>Certificates</strong>，即 <code>Provisioning Profiles</code> 中的 <em>iPhone Development Certificates</em>，该证书包含一对公钥和私钥，并且会被添加到你的 Keychain 中，可以通过 Mac 上自带的 Keychain Access 查看到（login -&gt; My Certificates）</li><li><strong>Keys</strong>，与证书相似，通过 Key 我们可以配置、认证并使用 Apple 的服务。相比证书的优点是不会过期，而且在创建后可以修改所使用的 Apple 服务的种类及数量。</li><li><strong>Identifiers</strong>，创建各种 ID 的地方，包括上面 <code>Provisioning Profiles</code> 中的 <em>App ID</em> 也是在这里创建的。</li><li><strong>Devices</strong>，测试设备列表，对应于 <code>Provisioning Profiles</code> 中的 <em>Unique Device Identifiers</em>。</li></ul><p>在创建证书的时候我们还需要使用到 CSR (Certificate Signing Request)，即证书签名请求文件。它里面包含了一串加密文字信息，当申请证书的时候我们需要将这个文件递交给认证机构（Apple）。</p><p>这里提供一个创建并配置 CSR、证书及 Provision Profile 等文件的<a href="http://dev.umeng.com/sdk_integate/ios-integrate-guide/push%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97">详细文档</a>，来自友盟，这里不得不佩服友盟的文档写的是真好。</p><h3 id="How-does-it-work"><a href="#How-does-it-work" class="headerlink" title="How does it work?"></a>How does it work?</h3><p>熟悉了以上几个概念后，我们就可以试着理解应用打包安装过程了。</p><img src='../assets/2018-10-09/signing-config.png' width=80%/><p>首先看下上面这张截图，在 Signing 时需要提供 <code>Provisioning Profile</code>，我们在添加完 <code>Provisioning Profile</code> 后就可以把它下载下来，并且导入到 xCode 就行了。</p><p>可以看到我这里分别在 Debug 和 Release 的 Signing 中使用了不同的 <code>Provisioning Profile</code>，其实他们唯一的区别是，Release 版可以上传到 App Store 经过 Apple 的审核并签名后被安装到任何 iOS 设备上，而 Debug 版只能被安装到该 <code>Provisioning Profile</code> 绑定了的设备上。</p><img src='../assets/2018-10-09/privisioning-profile-info.png' width=60%/><p>如上图，在配置了 <code>Provisioning Profile</code> 之后，xCode 首先会对一些基本信息进行验证，如果有不匹配的项会提示错误信息。</p><p>以 Debug 版为例，在打包安装会经历以下过程：</p><ul><li>首先，<code>Provisioning Profile</code> 会到 Keychain 中寻找匹配的 Certificate，即 Signing 中的 Signing Certificate</li><li>xCode 使用该 Certificate 对 app 进行签名</li><li>在安装时，首先会对设备的 UUID 和 <code>Provisioning Profile</code> 中的设备列表的 ID 进行匹配，匹配成功才会被安装，同时所需的 Entitlements 等信息也要与 AppID 中配置的一致</li><li>Keychain 中的私钥会用于和 Certificate 中的公钥进行验证（私钥如果丢失那么该 Certificate 也将失效，需要重新创建，建议导出私钥 .p12 文件并备份）</li></ul><p>在打包安装的过程中，只有所有信息都验证通过后，应用才能安装成功并被启动。对于发布版而言，如果想要安装到真机上则必须使用类型为 Ad Hoc 的 <code>Provisioning Profile</code> 才可以。</p><hr><p>参考文章：</p><ol><li><a href="https://medium.com/@abhimuralidharan/what-is-a-provisioning-profile-in-ios-77987a7c54c2">What is a provisioning profile &amp; code signing in iOS?</a></li><li><a href="https://help.apple.com/xcode/mac/current/#/dev3a05256b8">What is app signing?</a></li><li><a href="https://docs.microsoft.com/en-us/xamarin/ios/deploy-test/provisioning/entitlements?tabs=vsmac">Working with entitlements in Xamarin.iOS</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 推送调研</title>
      <link href="/android-push-notification/"/>
      <url>/android-push-notification/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35c75e88a6368765.png" alt="Android Push  Notification"></p><blockquote><p>最近开始做推送，发现 Android 平台的推送服务实在是太多了，于是就有了这篇推送调研文章。</p></blockquote><p>首先，iOS 设备的推送都会通过 APNS，所以不需要担心到达率的问题。</p><p>而安卓上的推送，由于国内无法使用 <a href="https://firebase.google.com/docs/cloud-messaging/">FCM</a> (<a href="https://developers.google.com/android/guides/overview">谷歌服务</a>被阉割)，也没有统一的推送平台，所以种类就比较繁多了。主要分为两种，一种是手机厂商自己做的推送服务，这种大都是集成到厂商系统级的 ROM 当中的，所以到达率较高。缺点是对于非自家系统，推送效果非常不理想，所以最好的做法是同时接入各个厂商的推送。</p><p>常见的手机厂商推送有：</p><ol><li><a href="https://dev.mi.com/console/appservice/push.html">小米 MIUI</a></li><li><a href="https://developer.huawei.com/consumer/cn/service/hms/pushservice.html">华为 EMUI</a></li><li><a href="https://open.oppomobile.com/service/openservice#id=1">OPPO ColorOS</a></li><li><a href="https://dev.vivo.com.cn/openAbility/pushNews">vivo FuntouchOS</a></li><li><a href="https://open.flyme.cn/open-web/views/push.html">魅族 Flyme</a></li></ol><span id="more"></span><p>另一种是专业第三方平台的推送服务，主流的有<a href="https://www.umeng.com/push">友盟推送</a>，<a href="https://www.getui.com/cn/getui.html">个推</a>，<a href="https://www.jiguang.cn/push">极光推送</a>等。其次还有各个巨头自己的推送服务，比如阿里的<a href="https://www.aliyun.com/product/cps">移动推送</a>，腾讯的<a href="http://xg.qq.com/">信鸽</a>，<a href="http://push.baidu.com/">百度云推送</a>。</p><p>第三方推送一般使用长连接和应用间互相唤醒的方式来保证推送的到达率，但是此种方式用户体验很差，存在内存大量占用以及电量消耗加快等负面影响。而且 Andoird 5.0 之后，后台进程以及定时任务的限制，保持长连接正在变得越来越困难，所以即使是极光、友盟等这样专业的推送平台，达到率也不会有他们宣称的那么高，一般估计在 50%~70%，甚至更低。不过，可以考虑通过商务合作手段让手机厂家给应用开白名单。</p><p>第三方平台的推送服务的优点是通道聚合，接入成本低。缺点除了上面提到的到达率不如系统级推送，另外还有用户数或设备数的限制，也就是说在量大的情况下部分推送平台需要收费。</p><p>以下是我个人针对第三方推送平台以及普通应用常见的推送需求整理出的一些对比：</p><table><thead><tr><th></th><th>收费</th><th>厂商通道支持</th><th>到达率</th><th>集成难度</th></tr></thead><tbody><tr><td>友盟</td><td>否</td><td>支持</td><td>高</td><td>较高</td></tr><tr><td>极光</td><td>用户数 &gt;= 500万收费（<a href="https://www.jiguang.cn/push-price">定价方案</a>）</td><td>支持 (仅 VIP)</td><td>高</td><td>一般</td></tr><tr><td>个推</td><td>否，高峰期有瓶颈限制，有 <a href="https://www.getui.com/cn/getui.html">VIP 套餐</a></td><td>不支持</td><td>高</td><td>一般</td></tr><tr><td>阿里移动推送 (ACMP)</td><td>设备数 &gt;= 5万收费（<a href="https://help.aliyun.com/document_detail/35315.html?spm=5176.56143.210096..38232ba9ebgAaI">收费方式</a>）</td><td>支持</td><td>一般</td><td>一般</td></tr><tr><td>信鸽</td><td>否</td><td>支持</td><td>一般</td><td>一般</td></tr><tr><td>百度云推送</td><td>否</td><td>不支持</td><td>高</td><td>一般</td></tr></tbody></table><blockquote><p>注：1. 到达率指标主要根据知乎等网站的网友评论，属于个人主观判断，未必准确。同时也参考了以下两篇文章：<a href="https://juejin.im/entry/5783410fa633bd005b24e079">国内 Top 500 Android 应用分析报告</a> 和 <a href="https://juejin.im/post/5add2c5c6fb9a07ab110c438">Android 推送平台试用总结报告</a>。</p><ol start="2"><li>集成难度判断主要根据文档编写质量，Demo 质量，以及个人主观判断。</li></ol></blockquote><p>综上，优先推荐使用友盟，同时后期可考虑接入小米、华为等厂商通道。</p><hr><p>参考文章：</p><ol><li><p><a href="https://sspai.com/post/42573">关于 Android 通知推送，你需要知道这些事</a></p></li><li><p><a href="https://juejin.im/entry/5783410fa633bd005b24e079">国内 Top 500 Android 应用分析报告</a></p></li><li><p><a href="https://juejin.im/post/5add2c5c6fb9a07ab110c438">Android 推送平台试用总结报告</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 推送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Root 教程</title>
      <link href="/android-root-tips/"/>
      <url>/android-root-tips/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35c714cac3529832.png" alt="Magisk"></p><blockquote><p>之前一直使用 <a href="https://twrp.me/">TWRP</a> 和 <a href="http://www.supersu.com/">SuperSu</a> 来 root 手机。但是最近发现 SuperSu 貌似已经不维护了，所以寻找了一个替代方案：<a href="https://github.com/topjohnwu/Magisk">Magisk</a>，其实 root 方式和之前没啥大的变化，但是还是觉得应该记录下，供自己以后以及他人参考。</p><p>2020/12 月更新：本文提及的 root 方法已经过时，推荐根据<a href="https://topjohnwu.github.io/Magisk/install.html">官网教程</a>安装 Magisk 即可，大多数新手机都可以直接通过 <a href="https://topjohnwu.github.io/Magisk/install.html#patching-images">Patching Images</a> 的方式来安装。</p></blockquote><h3 id="Root-介绍"><a href="#Root-介绍" class="headerlink" title="Root 介绍"></a>Root 介绍</h3><p>所谓 <code>Root</code> 也就是使手机可以获得超级管理员的权限，Andoird 系统是基于 Linux 内核的，但是出于安全角度的考虑，默认并不提供超级管理员的权限，所以获取 <code>su</code> 的权限的过程就变成了人们常说的 <code>Root</code>。</p><p><code>Root</code> 方式有很多种，主要分为两大类：使用第三方 App 或者通过进入 Recovery 模式刷写 root 包。</p><span id="more"></span><p>这两种方式各有各的优势。第一种方式的优点是方便简单，只需要安装一个 app 然后按照 app 中的提示进行操作即可完成 root，但是缺点是成功率不高，而且需要自己去寻找适用于自己手机的 app。而第二种方式的优点是成功率高，但是操作相对比较复杂。</p><p>本文介绍的 root 方式就是基于第二种方式的。</p><p>我们首先需要刷入 <a href="https://github.com/omnirom/android_bootable_recovery/">TWRP</a>，它是一个定制的 recovery，有了它之后我们就可以修改我们的系统了，比如 root 手机或者刷入第三方定制 ROM，总之有了它之后我们的手机就可以干很多之前干不了的事了。</p><p>其次，我们需要通过 TWRP 刷入 Magisk 来获取 Root 权限。<a href="https://github.com/topjohnwu/Magisk/blob/master/docs/README.MD#introduction">Magisk</a> 是一个开源的工具，提供了针对 Android 手机的 root、boot 脚本、SELinux 补丁包等许多强大的功能。它是 <a href="http://www.supersu.com/">SuperSU</a> 的完美替代解决方案，不过仅针对 Android 5.0 以上的系统。</p><h3 id="Root-步骤"><a href="#Root-步骤" class="headerlink" title="Root 步骤"></a>Root 步骤</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>首先，我们需要安装下载好对应你手机版本的 TWRP。进入 <a href="https://twrp.me/Devices/">TWRP 下载页</a>，找到对应你的手机品牌的制造商，然后选择型号。</p><p>以 Pixel XL 为例，首先找到 <strong>Google</strong>，然后选择 **Google Pixel XL (marlin)**，最后根据你手机的版本选择美版 Primary (Americas) 或欧版 Primary (Europe)。</p><blockquote><p> <strong>Q：如何查看 Pixel 的版本？</strong><br> <strong>A：</strong>打开 Settings 搜索 <code>label</code> 或 <code>标签</code>，找到 <code>Regulartory labels</code> 或 <code>监管标签</code>，点开后不管你的 MODEL 是什么，如果有看到 European Union 则代表你使用的是国际版，则直接下载欧版的 TWRP，否则如果看到 United States of America 则是美版。</p></blockquote><p>下载完 TWRP 之后，我们还需要到 <a href="https://github.com/topjohnwu/Magisk/releases">Magisk release</a> 下载最新版本的 Magisk。</p><p>最后，请确保你已经下载了 <a href="https://developer.android.com/studio/releases/platform-tools">Android Platform Tools</a>，其中包含了 <code>adb</code>、<code>fastboot</code> 等我们接下来需要用到的命令行工具。</p><h4 id="刷入-TWRP-和-Magisk"><a href="#刷入-TWRP-和-Magisk" class="headerlink" title="刷入 TWRP 和 Magisk"></a>刷入 TWRP 和 Magisk</h4><p>首先确保你的手机已经解锁，解锁方式请参考：<a href="https://developers.google.com/android/images">Factory Images</a></p><ol><li><p>重启手机进入 bootloader:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb reboot bootloader<br></code></pre></td></tr></table></figure></li><li><p>刷入 TWRP，不同手机的刷入方式不同，具体请参考你的 <a href="https://twrp.me/google/googlepixelxl.html">TWRP 下载页</a>。</p></li><li><p>刷入 Magisk，首先把 Magisk 的 .zip 包放到 sd 卡中，然后重启进入 recovery:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb reboot recovery<br></code></pre></td></tr></table></figure></li><li><p>进入 TWRP 后，选择 Install，选择 Install zip，找到 Magisk.zip 包的位置，选中后右滑确认刷入。你也可以参考这个 <a href="https://www.didgeridoohan.com/magisk/HomePage">Guide</a> 进行安装。</p></li><li><p>等待刷入完毕，成功后重启手机。</p></li><li><p>安装 <a href="https://github.com/topjohnwu/Magisk/tree/master/app">Magisk Manager</a>，用于管理哪些 app 可以拥有 root 权限，也可用来刷入一些基于 Magisk 开发的 module。不过注意谨慎尝试，有的 module 兼容性不佳，可能导致手机无法重启，发生这种情况就只能重刷系统了。如果重刷保留数据的话，那么记得先使用 Magisk-uninstaller 把 Magisk 卸载掉，不然再次安装 Magisk 会导致机子无法启动。</p></li></ol><h3 id="Root-之后如何更新系统"><a href="#Root-之后如何更新系统" class="headerlink" title="Root 之后如何更新系统"></a>Root 之后如何更新系统</h3><p>Root 之后我们就无法通过 OAT 直接更新系统了，一般需要绕过系统的检测，比如 Pixel 系统更新时会检测系统完整性，如果检测到你已经 root 过了会提醒你需要先恢复到 factory image 才能继续更新，这个时候我们需要作如下操作：</p><ul><li>  在 Magisk Manager 中点击 Uninstall，选择 RESTORE IMAGES</li><li>  在系统更新里下载并安装更新，安装完成后先不要点击重启</li><li>  回到 Magsik Manager 中，在 Magisk 一栏点击 Install - Install Magsik - Install to inactive slot，之后会下载并安装最新版本的 Magisk。</li><li>  最后点击重启整个更新就完成了。</li></ul><img src='../assets/2018-09-30/pixel-reinstall-magisk.png' width=40%/><p>其它机型操作方式也大同小异，请自行搜索。比如一加氧 OS 就不需要先卸载，OTA 更新后直接 Install to inactive slot 就可以了。</p><p>另外，TWRP 暂时<a href="https://twrp.me/site/update/2019/10/23/twrp-and-android-10.html">不支持</a> Android 10 以上的设备，所以如果是 Pixel 4 及以上的设备就没法刷 TWRP 了，只能先等等了。至于其它设备，如果存在 Android 10 之前的系统可以刷，那就先刷回老版本，再刷 TWRP 和 Magisk，然后再通过 Magsik Manager 进行 OTA 升级就好啦。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>总得来说，这种使用 Recovery 的方式来 root 手机还是挺方便的，成功率非常高。当然，root 前最好还是先备份数据，万一手机变砖了，至少还能通过刷机恢复过来。如果遇到一些小问题，记得多看看 <a href="https://www.didgeridoohan.com/magisk/Magisk">Troubleshoting</a>，我遇到的大多数问题基本上都在那里找到了答案。</p><p>祝大家国庆快乐，哈哈，又可以回家愉快得玩耍一礼拜了！开森~୧(﹒︠ᴗ﹒︡)୨</p>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tricks </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native - Redux 入门</title>
      <link href="/rn-redux-introduction/"/>
      <url>/rn-redux-introduction/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35c63419cc231618.png" alt="React Redux API Overview"></p><blockquote><p>从上周开始一直在看 Redux 相关的文档和资料，一开始一连几天都没有进展，只能一边看文档一边默默 debug，到今天总算稍微理解了一点儿，于是赶紧开始写这篇博客，目的是一点点记录下自己入门 Redux 的过程以及作为一个 React Native 菜鸟对使用 Redux 的心得体会。</p></blockquote><p>（长文预警：本文最佳阅读方式是先把 <a href="https://redux.js.org/">Redux 文档</a> 以及 <a href="https://github.com/reduxjs/react-redux/blob/master/docs/api.md#api">React Redux API 文档 </a>在另一个浏览器中打开，随时对比参考，然后把 <a href="https://github.com/aJIEw/HeadFirstRN/tree/master/src/redux">Demo 项目</a>打开，看到有疑惑的地方，随时停下来动手写一写、改一改代码，debug 下，然后再接着看）</p><h3 id="00-What’s-Redux"><a href="#00-What’s-Redux" class="headerlink" title="00 What’s Redux?"></a>00 What’s Redux?</h3><p>首先看下官方文档的解释『Redux is a predictable state container for JavaScript apps』，大致可以翻译为 Redux 是一个专为 JavaScript 应用设计的可预测的<strong>状态</strong>容器。</p><p>我的理解：如果把我们的 app 比做销售柜台的话，Redux 其实就像一个自动售货机，它可以帮助我们<strong>管理</strong>商品（<strong>组件</strong>）的各种<strong>状态</strong>。</p><span id="more"></span><p>我们知道在一个 RN 项目中，一般会定义许许多多的组件，每个组件都有自己的 <code>State</code>，通常情况下会通过 <code>setState</code> 去更改组件状态或者响应用户的在 UI 上的输入，但是随着一个 App 的内容的增加以及逻辑复杂度的上升，组件的的状态会变得越来越臃肿，继而变得难以维护（维护困难也是 RN 最大的痛点）。所以，这个时候就该 Redux 出场了，我们通过引入它来帮助我们<strong>管理组件的状态</strong>。</p><p>简单来说，有了 Redux 之后，我们基本上就不需要自己去 <code>setState</code> 了，因为几乎所有的 State 的变化都可以交给 Redux 来管理。</p><h3 id="01-Core-Concept"><a href="#01-Core-Concept" class="headerlink" title="01 Core Concept"></a>01 Core Concept</h3><p>Redux 中有四个核心的概念是需要我们掌握的，分别是 <code>Actions</code>, <code>Reducers</code>, <code>Store</code> 以及 <code>Data Flow</code>（强烈推荐看一遍 <a href="https://redux.js.org/introduction/core-concepts">Redux 文档</a> 里对这几个概念的介绍）。</p><p>看过文档后差不多就可以知道，我们通过在需要改变 state 的地方发送(dispatch) action，然后在 reducer 中根据 action 的 type 进行处理（返回增删改后的 state），而 state 则是根据 reducer 的组合结构保存在 store 的 state 树中的。</p><p>文字太枯燥，来看下面这张图辅助理解：</p><p><img src="https://i.loli.net/2019/07/22/5d35c65aca52827258.jpg" alt="Redux Data Flow (simple)"></p><p>我简单分析下这张图吧：</p><ol><li>首先 React 组件绑定了 Redux 之后（主要借助 React-Redux，下面会说到），就可以使用 <code>store.dispatch()</code> 去发送事件了，比如在按钮的点击事件中发送 action；</li><li>store 接收到 action 之后，会把之前的 state 连同发送的 action 一起传递给 reducer，然后 reducer 会根据我们定义好的处理方式去处理 action （增删改 state），然后返回新的 state 让 store 去更新全局 state 树；</li><li>最终 store 会把新的 state 返回给发送 action 的地方好让 React 组件更新 UI。</li></ol><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h4><p>这里再总结一些 Redux 新手会比较疑惑的点：</p><p><strong>问：</strong>什么是 <code>Action Creator</code> ?</p><p><strong>答：</strong>顾名思义，<code>Action Creator</code> 就是生成 action 的函数，我们知道 action 是一个对象，其中携带了一些用于更新 state 的数据。想象一下，如果我们每次发送事件的时候都自己定义一个 action 对象，那么无疑是非常容易出错的。而使用 <code>Action Creator</code> 后，管理 action 就容易多了，而且也不用担心在 action 中用错属性了，因为只要在 <code>Action Creator</code> 中定义好参数后，我们就可以在发送该 action 的地方确定需要携带哪些数据了。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeText</span>(<span class="hljs-params">text, color</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: CHANGE_TEXT,<br>    text,<br>    color,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问：</strong>reducer 当中是如何更改 state 的？可以在 reducer 中发请求吗？</p><p><strong>答：</strong>不可以！注意，reducer 只是通过接收 action 去处理 state 的变化，我们不可以在 reducer 中引入变化。引用文档上的话：</p><blockquote><p>Remember that the reducer must be pure. <strong>Given the same arguments, it should calculate the next state and return it. No surprises. No side effects. No API calls. No mutations. Just a calculation.</strong></p></blockquote><p>也就是说 reducer 必须是<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html"><em><strong>纯函数</strong></em></a>，接收输入，返回输出，只是纯粹的计算。举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">textReducer</span>(<span class="hljs-params">state = &#123;&#125;, action</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> text = action.text;<br>  <span class="hljs-keyword">let</span> color = action.color;<br>  <span class="hljs-comment">// 判断 action 类型</span><br>  <span class="hljs-keyword">switch</span> (action.type) &#123;<br>    <span class="hljs-keyword">case</span> CHANGE_TEXT:<br>      <span class="hljs-comment">// 返回新状态</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, state, &#123;<br>        <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;新文字：&#x27;</span> + text,<br>        <span class="hljs-attr">color</span>: color<br>      &#125;);<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，我们不可以改变原来的 state，也就是要保持 <code>Object.assign()</code> 中的第一个参数为空，当然也可以使用扩展运算符 <code>&#123;...state, &#123;newState&#125;&#125;</code> 来达到同样的目的。</p><p><strong>问：</strong>React 组件是如何更新的？</p><p><strong>答：</strong>哈哈，这个其实就是真正体现出 Redux 优势的地方。之前说过有了 Redux 之后我们就不需要自己去管理 state，这是怎么做到的呢？其实当我们把所有的 state 都交给 Redux 之后，Redux 在 store 中就保存了我们应用所有的 state (state tree)，这意味着我们可以在任意位置获取到这些 state。而在 RN 中，我们通过 React-Redux 来连接 Redux 和 RN 组件，然后在组件中通过将 state 映射成 props 来使用，而且我们还可以将 dispatch 也映射成 props 来使用。也就是说，我们只需要使用 <code>this.props.xxx</code> 就可以完成数据的展示、响应用户输入以及 UI 变化了，是不是非常神奇？后面 03 段会详细说我们是怎么通过 React-Redux 来做到这一点的。</p><h3 id="02-Basic-Usage"><a href="#02-Basic-Usage" class="headerlink" title="02 Basic Usage"></a>02 Basic Usage</h3><p>了解了 Redux 基本概念之后就可以来学习一下如何使用了。这一节主要介绍 API 的使用。</p><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p>之前举了个 Action Creator 和 reducer 的例子，也知道了我们需要通过 store 来将这两者绑定在一起，但是 store 究竟还有哪些作用呢？store 主要有以下职责：</p><ul><li>保存应用状态（state）</li><li>提供对 state 的访问：<a href="https://redux.js.org/api/store#getState">getState()</a></li><li>提供对状态进行更新的方法： <a href="https://redux.js.org/api/store#dispatch">dispatch(action)</a></li><li>注册监听器： <a href="https://redux.js.org/api/store#subscribe">subscribe(listener)</a></li><li>通过  <a href="https://redux.js.org/api/store#subscribe">subscribe(listener)</a> 返回的方法处理解注册监听器</li></ul><p>可以看出 store 就像<strong>母体</strong>一样，即保存了状态又连接了 Action Creator 和 reducer。但是究竟是怎么连接的呢？</p><p>首先，之前说过我们的 reducer 可以定义 store 保存的 state 树结构，为什么呢？因为 reducer 是可以层层组合的。通常一个组件会有很多层级以及类型（比如 UI 和数据）的 state，我们不可能全都把他们定义在一个 reducer 里，这样代码会变得又长又难以维护。正确的做法是我们应该把一个 reducer <a href="https://redux.js.org/basics/reducers#splitting-reducers">拆分成多个 reducer</a> 后再通过某种方式将它们组合起来。</p><h4 id="combineReducers-reducers"><a href="#combineReducers-reducers" class="headerlink" title="combineReducers(reducers)"></a>combineReducers(reducers)</h4><p>最常见的就是使用 <a href="https://redux.js.org/api/combinereducers">combineReducers()</a> 方法来组合 reducer，它可以把多个 reducer 合并成一个 reducer 对象，而合并后的 reducer 的层级结构就是我们访问 state 时的层级结构。接收的参数是一个 reducer 对象，我们可以自己指定 key，也可以直接组合，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> allReducers = combineReducers(&#123;textReducer, imageReducer, <span class="hljs-attr">videoRed</span>: videoReducer&#125;);<br></code></pre></td></tr></table></figure><h4 id="createStore-reducer-preloadedState-enhancer"><a href="#createStore-reducer-preloadedState-enhancer" class="headerlink" title="createStore(reducer, [preloadedState], [enhancer])"></a>createStore(reducer, [preloadedState], [enhancer])</h4><p>当把多个 reducer 合并成一个之后，我们就可以通过 <a href="https://redux.js.org/api/createstore">createStore</a> 来创建 store 了，它唯一必须的参数是 reducer，也就是我们 <code>combineReducer(reducers)</code> 返回的 reducer。</p><p>第二个参数是可选的初始状态 <code>preloadedState</code>。我们可以从服务器读取初始状态，或者在 app 启动时从本地数据读取初始状态。如果使用了 <code>combineReducer()</code> 后的 reducer 作为第一个参数，那么 <code>preloadedState</code> 就必须是结构和 reducer 中的结构保持一致。</p><p>第三个参数也是可选的 <code>enhancer</code>，接收的是一个函数，可以是你想要提供的第三方的功能，比如 Redux 自带的 <a href="https://redux.js.org/api/applymiddleware">applyMiddleware()</a>，这个属于高阶的内容，以后有时间会写写。举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> allReducers = combineReducers(&#123;textReducer&#125;);<br><br><span class="hljs-keyword">let</span> store = createStore(allReducers, applyMiddleware(thunkMiddleware));<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><p><code>createStore()</code> 返回的 store 就是保存了应用全局 state 的对象了，这个时候我们就可以使用 <a href="https://redux.js.org/api/store#getState"><code>getState()</code></a> 并且根据 reducer 的层级来访问保存在其中的 state 了！</p><h4 id="Others…"><a href="#Others…" class="headerlink" title="Others…"></a>Others…</h4><p>其实核心的 API 就是以上这些，但是下面这些也是比较常见的，这里贴个链接自己看吧(๑^ں^๑)</p><ul><li><a href="https://redux.js.org/api/applymiddleware">applyMiddleware(…middleware)</a></li><li><a href="https://redux.js.org/api/bindactioncreators">bindActionCreators(actionCreators, dispatch)</a></li><li><a href="https://redux.js.org/api/compose">compose(functions)</a></li></ul><h3 id="03-Combine-with-React-Redux"><a href="#03-Combine-with-React-Redux" class="headerlink" title="03 Combine with React-Redux"></a>03 Combine with React-Redux</h3><p>理解了 Redux 的核心概念以及基本 API 之后，我们就可以开始尝试学习如何在 RN 中使用 Redux 了。在 RN 中，我们一般会结合 <a href="https://github.com/reduxjs/react-redux">React-Redux</a> 来使用 Redux，通过它我们可以很方便地把 Redux 和 RN 组件绑定在一起。React-Redux 也是 Redux 官方推荐的用来和 <a href="https://redux.js.org/basics/usagewithreact">React 绑定</a> 的框架，其实我也有点奇怪为什么不直接把 React-Redux 加入到 Redux 中去？(・_・ヾ</p><p>同样的，在介绍 React-Redux 具体用法之前，建议先把 <a href="https://github.com/reduxjs/react-redux/blob/master/docs/api.md#api">API 文档</a> 打开放边上供随时参考。</p><h4 id="lt-Provider-gt"><a href="#lt-Provider-gt" class="headerlink" title="&lt;Provider&gt;"></a><a href="https://github.com/reduxjs/react-redux/blob/master/docs/api.md#provider-store">&lt;Provider&gt;</a></h4><p>从文档上可以发现，React-Redux 的 API 分为两部分，分别是 <code>&lt;Provider store&gt;</code> 以及<code>connect()</code> 方法。<code>connect()</code> 方法用于连接单个的 RN 组件和 <code>Redux Store</code>，而 <code>Provider</code> 则作为根布局用于包装所有的 RN 组件，使得其中使用了 <code>connect()</code>  后的组件可以自由访问 <code>Redux Store</code>。</p><p>比如假设你的根部组件是 <code>&lt;Main/&gt;</code> （如果你使用 <a href="https://gist.github.com/aksonov/e2d7454421e44b1c4c72214d14053410">react-native-router-flux</a> 作为 navigation 的话，那么根布局就是 <code>&lt;Router&gt;</code>），用 <code>&lt;Provider&gt;</code> 包装后就是这样的： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Main</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而在你的容器（Container，下面会说到）中，需要使用 <code>connect()</code> 方法来连接 RN 组件和 store，像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(mapStateToProps, &#123;changeText, changeBack&#125;)(Main);<br></code></pre></td></tr></table></figure><h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a><a href="https://github.com/reduxjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options">connect()</a></h4><p>React-Redux 的核心就是 <code>connect()</code> 方法了，所以下面详细介绍下 <code>connect()</code> 方法的各个参数。</p><p>调用 <code>connect()</code>  方法不会修改组件，但是会返回一个已经和 store 建立连接后的新组件，它使用了装饰器模式，装饰的是 <code>connectAdcanced()</code>，这个方法返回一个接收需要连接的组件的方法（比如上面的 <code>Main</code>）。</p><p>它的参数如下（建议参照文档看，我的翻译也许有误）：</p><h5 id="mapStateToProps-state-ownProps"><a href="#mapStateToProps-state-ownProps" class="headerlink" title="mapStateToProps(state, [ownProps])"></a>mapStateToProps(state, [ownProps])</h5><p>这是一个 <code>function</code> 类型的参数。</p><p>如果指定了这个参数，那么返回的新组件就会接收到 store 的更新。也就是说每次 store 发生更新时这个方法都会被调用。使用方式如下：</p><h6 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h6><ul><li><code>state</code>: 即 state 发生更新后接收到的新 state</li><li><code>ownProps</code>: 可选，新组件接收到的 props，如果指定了该值，那么这个方法也会被调用</li></ul><h6 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h6><ul><li>必须是对象 <code>object</code>，并且该对象会被合并到组件的 props 中去。我们一般将接收到的 state 里面关于该组件有用到的部分取出，映射成对应的 props 就可以了，其实这个方法就是一个选择器（<strong>selector</strong>）</li></ul><p>Tips: 如果不想接收到 state 的更新，可以传 <code>null</code> 或 <code>undifined</code></p><h5 id="mapDispatchToProps-dispatch-ownProps-or-Action-Creators"><a href="#mapDispatchToProps-dispatch-ownProps-or-Action-Creators" class="headerlink" title="mapDispatchToProps(dispatch, [ownProps]) or Action Creators"></a>mapDispatchToProps(dispatch, [ownProps]) or Action Creators</h5><p>这是一个 <code>function</code> 或 <code>object</code> 类型的参数。</p><p>如果指定的是 <code>object</code>，那么其中的每个属性必须是都是 Action Creator，每个 Action Creator 都会被包装到 <code>dispatch()</code> 中，并且合并到组件的 props 中去。</p><p>如果指定的是 <code>function</code>，使用如下：</p><h6 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h6><ul><li><code>dispatch</code>:  store 的 <code>dispatch()</code> 方法，你可以自己决定如何使用 <code>dispatch</code> 去发送事件（当然也是通过 Action Creator），比如使用 <a href="https://redux.js.org/api-reference/bindactioncreators">bindActionCreators()</a></li><li><code>ownProps</code>: 可选，和 <code>mapStateToProps</code> 一样也是新组件接收到的 props</li></ul><h6 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h6><ul><li>同样是一个对象 <code>object</code>，会被合并到 props 中作为发送事件的方法来使用</li></ul><p>Tips: 如果不指定该参数（mapDispatchToProps or Action Creator）那么 React- Redux 默认会把 <code>dispatch</code> 方法注入到组件中，方便你自己手动去调用 Action Creator。</p><h5 id="mergeProps-stateProps-dispatchProps-ownProps"><a href="#mergeProps-stateProps-dispatchProps-ownProps" class="headerlink" title="mergeProps(stateProps, dispatchProps, ownProps)"></a>mergeProps(stateProps, dispatchProps, ownProps)</h5><p>这是一个 <code>function</code> 类型的参数。</p><p>该方法用于将前面两个参数返回的对象以及组件自己的 props 进行重新组合或者过滤，一般如果 props 较多的话，我们可以指定这个方法来对 props 进行筛选，然后再合并到组件中。使用方法如下：</p><h6 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h6><ul><li><p><code>stateProps</code>: 表示 <code>mapStateToProps()</code> 返回的对象</p></li><li><p><code>dispatchProps</code>: 表示 <code>mapDispatchToProps()</code> 返回的对象</p></li><li><p><code>ownProps</code>: 组件自己的 props</p></li></ul><h6 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h6><ul><li>筛选后的对象，将会被合并到组件的 props 中去</li></ul><p>Tips: 如果不指定该方法，默认将调用 <code>Object.assign(&#123;&#125;, ownProps, stateProps, dispatchProps)</code> 来合并所有的 props。</p><h5 id="options"><a href="#options" class="headerlink" title="options"></a>options</h5><p>这是一个 <code>object</code> 类型的参数。</p><p>该方法用于定制连接器的行为，具体可使用的参数有：</p><ul><li><p>[<code>pure</code>] <em>(Boolean)</em>: 如果为 true 则当 state/props 值没有发生变化的时候则不重新渲染（rerender）或者调用 <code>mapStateToProps()</code> or  <code>mapDispatchToProps()</code> or <code>ownProps</code>，前提是组件必须是*”纯”*的（PureComponent？），不依赖组件内部的 state 而只依赖 props 和 Redux store。</p></li><li><p>[<code>areStatesEqual</code>] <em>(Function)</em>: 当是<em>纯</em>组件时，比较接收到的新 state 和之前的值，默认值 <code>strictEqual (===)</code></p></li><li><p>[<code>areOwnPropsEqual</code>] <em>(Function)</em>: 当是<em>纯</em>组件时，比较接收到的新 props 和之前的值，默认值 <a href="https://github.com/reduxjs/react-redux/blob/master/src/utils/shallowEqual.js">shallowEqual</a></p></li><li><p>[<code>areStatePropsEqual</code>] <em>(Function)</em>: 当是<em>纯</em>组件时，比较 <code>mapStateToProps()</code> 接收到的新 state 和之前的值，默认值 <a href="https://github.com/reduxjs/react-redux/blob/master/src/utils/shallowEqual.js">shallowEqual</a></p></li><li><p>[<code>areMergedPropsEqual</code>] <em>(Function)</em>: 当是<em>纯</em>组件时，比较 <code>mergeProps()</code> 接收到的新 props 和之前的值，默认值 <a href="https://github.com/reduxjs/react-redux/blob/master/src/utils/shallowEqual.js">shallowEqual</a></p></li><li><p>[<code>storeKey</code>] <em>(String)</em>: 从当前上下文中读取 store 的 key，当你有多个 store 的时候才会使用这个参数，不推荐使用多个 store，默认值 <code>store</code></p></li></ul><h4 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h4><p>当然，以上是核心 API，下面两个方法不是很常用，所以不多介绍了，自己看去吧~´･ᴗ･`</p><ul><li><a href="https://github.com/reduxjs/react-redux/blob/master/docs/api.md#connectadvancedselectorfactory-connectoptions">connectAdvanced(selectorFactory, [connectOptions])</a></li><li><a href="https://github.com/reduxjs/react-redux/blob/master/docs/api.md#createproviderstorekey">createProvider([storeKey])</a></li></ul><h3 id="04-Show-Me-The-Code"><a href="#04-Show-Me-The-Code" class="headerlink" title="04 Show Me The Code"></a>04 Show Me The Code</h3><p>能看到这里说明你真的很好学啊，既然这样那就一起来撸一下代码吧(๑•͈ᴗ•͈)。Demo 地址：<a href="https://github.com/aJIEw/HeadFirstRN/tree/master/app/redux">aJIEw/Redux</a></p><p>首先说明下，以下的项目分包是推荐的做法，你不一定需要完全遵守：</p><ul><li>components <em>[folder]</em></li><li>containers <em>[folder]</em></li><li>redux <em>[folder]</em><ul><li>actions <em>[folder]</em></li><li>reducers <em>[folder]</em></li><li>store.js <em>[file]</em></li></ul></li></ul><h4 id="Components-amp-Containers"><a href="#Components-amp-Containers" class="headerlink" title="Components &amp; Containers"></a>Components &amp; Containers</h4><p>Components 和 Containers 下面放的是两种不同的组件。这里的 Component 和 React 中的 <code>Component</code> 是有区别的，专指那些<strong>只是</strong>用来展示数据的、<strong>无状态</strong>的<em><strong>纯</strong></em>组件。Components 的特点是：1）通过 props 来接收数据；2）可在多处复用。由于是单纯用于展示的组件，我们一般不会在 Components 中发起网络请求、进行本地存储等操作。</p><p>而 Containers 指的是一个小的模块，用来连接数据并且可以修改数据的组件。Containers 一般会通过组合 Components 来使用，我们会在其中处理用户输入、状态变化，也可以发起网络请求等操作。Components 和 Containers 的最简单的区分方法是：有没有使用 React-Redux 的 <code>connect()</code> 连接组件。</p><p>而 redux 包下存放的当然就是和 Redux 相关的内容啦，actions 下存放 Action Creator，reducers 下存放 reducer，最外面的 store.js 则是创建 store 的地方了。</p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>看代码之前先看下我们的 demo 实现的效果吧：</p><img src="https://i.loli.net/2019/09/09/gQ3Vn4bSArMwsUp.gif" width="40%"/><p>根据最近学到的 <a href="http://sscce.org/">SSCCE</a> 原则，我尽可能把这个 demo 写的足够简单，目的是帮助理解 React Redux 的使用。</p><h5 id="ChangeableText"><a href="#ChangeableText" class="headerlink" title="ChangeableText"></a>ChangeableText</h5><p>这个 Component 的作用很简单——显示文字，不过文字和颜色是可以改变的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs react">export default class ChangeableText extends Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;Text style=&#123;&#123;color: this.props.color, borderWidth: 2, padding: 8&#125;&#125;&gt;&#123;this.props.text&#125;&lt;/Text&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h5><p>而作为 Container 的 <code>Main</code> 则组合了 <code>ChangeableText </code> 组件并且有两个可点击的按钮用于改变文字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs react">class Main extends Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;View style=&#123;styles.container&#125;&gt;<br>        &#123;/* 将从 state 映射而来的 props 传入 Component 中，state 发生变化则 props 的值也会相应地发生改变 */&#125;<br>        &lt;ChangeableText &#123;...this.props&#125;/&gt;<br><br>        &#123;/* 此时直接调用 props 上的 dispatcher */&#125;<br>        &lt;TouchableOpacity style=&#123;styles.changeText&#125; onPress=&#123;() =&gt; this.props.actions.changeText(&#x27;Hello&#x27;, &#x27;red&#x27;)&#125;&gt;<br>          &lt;Text&gt;改变文字&lt;/Text&gt;<br>        &lt;/TouchableOpacity&gt;<br><br>        &lt;TouchableOpacity onPress=&#123;() =&gt; this.props.actions.changeBack()&#125;&gt;<br>          &lt;Text&gt;恢复&lt;/Text&gt;<br>        &lt;/TouchableOpacity&gt;<br>      &lt;/View&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最重要的部分就是 <code>connect()</code> 方法啦，这里我使用了 <code>bindActionCreators()</code> 来创建 dispacher：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs react">// 将 state 映射成 props，这里我们可以自由组合需要使用到的 state，只要是 store 树中存在的 state 都可以直接拿来使用<br>function mapStateToProps(state) &#123;<br>  return &#123;<br>    text: state.textReducer.text,<br>    color: state.textReducer.color,<br>  &#125;<br>&#125;<br><br>function mapDispatchToProps(dispatch) &#123;<br>  return &#123;<br>    actions: bindActionCreators(TextChanger, dispatch)<br>  &#125;<br>&#125;<br><br>// 第二个参数如果是 Action Creator，则会被自动映射成组件上的 props 作为 dispatcher 使用<br>export default connect(mapStateToProps, mapDispatchToProps)(Main);<br></code></pre></td></tr></table></figure><h5 id="Action-Creators"><a href="#Action-Creators" class="headerlink" title="Action Creators"></a>Action Creators</h5><p>没啥好说的，注意 <code>type</code> 是必须要有的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> CHANGE_TEXT = <span class="hljs-string">&#x27;CHANGE_TEXT&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> CHANGE_BACK = <span class="hljs-string">&#x27;CHANGE_BACK&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeText</span>(<span class="hljs-params">text, color</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: CHANGE_TEXT,<br>    text,<br>    color,<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeBack</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: CHANGE_BACK,<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Hi&#x27;</span>,<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;black&#x27;</span>,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="reducers"><a href="#reducers" class="headerlink" title="reducers"></a>reducers</h5><p>如何组织 reducer 是门艺术，尤其是当 app 变得复杂之后，不过我们现在不用考虑这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">textReducer</span>(<span class="hljs-params">state = &#123;text: <span class="hljs-string">&#x27;Hi&#x27;</span>, color: <span class="hljs-string">&#x27;black&#x27;</span>&#125;, action</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> text = action.text;<br>  <span class="hljs-keyword">let</span> color = action.color;<br>  <br>  <span class="hljs-comment">// 判断 action 类型</span><br>  <span class="hljs-keyword">switch</span> (action.type) &#123;<br>    <span class="hljs-keyword">case</span> CHANGE_TEXT:<br>      <span class="hljs-comment">// 返回新状态</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, state, &#123;<br>        <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;新文字：&#x27;</span> + text,<br>        <span class="hljs-attr">color</span>: color<br>      &#125;);<br>    <span class="hljs-keyword">case</span> CHANGE_BACK:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        text,<br>        color<br>      &#125;;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> textReducer;<br></code></pre></td></tr></table></figure><h5 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h5><p>最后就是创建 store 了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> allReducers = combineReducers(&#123;textReducer&#125;);<br><br><span class="hljs-keyword">let</span> store = createStore(allReducers);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><h5 id="Root"><a href="#Root" class="headerlink" title="Root"></a>Root</h5><p>最最后，记得要把根组件用 <code>&lt;Provider&gt;</code> 包装起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs react">export default class Root extends Component &#123;<br>  render() &#123;<br>    return (<br>      // 连接组件和 store<br>      &lt;Provider store=&#123;store&#125;&gt;<br>        &lt;Main /&gt;<br>      &lt;/Provider&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>OK，大致就这么简单，接下来就是运行，debug，看看 state 是怎么在组件中被传递的。</p><h3 id="05-Sum-Up"><a href="#05-Sum-Up" class="headerlink" title="05 Sum Up"></a>05 Sum Up</h3><p>通过上面的介绍，配合官方文档和 Demo，如果你有完整看完的话，相信对于如何使用 Redux 应该基本没问题了，所以这个时候就可以祭出这张图了： </p><p><img src="../assets/2018-09-24/redux_flow_full.gif" alt="redux_flow_full"></p><p>这张图可以说非常完美地展现了 Redux 的工作原理，值得细看。其中 <a href="https://redux.js.org/advanced/middleware">middleware</a> 属于高级内容没有仔细讲，下次有时间的话会再续更。</p><p>Redux 可以说是管理 state 的神器，能把我们从混乱和无序中解救出来。希望这篇文章可以帮助想要学习 Redux 的同学尽早入门~(◍•ᴗ•◍)❤~~</p><p>祝大家中秋快乐！</p><hr><p>参考文章：<a href="https://www.jianshu.com/p/2a327a235f2d">React-Native 之 redux 与 react-redux</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pixel 手机升级保留基带和数据</title>
      <link href="/pixel-upgrade/"/>
      <url>/pixel-upgrade/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35c603712f186267.png" alt="Android Pie On Essential Phone"></p><blockquote><p>Andoird Pie (9.0) 早在今年 8 月 6 号就正式发布了，但是一直没有去更新升级自己的 Pixel XL，怕太折腾，刚好中秋在家有空，于是就研究了下如何保留数据与基带通过线刷升级到新系统。</p></blockquote><h4 id="00-为什么要保留基带？"><a href="#00-为什么要保留基带？" class="headerlink" title="00 为什么要保留基带？"></a>00 为什么要保留基带？</h4><p>我们知道 Pixel 手机根本就没考虑过国内的电信运营商，因为根本就无法通过正常销售渠道抵达国内的用户，所以呢，显而易见地对国内网络的支持就不是很好。比如中国电信直接就无法使用，需要通过某些手段才能开启电信4G。</p><p>Pixel 刚出的时候，你买了 Pixel 之后还需要花一笔钱请人『破解』才能使用，当然，现在有些『破解』手段已经被公布了，比如 『<a href="https://gist.github.com/coeusite/86f6318c13c5bc15aef13345f1bb3ed4">Pixel 破解电信 4G 记录</a>』 以及 『<a href="https://tieba.baidu.com/p/5666986960">Pixel 开启完美电信4G支持，双清保留</a>』（谨慎尝试，注意先备份数据）。</p><span id="more"></span><p>其实所谓的『破解』只不过是在手机基带的网络通讯模块中加入需要支持的运营商而已。而当我们通过原厂镜像刷机的时候，如果直接刷则会把原来的基带给覆盖掉，导致需要重新『破解』，所以这个时候如果能够在刷机的同时保留基带，那么我们就不需要重新『破解』了。同理，在使用 OTA 更新的时候，如果基带发生了更新，那么我们的『破解』也会失效。</p><p>综上，为了避免重新『破解』的麻烦，我们需要在更新时保留基带，当然最好也保留数据。</p><h4 id="01-操作步骤"><a href="#01-操作步骤" class="headerlink" title="01 操作步骤"></a>01 操作步骤</h4><p>进行如下操作前，请先把手机中的重要数据备份好，否则一切后果自负！</p><ol><li><p>首先确保你的手机已经解锁，如果没解锁的第一次解锁后数据有可能会丢失！</p></li><li><p>把对应你的 Pixel 型号的原厂镜像下载好，下载地址：<a href="https://developers.google.com/android/images">Factory Images</a>，比如我是 Pixel XL，那么对应的目前最新的系统就是 9.0.0 (PPR2.180905.006, Sep 2018)</p></li><li><p>把下载好的 zip 文件解压出来，里面有几个文件，分别是:</p></li></ol><ul><li><code>bootloader*.img</code>: 引导装载程序的镜像，bootloader 主要负责启动安卓内核，同时验证引导程序与还原分区的完整性。</li><li><code>radio*.img</code>: 通讯模块的镜像，这就是基带以及其他无线通讯模块的位置。</li><li><code>flash-all.sh</code>: 用于一键刷机（Mac/Linux）</li><li><code>flash-all.bat</code>: 用于一键刷机（Windows）</li><li><code>image*.zip</code>: 系统镜像文件</li></ul><ol start="4"><li>在解压后的文件夹中添加 <code>android-info.txt</code> 文件，其中内容为：</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">require board=marlin|sailfish<br></code></pre></td></tr></table></figure><p>  如果是 Pixel 2 或 Pixel 2 XL，则对应为：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">require board=walleye|taimen<br></code></pre></td></tr></table></figure><p>这一步的目的是替换系统镜像中的 <code>android-info.txt</code> 这样就可以跳过 bootloader 以及 baseband 的版本检测了。</p><p>原本的 <code>android-info.txt</code> 是这样的：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">require board=marlin|sailfish<br>  <br>require version-bootloader=8996-012001-1804121206<br>  <br>require version-baseband=8996-130181-1806061856<br></code></pre></td></tr></table></figure><ol start="5"><li>修改 <code>flash-all.sh</code>，添加命令，删除系统镜像中的 <code>userdata.img</code>（如果存在的话），以及用我们上一步新建的文件去更新 <code>android-info.txt</code>，这里的 <code>image*.zip</code> 改成你下载的系统镜像名称就好：</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># remove userdata.img and update android-info.txt</span><br>zip -d image*.zip userdata.img<br>zip -u image*.zip android-info.txt<br></code></pre></td></tr></table></figure><p>  注释掉更新基带的命令，同样这里的 <code>radio*.img</code> 是你下载的镜像中的 radio 文件的名称：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># fastboot flash radio radio*.img</span><br></code></pre></td></tr></table></figure><p>  去掉更新系统时的默认清除数据选项 <code>-w</code> (wipe)：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">fastboot</span> update image<span class="hljs-regexp">*.img</span><br></code></pre></td></tr></table></figure><p>  最后，修改后的 <code>flash-all.sh</code> 是这样的（Pixel XL 9.0.0 (PPR2.180905.006, Sep 2018)）：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><br><span class="hljs-keyword">if</span> ! grep -q dtbo.sig $(<span class="hljs-built_in">which</span> fastboot); <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;fastboot too old&quot;</span><br>  <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># remove userdata.img and update andoir-info.txt</span><br>zip -d image-marlin-ppr2.180905.006.zip userdata.img<br>zip -u image-marlin-ppr2.180905.006.zip android-info.txt<br><br>fastboot flash bootloader bootloader-marlin-8996-012001-1804121206.img<br>fastboot reboot-bootloader<br>sleep 5<br>fastboot update image-marlin-ppr2.180905.006.zip<br></code></pre></td></tr></table></figure><ol start="6"><li>接下来手机连接电脑，进入 fastboot 模式：</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb reboot bootloader<br></code></pre></td></tr></table></figure><ol start="7"><li>运行 <code>flash-all.sh</code>: </li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh flash-all.sh<br></code></pre></td></tr></table></figure><p>大致就这么简单了，另外附上脚本输出的日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs shell">zip warning: name not matched: userdata.img # 说明我们的系统镜像没有 userdata.img<br><br>zip error: Nothing to do! (image-marlin-ppr2.180905.006.zip)<br>updating: android-info.txt (stored 0%)<br>Sending &#x27;bootloader_b&#x27; (32384 KB)                  OKAY [  0.901s]<br>Writing &#x27;bootloader_b&#x27;                             (bootloader) Valid bootloader version.<br>(bootloader) Flashing active slot &quot;_b&quot; <br>(bootloader) Flashing active slot &quot;_b&quot; <br>OKAY [ 10.058s]<br>Finished. Total time: 11.069s<br>rebooting into bootloader                          OKAY [  0.009s]<br>Finished. Total time: 0.010s<br>extracting android-info.txt (0 MB) to RAM...<br>--------------------------------------------       <br>Bootloader Version...: 8996-012001-1804121206<br>Baseband Version.....: 8996-012761-1612201801<br>Serial Number........: xxxxxxxxxxxx<br>--------------------------------------------       <br>Checking product                                   OKAY [  0.050s]<br>extracting boot.img (30 MB) to disk... took 0.161s<br>archive does not contain &#x27;boot.sig&#x27;<br>archive does not contain &#x27;boot_other.img&#x27;<br>archive does not contain &#x27;dtbo.img&#x27;<br>archive does not contain &#x27;dt.img&#x27;<br>archive does not contain &#x27;odm.img&#x27;<br>archive does not contain &#x27;product.img&#x27;<br>archive does not contain &#x27;product-services.img&#x27;<br>archive does not contain &#x27;recovery.img&#x27;<br>archive does not contain &#x27;super.img&#x27;<br>extracting system.img (1940 MB) to disk... took 10.183s<br>archive does not contain &#x27;system.sig&#x27;<br>extracting system_other.img (313 MB) to disk... took 1.830s<br>archive does not contain &#x27;system.sig&#x27;<br>archive does not contain &#x27;vbmeta.img&#x27;<br>extracting vendor.img (260 MB) to disk... took 1.454s<br>archive does not contain &#x27;vendor.sig&#x27;<br>archive does not contain &#x27;vendor_other.img&#x27;<br>Sending &#x27;boot_b&#x27; (30993 KB)                        OKAY [  0.851s]<br>Writing &#x27;boot_b&#x27;                                   OKAY [  0.661s]<br>Sending sparse &#x27;system_b&#x27; 1/4 (524284 KB)          OKAY [ 15.063s]<br>Writing sparse &#x27;system_b&#x27; 1/4                      OKAY [  7.493s]<br>Sending sparse &#x27;system_b&#x27; 2/4 (524284 KB)          OKAY [ 14.819s]<br>Writing sparse &#x27;system_b&#x27; 2/4                      OKAY [  6.191s]<br>Sending sparse &#x27;system_b&#x27; 3/4 (524284 KB)          OKAY [ 14.819s]<br>Writing sparse &#x27;system_b&#x27; 3/4                      OKAY [  4.490s]<br>Sending sparse &#x27;system_b&#x27; 4/4 (413888 KB)          OKAY [ 10.964s]<br>Writing sparse &#x27;system_b&#x27; 4/4                      OKAY [  6.595s]<br>Sending &#x27;system_a&#x27; (321188 KB)                     OKAY [  8.458s]<br>Writing &#x27;system_a&#x27;                                 OKAY [  5.895s]<br>Sending &#x27;vendor_b&#x27; (266504 KB)                     OKAY [  7.021s]<br>Writing &#x27;vendor_b&#x27;                                 OKAY [  4.284s]<br>Setting current slot to &#x27;b&#x27;                        OKAY [  0.404s]<br>Rebooting                                          <br>Finished. Total time: 125.766s<br></code></pre></td></tr></table></figure><p><em>重启之后，新系统大概需要 4~5 分钟加载，进入系统后等待配置完毕就可以愉快地使用啦！</em></p><h4 id="03-注意事项"><a href="#03-注意事项" class="headerlink" title="03 注意事项"></a>03 注意事项</h4><p>刷机之前一点要记得备份数据，重要的话说多少遍都不为过。</p><p>按照以上步骤操作，虽然数据和基带可以保留，但是 root 权限还是会丢的（因为系统都被覆盖了嘛！），但是从我个人的使用体验来看，Andoird 9.0  不 root 使用起来体验也非常的棒。看你个人的使用方式了吧，我觉得还是先用一段时间看看再决定要不要 root~ ୧(﹒︠ᴗ﹒︡)୨</p><p>祝大家中秋御快，阖家欢落~~蛤蛤<del>\</del></p><hr><p>参考文章：<a href="http://www.pixcn.cn/forum.php?mod=viewthread&tid=27393&extra=page=1&page=1">不丢电信破解，线刷最新版谷歌软件的方法</a></p>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tricks </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钉钉自动拍照打卡 App 的实现</title>
      <link href="/ding-ding-auto-punch-app/"/>
      <url>/ding-ding-auto-punch-app/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35c53a7de3a39662.jpg" alt="Autumn from Bascom Hill in Madison, Wisconsin"></p><blockquote><p>每天上下班使用钉钉拍照打卡是个很烦人的事情，因为我经常会忘记打卡。而且每天要打开手机操作两次，这么机械化的事情，作为一个安卓开发工程师，难道就没有什么办法可以把它给自动化吗？答案当然是 Yes, we can!</p></blockquote><h3 id="00-实现方式的探讨"><a href="#00-实现方式的探讨" class="headerlink" title="00 实现方式的探讨"></a>00 实现方式的探讨</h3><p>首先上网搜索了一番，果然我不是第一个觉得打卡这件事很麻烦的人。发现钉钉打卡其实还分很多种，比如公司 WIFI 打卡，如果你们使用的是这种打卡方式，那么钉钉其实是有一个快速打卡（相当于自动打卡）的功能，只要管理员开启这个功能就可以了，我们也就不需要折腾了。但是，很显然我们拍照打卡是不可能使用这种方案来解决的，于是又看了几篇拍照打卡的文章，发现实现方案大致分为两种：1）使用钉钉打卡的接口；2）模拟屏幕点击完成打卡。</p><p>第一种方案需要抓包获取到钉钉的打卡请求的接口，然后我们只要到点按时发起请求就完成打卡了，这种方案感觉难度比较高，而且请求接口也有可能发生变化，所以果断 PASS 了。第二种方案模拟屏幕点击，想了想感觉还是比较靠谱的，也比较符合我们的需求，我们只要把拍照打卡这一系列的点击屏幕的操作规划好就行了。于是乎，撸起袖子开干！</p><span id="more"></span><h3 id="01-初步尝试"><a href="#01-初步尝试" class="headerlink" title="01 初步尝试"></a>01 初步尝试</h3><p>一开始，我参考了这位博主的<a href="https://www.jianshu.com/p/2b416ad0b949">方案</a>：</p><blockquote><p>监听闹钟广播，闹钟响起的时候，解锁，并打开钉钉 App，然后模拟屏幕点击，滑动等操作，最后关闭钉钉。</p></blockquote><p>看似很完美的方案对不对，但是也有问题，那就是在我的 Nexus 6P (Android 8.0) 上，根本就没办法监听到闹钟广播好吗！查了下发现，8.0 以后隐式广播被禁止了，真是非常抱歉呢！</p><img src="https://i.loli.net/2019/07/22/5d35c55ea86ad81295.png" style="zoom:80%"/><p>不过也有一些例外，看这里：<a href="https://developer.android.com/guide/components/broadcast-exceptions">Implicit Broadcast Exceptions</a>，只有这些列出的隐式广播还是可以继续在 manifest 里注册的。看吧，谷歌爸爸也不是那么霸道呢~</p><p>既然闹钟广播监听不到，那就监听可以监听到的呗，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">IntentFilter filter = <span class="hljs-keyword">new</span> IntentFilter();<br>filter.addAction(Intent.ACTION_TIME_TICK);<br>registerReceiver(<span class="hljs-keyword">new</span> AutoStartReceiver(), filter);<br></code></pre></td></tr></table></figure><p><code>Intent.ACTION_TIME_TICK</code> 是由系统发出的<strong>时间变化</strong>的广播（闹钟响起的时候同时也会触发），触发后每分钟发送一次。所以我们可以监听这个广播然后判断当前时间是否是打卡时间，是则执行打卡，否则就忽略。</p><p>这种方案经过我的初步尝试后的确可行，但是设置闹钟难免有点麻烦。后来想了想，既然只是自己用，那么干脆就用比较暴力的手段实现：保持 Service 运行，时间一到就执行打卡，嗯~(•̀ᴗ•́)و ̑̑</p><h3 id="02-实现策略"><a href="#02-实现策略" class="headerlink" title="02 实现策略"></a>02 实现策略</h3><p>首先说明下，我的实现方案肯定不是最好的，而且一些编码的方式也不推荐在实际的项目中使用。</p><img src="https://i.loli.net/2019/07/22/5d35c58c38af732270.png" style="zoom:50%"/><p>我们使用一个 <code>KeepRunningService</code> 来保证应用始终能够在后台运行，最好把应用加入到 Greenify 的白名单中。Service 中只做一件事，注册监听 <code>Intent.ACTION_TIME_TICK</code> 的广播，然后把这个 Service 设置成前台 Service 并每 5 分钟运行一次来达到保持后台运行的目的。</p><p>通过 <code>PunchReceiver</code> 来运行 <code>PunchService</code>，<code>PunchService</code> 就是实际进行打卡操作的地方，我们使用 <code>IntentService</code> 来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PunchService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IntentService</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// ...</span><br>   <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理打卡，利用 adb 命令点击屏幕完成打卡</span><br><span class="hljs-comment">     * 不同屏幕坐标位置不同，可以在开发者选项中开启查看屏幕坐标：Developer options -&gt; Input -&gt; Pointer location</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHandleIntent</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Intent intent)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!timeForPunch()) &#123;<br>            stopSelf();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Log.d(<span class="hljs-keyword">this</span>.getClass().getSimpleName(), <span class="hljs-string">&quot;onHandleIntent: start punching...&quot;</span>);<br><br>        <span class="hljs-comment">// 唤醒屏幕</span><br>        wakeUp();<br>        <span class="hljs-comment">// 上滑解锁</span><br>        swipe(<span class="hljs-string">&quot;720&quot;</span>, <span class="hljs-string">&quot;2320&quot;</span>, <span class="hljs-string">&quot;720&quot;</span>, <span class="hljs-string">&quot;1320&quot;</span>);<br>        SystemClock.sleep(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-comment">// 输入 PIN 码解锁</span><br>        inputPinIfNeeded();<br>        SystemClock.sleep(<span class="hljs-number">3000</span>);<br><br>        showToast(<span class="hljs-string">&quot;打开钉钉&quot;</span>);<br>        startAppLauncher(DD_PACKAGE_NAME);<br>        SystemClock.sleep(<span class="hljs-number">10000</span>);<br><br>        showToast(<span class="hljs-string">&quot;点击中间菜单&quot;</span>);<br>        clickXY(<span class="hljs-string">&quot;700&quot;</span>, <span class="hljs-string">&quot;2325&quot;</span>);<br>        SystemClock.sleep(<span class="hljs-number">5000</span>);<br><br>        showToast(<span class="hljs-string">&quot;点击考勤打卡&quot;</span>);<br>        clickXY(<span class="hljs-string">&quot;540&quot;</span>, <span class="hljs-string">&quot;1800&quot;</span>);<br>        SystemClock.sleep(<span class="hljs-number">10000</span>);<br><br>        showToast(<span class="hljs-string">&quot;点击打卡&quot;</span>);<br>        clickXY(<span class="hljs-string">&quot;700&quot;</span>, punchPositionY);<br>        SystemClock.sleep(<span class="hljs-number">5000</span>);<br><br>        showToast(<span class="hljs-string">&quot;点击拍照&quot;</span>);<br>        clickXY(<span class="hljs-string">&quot;710&quot;</span>, <span class="hljs-string">&quot;2280&quot;</span>);<br>        SystemClock.sleep(<span class="hljs-number">8000</span>);<br><br>        showToast(<span class="hljs-string">&quot;点击 OK&quot;</span>);<br>        clickXY(<span class="hljs-string">&quot;710&quot;</span>, <span class="hljs-string">&quot;2281&quot;</span>);<br>        SystemClock.sleep(<span class="hljs-number">5000</span>);<br><br>        showToast(<span class="hljs-string">&quot;退出钉钉&quot;</span>);<br>        stopApp(DD_PACKAGE_NAME);<br><br>        startAppLauncher(getPackageName());<br>        SystemClock.sleep(<span class="hljs-number">3000</span>);<br><br>        <span class="hljs-comment">// 更新 UI</span><br>        String currentTime = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>, Locale.CHINA).format(<span class="hljs-keyword">new</span> Date());<br>        EventBus.getDefault().post(<span class="hljs-keyword">new</span> PunchFinishedEvent(punchType, currentTime));<br>        Log.d(<span class="hljs-keyword">this</span>.getClass().getSimpleName(), <span class="hljs-string">&quot;onHandleIntent: punch finished&quot;</span>);<br><br>        close();<br><br>        stopSelf();<br>    &#125;        <br>&#125;<br></code></pre></td></tr></table></figure><p>以上是核心代码，点击以及滑动操作都是通过 adb 命令完成的（需要 root 权限）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 滑动屏幕</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swipe</span><span class="hljs-params">(String x1, String y1, String x2, String y2)</span> </span>&#123;<br>      String cmd = String.format(<span class="hljs-string">&quot;input swipe %s %s %s %s \n&quot;</span>, x1, y1, x2, y2);<br>      exec(cmd);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 点击</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clickXY</span><span class="hljs-params">(String x, String y)</span> </span>&#123;<br>      Log.d(AppUtil.class.getSimpleName(), <span class="hljs-string">&quot;clickXY: &quot;</span> + x + <span class="hljs-string">&quot;, &quot;</span> + y);<br>      String cmd = String.format(<span class="hljs-string">&quot;input tap %s %s \n&quot;</span>, x, y);<br>      exec(cmd);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 执行 ADB 命令</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exec</span><span class="hljs-params">(String cmd)</span> </span>&#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">if</span> (os == <span class="hljs-keyword">null</span>) &#123;<br>              os = Runtime.getRuntime().exec(<span class="hljs-string">&quot;su&quot;</span>).getOutputStream();<br>          &#125;<br>          os.write(cmd.getBytes());<br>          os.flush();<br>      &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>          e.printStackTrace();<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>打卡完成后会提示，而且主页面提供手动打卡的方式，基本上和自动打卡操作是一样的，点击后会直接打开钉钉进行打卡，以防如果自动打卡不起作用（服务被杀死）的情况。</p><img src="https://i.loli.net/2019/07/22/5d35c5be95fac24261.png" style="zoom:20%"/><p>项目地址：<a href="https://github.com/aJIEw/AutoPunchDing">aJIEw/AutoPunchDing</a></p><p>当然这个实现方式还是很原始的，如果想要使用的话还是得自己改代码，比如点击位置以及打卡时间。另外，闹钟其实可以不设置，因为只要应用不被杀死就可以自动打卡，但是最好还是设置一下，因为根据我一个礼拜下来的使用体验来看，偶尔还是会不能自动打卡的。最理想的方式是快到打卡时间的时候把应用打开一下，但是要是能记得就不需要这个 app 了，所以还是设闹钟吧(•̀ᴗ•́)و ̑̑</p><hr><p>参考文章：<a href="https://www.jianshu.com/p/2b416ad0b949">钉钉自动打卡的一种实现</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈改变</title>
      <link href="/talk-about-change/"/>
      <url>/talk-about-change/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35c3908e3fa43238.jpg" alt="All the books I&#39;ve read only told me one thing: Change"></p><h3 id="两次危机"><a href="#两次危机" class="headerlink" title="两次危机"></a>两次危机</h3><p>这两周一直都在忙着学习 RN，期间还经历了两次危机。</p><p>一次是工作上的。公司名称修改后域名需要重新备案，由于部门间沟通不够及时，没来得及更换请求的地址，导致所有服务都无法使用，于是几个项目都不得不发布紧急更新，不过还好几个项目都集成了热更新（虽然不那么及时），最后总算有惊无险。</p><p>另一次是生活上的。前天晚上下班后刚坐进懒人椅就发现自己头晕得不行，一开始还以为是贫血造成的，于是就靠着椅子刷手机，但是过了一会儿发现自己眼睛越来越烫，一摸发现额头上也烫的不行。依旧没太在意，以为过一会儿就好了。后来洗完澡，发现身上还是很烫，心想自己不会真发烧了吧。于是出门去药店买退烧药，然后发现自己居然烧到 39.4 度Σ（ﾟдﾟlll）。</p><p>吃了退烧药后也没有好转，反而越发觉得难受了。我甚至尝试了敷面膜降体温，但是也只能缓解一点儿。晚上躺床上开始想自己为什么会突然发烧，是吃了什么不卫生的东西？还是因为太劳累了？又或者是接触到什么病毒被感染了？</p><p>第二天 5 点多醒来发现烧还是没退，而且全身酸痛，躺着难受坐着也难受，吃了药后开始正念冥想。20 分钟后发现自己明显好多了，不知道是冥想让疼痛缓解了还是药效起作用了，或许两者都有吧。</p><span id="more"></span><p>这么详细写这件事，是因为这件事让我切身感受到拥有一个健康的身体的重要性，我们很多时候都忙着工作忙着赚钱而忽略了比工作、赚钱更重要的东西。</p><p>这两次危机，前一次让我体会到很多时候总会有一些不可抗力的因素出现，导致事情没有按照正轨去发展。虽然这样的事情可以通过流程化去避免，但是就算做的再正规，想要完全避免总归不太现实。所以这个时候就要求我们提高应对危机的能力。当危机发生的时候，团队成员间是否可以相互合作去解决危机？危机其实也给我们提供了一个发现问题的机会，当危机解除后，我们就应该开始思考我们要做哪些调整与<strong>改变</strong>去降低类似的危机发生的概率。</p><p>而后一次危机则是催生我写这篇博客的原因。很多时候<strong>改变</strong>并不是我们主动去发起的，而是由于外界的刺激迫使我们去<strong>改变</strong>。通过这一次不大不小的“病痛”的折磨，我开始思考近期发生在自己身上的一些事。这篇博客的主题是改变，其实一开始只是想写写自己最近做了点什么，所以写到哪算哪吧。</p><h3 id="入职以来"><a href="#入职以来" class="headerlink" title="入职以来"></a>入职以来</h3><p>入职到现在刚好满三个月，对公司的核心业务线大致了解了，从前端的上门回收到后端的分拣处理，再到用户使用我们返给他们的环保金到我们的合作便利店进行消费。其实我们做的无非就是以一定的利益作为引导，让用户更方便地参与到垃圾回收中。</p><p>不知道这个行业市场前景怎么样，但是现在看来，想要实现盈利还是挺困难的一件事。别说盈利，就是自负亏盈暂时也做不到，目前公司的运转依旧离不开政府的扶持。下面说下自己的入职以来的感受吧。</p><h4 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h4><p>老实说，目前的工作环境各方面条件的确比较简陋，毕竟属于余杭比较郊区的地方，而且公司也处于发展阶段，除了理解好像也没什么办法了┐(ﾟ～ﾟ)┌。但是，和那些高大上的写字楼相比，这里也有自己的优势，比如人少，比如没有门禁，唯一需要花点时间适应的是厕所，不过反正我一般早上上完厕所再出门，所以影响也不是特别大。再者就是公司食堂，完全免费哦，就是饭菜质量堪忧，不过怎么说呢，至少能帮你每天省一顿饭钱吧，哈哈~</p><p>另外，我们公司技术团队统一使用 Mac，而且都是高配，我接触到的设计也都是用的 Mac，看来公司在这方面还是比较舍得花钱的。具体使用感受可以看我之前写的<a href="https://ajiew.github.io/2018-half/">一篇文章</a>。</p><h4 id="公司同事"><a href="#公司同事" class="headerlink" title="公司同事"></a>公司同事</h4><p>由于团队比较小，所以基本上入职一周后就已经可以和同事们一起开玩笑了。办公室里，有工作极其认真负责但是逗比起来也很可爱的技术经理，有语不惊人死不休的开心果，也有要么不开口一开口就把大家全都逗乐的、典型的闷骚性格的后端程序员，有集美貌与吃货属性于一身同时还是两个孩子的妈但是身材却保持得像只有 18 的大姐姐，还有一位刚入职的 95 后小鲜肉（自从他来了之后大家都叫我老鲜肉了(ಥ_ಥ)）。当然还有我们的技术副总，性格极好，属于那种说话让人完全挑不出刺的人，处理一些事情的方式也让我开了眼界。</p><p>嗯，都是我学习的榜样。</p><h4 id="业务与技术"><a href="#业务与技术" class="headerlink" title="业务与技术"></a>业务与技术</h4><p>之前大致介绍了公司的业务，其实在这条业务线上的每一个环节，涉及到使用的工具还是挺多的。比如回收环节虎哥使用的 app，物流运输车司机使用的虎哥助手（用于垃圾称重确认后运回总仓），以及 C 端的 app（线上呼叫回收与商城消费），还有合作便利店里的收银程序。除此之外，还有我们的仓储系统、数据中心等等。</p><p>这些工具的最终目的其实都是一样的：获取数据然后通过监控到的数据去优化资源的配置方式。比如运输环节，每个小区的服务站一段时间内回收到的垃圾量大致是稳定的，所以我们可以估算出我们的物流运输车应该何时出发去接收这些垃圾并运回总仓。</p><p>作为一名安卓开发，我觉得目前所涉及到的技术性挑战还是其次的，关键还是精力问题，除了需要维护虎哥与司机内部使用的两个 app 以及<a href="https://ajiew.github.io/android-cashier-app/">安卓版收银机</a>之外，还得学习 RN，因为我们 C 端的应用使用 RN 开发而前端人手又不够…但是呢，经过差不多一个月的摸索，现在差不多也可以开始改改页面了，不过离独立开发的目标还早着呢。</p><h4 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h4><p>其实生活和之前没什么大的不同，只不过上班的时间比之前早了一点，下班的时间比之前晚了一点，然后周末单休_(:з」∠)_。而且由于和公司同事住一块儿，平时上下班也都一起，所以结果就是——我变得更宅了 (●ﾟωﾟ●)。</p><h3 id="我的阅读"><a href="#我的阅读" class="headerlink" title="我的阅读"></a>我的阅读</h3><p>最近看了不少书，很多书一开始并没打算看完，只是想着随便翻翻，结果越翻越觉得真是好书。</p><h5 id="《爱你就像爱生命》"><a href="#《爱你就像爱生命》" class="headerlink" title="《爱你就像爱生命》"></a><a href="https://book.douban.com/subject/1069685/">《爱你就像爱生命》</a></h5><p>很多人喜欢王小波，是因为他的文字干净、纯粹，而且字里行间透露着智慧。他是我自由主义的启蒙，大学期间看过他的<a href="https://book.douban.com/subject/1082406/">《黄金时代》</a>和<a href="https://book.douban.com/subject/6902317/">《革命时期的爱情》</a>，从此在心里种下一颗种子：人一定要活的有趣。去年看了他的杂文集<a href="https://book.douban.com/subject/27013708/">《一只特立独行的猪》</a>，然后最近看了这本记录了他和李银河以及好友之间往来信件的《爱你就像爱生命》。他和李的爱情也是那样的纯粹，让人羡慕。人生得一知己相伴足矣。</p><p>王小波在信件中里提到了卡尔维诺的《未来千年备忘录》里关于文学的各种素质：</p><blockquote><p>真正的作家应该具备这些素质，在同一篇作品里，体现轻逸、迅捷、确切、易见和繁复，再加上连贯。</p></blockquote><p>要做到这些真的不容易，但是他的文字让人觉得有趣，我觉得仅此一点就可以超越目前绝大多数的“作家”了。除此之外，他的小说真的很耐读，借用一段不知在哪看到的评论：你可以拿起王小波的书从任意一章翻开看，然后在任意位置放下书，同时还能获得启发。可以说描述得相当到位了。</p><h5 id="《沟通的艺术》"><a href="#《沟通的艺术》" class="headerlink" title="《沟通的艺术》"></a><a href="https://book.douban.com/subject/4827593/">《沟通的艺术》</a></h5><p>表面上这是一本教你如何在公众面前演讲的书，但其实卡耐基在书中所教授的演讲技巧，可以被应用到生活中每一个说话的场合。无论你是提供消息（闲聊），说服他人赞同你的观点，还是游说他人采取某种行动（推销），都可以使用书中所提到的技巧。给我印象最深的一点是，一定要找机会实战，慢慢培养自信。</p><p>既然说到沟通，不得不补充一下另外几本写沟通的、同样觉得写得很好的书。首先是<a href="https://book.douban.com/subject/26948148/">《好好说话》</a>，由奇葩说辩手们总结的说话技巧，满满的干货。看完这本书最大的收获是说话一定要先根据情景判断权利的中心在哪，这样才能让我们说的话收到最大的效果。</p><p>另外两本是<a href="https://book.douban.com/subject/3533221/">《非暴力沟通》</a>和<a href="https://book.douban.com/subject/10586741/">《关键对话》</a>。前者专注于让我们关注自己和他人的需要，通过观察，以非暴力（不批评、指责自己或他人）的方式表达自己或他人的感受，分析造成目前这种感受的需要或价值是什么，然后发出请求，从而改善自己的人际关系。</p><p>后者聚焦如何处理好那些会影响到我们生活、工作和人际关系的关键对话，比如那些观点迥异、充满风险、双方可能表现出激烈情绪的对话。大部分人在处理这种对话的时候要么选择暴力对抗（争吵、诋毁、冷嘲热讽），要么选择消极应对（逃避、沉默、推卸责任），无论哪一种，最终都会给我们的人际关系带来负面的影响。所以想要学习如何处理好这些关键对话的话，这本书就非常值得一读了。</p><h5 id="《终身成长》"><a href="#《终身成长》" class="headerlink" title="《终身成长》"></a><a href="https://book.douban.com/subject/27154533/">《终身成长》</a></h5><p>这本就是我说的原本只是想随便翻翻，结果一翻就停不下来的书了。它花了300多页的篇幅只告诉你一件事：人的智力是可以改变的。</p><p>相信能看到这篇博客的人，应该都听说过固定式思维模式和成长型思维模式。没看这本书之前我一直以为自己是成长型思维模式的人，但后来发现自己并不完全是。我相信努力可以弥补一些差距，但是从来不相信努力真的可以让你追平和大神的间差距，这本书让我相信我还是有机会的ヾ(=･ω･=)o。</p><p>首先，大神们不是生来就是大神的，在他们的成长过程当中肯定有某种动因刺激到他们，让他们像看到自己的未来一样，发现了自己热爱并且值得用一生去追求的东西。在确定了自己的方向后，他们同样也需要付出巨大的努力，而且是日复一日、持续不断的努力，最终他们才变成了大家眼中的大神。我们想要做到和他们一样其实也很简单：付出比他们更大的努力。</p><p>虽然看起来像是鸡汤，但是事实确实就是这样。本书作者列举了各行业各领域大量的实例用以说明这两种思维方式所造成的差异，其中有不少拥有成长型思维的人和同样做到行业内顶尖水平但却拥有固定性思维的人的对比，后者当时取得的成就的确让人佩服，但是由于不同的思维方式的影响，他们最终人生的结局却与前者截然不同。</p><p>所以开始改变自己的思维方式吧，做一个拥有成长型思维的人。正如作者所说：</p><blockquote><p>巅峰状态的维持，需要一种健康、积极、不断进取的思维模式，一种不推崇智商或者成功本身，而将关注点投放在持续不断的努力、不畏挫折的态度上的长期的思考方式。</p></blockquote><p><strong>“改变也许很难，但是我从未见谁说过不值得。”</strong></p><hr><h3 id="最近的尝试"><a href="#最近的尝试" class="headerlink" title="最近的尝试"></a>最近的尝试</h3><p>说到改变，不得不说下最近才开始尝试的一个改变，那就是使用双拼。记得小学第一次上多媒体与技术的时候，我们的多媒体老师就告诉我们说，他一直使用双拼，然后教我们用金山打字通练习盲打。但是那时候第一次接触电脑，连全拼都不怎么会，更不用说双拼了。</p><p>等到家里有了电脑后，全拼的输入法已经普及了，只有少数人使用五笔，双拼输入对于那时只是使用电脑做为聊天娱乐的工具的我来说，更是想都没想过的事。偶尔不小心把输入法切换到双拼，打出让人一脸懵逼的句子，我还会以为是键盘坏了╮(╯▽╰)╭。</p><p>然而最近一次让我有了再次开始学习双拼的想法，是在看了李笑来的<a href="https://book.douban.com/subject/3609132/">《把时间当做朋友》</a>之后（我知道有很多人不喜欢他，但是他身上的确有很多值得我们学习的地方），而最终让我下定决心开始学习双拼则是因为这个 <a href="ted_better">TED</a> 视频。有些事情明明花很少的时间<a href="https://book.douban.com/subject/26895993/">刻意练习</a>就可以获得巨大的收益，但是却很少有人愿意花时间坚持。当时看完这个视频之后，我就立马开始搜索练习双拼的方法。</p><p>我是看了<a href="https://sspai.com/post/32809">这篇文章</a>之后，决定使用<a href="http://www.flypy.com/">小鹤双拼</a>作为我的双拼方案，这篇文章很好地解释了学习双拼的优势，比如减少击键次数和节奏感，因为从这两个方面来看，双拼输入可以说完爆全拼。</p><p>当然，双拼的劣势也很明显，那就是学习成本。不过一旦掌握正确的练习方法后，其实也不需要花很长时间。以我为例，每天花30分钟，一个月左右就可以学会，下面我就介绍下我是怎么做的。</p><p>首先，在学习双拼之前，要保证你的盲打很熟练。我所说的『盲打很熟练』是指指法正确并且完全不需要看键盘，如果你觉得自己没问题那么直接开始学双拼吧，如果不是则建议先从练习盲打开始。</p><p>这里提供两个学习盲打的网站，<a href="https://www.keybr.com/">keybr.com</a> 和 <a href="https://www.typingclub.com/">TypingClub</a>，前者可以让你快速熟悉键盘26个英文字母的盲打，就算之前完全没有接触过盲打训练，每天花1小时练习，一周后也可以达到盲打中速（50wpm）的水平。</p><p><img src="https://i.loli.net/2019/07/22/5d35c4af0176f66909.png" alt="keybr.com"></p><p>Typing Club 的练习课程就比较丰富了，最基础的课程 <a href="https://www.typingclub.com/sportal/program-3.game">Typing Jungle</a> 主要帮你熟悉键盘的其他所有键位，包括大小写与特殊符号，推荐直接练习这个课程就可以了。比较好玩的一点是，Typing Jungle 是以闯关的形式来作为练习方式的。每完成一关后都有打分，难度逐渐升高，每完成一小节后还有打字小游戏。我觉得这个设计还是挺好的，可以让你从打字练习中体验到打怪升级的感觉，而且你也更容易坚持下去。不过老实说，这个练习课程还是挺长的，想要全都练完需要花点时间，总共有 684 节！щ(ﾟДﾟщ)</p><p><img src="https://i.loli.net/2019/07/22/5d35c4e36298a79278.png" alt="Typing Jungle"></p><p>通过这两个网站，以及勤奋练习，相信大多数人都可以在 2~3 周内熟练掌握盲打。</p><p>学会盲打之后再来学习双拼就事半功倍啦，当然这里也有一个非常好用的<a href="https://api.ihint.me/shuang/">双拼练习</a>网站推荐给大家。在这个网站上，你可以自由选择双拼方案，或者切换练习模式，难度从 [全部顺序-&gt;全部随机-&gt;困难随机-&gt;无拼音] 逐渐升高，而且这个项目还是<a href="https://github.com/BlueSky-07/Shuang">开源的</a>！觉得不错的话给作者点个小星星吧~(๑•̀ㅂ•́)و✧</p><p>项目作者还贴心地开发了小程序版本，所以我们可以利用碎片时间练习双拼了。 觉得好用的话，不妨打赏下请作者喝杯奶茶吧~</p><p><img src="https://i.loli.net/2019/07/22/5d35c50756e1a96602.jpeg" alt="双拼练习微信小程序版"></p><p>Stay awesome!</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><h4 id="书本"><a href="#书本" class="headerlink" title="书本"></a>书本</h4><ul><li><a href="https://book.douban.com/subject/1069685/">爱你就像爱生命</a></li><li><a href="https://book.douban.com/subject/1082406/">黄金时代</a></li><li><a href="https://book.douban.com/subject/6902317/">革命时期的爱情</a></li><li><a href="https://book.douban.com/subject/27013708/">一只特立独行的猪</a></li><li><a href="https://book.douban.com/subject/4827593/">沟通的艺术</a></li><li><a href="https://book.douban.com/subject/26948148/">好好说话</a></li><li><a href="https://book.douban.com/subject/3533221/">非暴力沟通</a></li><li><a href="https://book.douban.com/subject/10586741/">关键对话</a></li><li><a href="https://book.douban.com/subject/27154533/">终身成长</a></li><li><a href="https://book.douban.com/subject/3609132/">把时间当做朋友</a></li><li><a href="https://book.douban.com/subject/26895993/">刻意练习</a></li></ul><h4 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h4><ul><li><a href="https://open.163.com/movie/2017/2/C/U/MCC01J0QP_MCC021ACU.html">【TED】如何做得更好 - 网易公开课</a></li><li><a href="https://sspai.com/post/32809">做少数派中的少数派：双拼输入快速入门</a></li><li><a href="http://www.flypy.com/">小鹤双拼·小鹤音形 - 官方网站</a></li><li><a href="https://www.keybr.com/">Typeing practice</a></li><li><a href="https://www.typingclub.com/">Learn Touch Typing Free - TypingClub</a></li><li><a href="https://api.ihint.me/shuang/">双拼练习 @ BlueSky</a></li><li><a href="https://github.com/BlueSky-07/Shuang">BlueSky-07/Shuang: :pencil2: 双拼练习</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reviews </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 来电呼叫转移功能</title>
      <link href="/android-call-forward/"/>
      <url>/android-call-forward/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35c3f9636f534725.png" alt="Google Earth View"></p><blockquote><p>这篇其实不算技术博客，简单记录下关于来电转移的使用。</p></blockquote><h3 id="00-呼叫转移的类型"><a href="#00-呼叫转移的类型" class="headerlink" title="00 呼叫转移的类型"></a>00 呼叫转移的类型</h3><p>呼叫转移其实是一个比较常见的功能了，当你在开发一个使用电话场景的业务比较多的 app 的时候，难免会遇到需要使用呼叫转移功能的需求，这样当使用你 app 的用户（公司员工）无法立即接听或者处于忙碌状态的时候，如果有个一键呼叫转移的功能那是不是很方便呢？</p><p>经过一番搜索，不同移动网络对呼叫转移的支持也有区别，大致分为两种，C 网与 G 网，C 网是指 <a href="https://en.wikipedia.org/wiki/Code-division_multiple_access">CDMA</a> 网，G 网是指 <a href="https://en.wikipedia.org/wiki/GSM">GSM</a> 网。其实就是两种不同的网络通信方式，维基百科的解释看不太懂，后来还是看了这个<a href="https://zhidao.baidu.com/question/26974139.html">百度知道</a>的回答后才稍微明白了一点（好吧，百度知道也不全是垃圾😂）：</p><span id="more"></span><blockquote><p>C网是CDMA频段：CDMA 1X：CDMA 1X采用扩频速率为SR1，即指前向信道和反向信道均用码片速率 1.2288Mbit/s的单载波直接系列扩频方式。因此它可以方便地与IS-95（A/B）后向兼容，实现平滑 过渡。由于CDMA 1X采用了反向相干解调、快速前向功控、发送分集、Turbo编码等新技术，其容量比 IS-95大为提高。在相同条件下，对普通话音业务而言，容量大致为IS-95系统的两倍。CDMA 1X网络 可以作为话音业务的承载平台，也可以作为无线接入Internet分组数据承载平台，既可以为用户提 供传统的话音业务，也可以为用户提供端对端分组传输模式的数据业务。</p><p>CDMA网络是由联通统一建设和运营，这一独家运营权所能带来的市场空间也是很明显的。有了 CDMA网的支持，联通可以实现许多新的增值数据业务，由此可能会赢得更多CDMA用户。</p></blockquote><blockquote><p>G网是GSM数字网：GSM：GSM(Global System For Mobile Communication)网即全球移动通信系统，又称 “全球通”，很多公司参与了标准的制定工作。GSM数字移动通信系统是由欧洲主要电信运营者和 制造厂家组成的标准化委员会设计出来的，它是在蜂窝系统的基础上发展而成。</p><p>GSM采用的是数字调制技术，其关键技术之一是时分多址(每个用户在某一时隙上选用载频且只能在特 定时间下收信息)，GSM系统有几项重要特点：防盗拷能力佳、网络容量大、号码资源丰富、通话清晰、 稳定性强不易受干扰、信息灵敏、通话死角少、手机耗电量底等。因此其话音清晰，保密容易，能提 供的数据传输服务较多。GSM网能支持的用户数量为模拟网的1.8-2倍。</p></blockquote><p>目前来看，中国电信使用的网络制式中同时包含了C网与G网（大部分是C网），中国移动与中国联通大多使用G网。</p><h3 id="01-C网和G网设置呼叫转移的规则"><a href="#01-C网和G网设置呼叫转移的规则" class="headerlink" title="01 C网和G网设置呼叫转移的规则"></a>01 C网和G网设置呼叫转移的规则</h3><p>经过多番搜索，整理出下面两张表格。</p><p><strong>C网（适用中国电信）</strong></p><table><thead><tr><th align="center">类型</th><th align="center">启用</th><th align="center">取消</th></tr></thead><tbody><tr><td align="center">无条件呼叫转移</td><td align="center">*72[电话号码]+拨打键</td><td align="center">*720+拨打键</td></tr><tr><td align="center">遇忙呼叫转移</td><td align="center">*90[电话号码]+拨打键</td><td align="center">*900+拨打键</td></tr><tr><td align="center">无信号/关机/无应答呼叫转移</td><td align="center">*92[电话号码]+拨打键</td><td align="center">*920+拨打键</td></tr><tr><td align="center">取消所有呼叫转移</td><td align="center">*730+拨打键</td><td align="center"></td></tr></tbody></table><p>参考：<a href="http://gd.189.cn/esurfing/yewu/2011/11/05/10990.htm">中国电信呼叫转移业务介绍</a></p><p><strong>G网（适用中国移动与中国联通）</strong></p><table><thead><tr><th align="center">类型</th><th align="center">启用</th><th align="center">取消</th><th align="center">状态查询</th></tr></thead><tbody><tr><td align="center">无条件呼叫转移</td><td align="center">**21*[电话号码]#+拨打键</td><td align="center">##21#+拨打键</td><td align="center">*#21#+拨打键</td></tr><tr><td align="center">遇忙呼叫转移</td><td align="center">**67*[电话号码]#+拨打键</td><td align="center">##67#+拨打键</td><td align="center">*#67#+拨打键</td></tr><tr><td align="center">无信号/关机呼叫转移</td><td align="center">**62*[电话号码]#+拨打键</td><td align="center">##62#+拨打键</td><td align="center">*#62#+拨打键</td></tr><tr><td align="center">无应答呼叫转移</td><td align="center">**61*[电话号码]#+拨打键</td><td align="center">##61#+拨打键</td><td align="center">*#61#+拨打键</td></tr><tr><td align="center">取消所有呼叫转移</td><td align="center"></td><td align="center">##002#+拨打键</td><td align="center"></td></tr></tbody></table><p>参考：<a href="http://gd.10086.cn/commodity/options/detail/SVC_CALLFORWARD.shtml">中国移动呼叫转移设置使用</a> &amp; <a href="http://www.sendsms.cn/download/cabe6252319447f75888ab17a49c8aa8.pdf">呼叫转移的命令代码</a></p><h3 id="02-发起呼叫转移"><a href="#02-发起呼叫转移" class="headerlink" title="02 发起呼叫转移"></a>02 发起呼叫转移</h3><p>知道上述规则之后，其实发起呼叫转移就很简单了，首先保证你的应用已经声明了打电话的权限，然后只要发起 <code>Intent.ACTION_CALL</code> 的 Intent 就可以了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">callForward</span>(<span class="hljs-params">Context context, <span class="hljs-built_in">String</span> forwardNumber</span>)</span> &#123;<br>    Intent dialIntent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_CALL,<br>    Uri.parse(<span class="hljs-built_in">String</span>.format(<span class="hljs-string">&quot;tel:%s&quot;</span>, forwardNumber)));<br>    dialIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br>    context.startActivity(dialIntent);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这里可以结合我的上一篇文章做一点优化，对呼出的号码进行过滤，如果包含呼叫转移的前缀则对呼叫转移的类型进行判断并提示信息。具体请看：<a href="https://ajiew.github.io/android-phone-call-app-and-listen-phone-calls">安卓代替系统默认电话应用(Android 6.0+)与电话状态监听</a></p><p>祝各位周末愉快！</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓代替系统默认电话应用 (Android 6.0+) 与电话状态监听</title>
      <link href="/android-phone-call-app-and-listen-phone-calls/"/>
      <url>/android-phone-call-app-and-listen-phone-calls/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35c2c08ec1575678.png" alt="Procrastinator&#39;s Brain"></p><blockquote><p>Android 6.0 之后开始支持修改默认电话应用，刚好最近有个相关的需求，于是记录下自己探索之旅。</p></blockquote><h3 id="00-Android-Telecom-framework"><a href="#00-Android-Telecom-framework" class="headerlink" title="00 Android Telecom framework"></a>00 Android Telecom framework</h3><p>从 API 21 开始，谷歌添加了 <a href="https://developer.android.com/reference/android/telecom/TelecomManager"><code>TelecomManager</code></a> 用于提供对电话通讯状态的监听，而 API 23 之后，又开放了 <a href="https://developer.android.com/guide/topics/connectivity/telecom/">Telecom framework</a>，这个框架允许第三方应用开发者编写应用来替换系统默认电话应用，而其中大部分接口就添加在 <code>android.telecom</code> 包下。</p><p> Telecom framework 其实提供了两个方面的 API，一个是 <a href="https://developer.android.com/reference/android/telecom/ConnectionService.html">ConnectionService</a> 用于实现通讯（比如通过电信服务商提供的电话连接服务），另一个就是我们这次的需要用到的 <a href="https://developer.android.com/reference/android/telecom/InCallService.html">InCallService</a>，它主要负责提供 UI 来管理电话。一般系统自带的电话应用同样也是实现这套 API 来提供电话通信的交互界面的。</p><span id="more"></span><h3 id="01-替代系统默认电话应用"><a href="#01-替代系统默认电话应用" class="headerlink" title="01 替代系统默认电话应用"></a>01 替代系统默认电话应用</h3><p>整个实现过程其实分为两步，首先是新增一个 Service 继承 <code>InCallService</code> 并实现其中你感兴趣的方法，然后再添加一个 Activity 用于提供用户界面。</p><p>首先我们来看下 Service 部分。</p><h4 id="实现-InCallService"><a href="#实现-InCallService" class="headerlink" title="实现 InCallService"></a>实现 <code>InCallService</code></h4><p>继承 <code>InCallService</code> 后我们需要实现两个方法 <code>onCallAdded</code> 和 <code>onCallRemoved</code>，分别代表电话进来与断开时会被调用，一般我们会在 <code>onCallAdded</code> 中注册电话状态监听，并在 <code>onCallRemoved</code> 中解除监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneCallService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InCallService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Call.Callback callback = <span class="hljs-keyword">new</span> Call.Callback() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStateChanged</span><span class="hljs-params">(Call call, <span class="hljs-keyword">int</span> state)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onStateChanged(call, state);<br>            <span class="hljs-keyword">switch</span> (state) &#123;<br>                <span class="hljs-keyword">case</span> Call.STATE_ACTIVE: &#123;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 通话中</span><br>                &#125;<br>                <span class="hljs-keyword">case</span> Call.STATE_DISCONNECTED: &#123;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 通话结束</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCallAdded</span><span class="hljs-params">(Call call)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCallAdded(call);<br><br>        call.registerCallback(callback);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCallRemoved</span><span class="hljs-params">(Call call)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCallRemoved(call);<br><br>        call.unregisterCallback(callback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，对于通话 Service 在 menifest 中注册的方法肯定也和普通的 service 有点区别：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.PhoneCallService&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:permission</span>=<span class="hljs-string">&quot;android.permission.BIND_INCALL_SERVICE&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.telecom.IN_CALL_SERVICE_UI&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.telecom.InCallService&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代替系统默认通话应用并不需要添加特殊的权限，但是要在你实现的 <code>InCallService</code> 上声明 <code>android.permission.BIND_INCALL_SERVICE</code> 权限，另外还要加上 &lt;meta-data&gt; 用于表明我们的应用提供了接听电话的 UI，<code>android.telecom.InCallService</code> 的 &lt;intent-filter&gt; 当然就是用于在电话拨出或打进的时候，让系统发送的广播能够直接启动我们的电话服务。</p><h4 id="实现电话接听的-UI"><a href="#实现电话接听的-UI" class="headerlink" title="实现电话接听的 UI"></a>实现电话接听的 UI</h4><p>这部分比较简单，只要创建一个 Activity 然后在 menifest 中注册就可以了，不过注册时至少需要添加这两个 &lt;intent-filter&gt;：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- provides ongoing call UI --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.DIAL&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">&quot;tel&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-comment">&lt;!-- provides dial UI --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.DIAL&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br></code></pre></td></tr></table></figure><p>看起来好像有点奇怪，因为好像这两个 &lt;intent-filter&gt; 几乎一样，但其实第一个 &lt;intent-filter&gt; 是用来提供打电话UI的 ，而第二个用于提供拨号功能，至于为什么要分开呢？可以参考 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/telecomm/java/android/telecom/DefaultDialerManager.java#144">DefaultDialerManager</a>，这是安卓源码里的一个隐藏的类。方法 <code>getInstalledDialerApplications()</code> 上的注释写的很清楚，想要让系统检测到可供拨号的应用就必须至少要添加这两个 &lt;intent-filter&gt;。</p><h4 id="管理电话的接打"><a href="#管理电话的接打" class="headerlink" title="管理电话的接打"></a>管理电话的接打</h4><p>接下来我们需要定义一个接打电话的管理类 <code>PhoneCallManager</code>，用于给 activity 提供一些电话相关的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneCallManager</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Call call;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接听电话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">answer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (call != <span class="hljs-keyword">null</span>) &#123;<br>            call.answer(VideoProfile.STATE_AUDIO_ONLY);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 断开电话，包括来电时的拒接以及接听后的挂断</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (call != <span class="hljs-keyword">null</span>) &#123;<br>            call.disconnect();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>PhoneCallManger</code> 包含接听和断开电话的方法调用，我们要做的只是在合适的地方将 call 对象传进去，最合适的地方当然是在 <code>InCallService</code> 里添加与移除 <code>Call</code> 的时候了。</p><p>另外，在添加电话的时候，我们要记得启动我们作为电话界面的 activity 去提供接打的操作，这里我们可以根据 call 的 state 来判断电话是打进的还是拨出的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCallAdded</span><span class="hljs-params">(Call call)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCallAdded(call);<br><br>    call.registerCallback(callback);<br>    PhoneCallManager.call = call; <span class="hljs-comment">// 传入call</span><br>    <br>    CallType callType = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">if</span> (call.getState() == Call.STATE_RINGING) &#123;<br>    callType = CallType.CALL_IN;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (call.getState() == Call.STATE_CONNECTING) &#123;<br>    callType = CallType.CALL_OUT;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (callType != <span class="hljs-keyword">null</span>) &#123;<br>    Call.Details details = call.getDetails();<br>    String phoneNumber = details.getHandle().toString().substring(<span class="hljs-number">4</span>)<br>    .replaceAll(<span class="hljs-string">&quot;%20&quot;</span>, <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 去除拨出电话中的空格</span><br>    PhoneCallActivity.actionStart(<span class="hljs-keyword">this</span>, phoneNumber, callType);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCallRemoved</span><span class="hljs-params">(Call call)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCallRemoved(call);<br><br>    call.unregisterCallback(callback);<br>    PhoneCallManager.call = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>还记得之前的我们创建的 call 的回调吗，我们监听了电话状态的改变，所以可以在电话断开的时候退出电话界面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> Call.STATE_DISCONNECTED: &#123;<br><span class="hljs-comment">// 通话结束</span><br>ActivityStack.getInstance().finishActivity(PhoneCallActivity.class);<br><span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至于 UI 界面如何实现，取决于你的需求了，这里我只是提供了接听和挂断的按钮用于演示，来看下效果图：</p><p><img src="https://i.loli.net/2019/07/22/5d35c2e340e9371588.gif" alt="In Call Demo"></p><p>最后，既然要替换系统默认电话应用，当然要提醒用户将我们的应用设置为默认应用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br>        <span class="hljs-comment">// Android M 以上的系统则发起将本应用设为默认电话应用的请求</span><br>        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;<br>            Intent intent = <span class="hljs-keyword">new</span> Intent(TelecomManager.ACTION_CHANGE_DEFAULT_DIALER);<br>            intent.putExtra(TelecomManager.EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME, <br>            getPackageName());<br>            startActivity(intent);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码会在我们的 Actiivty 中启动这样一个 Dialog，如果用户点击确定后我们的应用就变成了默认电话应用啦╭(๑•̀ㅂ•́)و✧</p><p><img src="https://i.loli.net/2019/07/22/5d35c2fd6d30a17925.jpg" alt="请求将App设置为默认应用"></p><h3 id="02-电话状态监听"><a href="#02-电话状态监听" class="headerlink" title="02 电话状态监听"></a>02 电话状态监听</h3><p>以上实现的功能只能在 Android M 以上的系统才有效，那么 Android M 以下怎么办呢？其实我们可以通过监听电话状态然后做一些操作。</p><p>之前说过从 API 21 开始 Google 添加了 <code>TelecomManager</code> 类，所以我们可以借助这个类来监听电话状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initPhoneStateListener</span><span class="hljs-params">()</span> </span>&#123;<br>    phoneStateListener = <span class="hljs-keyword">new</span> PhoneStateListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCallStateChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> state, String incomingNumber)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onCallStateChanged(state, incomingNumber);<br><br>            <span class="hljs-keyword">switch</span> (state) &#123;<br>                <span class="hljs-keyword">case</span> TelephonyManager.CALL_STATE_IDLE: <span class="hljs-comment">// 待机，即无电话时，挂断时触发</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> TelephonyManager.CALL_STATE_RINGING: <span class="hljs-comment">// 响铃，来电时触发</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> TelephonyManager.CALL_STATE_OFFHOOK: <span class="hljs-comment">// 摘机，接听或打电话时触发</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>    telephonyManager = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);<br>    <span class="hljs-keyword">if</span> (telephonyManager != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 设置来电监听</span><br>        telephonyManager.listen(phoneStateListener, PhoneStateListener.LISTEN_CALL_STATE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以把监听放到 Service 中，然后再注册一个电话变化的广播接收器来启动这个 Service，这样无论何时电话状态发生变化我们都可以接收到并做出一些操作。比如这里我监听了来电并弹出一个顶级弹框覆盖默认的电话应用，然后提供一个按钮用于打开App。</p><p><img src="https://i.loli.net/2019/07/22/5d35c3386355e80306.gif" alt="电话状态的监听"></p><p>具体代码请看我写的 Demo，Github 地址：<a href="https://github.com/aJIEw/PhoneCallApp">aJIEw/PhoneCallApp</a></p><p>Demo 包括两部分，代替默认电话应用以及电话监听。</p><p>这里记录一个小坑，一般情况下，Android M 以下只要在 <code>manifest</code> 中声明权限就可以显示顶级弹框了，但是在某些国产 Rom 上顶级弹框默认是禁止的，需要在<strong>悬浮窗管理</strong>中允许后才可以。所以这里有个三方库就非常值得推荐了：<a href="https://github.com/czy1121/settingscompat">czy1121/SettingsCompact</a></p><p>用法也相当简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检查是否开启了权限</span><br><span class="hljs-keyword">if</span> (!SettingsCompat.canDrawOverlays(<span class="hljs-keyword">this</span>)) &#123;<br>    <span class="hljs-keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;<br>        <span class="hljs-comment">// Android M 以上引导用户去系统设置中打开允许悬浮窗</span><br>        <span class="hljs-comment">// 使用反射是为了用尽可能少的代码保证在大部分机型上都可用</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Context context = <span class="hljs-keyword">this</span>;<br>            Class clazz = Settings.class;<br>            Field field = clazz.getDeclaredField(<span class="hljs-string">&quot;ACTION_MANAGE_OVERLAY_PERMISSION&quot;</span>);<br>            Intent intent = <span class="hljs-keyword">new</span> Intent(field.get(<span class="hljs-keyword">null</span>).toString());<br>            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br>            intent.setData(Uri.parse(<span class="hljs-string">&quot;package:&quot;</span> + context.getPackageName()));<br>            context.startActivity(intent);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Toast.makeText(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;请在悬浮窗管理中打开权限&quot;</span>, Toast.LENGTH_LONG).show();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 6.0 以下则直接使用 SettingsCompat 中提供的接口</span><br>        SettingsCompat.manageDrawOverlays(act);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="03-后记"><a href="#03-后记" class="headerlink" title="03 后记"></a>03 后记</h3><p>这篇文章拖了一个礼拜才写完，论拖延的功底也是没谁了。其实本来应该上周日发的，但是后来把时间花在了研究各种录屏软件的使用，然后为了一个视频截取的功能又开始研究各种视频软件。推荐一个TED视频：<a href="https://www.ted.com/talks/tim_urban_inside_the_mind_of_a_master_procrastinator">拖延症人群的内心世界</a>，可以说把拖延症人群的心理描述得相当到位了。拖延不可怕，可怕的是拖出习惯了，完全不拖延的人不存在，所以我们每个人都应该问问自己：我有没有在那些会影响到自己未来的事上拖延？</p><hr><h6 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h6><ol><li><p><a href="https://blog.csdn.net/jenly121/article/details/50848909">Android 之来电秀实现（一）</a></p></li><li><p><a href="https://blog.csdn.net/jenly121/article/details/50856994">Android 之来电秀实现（二）</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 收银机开发笔记</title>
      <link href="/android-cashier-app/"/>
      <url>/android-cashier-app/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35c290e907769336.jpg" alt="Summer Wind"></p><blockquote><p>前言：记录下自己在收银机开发过程中的一些心得笔记，此博客长期更新。</p></blockquote><h3 id="00-收银机开发和普通安卓手机应用开发的区别"><a href="#00-收银机开发和普通安卓手机应用开发的区别" class="headerlink" title="00 收银机开发和普通安卓手机应用开发的区别"></a>00 收银机开发和普通安卓手机应用开发的区别</h3><p>个人觉得，最大的区别就是，屏幕空间变大了，一屏之内可展示的内容变多了。其实不仅仅是屏幕空间变大了，也由原来的习惯看竖屏到习惯看横屏了。另外需要做的适配工作也简单很多，因为收银机屏幕分辨率和屏幕大小都差不多，几乎不需要做特殊的适配，而且你还可以更改屏幕密度，下面会说到。</p><p>还有一点就是，不再需要担心应用保活的问题了，因为基本上安装到商家的收银机上之后，我们的应用就是主角，所以可供我们发挥的空间就大了。另外诸如开机自启、系统敏感权限等，这些都不是事儿~</p><p>虽然少了很多限制，但还是想说，安全对一款收银机应用来说还是非常重要的，比如怎样保证应用的数据安全以及网络安全，这些都是目前还没来得及做、未来需要完善的。</p><span id="more"></span><h3 id="01-应用全屏"><a href="#01-应用全屏" class="headerlink" title="01 应用全屏"></a>01 应用全屏</h3><h4 id="PART-1"><a href="#PART-1" class="headerlink" title="PART 1"></a>PART 1</h4><p>一般来说，我们的收银机应用大多数时候都应该占满屏幕，所以需要用到全屏模式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.AppCompat.Light.NoActionBar&quot;</span>&gt;</span><span class="xml"></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowAnimationStyle&quot;</span>&gt;</span>@style/notAnimation<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowFullscreen&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowContentOverlay&quot;</span>&gt;</span>@null<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到我们使用了 <code>Theme.AppCompat.Light.NoActionBar</code> 作为父主题，然后覆盖了 <code>android:windowFullscreen</code> 和 <code>android:windowContentOverlay</code> 属性，前者用于隐藏状态栏，后者用于消除包裹应用 content 的 drawable（通常是标题下的阴影），参考 <a href="https://developer.android.com/reference/android/R.attr.html#windowContentOverlay">windowContentOverlay</a>。</p><h4 id="PART-2"><a href="#PART-2" class="headerlink" title="PART 2"></a>PART 2</h4><p>当然，这些只是最基本的，我们还需要处理 activity 配置发生改变的情况，在 activity 下添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:configChanges=&quot;orientation|screenSize|keyboardHidden&quot;<br></code></pre></td></tr></table></figure><p>这样，我们就告诉系统当 activity 屏幕方向或者键盘可见性发生变化后不要退出重启 activity，因为收银机应用几乎所有 activity 屏幕方向都应该是水平的。</p><p>另外关于键盘，还需要在 activity 中加上 <code>android:windowSoftInputMode=&quot;stateHidden|adjustPan&quot;</code> 属性，<code>stateHidden</code> 表明当用户初次进入 activity 的时候，键盘不会显示出来（一般只有在登录界面才会需要键盘一开始就显示），而 <code>adjustPan</code> 则会在键盘显示出来的时候自动调整 UI 内容，让用户始终可以看到他们输入的内容而不是被键盘覆盖掉。</p><p>所以 AndroidManifest 中我们的 activity 大多数是这样配置的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:configChanges</span>=<span class="hljs-string">&quot;orientation|keyboardHidden|screenSize&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:screenOrientation</span>=<span class="hljs-string">&quot;landscape&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:windowSoftInputMode</span>=<span class="hljs-string">&quot;stateHidden|adjustPan&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>具体参数介绍请看 <a href="https://developer.android.com/guide/topics/manifest/activity-element#wsoft"><activity></a>。</p><h4 id="PART-3"><a href="#PART-3" class="headerlink" title="PART 3"></a>PART 3</h4><p>这些就够了吗？当然不是！通常，我们还需要在我们的 BaseActivity 中做如下配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//开启全屏</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fullScreenFlags = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN<br>        | View.SYSTEM_UI_FLAG_FULLSCREEN <span class="hljs-comment">//hide statusBar</span><br>        | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION<br>        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION <span class="hljs-comment">//hide navigationBar</span><br>        | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY<br>        | View.SYSTEM_UI_FLAG_LAYOUT_STABLE;<br><br><span class="hljs-keyword">final</span> Window window = getWindow();<br>window.getDecorView().setSystemUiVisibility(fullScreenFlags);<br>window.getDecorView().setOnSystemUiVisibilityChangeListener(<span class="hljs-keyword">new</span> View.OnSystemUiVisibilityChangeListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSystemUiVisibilityChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> visibility)</span> </span>&#123;<br>    window.getDecorView().setSystemUiVisibility(fullScreenFlags);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>可以看到我们给 DecorView 设置了一些 Visibility 的 Flag， 首先是隐藏状态栏和导航栏，然后是 <code>View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY</code> 用于沉浸模式，也就是使状态栏变得半透明，同时接受屏幕边缘的滑动事件（通常这类事件是由系统处理掉的）。文档上是这么写的：</p><blockquote><p>While in sticky immersive mode, if the user swipes from an edge with a system bar, system bars appear but they’re semi-transparent, and the touch gesture is passed to your app so it app can also respond to the gesture.</p></blockquote><p>然后是 <code>View.SYSTEM_UI_FLAG_LAYOUT_STABLE</code> 用于保证你的布局全屏，不会因为系统栏的显示而重新调整大小。具体请参考文档：<a href="https://developer.android.com/training/system-ui/immersive">Enable fullscreen mode</a></p><h4 id="PART-4"><a href="#PART-4" class="headerlink" title="PART 4"></a>PART 4</h4><p>除此之外，我们还应该考虑到一些特殊情况，比如显示 dialog 或者用户输入的情况下，这些时候导航栏都会显示出来，所以通常我们还会写这么一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enterFullScreen</span><span class="hljs-params">(Window window)</span> </span>&#123;<br>    window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);<br>    window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE | WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);<br>    <span class="hljs-keyword">int</span> uiOptions = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION<br>        | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION<br>        | View.SYSTEM_UI_FLAG_LAYOUT_STABLE<br>        | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY<br>        | View.SYSTEM_UI_FLAG_FULLSCREEN;<br>    window.getDecorView().setSystemUiVisibility(uiOptions);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在显示 dialog 或者其他一些有可能触发导航栏显示的地方调用下这个方法，这样就能保证始终全屏啦。另外对于监听键盘输入，推荐一个三方库：<a href="https://github.com/yshrsmz/KeyboardVisibilityEvent">KeyboardVisibilityEvent</a>，使用起来非常方便，只要在 activity 初始化的地方调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">KeyboardVisibilityEvent.setEventListener(<span class="hljs-keyword">this</span>,<br>    <span class="hljs-keyword">new</span> KeyboardVisibilityEventListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onVisibilityChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isOpen)</span> </span>&#123;<br>        UIHelper.create().enterFullScreen(getWindow());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样当用户使用键盘输入的时候，我们可以保证始终全屏显示。</p><p>最后，也许有人会有疑问，如果我们的应用开机自启，而且始终全屏，那不是无法回到桌面了吗？其实不用担心，我们可以自己设置一个按钮，提供回到桌面的功能，比如当用户点击右下角显示当前时间的地方。是不是听起来有点熟悉？没错，就是受到了 windows 的启发~</p><h3 id="02-修改收银机主屏幕密度"><a href="#02-修改收银机主屏幕密度" class="headerlink" title="02 修改收银机主屏幕密度"></a>02 修改收银机主屏幕密度</h3><h4 id="PART-1-1"><a href="#PART-1-1" class="headerlink" title="PART 1"></a>PART 1</h4><p>首先说明下，这种方式只针对使用<a href="http://www.rock-chips.com/a/cn/product/index.html">瑞芯</a>芯片的收银机才有效，可以用以下命令检查是否是支持修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell cat /system/build.prop | grep ro.sf.lcd_density<br><span class="hljs-meta">#</span><span class="bash"> or</span><br>adb shell getprop ro.sf.lcd_density<br></code></pre></td></tr></table></figure><p>如果存在该属性则证明可以修改。下面是步骤（过时，参考 PART 3）：</p><ol><li>将 <code>/system/build.prop</code> 文件拉到本地，使用 adb 命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb pull /system/build.prop ./<br></code></pre></td></tr></table></figure><ol start="2"><li>打开 <code>build.prop</code> 文件，找到 <code>ro.sf.lcd_density</code> 属性，这个属性就是用来指定屏幕密度的，直接修改成我们想要的密度就可以了，默认是 160，我们可以修改为 240。个人觉得，对于一般收银机来说，这是看着最舒服的：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">set</span> default lcd density to Rockchip tablet</span><br>ro.sf.lcd_density=240<br></code></pre></td></tr></table></figure><ol start="3"><li>将修改完毕后的文件覆盖掉原文件，当然首先要将 <code>/system</code> 挂载为可读写再覆盖：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb root<br>adb shell mount -o rw,remount /system<br>adb push build.prop /system/<br></code></pre></td></tr></table></figure><ol start="4"><li>最后不要忘记修改 <code>/system</code> 为只读：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell mount -o ro,remount /system<br>adb shell reboot<br></code></pre></td></tr></table></figure><p>最后，当机子重启完毕，新的屏幕密度就已经起作用了。</p><h4 id="PART-2-1"><a href="#PART-2-1" class="headerlink" title="PART 2"></a>PART 2</h4><p>当然，上面这些步骤对于安卓开发来说没难度，但是对于运维来说，其实还是挺麻烦的，所以写了个 batch 脚本（运维用 Windows ¯\_(ツ)_/¯），只要用数据线连接上收银机，双击运行下就ok了，我是不是很棒~</p><p>Github 地址：<a href="https://github.com/aJIEw/ChangeDensity-win-batch">ChangeDensity-win-batch</a> </p><h4 id="PART-3-1"><a href="#PART-3-1" class="headerlink" title="PART 3"></a>PART 3</h4><p>其实修改屏幕分辨率还有一个更简便的方法，那就是通过 <code>adb</code> 命令中的 Window Manager，一行命令就可以搞定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell wm density [reset|DENSITY] <br></code></pre></td></tr></table></figure><p>参数中 reset 表示恢复默认值，DENSITY 就是你想要修改成的屏幕密度，是不是异常简单？而且这种修改方式是立即生效的，和之前的方法一比简直不要太方便。同样只要检查 <code>ro.sf.lcd_density</code> 参数是否存在就可以了。另外，wm 全部命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">usage: wm [subcommand] [options]<br>       wm size [reset|WxH|WdpxHdp]<br>       wm density [reset|DENSITY]<br>       wm overscan [reset|LEFT,TOP,RIGHT,BOTTOM]<br>       wm scaling [off|auto]<br>       wm screen-capture [userId] [true|false]<br><br>wm size: return or override display size.<br>         width and height in pixels unless suffixed with &#x27;dp&#x27;.<br><br>wm density: override display density.<br><br>wm overscan: set overscan area for display.<br><br>wm scaling: set display scaling mode.<br><br>wm screen-capture: enable/disable screen capture.<br><br>wm dismiss-keyguard: dismiss the keyguard, prompting the user for auth if necessary.<br><br>wm surface-trace: log surface commands to stdout in a binary format.<br></code></pre></td></tr></table></figure><p>可以看到屏幕分辨率也是可以直接修改的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell wm size [reset|WxH|WdpxHdp]<br></code></pre></td></tr></table></figure><p>新技能 GET✓ (•̀ᴗ•́)و ̑̑</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>年中小记</title>
      <link href="/2018-half/"/>
      <url>/2018-half/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35c0c13576823514.jpg" alt="Moving Clouds in the Summer"></p><blockquote><p>拖延症如我，写年中总结也比别人慢半拍，但是 late better then never，开始了就有希望。</p></blockquote><p>6月1号到现在，转眼入职新公司一个多月了，时间真的是过的好快，从当初刚入职的忐忑到现在越来越自信，真的很感谢同事们的照顾。</p><p>虽然来了没多久，但是陆续有两位同事都离职了，走了一个前端和产品，觉得有点不可思议。虽说互联网公司人员变动从来不是新鲜事，但是这频率给我感觉这也太密集了吧，尤其是对我们这种小团队而言，少了两个人办公室一下就冷清了不少。但是还是要习惯变化吧，毕竟人生路很长，我们都还有很长的路要走。祝他们好吧。</p><span id="more"></span><p>说下自己入职以来的变化吧。首先，来了之后，最大的变化就是工具，第一次切换到 Mac 开发，之前觉得没有必要用 Mac，用了之后才觉得是自己当初太年轻了，现在让我切换回 PC，的确有点不习惯。虽然普通使用（玩游戏）还是要用 PC，但是对于开发来说，Mac 的优势真的太明显了，运行速度加上各种快捷键以及各种工具对开发效率的提高真的帮助太大。在上一个公司一直用 ThinkPad+Win 10，对比发现，还是 Mac 的触摸控制好用一点乀(ˉεˉ乀)~</p><p>之前一直拒绝使用 Mac 的主要原因是害怕自己不习惯 Mac 上的快捷键以及习惯了 Win 上的一些软件，事实证明，的确有影响，但是绝对不足以构成拒绝使用 Mac 的理由。我入职第一天做的第一件事就是先把 Mac 上的各种快捷键整理出几个文件，包括 Mac 常用快捷键，AS 快捷键，Terminal 快捷键等等。多用用，多搜索搜索，差不多一个多礼拜吧，基本就可以熟悉了。</p><p>另外软件方面，之前虽然收集了很多 Win 上提高效率的软件，切换到 Mac 后，除了像 Dropbox 之类的 Mac 上也能用，大部分都只能抛弃了。但是，Mac 上优秀的软件也非常多啊，之前收藏的一些关于 Mac 上效率提升的软件的文章也可以翻出来看看了。好软件很多，不过大多都收费，有些还很贵，这也进一步刺激了自己要努力赚钱，起码要做到买这些软件不需要觉得心疼钱吧~(ಡωಡ)</p><p>其次，第一次感到自己真正参与到一个产品的开发，而不是对着设计师给的设计图以及需求说明、只是负责实现的程序猿了，第一次会全方位站在不同的使用者的角度来考虑自己的实现是否合理，有时候也会和产品或者技术老总讨论下需求，然后遇到觉得自己的意见更合理的时候也会和产品争论一波（虽然大部分时候都被产品说服了(ಡωಡ)。回想这些经历，有些挺让人发笑的，但是我觉得这才是一个产品发展的轨迹吧，而且我从中更能体会到自己的价值了，也能清楚认识到技术真的不是全部。这也算是成长了吧。</p><p>虽然才短短一个多月，但是技术上也收获了不少，比如接触了热更新，接触了收银机开发，第一次自己发布应用到应用市场上，然后也开始学RN了（前端小萌新一枚）。还有就是养成写笔记的习惯了，之后应该会把自己写的笔记修改下整理成博客，一直听『输出倒逼输入』耳朵都快听出茧了（记得最早是从 Scalers 老师那听到这句话的吧），但是从来没有长期实践过，希望这次能坚持下来吧。</p><p>最后，虽然2018已经过去一半多，但还是要告诫自己，下半年还有很多事要做，千万不能松懈，要昂扬斗志哇。先给自己定下些目标吧，虽然不一定全都能在年底前完成，但至少可以指导自己如何去做。</p><p>技术方面：</p><ol><li>继续学习 RN，看完文档，做到能够独立开发。</li><li>继续进阶安卓，有针对性地看文档，学习完《Android 开发艺术探索》和《Android 群英传》。</li><li>学习 Kotlin，做到入门，看得懂、写的了 Kotlin 代码，通过官方文档结合《Kotlin 实战》学习。</li><li>每天整理自己的学习笔记，每周写总结与博客。</li></ol><p>生活方面：</p><ol><li>保持自律，早睡早起（晚11早7）</li><li>保持早上冥想与写当日计划的习惯，每天打扫房间卫生</li><li>养成运动的习惯，做腹肌撕裂者，9月份开始恢复夜跑</li><li>养成阅读的习惯，睡前看书30分钟</li><li>坚持流利说打卡</li><li>少刷手机，少上 <del>Pornhub</del></li></ol><hr><p>写完这篇感觉压力瞬间大了不少，写成文字发到博客就会觉得好像有人在督促自己。希望年底不会打自己脸。</p><p>We are still moving forward.</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reviews </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@android, ?attr/ 和 ?android 的区别</title>
      <link href="/ways-of-reference-resources/"/>
      <url>/ways-of-reference-resources/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：安卓开发中我们时常会需要引用一些特殊的资源，比如设置一些可点击组件的波纹效果时，我们会用到：android:foreground=”?attr/selectableItemBackground”，但是这些引用方式之间有哪些区别呢？</p></blockquote><h3 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h3><p>首先来复习一下安卓中获取资源的几种方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">@[<span class="hljs-tag">&lt;<span class="hljs-name">package_name</span>&gt;</span>:]<span class="hljs-tag">&lt;<span class="hljs-name">resource_type</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">resource_name</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种方式是最为常见的，直接获取对应的包下的资源，一般在相同的包下，可以省略包名，比如为 TextView 设置文字时，就可以通过这样的方式来获取我们应用内定义的 string 资源：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:text=&quot;@string/hello&quot;<br></code></pre></td></tr></table></figure><p>另一种获取资源的方式是通过引用 <code>style</code> 属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:textColor=&quot;?colorAccent&quot;<br></code></pre></td></tr></table></figure><p>通过这种方式，我们可以获取到当前应用主题下的 <code>style</code> 属性值，这些属性值一般可以在属性文件夹 <code>values</code> 下找到。这里由于当前使用的是 <code>Theme.AppCompat</code> 下的主题，这是 <code>com.android.support:appcompat-v7</code> 下的 Theme，所以 <code>colorAccent</code> 会指向该库下的 <code>values</code> 文件：</p><span id="more"></span><p><img src="https://i.loli.net/2019/07/22/5d35c0c14c67680730.png" alt="appcompat-v7 包下的 colorAccent 属性"></p><p>关于资源引用的方式，具体请参考官方文档：<a href="https://developer.android.com/guide/topics/resources/providing-resources#Accessing">Accessing your app resources</a></p><h4 id="01-android-引用安卓内建的系统资源"><a href="#01-android-引用安卓内建的系统资源" class="headerlink" title="01 @android: 引用安卓内建的系统资源"></a>01 @android: 引用安卓内建的系统资源</h4><p>除了引用自己应用中的资源外，我们还可以通过指定引用时的包名为 <code>android</code> 来获取安卓平台下的一些系统资源，举个例子：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">android:</span>background=“<span class="hljs-variable">@android</span><span class="hljs-symbol">:drawable/ic_menu_delete</span>”<br></code></pre></td></tr></table></figure><p>我们知道当新建一个项目的时候，必须在 gradle 中设置 <code>compileSdkVersion</code> 来指定编译我们应用的 SDK 版本，这也决定了我们能调用哪个 level 的 API，同时也表明了哪个 level 的系统资源可供我们使用，比如如果指定的 <code>compileSdkVersion</code> 是 27，那么我们调用的就是 Android 8.1 下的系统资源。</p><p><img src="https://i.loli.net/2019/07/22/5d35c0c13fabc45934.png" alt="@android:drawable/ic_menu_delete"></p><h4 id="02-attr-引用应用内的属性资源"><a href="#02-attr-引用应用内的属性资源" class="headerlink" title="02 ?attr/: 引用应用内的属性资源"></a>02 ?attr/: 引用应用内的属性资源</h4><p>通过这种方式可以让我们间接地使用应用内的某些资源。我们知道当我们自定义View的时候，一般会需要自定义一些属性资源，通常我们会在 <code>values/</code> 文件夹下建一个 <code>attrs</code> 文件，在这里保存一些我们自己的 style 属性，其实这些属性就可以通过 <code>?attr/</code> 这种方式来引用了。比如我在 <code>styles</code> 里定义了一个属性：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;attr <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;colorReallyGreen&quot;</span> <span class="hljs-attribute">format</span>=<span class="hljs-string">&quot;color&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>定义完之后，我就可以直接在 <code>layout</code> 中通过引用的方式去使用这个属性了：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">android:background=<span class="hljs-string">&quot;?attr/colorReallyGreen&quot;</span><br></code></pre></td></tr></table></figure><p>当然，要想让该属性起作用还需要在 Theme 下指定值：</p><p><img src="https://i.loli.net/2019/07/22/5d35c0c12307b23422.png" alt="在当前 Theme 下为自定义属性赋值"></p><p>另外，由于在 <code>layout</code> 中，可以自动识别出当前所需的是属性资源，所以可以省略 <code>attr/</code> 而直接使用 <code>?colorReallyGreen</code> 就可以了。</p><h4 id="03-android-引用系统自带的属性资源"><a href="#03-android-引用系统自带的属性资源" class="headerlink" title="03 ?android: 引用系统自带的属性资源"></a>03 ?android: 引用系统自带的属性资源</h4><p>了解了前两种资源引用的方式后，<code>?android</code> 这种引用资源的方式也就不难理解了。与 <code>?attr/</code> 类似，通过这种方式可以直接访问到安卓内建的属性资源，只不过是省略了 <code>attr/</code> 而已。比如给 TextView 引用一个系统内的 style <code>buttonStyleSmall</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;?android:buttonStyleSmall&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;You Are Beautiful&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>然后 TextView 就变成了这样：</p><p><img src="https://i.loli.net/2019/07/22/5d35c0c0b99b369534.png" alt="引用了安卓内建属性作为 style 的 TextView"></p><p>当然如果你尝试去掉 <code>android</code> 包名之后，发现该属性还是可以起作用，说明应用内也是可以引用这个资源的。那么这是不是意味着绝大部分属性资源都不需要加 <code>android</code> 包名呢？其实我觉得是这样的，因为加了包名之后其实限制反而会更多，比如有些内建属性资源是针对某个 API level 以上的 Android 平台才可以使用的，当然这也与你当前使用的 Theme 有关。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>总结下，获取资源有两种方式，一种是通过直接引用（使用 <code>@</code>），一种是通过 style 属性（使用 <code>?</code>，除了自定义属性外，引用的资源类型和当前使用的主题有关）。另外，系统中内置了不少资源，学会合理利用它们可以帮助我们节约不少时间，建议大家花点精力自己探索下。</p><hr><h6 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h6><ol><li><a href="https://stackoverflow.com/questions/36642430/whats-the-difference-between-androidattr-and-attr-in-an-android-layout">What‘s the difference between “?android:attr/” and “?attr/” in an android layout xml file?</a></li><li><a href="http://grishma102.blogspot.com/2015/02/difference-between-attr-and-androidattr.html">Difference between “?attr/” and “?android:attr/” in android</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tinker 热更新笔记</title>
      <link href="/tinker-hot-update/"/>
      <url>/tinker-hot-update/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35c0c12b70b29836.png" alt="Tinker is a hot-fix solution library for Android"></p><blockquote><p>前言：最近接手一个新项目，用到了 tinker 热更新，记录一下使用心得。</p></blockquote><h4 id="00-Tinker-热更新过程"><a href="#00-Tinker-热更新过程" class="headerlink" title="00 Tinker 热更新过程"></a>00 Tinker 热更新过程</h4><p>关于热更新原理，可以参考这篇文章：<a href="https://juejin.im/entry/59afb8fc518825243b2a9f7f">Android热更新技术的研究与实现</a>。我简单说下 tinker 热更新的过程吧，首先当我们的应用集成了 tinker 后，每次应用冷启动都会请求补丁策略，tinker 首先会上报当前版本的 TINKER_ID：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">07</span>-<span class="hljs-number">04</span> <span class="hljs-number">09</span>:<span class="hljs-number">56</span>:<span class="hljs-number">13</span>.<span class="hljs-number">393</span> <span class="hljs-number">2211</span>-<span class="hljs-number">2211</span>/com.huge.logistics I/CrashReport: TINKER_ID:base-<span class="hljs-number">2</span>.<span class="hljs-number">20</span><br>    <span class="hljs-attribute">NEW_TINKER_ID</span>:<br></code></pre></td></tr></table></figure><p>这样我们后台就能将这个唯一的 TINKER_ID 对应到一个版本，所以当我们上传了补丁包并选择下发后，如果匹配到目标版本，后台就会下发补丁策略，我们的 app 检测到有补丁就会去下载补丁并合成：</p><span id="more"></span><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">07-04 09:56:16.884 2211-2243/com.huge.logistics I/CrashReport: onUpgradeReceived: title:</span> <br>    <span class="hljs-attr">newFeature:</span> <span class="hljs-string">测试热更新</span><br>    <span class="hljs-attr">publishTime:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">publishType:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">appBasicInfo:</span> &#123;<br>    <span class="hljs-attr">appId:</span> <span class="hljs-string">42477c8883</span><br>    <span class="hljs-attr">platformId:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">versionCode:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">versionName:</span> <span class="hljs-literal">null</span><br>    <span class="hljs-attr">buildNo:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">iconUrl:</span> <span class="hljs-literal">null</span><br>    <span class="hljs-attr">apkId:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">channelId:</span> <span class="hljs-literal">null</span><br>    <span class="hljs-attr">md5:</span> <span class="hljs-string">c234ccd77afba4d76b7148c305d87d426158df98</span><br>    <span class="hljs-attr">sdkVer:</span> <br>    <span class="hljs-attr">bundleId:</span> <span class="hljs-literal">null</span><br>    &#125;<br>    <span class="hljs-attr">apkBaseInfo:</span> &#123;<br>    <span class="hljs-attr">apkMd5:</span> <span class="hljs-string">c234ccd77afba4d76b7148c305d87d426158df98</span><br>    <span class="hljs-attr">apkUrl:</span> <span class="hljs-string">https://s.beta.gtimg.com/rdmimg/hot_patch/42477c8883/1d240f8e-2d20-4c58-a156-d3e919342498.zip</span><br>    <span class="hljs-attr">manifestMd5:</span> <br>    <span class="hljs-attr">fileSize:</span> <span class="hljs-number">175772</span><br>    <span class="hljs-attr">signatureMd5:</span> <br>    &#125;<br>    <span class="hljs-attr">updateStrategy:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">popTimes:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">popInterval:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">diffApkInfo:</span> &#123;<br>    <span class="hljs-literal">null</span>&#125;<br>    <span class="hljs-attr">netType:</span> <span class="hljs-literal">null</span><br>    <span class="hljs-attr">reserved:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> &#123;<br>    <span class="hljs-string">(</span><br>    <span class="hljs-string">H2</span><br>    <span class="hljs-number">3</span><br>    <span class="hljs-string">)</span><br>    &#125;<br>    <span class="hljs-attr">strategyId:</span> <span class="hljs-string">ceb6de11-d954-4470-a967-2c008f0a2f53</span><br>    <span class="hljs-attr">status:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">updateTime:</span> <span class="hljs-number">1530668503000</span><br>    <span class="hljs-attr">updateType:</span> <span class="hljs-number">3</span><br><span class="hljs-attr">07-04 09:56:17.977 2211-2211/com.huge.logistics D/Tinker.TinkerManager:</span> <span class="hljs-string">onDownloadSuccess.</span><br><span class="hljs-attr">07-04 09:56:17.978 2211-2211/com.huge.logistics D/Tinker.TinkerManager:</span> <span class="hljs-string">check</span> <span class="hljs-string">if</span> <span class="hljs-string">has</span> <span class="hljs-string">new</span> <span class="hljs-string">patch.</span><br><span class="hljs-attr">07-04 09:56:18.127 2211-2211/com.huge.logistics D/Tinker.TinkerManager:</span> <span class="hljs-string">has</span> <span class="hljs-string">new</span> <span class="hljs-string">patch.</span><br><span class="hljs-attr">07-04 09:56:18.133 2211-2211/com.huge.logistics D/Tinker.TinkerManager:</span> <span class="hljs-string">starting</span> <span class="hljs-string">patch.</span><br></code></pre></td></tr></table></figure><p>合成成功后需要等用户重启应用后，更新才会生效：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">07</span>-<span class="hljs-number">04</span> <span class="hljs-number">09</span>:<span class="hljs-number">56</span>:<span class="hljs-number">24</span>.<span class="hljs-number">662</span> <span class="hljs-number">2211</span>-<span class="hljs-number">2414</span>/com.huge.logistics W/Tinker.DefaultTinkerResultService: deleteRawPatchFile rawFile path: /data/user/<span class="hljs-number">0</span>/com.huge.logistics/app_tmpPatch/tmpPatch.apk<br><span class="hljs-attribute">07</span>-<span class="hljs-number">04</span> <span class="hljs-number">09</span>:<span class="hljs-number">56</span>:<span class="hljs-number">24</span>.<span class="hljs-number">662</span> <span class="hljs-number">2211</span>-<span class="hljs-number">2414</span>/com.huge.logistics I/Tinker.PatchFileUtil: safeDeleteFile, try to delete path: /data/user/<span class="hljs-number">0</span>/com.huge.logistics/app_tmpPatch/tmpPatch.apk<br><span class="hljs-attribute">07</span>-<span class="hljs-number">04</span> <span class="hljs-number">09</span>:<span class="hljs-number">56</span>:<span class="hljs-number">24</span>.<span class="hljs-number">662</span> <span class="hljs-number">2211</span>-<span class="hljs-number">2414</span>/com.huge.logistics I/Tinker.TinkerResultService: tinker wait screen to restart process<br><span class="hljs-attribute">07</span>-<span class="hljs-number">04</span> <span class="hljs-number">09</span>:<span class="hljs-number">56</span>:<span class="hljs-number">24</span>.<span class="hljs-number">662</span> <span class="hljs-number">2211</span>-<span class="hljs-number">2211</span>/com.huge.logistics I/CrashReport: Tinker patch success, result: <br>    <span class="hljs-attribute">PatchResult</span>: <br>    <span class="hljs-attribute">isSuccess</span>:true<br>   <span class="hljs-attribute">rawPatchFilePath</span>:/data/user/<span class="hljs-number">0</span>/com.huge.logistics/app_tmpPatch/tmpPatch.apk<br>    <span class="hljs-attribute">costTime</span>:<span class="hljs-number">6267</span><br>    <span class="hljs-attribute">patchVersion</span>:<span class="hljs-number">4</span>a<span class="hljs-number">0</span>c<span class="hljs-number">61</span>fdc<span class="hljs-number">87</span>d<span class="hljs-number">6</span>a<span class="hljs-number">04</span>b<span class="hljs-number">9</span>fa<span class="hljs-number">74844819</span>b<span class="hljs-number">4</span>c<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到合成成功后日志中有这么一行“tinker wait screen to restart process”，也就是需要重启应用所在的进程（重新加载dex）。当然如果你开启了更新弹窗，也可以让用户手动点击重启应用：</p><img src="https://i.loli.net/2019/07/22/5d35c254aef3e41962.png" width="50%"/><p>应用重启之后的日志：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">07</span>-<span class="hljs-number">04</span> <span class="hljs-number">10</span>:<span class="hljs-number">10</span>:<span class="hljs-number">42</span>.<span class="hljs-number">859</span> <span class="hljs-number">8022</span>-<span class="hljs-number">8022</span>/com.huge.logistics I/Tinker.TinkerLoader: tryLoadPatchFiles: load end, ok!<br><span class="hljs-attribute">07</span>-<span class="hljs-number">04</span> <span class="hljs-number">10</span>:<span class="hljs-number">10</span>:<span class="hljs-number">42</span>.<span class="hljs-number">867</span> <span class="hljs-number">8022</span>-<span class="hljs-number">8022</span>/com.huge.logistics I/Tinker.TinkerLoadResult: oh yeah, tinker load <span class="hljs-literal">all</span> success<br><span class="hljs-attribute">07</span>-<span class="hljs-number">04</span> <span class="hljs-number">10</span>:<span class="hljs-number">10</span>:<span class="hljs-number">42</span>.<span class="hljs-number">867</span> <span class="hljs-number">8022</span>-<span class="hljs-number">8022</span>/com.huge.logistics I/Tinker.DefaultLoadReporter: patch loadReporter onLoadPatchVersionChanged: patch version change from  to <span class="hljs-number">4</span>a<span class="hljs-number">0</span>c<span class="hljs-number">61</span>fdc<span class="hljs-number">87</span>d<span class="hljs-number">6</span>a<span class="hljs-number">04</span>b<span class="hljs-number">9</span>fa<span class="hljs-number">74844819</span>b<span class="hljs-number">4</span>c<span class="hljs-number">0</span><br>    <span class="hljs-attribute">onLoadPatchVersionChanged</span>, try kill <span class="hljs-literal">all</span> other process<br><span class="hljs-attribute">07</span>-<span class="hljs-number">04</span> <span class="hljs-number">10</span>:<span class="hljs-number">10</span>:<span class="hljs-number">42</span>.<span class="hljs-number">871</span> <span class="hljs-number">8022</span>-<span class="hljs-number">8022</span>/com.huge.logistics I/Tinker.DefaultLoadReporter: patch loadReporter onLoadResult: patch load result, path:/data/user/<span class="hljs-number">0</span>/com.huge.logistics/tinker, code: <span class="hljs-number">0</span>, cost: <span class="hljs-number">176</span>ms<br></code></pre></td></tr></table></figure><p>可以看到更新后的 tinker-id：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">07<span class="hljs-string">-04</span> 10:10:43.106 8022<span class="hljs-string">-8022</span>/com.huge.logistics I/CrashReport: [patch] inject success<br>07<span class="hljs-string">-04</span> 10:10:43.124 8022<span class="hljs-string">-8022</span>/com.huge.logistics I/CrashReport: save patch success event success!<br>07<span class="hljs-string">-04</span> 10:10:43.128 8022<span class="hljs-string">-8022</span>/com.huge.logistics I/CrashReport: TINKER_ID:base<span class="hljs-string">-2</span>.20<br>    NEW_TINKER_ID:base<span class="hljs-string">-2</span>.20-hotfix-test<br></code></pre></td></tr></table></figure><p>至此，一次热更新结束。</p><h4 id="01-集成与初始化"><a href="#01-集成与初始化" class="headerlink" title="01 集成与初始化"></a>01 集成与初始化</h4><p><a href="https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix/">官方文档</a>写的很详细，直接按照文档写的步骤一步步执行就行了。tinker-support 插件各参数的详细配置介绍看<a href="https://bugly.qq.com/docs/utility-tools/plugin-gradle-hotfix/">这里</a>，另外强烈推荐看一遍<a href="https://bugly.qq.com/docs/user-guide/api-hotfix/">热更新API</a>和<a href="https://bugly.qq.com/docs/user-guide/faq-android-hotfix/">热更新常见问题</a>。</p><h4 id="02-如何使用"><a href="#02-如何使用" class="headerlink" title="02 如何使用"></a>02 如何使用</h4><p>同样官方文档上有很好的<a href="https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix-demo/">范例</a>可供参考。</p><h4 id="03-一些细节"><a href="#03-一些细节" class="headerlink" title="03 一些细节"></a>03 一些细节</h4><p>之前想到一个问题，如果我们发布了一个基准版本 base-1.0 后，然后一部人安装了这个基准版本，然后我们又再次做了一些修改，发布了新的版本 base-1.1，这个时候另一部分人安装了这个新的版本，那么当我们发布热更新，这部分安装了 base-1.1 的人还能收到热更新吗？自己做了一个实验，结果证明是可以的，只要保证你发布的 base-1.1 的 tinkerId 和 base-1.0 是一样的（同时基准包目录也还是 base-1.0 的），这样就可以保证两个版本都可以收到热更新。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 热更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Think in Java 回顾之泛型</title>
      <link href="/think-in-java-generics/"/>
      <url>/think-in-java-generics/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35c0c10f71571932.jpg" alt="想去海边玩沙子"></p><h3 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h3><p>Java SE 5 开始引入了泛型的概念，泛型即<strong>参数化类型</strong>，利用泛型我们可以编写出更通用的代码（先不指定类型，使用时再指定类型）。泛型出现的最大的目的之一就是用来指定容器要持有的对象的类型，而且这种指定是由编译器来保证其正确性的。来看个例子：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Holder</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Holder</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Holder</span><span class="hljs-params">(T value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 可以不指定类型，类型参数 T 就是 Object，因此会被初始化为 null</span><br>        Holder holder = <span class="hljs-keyword">new</span> Holder();<br>        System.out.println(holder.get());<br><br>        Holder&lt;String&gt; strHolder = <span class="hljs-keyword">new</span> Holder&lt;&gt;(<span class="hljs-string">&quot;Aaron&quot;</span>);<br>        System.out.println(strHolder.get());<br><br>        strHolder.set(<span class="hljs-number">1</span>); <span class="hljs-comment">// Error</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码中定义了一个 <code>Holder</code> 类，使用类型参数 <code>T</code> 作为持有的对象的类型。<code>T</code> 可以表示任何对象，所以<code>Holder</code> 类也就具有了持有任何对象的能力。当我们使用它的时候，可以使用 <code>&lt;&gt;</code> 来确定 <code>Holder</code> 所持有的对象的类型，这样我们就可以保证持有对象的类型的正确性。</p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>如果普通方法中定义了泛型参数，那么这就是一个泛型方法。泛型方法和与该类是否是泛型类无关，但是如果静态方法想要使用泛型参数，那么它就必须定义为泛型方法，因为静态方法无法访问泛型类中的泛型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoGenericMethod</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> E e;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DemoGenericMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        e = (E) <span class="hljs-keyword">new</span> Object();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DemoGenericMethod</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.e = e;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据泛型类的类型变量返回相应类型的 List</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;E&gt; <span class="hljs-title">getAsList</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        System.out.println(e.getClass().getName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 普通泛型方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">printClassName</span><span class="hljs-params">(T t)</span> </span>&#123;<br>        System.out.println(t.getClass().getName());<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printSelfAndThis</span><span class="hljs-params">(T t)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;this = &quot;</span> + e.getClass().getName()<br>                + <span class="hljs-string">&quot;, that = &quot;</span> + t.getClass().getName());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 静态方法一旦使用了泛型参数就必须定义为泛型方法。</span><br><span class="hljs-comment">     * 因为静态方法是独立于类之外的，无法访问类中的泛型参数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">(T t)</span> </span>&#123;<br>        System.out.println(t.getClass().getName());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 可变参数列表与泛型方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">makeList</span><span class="hljs-params">(T... args)</span> </span>&#123;<br>        List&lt;T&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Collections.addAll(result, args);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="擦除"><a href="#擦除" class="headerlink" title="擦除"></a>擦除</h3><p>在使用泛型时，你是无法通过代码获得任何有关泛型参数类型的信息的，这其实是因为擦除的存在。在泛型类或泛型方法中，关于泛型参数的任何具体的类型信息都被擦除了(wiped)，所以我们只能把类型参数当作一个 <code>Object</code> 使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ArrayList&lt;String&gt; 被擦除为 ArrayList</span><br>Class c1 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;().getClass();<br><span class="hljs-comment">// ArrayList&lt;Integer&gt; 被擦除为 ArrayList</span><br>Class c2 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;().getClass();<br><span class="hljs-comment">// 这两个 Class 对象都被擦除为 ArrayList了，所以是相等的</span><br>System.out.println(<span class="hljs-string">&quot;c1 == c2? &quot;</span> + (c1 == c2)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>擦除意味着无法使用 <code>instanceof</code>，<code>new</code> 或者转型等需要在运行时才能知道确切类型信息的操作。</p><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><p>边界允许我们在参数类型上设置限制条件，这样就能部分抵消擦除带来的负面影响。来看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HasColor</span> </span>&#123;<br>    <span class="hljs-function">Color <span class="hljs-title">getColor</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用 extend 关键字指定类型参数的边界</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Colored</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HasColor</span>&gt; </span>&#123;<br>    T element;<br><br>    Colored(T element) &#123;<br>        <span class="hljs-keyword">this</span>.element = element;<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">getElement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br><br>    <span class="hljs-function">Color <span class="hljs-title">color</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 因为设置了边界，所以调用是安全的</span><br>        <span class="hljs-keyword">return</span> element.getColor();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们用 <code>extend</code> 关键字指定泛型边界。当参数类型继承多个边界时，定义的规则与类的继承相同，类在前，接口在后，类与多个接口的连接符用 <code>&amp;</code>，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solid</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Dimension</span> &amp; <span class="hljs-title">HasColor</span> &amp; <span class="hljs-title">Weight</span>&gt; </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符可以保证<strong>类型安全</strong>，允许我们更加自由地使用泛型类，使得泛型支持协变和逆变。</p><ol><li>首先是通配符 + <code>extends</code> 关键字，用于确定泛型类的上边界。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该 List 的泛型类型是 ? extends List，表示&quot;任何从 Number 类继承的类型&quot;</span><br>List&lt;? extends Number&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>但是此时往 numbers 中添加任何元素都是不被允许的，因为只声明了上边界，编译器是无法确定捕获 (capture) 的类型到底是什么，所以无论添加任何对象都是类型不安全的。</p><ol start="2"><li>通配符 + <code>super</code> 关键字，即超类型通配符，用于确定泛型类的下边界。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 表示边界范围是 &quot;Number 类的任何父类&quot;，也就是说至少 Number 类及其子类是可以安全添加的</span><br>List&lt;? <span class="hljs-keyword">super</span> Number&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br></code></pre></td></tr></table></figure><p>使用超类型通配符后，由于下边界确定，所以当我们向 list 中添加 Number 类及其子类的时候，才可能保证是类型安全的。不过，如果添加的是 Number 类的超类，也是不被允许的，因为编译器无法确定捕获的超类型到底是哪个超类。</p><p>可能文字比较难以理解，来看几个例子，更为直观：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    <span class="hljs-comment">// Incompatible types，泛型默认不支持协变（返回值的类型是接收处的子类）</span><br>    <span class="hljs-comment">// List&lt;Number&gt; numberList = new ArrayList&lt;Integer&gt;(); // Incompatible types</span><br><br>    System.out.println(<span class="hljs-string">&quot;----------确定泛型的上边界----------&quot;</span>);<br>    <span class="hljs-comment">// 用 extends 表示这个集合中的对象是“继承了 Number 类的子类”</span><br>    <span class="hljs-comment">// 这样就为集合确定了上边界(Number)，所以协变是安全的</span><br>    List&lt;? extends Number&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 但是这样的List是非常有局限性的，无法添加任何有意义的元素</span><br><span class="hljs-comment">    * 因为List的参数类型为 ? extends Number，也就是任何继承自 Number 类的对象</span><br><span class="hljs-comment">    * 编译器无法确定 List 所持有的类型，这样就无法保证类型安全性，所以不允许添加任何有意义的对象</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-comment">//numbers.add(1);</span><br>    <span class="hljs-comment">//numbers.add(new Object()); // 甚至连 Object 都无法添加</span><br>    <span class="hljs-comment">// 可以添加 null 进去，因为 null 可以表示任何对象，这也说明了此时添加某个对象是不安全的</span><br>    numbers.add(<span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-comment">// 可以从中取出元素，因为至少可以确定这是一个 Number 类的对象</span><br>    Number number = numbers.get(<span class="hljs-number">0</span>);<br>    System.out.println(number);<br><br>    <span class="hljs-comment">// 最主要的用途是在泛型方法中使用，此时由于上边界确定，所以可以安全调用</span><br>    List&lt;Apple&gt; appleList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    appleList.add(<span class="hljs-keyword">new</span> Apple(<span class="hljs-string">&quot;Apple&quot;</span>));<br>    showList(appleList); <span class="hljs-comment">// 只能对集合进行读取，而无法写入</span><br><br><br>    System.out.println(<span class="hljs-string">&quot;----------确定泛型的下边界----------&quot;</span>);<br>    <span class="hljs-comment">// 用 super 关键字表示这个集合中对对象是 &quot;Number 类的父类&quot;</span><br>    <span class="hljs-comment">// 也就是下边界确定(Number)，所以可以添加 Number 及其子类</span><br>    List&lt;? <span class="hljs-keyword">super</span> Number&gt; boundedNums = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    boundedNums.add(<span class="hljs-number">1</span>);<br>    boundedNums.add(<span class="hljs-number">1.0f</span>);<br>    boundedNums.add(<span class="hljs-number">1.33d</span>);<br>    <span class="hljs-comment">// 无法添加父类对象，因为无法确定捕获到的是哪个父类</span><br>    <span class="hljs-comment">// boundedNums.add(new Object());</span><br>    System.out.println(boundedNums);<br><br>    <span class="hljs-comment">// 此时列表中的元素类型是捕获类型，因此只能被读取为 Object</span><br>    <span class="hljs-comment">// Number n1 = boundedNums.get(0);</span><br>    Object num1 = boundedNums.get(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 同时也支持逆变</span><br>    Integer number1 = (Integer) boundedNums.get(<span class="hljs-number">0</span>);<br><br><br>    System.out.println(<span class="hljs-string">&quot;----------无界通配符----------&quot;</span>);<br>    List&lt;?&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <span class="hljs-comment">// 捕获的参数类型是 capture&lt;?&gt;，无法应用到 String</span><br>    <span class="hljs-comment">//list.add(&quot;1&quot;);</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showList</span><span class="hljs-params">(Collection&lt;? extends Fruit&gt; fruits)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (Fruit fruit : fruits) &#123;<br>        fruit.sayName();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下，上界通配符使得泛型类只能被读取而无法修改，因此这种泛型类型也被称为生产者；而下界通配符使得泛型类只能被修改而无法被读取，因此这种泛型类型就是消费者。</p><h4 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h4><p>上面的例子中有关于无界通配符的使用，第一次看到会觉得似乎难以理解，其实它表示的意思是”我可以持有任何类型“，它是更为泛化的参数化类型，但也因此无法像有界的泛型参数那样做更多的事。它最主要的用途就是捕获转换，即捕获未指定的通配符类型，然后将之转换为确切的某种类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoCaptureConversion</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">captureWithType</span><span class="hljs-params">(Holder&lt;T&gt; holder)</span> </span>&#123;<br>        System.out.println(holder.get().getClass().getSimpleName());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 未指定的通配符类型会被捕获并转换为类型参数来使用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">captureWithWildcard</span><span class="hljs-params">(Holder&lt;?&gt; holder)</span> </span>&#123;<br>        <span class="hljs-comment">// 通配符可以捕获到类型参数</span><br>        captureWithType(holder);<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Holder raw = <span class="hljs-keyword">new</span> Holder(<span class="hljs-number">1</span>);<br>        captureWithType(raw);<br>        captureWithWildcard(raw);<br>      <br>        <span class="hljs-comment">// 同样发生了类型参数的捕获</span><br>        Holder&lt;?&gt; wildcarded = <span class="hljs-keyword">new</span> Holder&lt;&gt;(<span class="hljs-number">1.2f</span>);<br>        captureWithType(wildcarded);<br>        captureWithWildcard(wildcarded);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码中，第一个方法中的参数是确切的已知的，而第二个方法中使用了无界通配符，参数是未知的。在调用第二个方法的时候，可以捕获到类型参数并进行调用。</p><h3 id="泛型存在的问题"><a href="#泛型存在的问题" class="headerlink" title="泛型存在的问题"></a>泛型存在的问题</h3><ol><li>基本类型无法作为类型参数，必须使用其包装类。</li><li>不能同时实现同一个泛型接口的两种变体，原因是接口的参数类型会被擦除，也就相当于同一个接口被实现了两次。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Pay</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employ</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Pay</span>&lt;<span class="hljs-title">Emp</span>&gt; </span>&#123;&#125;<br><br><span class="hljs-comment">// cannot be inherited with different type arguments</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hour</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employ</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Pay</span>&lt;<span class="hljs-title">Hour</span>&gt;</span>&#123;&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>对泛型转型有时会产生”unchecked cast“的警告，因为编译期无法确定转型是否安全。</li><li>无法使用泛型参数作为区分两个方法，也就是无法用类型参数作为重载的依据。</li><li>基类劫持接口，最常见的例子就是实现 <code>Comparable</code> 接口。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Pet 类把自己作为参数类型传到 Comparable 接口中</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Pet</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pet</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Pet pet)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Integer.compare(<span class="hljs-keyword">this</span>.age, pet.age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在 Think in Java 中，除了以上问题外，还详细讲解了自限定的类型、动态类型安全、泛型在异常中的使用、混型、潜在类型机制的缺失及补偿、将函数对象用作策略等，想要深入了解泛型的，不妨仔细阅读下这部分内容，如果有新的感受记得留言交流哦~</p><hr><p>参考资料：</p><ul><li>Think in Java 第4版</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 RTTI</title>
      <link href="/talk-about-rtti/"/>
      <url>/talk-about-rtti/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35c0c103a5814619.jpg" alt="Forest in West Virginia"></p><h3 id="什么是-RTTI？"><a href="#什么是-RTTI？" class="headerlink" title="什么是 RTTI？"></a>什么是 RTTI？</h3><p>RTTI 即 Runtime Type Information，顾名思义，也就是在运行时，识别对象和类的信息。RTTI 有两种，一种是“传统的” RTTI，它假定我们在编译时就已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。</p><p>最简单的一个例子，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Shape&gt; shapeList = Arrays.asList(<span class="hljs-keyword">new</span> Circle(), <span class="hljs-keyword">new</span> Square(), <span class="hljs-keyword">new</span> Triangle());<br><span class="hljs-keyword">for</span>(Shape shape : shapeList) &#123;<br>    shape.draw();<br>&#125;<br></code></pre></td></tr></table></figure><p>当从 shapeList 中取出元素时（其实元素是用数组保存的，而数组会把所有元素都当作 Object 来持有），会自动将元素转型回对应的对象。</p><span id="more"></span><p>也就是说在保存对象和取出对象后，会发生以下这两个过程：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">(Object) shape <span class="hljs-regexp">//</span> 向上转型<br>(Shape) object <span class="hljs-regexp">//</span> 向下转型<br></code></pre></td></tr></table></figure><p>这其实就是就是 RTTI 最基本的使用形式。在 Java 中，所有的类型转换都是在运行时进行类型正确性检查的。</p><h3 id="Class-对象：类的信息"><a href="#Class-对象：类的信息" class="headerlink" title="Class 对象：类的信息"></a>Class 对象：类的信息</h3><p>Class 对象包含了与类有关的信息，事实上 Java 中是用 Class 对象来创建这个类中的所有的对象的。每当编译完成，就会生成一个 Class 对象，被保存在 .class 文件中。JVM 使用 ClassLoader 来加载对象，所有的类都是在对其第一次使用（静态成员被引用，静态常量除外）或者用 new 关键字创建对象后，动态加载到 JVM 中的。所谓的动态加载也就是在被使用到时才去加载。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;package.name.CanonicalName&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>这个方法是获取 Class 对象引用的一种方法，调用 Class.forName() 之后该类会被初始化。Class 对象中还有一个 newInstance() 的方法，可以用来创建对象新实例。除此之外，Class 对象中还有很多实用的方法，用来获取类的信息，比如获取类的接口、方法、成员变量等等。</p><h4 id="类字面常量"><a href="#类字面常量" class="headerlink" title="类字面常量"></a>类字面常量</h4><p>我们还可以使用 .class 的形式来引用 Class 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class intClass = <span class="hljs-keyword">int</span>.class;<br></code></pre></td></tr></table></figure><h4 id="泛化的-Class-引用"><a href="#泛化的-Class-引用" class="headerlink" title="泛化的 Class 引用"></a>泛化的 Class 引用</h4><p>从 Java SE 5 开始，我们可以利用泛型对 Class 对象进行类型限定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Integer&gt; intClass = <span class="hljs-keyword">int</span>.class; <span class="hljs-comment">// legal</span><br>intClass = <span class="hljs-keyword">double</span>.class; <span class="hljs-comment">// illegal</span><br></code></pre></td></tr></table></figure><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>RTTI 除了可以确保类型转换的正确性和通过 Class 对象获取运行时的类型信息外，还有第三种形式，那就是 instanceof，我们可以用这个关键字来确定某个对象是不是某个类的实例，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java">Animal[] animals = &#123;<span class="hljs-keyword">new</span> Dog(), <span class="hljs-keyword">new</span> Fish()&#125;;<br><span class="hljs-keyword">for</span> (Animal animal : animals) &#123;<br>    <span class="hljs-comment">// 向下转型前，先使用 instanceof 来判断类型</span><br>    <span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> Fish) &#123;<br>        Fish fish = (Fish) animal;<br>        fish.swim();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射：无所不能"><a href="#反射：无所不能" class="headerlink" title="反射：无所不能"></a>反射：无所不能</h3><p>RTTI 会在编译期打开和检查 .class 文件并利用这些信息做一些有用的事，而反射会在运行时打开和检查 .class 文件，这是 RTTI 和反射之间的真正区别。Java 中通过 Class 类和 java.lang.reflect 类库对反射的概念进行了支持。一起来看下这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 在编译期，Class.forName() 的结果是不可知的，只能通过反射去获取运行时的信息</span><br>Class&lt;?&gt; klass = Class.forName(args[<span class="hljs-number">0</span>]);<br>    Method[] methods = klass.getMethods();<br>    <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>        System.out.println(method);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上 main() 方法中，通过读取命令行参数实例化 Class 对象，然后打印该对象中的方法。此时的 klass 对象完全是未知的，但是我们可以通过反射去获取其中的信息，创建对象或者调用方法。</p><p>反射是无孔不入的，无论是私有方法还是私有内部类的方法，哪怕是匿名类的方法，也无法逃脱反射的调用。对于私有域来说也一样，只有 final 域，才不会被修改。反射可以说是给我们的程序留了一道后门，但是总的来说，从反射给我们带来的优劣对比上看，利大于弊。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>代理是最常见的设计模式之一，它可以让我们的代码更加灵活，比如在进行操作之前做一些额外的工作。下面是一个简单代理的例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">interface Interface &#123;<br>    void <span class="hljs-keyword">do</span><span class="hljs-constructor">Something()</span>;<br><br>    void <span class="hljs-keyword">do</span><span class="hljs-constructor">SomethingElse(String <span class="hljs-params">args</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> RealObject implements Interface &#123;<br><br>    @Override<br>    public void <span class="hljs-keyword">do</span><span class="hljs-constructor">Something()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;doSomething&quot;</span>);<br>    &#125;<br><br>    @Override<br>    public void <span class="hljs-keyword">do</span><span class="hljs-constructor">SomethingElse(String <span class="hljs-params">args</span>)</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;doSomethingElse &quot;</span> + args);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> SimpleProxy implements Interface &#123;<br><br>    Interface mInterface;<br><br>    public <span class="hljs-constructor">SimpleProxy(Interface <span class="hljs-params">anInterface</span>)</span> &#123;<br>        mInterface = anInterface;<br>    &#125;<br><br>    @Override<br>    public void <span class="hljs-keyword">do</span><span class="hljs-constructor">Something()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;SimpleProxy doSomething&quot;</span>);<br>        mInterface.<span class="hljs-keyword">do</span><span class="hljs-constructor">Something()</span>;<br>    &#125;<br><br>    @Override<br>    public void <span class="hljs-keyword">do</span><span class="hljs-constructor">SomethingElse(String <span class="hljs-params">args</span>)</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;SimpleProxy doSomethingElse&quot;</span>);<br>        mInterface.<span class="hljs-keyword">do</span><span class="hljs-constructor">SomethingElse(<span class="hljs-params">args</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说，代理就是将实际对象的方法调用分离开来，从而允许我们对一些操作进行修改，或者添加额外的操作。而动态代理比代理的思想更进一步，它允许我们动态地创建代理并动态地处理对所代理方法的调用。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SimpleDynamicProxy &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> consumer(Interface interf) &#123;<br>        interf.doSomething();<br>        interf.doSomethingElse(&quot;args&quot;);<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;---------- no proxy ----------&quot;);<br>        RealObject <span class="hljs-type">real</span> = <span class="hljs-built_in">new</span> RealObject();<br>        consumer(<span class="hljs-type">real</span>);<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;---------- simple proxy ----------&quot;);<br>        consumer(<span class="hljs-built_in">new</span> SimpleProxy(<span class="hljs-type">real</span>));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;---------- dynamic proxy ----------&quot;);<br>        <br>        // 创建代理对象：设置 ClassLoader、接口 <span class="hljs-keyword">Class</span> 对象、InvocationHandler<br>        Interface proxy = (Interface) Proxy.newProxyInstance(<br>                Interface.<span class="hljs-keyword">class</span>.getClassLoader(),<br>                <span class="hljs-built_in">new</span> <span class="hljs-keyword">Class</span>[]&#123;Interface.<span class="hljs-keyword">class</span>&#125;, // 数组里的 <span class="hljs-keyword">Class</span> 对象必须是接口且不能重复<br>                <span class="hljs-built_in">new</span> DynamicProxyHandler(<span class="hljs-type">real</span>));<br>        consumer(proxy);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代理对象必须实现自己的 InvocationHandler，所有的调用都会被重定向到这个调用处理器上</span><br><span class="hljs-comment">     */</span><br>    static <span class="hljs-keyword">class</span> DynamicProxyHandler implements InvocationHandler &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 被代理的对象，调用的请求会转发到这个“实际”对象上</span><br><span class="hljs-comment">         */</span><br>        private <span class="hljs-keyword">Object</span> proxied;<br><br>        <span class="hljs-built_in">public</span> DynamicProxyHandler(<span class="hljs-keyword">Object</span> proxied) &#123;<br>            this.proxied = proxied;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 该方法接收三个参数，代理对象的实例、调用的方法的实例以及方法的参数。</span><br><span class="hljs-comment">         * 我们一般在这里确定调用该方法时所采取的措施。</span><br><span class="hljs-comment">         */</span><br>        @Override<br>        <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> invoke(<span class="hljs-keyword">Object</span> proxy, <span class="hljs-keyword">Method</span> <span class="hljs-keyword">method</span>, <span class="hljs-keyword">Object</span>[] args) throws Throwable &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Proxy: &quot; + proxy.getClass()<br>                    + &quot;, method: &quot; + <span class="hljs-keyword">method</span> + &quot;, args: &quot; + args);<br><br>            // 如果方法参数不为空则输出参数<br>            <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>                    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;args[&quot; + i + &quot;] = &quot; + args[i]);<br>                &#125;<br>            &#125;<br><br>            // 转发请求给被代理对象<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">method</span>.invoke(proxied, args);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用动态代理其实很简单，首先要定义一个自己的 <code>InvocationHandler</code>，然后再通过 <code>Proxy.newProxyInstance</code> 创建一个代理对象。</p><h4 id="使用动态代理的优势"><a href="#使用动态代理的优势" class="headerlink" title="使用动态代理的优势"></a>使用动态代理的优势</h4><p>动态代理的优点主要有两个：</p><ol><li>更强的灵活性。我们不用在设计实现的时候就指定某一个代理类来代理某一个被代理对象，而是可以把这种指定延迟到程序<strong>运行时</strong>由 JVM 来实现。</li><li>动态代理更为统一与简洁。</li></ol><p>第一点从上面的例子就能看出，我们必须事先就确定 <code>SimpleProxy</code> 作为 <code>Interface</code> 的代理，并且编写每种方法对应的代码，而动态代理允许我们利用反射机制生成任意类型的动态代理类。第二点也很明显，当使用动态代理的时候，我们只需要在一个地方进行修改，写的代码也变少了。</p><hr><p>参考资料：</p><ul><li>Think in Java（第4版）</li><li><a href="https://segmentfault.com/a/1190000007089902">Java 动态代理(Dynamic proxy) 小结</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy-pattern/">代理模式原理及实例讲解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在第二个本命年</title>
      <link href="/2017/"/>
      <url>/2017/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/22/5d35bda874b6e50927.jpg" alt="新春快乐，狗年大吉！"></p><p>转眼毕业半年多了，时间过的真是快啊。说好的坚持写作，最终还是败给了懒惰与<a href="https://www.ted.com/talks/tim_urban_inside_the_mind_of_a_master_procrastinator">拖延</a>。这半年多来，大多数写作都是发生在印象笔记中，而且基本上是一些小技巧、小经验以及日常琐碎的记录。相比较而言，长时间坚持写博客写文章真的很难得，这是一件需要<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712328&idx=1&sn=6b46bae8eda16149deb53a81ad8751ad&mpshare=1&scene=24&srcid=0213jkbYI1SVGlVSBlz7MJpY&pass_ticket=PUq7LhjQeFFjwr2mT4EynCDjJqHH73ZYpnnZRjVWxthUGpCf+6tFH3mIhHLVzEv3#rd">毅力和耐心</a>的事。</p><p>虽然经历了几个<del>半路腰斩</del>普通的项目的洗礼，也算的上是一个老油条了，总觉得应该有点东西可写了吧，回头一看，咦，好像留下的东西并不多。所以说，光做项目，但是不去思考总结，那么项目做的再多也只是无意义的重复而已。所以虽然有点久远了(才一年不到好吗)，还是简单总结一下做过的几个安卓项目吧。</p><span id="more"></span><p>首先，还在实习期的时候，leader 给了一个公司内部的课程通知的 app，让我和另一名实习生做一些改进，算是练练手吧。头一次接手别人的项目难免有点心慌慌，但是经过一段时间熟悉后，改功能或者UI也就轻车熟路了，有种慢慢找回自信的感觉。尤记得刚拿到项目的时候，发现项目里网络请求用的是 Spring Framework，心里吐槽了好久。不过有时候遇到写的巧妙的地方也会忍不住和同事感叹一下，尽管现在看起来可能会觉得很常见。另外关于这项目有意思的地方是用到了<a href="https://altbeacon.github.io/android-beacon-library/index.html">beacon</a>，发现原来这东西结合 BLE 还可以玩出这么多花样儿，比如打开蓝牙搜索附件房间未来有哪些课程，进入房间推送签到，离开房间推送课程评价等等，还是挺好玩儿的。</p><p>第二个项目Cedars-Sinai，算是接手的第一个正式的项目吧，需求不算复杂。虽然项目架构不是我定的，但是从零开始搭项目，一开始的时候还是觉得挺有挑战的。尤其是使用依赖注入库 <a href="https://google.github.io/dagger/">dagger</a>，由于之前没有接触过，花了好长时间总算基本熟悉了，写了一篇<a href="https://blogs.perficient.com/delivery/blog/2017/09/18/dependency-injection-a-basic-tutorial-to-dagger-2/">博客</a>发在了公司的博客站点。然后其它难点好像也没有了，诸如谷歌地图之类的熟悉了之后感觉也没啥特别的，<a href="https://blogs.perficient.com/delivery/blog/2017/09/20/integrate-google-map-into-your-app/">调调API而已</a>。这项目做了3个月左右，然后9月份上线 <a href="https://play.google.com/store/apps/details?id=com.cedars_sinai.mycslink">Play Store</a>，感兴趣的可以下载体验下，虽然现在只有美国的同事在维护了。</p><p>做完 Cedars-Sinai 项目的 KT 之后，开始闲下来了，于是学习了差不多一个多礼拜的官方文档，然后被通知要做一个公司内部的AR小项目。项目的 Product Owner 是公司的 Principal，那天 leader 拉着我们几个过去开会，听 Principal 聊了一会儿，只是知道他们大概要什么样的效果，但还是感觉一脸懵逼，不过最后很豪放地说让我们自己大胆放手去做。头一次接触AR开发，有点手忙脚乱但是又很有新鲜感。因为是内部项目，所以技术上选型还是非常自由的，加上安卓和 iOS 完全是分开独立的，所以尝试了很多AR开发SDK，比如ARCore/ARToolKit/Vuforia，最终选定 <a href="https://www.easyar.com/">EasyAR</a>，因为支持的设备更广泛，文档比较全，使用也比较简单，而且功能上完全可以满足需求。由于做AR应用涉及到的不仅仅是安卓相关的知识，还有比如OpenGL等，还是花了不少时间来熟悉的。那段时间阅读了很多关于OpenGL的文档和博客，甚至公众号也关注了不少，然后也写了一篇<a href="http://blogs.perficient.com/delivery/blog/2017/09/28/build-graphics-with-opengl-es-2-0/">总结</a>。最后刚刚做出一点雏形的时候，被调去另一个项目，我的“AR 之路”也就不了了之了，当然这次只是浅浅接触，以后应该还有机会再深入学习的吧。</p><p>现在在做的项目差不多算是第四个项目了吧，<a href="https://play.google.com/store/apps/details?id=com.ace.shell.production">Auto Club</a>，在我接手之前就早已上线了，现在基本上处于维护的阶段。这是一个大项目吧，不仅体积大，开发周期也长，估计要做到今年年中。团队的话，我们这边 iOS 有两个，Android 也有两个，美国那边也有5、6个人和我们一起协同开发，基本上是他们下班了我们这边接着干。接手这个项目也学到了不少新东西，除了常见的三方库外，也对很多东西加深了理解，比如模块化、TDD等，尤其是<a href="https://github.com/OpenDevTeam/OpenBox/blob/master/topic/%5BAndroid%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%5D%E4%B8%8D%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%B4%BB%E8%AF%A5%E4%BD%A0%E5%8A%A0%E7%8F%AD.md">单元测试</a>。以前总是觉得单元测试不重要而不去做，进入这项目一段时间后，发现这种级别(多模块、业务逻辑复杂)的项目，充足、完备的测试对新接手项目的人来说简直是救星，做完改动也不用担心会把其它功能给改坏，只要输入<a href="https://github.com/ruby/rake">一行命令</a>把测试都跑一遍就行了，不要太爽，而且看单元测试也有助于理解项目代码。然后唯一不太习惯的是TDD的开发方式，不过相信一段时间之后就会适应的吧？</p><p>其实从去年10月底到今年1月初还做了一段时间的 Java 后端开发，一个基于 Spring Boot 的项目，跟着公司后端大佬一起写写接口、调试代码，想着有时间也谈谈做后端的经历对 Android 开发人员的帮助吧，做过后端之后还是产生了不少新的想法的。编程都是相通的，重要的是打开思路，光是埋头苦干还是不够的，有时候多看看隔壁后端兄弟或者前端妹子在忙什么，也有助于我们了解自己的工作到底该怎么做，怎样才能做的更好。</p><p>好了，差不多就写这么多了，待会儿要去看烟火了~各位辛苦看到这的，祝大家新年快乐啦！（看到这篇的时候新年已经过了？那就祝各位长的越来越好看！ヾ(¯∇￣๑) ）</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
            <tag> Reviews </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradle 介绍及解惑</title>
      <link href="/introducing-gradle-and-faq/"/>
      <url>/introducing-gradle-and-faq/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/2017-12-24/gradle-logo.png"></p><blockquote><p>  个人笔记整理系列，本文整理自张哥 QQ 聊天群 (2016-6-24)</p></blockquote><h3 id="Gradle-是什么"><a href="#Gradle-是什么" class="headerlink" title="Gradle 是什么?"></a>Gradle 是什么?</h3><p>简单来说，Gradle 是一种构建系统，但是什么是构建系统呢？</p><p>当我们使用 Android Studio，写完代码，编译、运行、生成 apk 包并且安装到手机上，这一系列过程都可以算是 Android 应用程序构建的一部分。在 Gradle 之前，Google 开发了 ADT (Android Development Tools) 用于构建 Android 应用程序，而 AS 正式版的问世之后，这个构建的工作就交给 Gradle 来做了。Gradle 由开源社区维护，使用起来简洁高效，所以谷歌把它作为 AS 的默认构建工具。</p><p>有了 Gradle 之后，即使不使用 IDE，而是在 EditPlus、Sublime Text 这样的编辑器上写代码，我们依旧可以通过简单的 Gradle 命令，将程序编译、打包、运行，只不过没有那么多的智能提示、智能跳转而已。</p><p>Gradle 最令人称道的部分其实不仅仅是编译、运行、打包的高效上，还有便捷的依赖管理。举个例子：最早期开发时引用第三方库大都是下载 jar 包，然后拷贝到 libs 文件夹下。这种方式管理起来很麻烦，很混乱，比如 jar 包升级了，那么我们又得重新下载，重新拷贝过来并替换。用了 Gradle 之后，只需要一行简单的代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">implementation <span class="hljs-string">&#x27;androidx.xxx:version_name&#x27;</span><br></code></pre></td></tr></table></figure><p>类似这样的依赖方式，既方便又直观，升级的话直接改下版本号就可以了。</p><span id="more"></span><h3 id="关于-Gradle-的常见疑问"><a href="#关于-Gradle-的常见疑问" class="headerlink" title="关于 Gradle 的常见疑问"></a>关于 Gradle 的常见疑问</h3><p><strong>Q：</strong>Gradle 是专门针对 Android 开发使用的吗？</p><p><strong>A：</strong>Gradle 是一个基于 Groovy 语言的构建工具。它是可以单独存在的，跟平台无关，也跟 IDE 无关。</p><br/><p><strong>Q：</strong>AS 一推出就默认集成了 Gradle 构建工具，抛弃了原来的 ADT。怎么集成的呢？</p><p><strong>A：</strong>Google 为了让 Android 支持 Gradle 构建，单独开发了 Android Gradle Plugin，当我们创建 Android 的 Gradle 项目时都需要使用到这个 Gradle 插件。打开项目根目录的 build.gradle，<code>buildscript</code> 中的 <code>dependencies</code> 代码块中有这样一行代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">classpath</span> <span class="hljs-string">&#x27;com.android.tools.build:gradle:version_name&#x27;</span><br></code></pre></td></tr></table></figure><p>这个就是 Gradle 插件的依赖，后面的版本号代表的是这个 Android Gradle Plugin 的版本。</p><p><a href="https://developer.android.com/studio/releases/gradle-plugin.html">查看 Android Gradle Plugin 的版本更新以及 Release Note</a></p><p><a href="https://gradle.org/releases/">查看 Gradle 的版本更新以及 Release Note</a></p><br/><p><strong>Q：</strong>如何查看当前 android gradle 插件版本对应的 gradle 版本？</p><p><strong>A：</strong>首先确保启用了 gradle wrapper，在 AS 的设置中找到 Build - Gradle，然后在 Project Level Settings 中选择Use default gradle wrapper (recommanded)。然后在项目根目录下，输入 ./gradllew -v，就可以看到当前的 gradle 版本（首次输入会下载 Gradle）。</p><br/><p><strong>Q：</strong>为什么输入的命令是 gradlew  而不是 gradle ？</p><p><strong>A：</strong>gradlew 是 gradle wrapper 的缩写，顾名思义，它是 gradle 的一层包装，方便兼容不同版本的 gradle。比如我们有多个项目，每个项目依赖的 gradle 版本不同，为了让每个项目都能成功构建，我们就需要使用 gradle wrapper，它相当于在每个 Android 项目里都内置了一个 gradle。</p><p>打开项目根目录可以看到有一个 gradle 文件夹，下面有个 wrapper 的文件夹，打开里面的 gradle-wrapper.properties 文件，可以看到如下内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">\#Mon</span> <span class="hljs-string">Dec 28 10:00:20 PST 20xx</span><br><br><span class="hljs-attr">distributionBase</span>=<span class="hljs-string">GRADLE_USER_HOME</span><br><br><span class="hljs-attr">distributionPath</span>=<span class="hljs-string">wrapper/dists</span><br><br><span class="hljs-attr">zipStoreBase</span>=<span class="hljs-string">GRADLE_USER_HOME</span><br><br><span class="hljs-attr">zipStorePath</span>=<span class="hljs-string">wrapper/dists</span><br><br><span class="hljs-attr">distributionUrl</span>=<span class="hljs-string">https\://services.gradle.org/distributions/gradle-x.x-all.zip</span><br></code></pre></td></tr></table></figure><p>这里其实就已经可以看到你当前项目依赖的 gradle 版本是多少了，跟你输入 ./gradlew -v 应该显示的是一个版本。如果你本地没有下载这个版本的 gradle，那么第一次运行项目时会自动先去下载 gradle。</p><p>下载后的位置在：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Windows: C:\Users\&#123;<span class="hljs-keyword">user</span>.name&#125;\.gradle\<span class="hljs-keyword">wrapper</span>\dists\<br><br>Mac: /Users/&#123;<span class="hljs-keyword">user</span>.name&#125;/.gradle/<span class="hljs-keyword">wrapper</span>/dists/<br></code></pre></td></tr></table></figure><br/><p><strong>Q：</strong>为什么命令行下第一次输入 ./gradlew 命令要下载？AS 运行过不是说明已经下载了对应版本的 gradle 了吗？</p><p><strong>A：</strong>这应该是个 bug。我猜测命令行下可能无法识别 AS 使用的 gradle 位置，所以又重新下载了一个，打开 /Users/{user.name}/.gradle/wrapper/dists/gradle_version，可以看到同一个 gradle 版本下有两个文件夹，说明下载了两次，一个是 AS 下载的，一个是通过命令行下载的。</p><br/><p><strong>Q：</strong>如何使用 AS 打开 Github 上的 Demo？</p><p><strong>A：</strong>首先检查 gradlew wrapper，不同版本的 AS 支持的 gradle 版本也不同，比如 AS 1.0 的时候要求只能使用 gradle 1.x 的版本，等到 AS 2.0 推出后，开始不支持 gradle 1.x 的版本，会强制让你升级到 gradle 2.0 以上，AS 3.0 之后支持 gradle 4.0 及以上（同时开始支持 Java 8）。所以新项目还需要检查下 gradle wrapper 版本是不是很老旧了，一般与你本地的 gradle 版本保持一致就可以了。</p><p>我写了一个批量修改 gradle 版本的<a href="https://gist.github.com/aJIEw/4c666af6c4f9b5fb8f9786e236c76073">工具类</a>，有需要的可以参考下。</p><h3 id="常见问题解决方案"><a href="#常见问题解决方案" class="headerlink" title="常见问题解决方案"></a>常见问题解决方案</h3><ol><li><p>遇到 ./gradlew: Permission denied 怎么办？</p><p>只要在项目根目录下执行 <code>chmod +x gradlew</code> 就可以了</p></li></ol><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>Gradle 命令 (Windows 上使用 gradlew)</th><th>解释</th></tr></thead><tbody><tr><td>./gradlew clean</td><td>清除编译缓存，删除 build 文件夹</td></tr><tr><td>./gradlew tasks –all</td><td>查看所有任务</td></tr><tr><td>./gradlew :moduleName:taskName</td><td>执行对应 module 下的 task</td></tr><tr><td>./gradlew app:dependencies –configuration releaseRuntimeClasspath</td><td>查看编译时依赖库</td></tr><tr><td>./gradlew assembleRelease (gradlew aR)</td><td>编译并打 release 包</td></tr><tr><td>./gradlew assembleDebug (gradlew aD)</td><td>编译并打 debug 包（app/build/outputs/apk）</td></tr><tr><td>./gradlew aD –offline</td><td>编译打包时使用 offline 模式</td></tr><tr><td>./gradlew installDebug</td><td>安装 Debug 包</td></tr><tr><td>./gradlew -q dependencies app:dependencies compileReleaseSource</td><td>查看项目库的依赖树</td></tr><tr><td>./gradlew processDebugManifest –stacktrace</td><td>显示 Manifest 合并出错信息</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware 下安装 macOS 和 Chrome OS</title>
      <link href="/vmware-install-macosx-and-chromeos/"/>
      <url>/vmware-install-macosx-and-chromeos/</url>
      
        <content type="html"><![CDATA[<p>最近闲来无事，突然想用 VMWare 安装 macOS 和 Chrome OS 玩玩。虽然网上教程有很多，但是每次去搜总是花费掉不少时间，所以记录下来以备不时之需。</p><hr><h5 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h5><p>操作系统：Windows 10, 64-bit (Build 17134) 10.0.17134</p><p>VMware 版本：VMware® Workstation 12 Pro (Build 3272444) 12.1.0</p><span id="more"></span><h5 id="安装-macOS"><a href="#安装-macOS" class="headerlink" title="安装 macOS"></a>安装 macOS</h5><p>网上这部分教程很多，基本步骤就是先下载并运行 <a href="https://github.com/DrDonk/unlocker/releases">macOS Unlocker for VMware</a>，这样 VMWare 就能够识别 macOS 了，之后新建虚拟机并安装就可以了。</p><p>如果遇到了“不可恢复错误：(vcpu-0)”，只要打开 macOS 虚拟机根目录下的 .vmx 文件，并添加一行“<strong>smc.version = 0</strong>”，然后重启就可以解决。</p><p>如果遇到其他提示错误，一般只要关闭虚拟机，并删除根目录下的 .lck 文件夹并重启虚拟机就可以解决。</p><h5 id="安装-Chrome-OS"><a href="#安装-Chrome-OS" class="headerlink" title="安装 Chrome OS"></a>安装 Chrome OS</h5><p>一开始花了不少时间在找 Chrome OS 的镜像文件上，但其实 VMWare 同样不能识别 Chrome OS，所以我们需要的是直接包含了 Chrome OS 的虚拟硬盘 (.vmdk) 文件，可以从 <a href="https://www.neverware.com/#introtext-3">neverware </a>网站上获取，这里我使用的是一个<a href="https://neverware.zendesk.com/hc/en-us/articles/214564457--UPDATED-Un-Official-CloudReady-Virtual-Machine-Images-">非官方版本</a>，下载解压后运行 .ovf 文件即可导入 Chrome OS 到  VMWare 中了。</p><p>当然，Chrome OS 必须在联网后才能愉快使用，毕竟一切程序都是从网络上获取的，不联网的话只能以访客身份进入。</p><div style="text-align:center">『以访客模式进入 Chrome OS』</div><img src="https://i.loli.net/2019/08/30/casjxClKADgfNV1.png" width=100%/><p>好啦，以上就是今天的全部内容啦，感谢收看，下次再见 ：)</p><hr><p>参考内容：</p><p>1.<a href="https://nmilosev.svbtle.com/how-to-run-chrome-os-not-chromium-os-in-vmware-player-and-workstation">How to run Chrome OS (not Chromium OS) in VMWare Workstation and Player</a></p><p>2.<a href="http://getchrome.eu/download.php">Download Cr OS Linux</a></p><p>3.<a href="https://neverware.zendesk.com/hc/en-us/articles/214564457--UPDATED-Un-Official-CloudReady-Virtual-Machine-Images-">Un-Official CloudReady Virtual Machine Images</a></p><p>4.<a href="https://www.zhihu.com/question/52168379">在哪可以下载 macOS 镜像？</a></p>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tricks </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
